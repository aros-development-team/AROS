/*
    Copyright © 1995-2001, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Archive of MathIEEESingBas Functions
    Lang: english
*/
#Archive
#Header
#include <libraries/mathieeesp.h>
#include <aros/libcall.h>
#include <proto/mathieeesingbas.h>
#include <proto/exec.h>
#include <exec/types.h>
#include "mathieeesingbas_intern.h"
#/Header

#Function LONG IEEESPFix
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 5
#AutoDoc
    FUNCTION
        Convert ieeesp-number to integer

    RESULT
        absolute value of y

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : ieeesp out of integer-range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Res;
  LONG Shift;

  if ((y & IEEESPExponent_Mask) > 0x60000000 )
  {
    if(y < 0) /* don`t hurt the SR! */
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0x80000000;
    }
    else
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0x7fffffff;
    }
  }

  if (0 == y || 0x80000000 == y) /* y=+-0; */
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }


  Shift = (y & IEEESPExponent_Mask) >> 23;
  Shift -=0x7e;


  if ((char) Shift >= 25)
    Res = ((y & IEEESPMantisse_Mask) | 0x00800000)  << (Shift-24);
  else
    Res = ((y & IEEESPMantisse_Mask) | 0x00800000)  >> (24 - Shift);

  /* Test for a negative sign  */
  if (y < 0)
  {
    Res = -Res;
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  }

  return Res;
#/Code
#/Function


#Function float IEEESPFlt
#Parameter LONG y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 6
#AutoDoc
    FUNCTION

    RESULT
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : IEEE single precision number is not exactly the integer

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Exponent = 0;
  LONG TestMask = 0xFFFFFFFF;
  LONG Res = 0;

  if (y == 0)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (y < 0)
  {
    Res = IEEESPSign_Mask;
    y= -y;
  }
  /* find out which is the number of the highest set bit */
  while (TestMask & y)
  {
    Exponent ++;
    TestMask <<= 1;
  }

  if (Exponent >= 26)
    y >>= (Exponent - 25) & IEEESPMantisse_Mask;
  else
    y <<= (25 - Exponent) & IEEESPMantisse_Mask;

  if ((char) (y & 1) != 0)
  {
    y ++;
    if (0x02000000 == y)
      Exponent++;
  }

  y >>= 1;
  y &= IEEESPMantisse_Mask;

  Exponent += 0x7E;

  /* adapt Exponent to IEEESP-Format */
  Exponent <<= 23;
  Res |= y | Exponent;
  if (Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  /* The resulting IEEESP is lacking precision */
  if (Exponent > 0x4c800000)
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function LONG IEEESPCmp
#Parameter LONG y D0
    IEEEE single precision floating point
#/Parameter
#Parameter LONG z D1
    IEEEE single precision floating point
#/Parameter
#LibOffset 7
#AutoDoc
    FUNCTION
        Compares two ieeesp numbers

    RESULT
       <code>
       +1 : y > z
        0 : y = z
       -1 : y < z


        Flags:
          zero     : y = z
          negative : y < z
          overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS

    HISTORY

#/AutoDoc
#Code
  if (y == z)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (y < 0 && z < 0)
  {
    if (-y > -z)
    {
      SetSR(0,  Zero_Bit | Negative_Bit | Overflow_Bit);
      return 1;
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return -1;
    }
  }

  if ((LONG)y < (LONG)z)
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return -1;
  }
  else
  {
    SetSR(0,  Zero_Bit | Negative_Bit | Overflow_Bit);
    return 1;
  }
#/Code
#/Function


#Function LONG IEEESPTst
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 8
#AutoDoc
    FUNCTION
        Compare a ieeesp-number against zero.

    RESULT
	<code>
        +1 : y > 0.0
         0 : y = 0.0
        -1 : y < 0.0

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0
	</code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS
      ALGORITHM:
	<code>
        Sign is negative: return -1
        y == 0          : return 0
        Otherwise       : return 1
	</code>

    HISTORY

#/AutoDoc
#Code
  /* y is negative */
  if (y < 0)
  {
    SetSR(Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return -1;
  }

  /* fnum1 is zero */
  if (0 == y)
  {
    SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return 0;
  }

  /* fnum1 is positive */
  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );
  return 1;
#/Code
#/Function


#Function float IEEESPAbs
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 9
#AutoDoc
    FUNCTION
        Calculate the absolute value of a given floating point number

    RESULT
        absolute value of y

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS
      ALGORITHM:
        set the sign-bit to zero

    HISTORY

#/AutoDoc
#Code
    if (0 == y)
      /* value is 0 -> set the Zero Flag */
      SetSR( Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    else
    {
      /* set the sign-bit to zero */
      y &= (IEEESPMantisse_Mask | IEEESPExponent_Mask);
      SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );
    }
    return y;
#/Code
#/Function


#Function float IEEESPNeg
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 10
#AutoDoc
    FUNCTION
        Switch the sign of the given ieeesp number

    RESULT
        -y

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS
      ALGORITHM:
        Return -0 if y == 0.
        Otherwise flip the sign-bit.

    HISTORY

#/AutoDoc
#Code
  if (0 == y || 0x80000000 == y)
  {
    SetSR( Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (IEEESPSign_Mask ^ y);
  }

  /* flip sign-bit */
  y ^= IEEESPSign_Mask;

  if(y < 0)
  /* result is negative */
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  else
  /* result is positive */
    SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  return y;
#/Code
#/Function


#Function float IEEESPAdd
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#Parameter float z D1
    IEEEE single precision floating point
#/Parameter
#LibOffset 11
#AutoDoc
    FUNCTION
        Calculate the sum of two IEEE single precision numbers

    RESULT
        sum of y and z

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is too large or too small for IEEESP format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Res;
  LONG Mant1, Mant2;
  LONG Shift;
  LONG Exponent;

  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  Shift = ((y & IEEESPExponent_Mask) -
           (z & IEEESPExponent_Mask)) >> 23;

  if (y != 0 && y != IEEESPSign_Mask )
    Mant1 = (y & IEEESPMantisse_Mask) | 0x00800000;
  else
    Mant1 = 0;

  if (z != 0 && z != IEEESPSign_Mask )
    Mant2 = (z & IEEESPMantisse_Mask) | 0x00800000;
  else
    Mant2 = 0;

  if (Shift > 0)
  {
    Mant2 >>= Shift;
    Exponent = (y & IEEESPExponent_Mask);
  }
  else
  {
    Mant1 >>= (-Shift);
    Exponent = (z & IEEESPExponent_Mask);
  }

  /* sign(fnum1) == sign(fnum2)
  ** simple addition
  ** 0.25 <= res < 1
  */
  if ( (z & IEEESPSign_Mask) - ( y & IEEESPSign_Mask) == 0)
  {
    Res = y & IEEESPSign_Mask;
    Mant1 += Mant2;
    if ( (Mant1 & 0x01000000) != 0)
    {
      Exponent += 0x00800000;
      Mant1 >>= 1;
    }
    Mant1 &= IEEESPMantisse_Mask;
  }
   /* second case: sign(fnum1) != sign(fnum2)
   **   -1 <= res < 1
   */
  else
  {
    if ( y < 0)
      Mant1 = Mant2 - Mant1;
    else /* fnum2 < 0 */
      Mant1 = Mant1 - Mant2;
    /*if the result is below zero */
    if (  Mant1 < 0)
    {
      Res = IEEESPSign_Mask;
      Mant1 =-Mant1;
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    }
    else
      Res = 0;

    if (0 == Mant1)
    {
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0;
    }
    else
    {
      /* normalize the mantisse */
      while ( (Mant1 & 0x00800000) == 0)
      {
        Mant1 += Mant1;  /*one bit to the left. */
        Exponent -= 0x00800000;
      }
      Mant1 &= IEEESPMantisse_Mask;
    } /* else */

  } /* else */

  if ( Exponent < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit);
    /* do NOT change Negative_Bit! */
    return (Res | (IEEESPMantisse_Mask | IEEESPExponent_Mask));
  }

  Res |= Mant1 | Exponent;
  return Res;
#/Code
#/Function


#Function float IEEESPSub
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#Parameter float z D1
    IEEEE single precision floating point
#/Parameter
#LibOffset 12
#AutoDoc
    FUNCTION
        Subtract two ieeesp numbers
        x = y-z;

    RESULT

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS
      ALGORITHM:
        x = y - z = y + (-z).

    HISTORY

#/AutoDoc
#Code
  return IEEESPAdd(y, z ^ IEEESPSign_Mask);
#/Code
#/Function


#Function float IEEESPMul
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#Parameter float z D1
    IEEEE single precision floating point
#/Parameter
#LibOffset 13
#AutoDoc
    FUNCTION
        Multiply two IEEE single precision numbers
        res = y * z;

    RESULT

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  ULONG Mant1H = ((y & 0x00fff000) >> 12 ) | 0x00000800;
  ULONG Mant2H = ((z & 0x00fff000) >> 12 ) | 0x00000800;
  ULONG Mant1L = y & 0x00000fff;
  ULONG Mant2L = z & 0x00000fff;
  LONG Res;
  LONG Exponent =((( y & IEEESPExponent_Mask)) +
                  (( z & IEEESPExponent_Mask)) -
                  0x3f800000 );

  if (0 == y || 0 == z)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return ((y & IEEESPSign_Mask) ^ (z & IEEESPSign_Mask) );
  }

  Res  =  (Mant1H * Mant2H) <<  8;
  Res += ((Mant1H * Mant2L) >>  4);
  Res += ((Mant1L * Mant2H) >>  4);
  Res += ((Mant1L * Mant2L) >> 16);

  /* Bit 32 is not set */
  if ((LONG)Res > 0)
    Res += Res;
  else
    Exponent += 0x00800000;

  /* Correction for precision */
  if ((char) Res < 0)
    Res += 0x100;

  Res >>= 8;
  Res &= IEEESPMantisse_Mask;

  Res |= ((y & IEEESPSign_Mask) ^ (z & IEEESPSign_Mask) );

  if ( Exponent < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (0x7f800000 | (Res & IEEESPSign_Mask) );
  }

  Res |= Exponent;

  if ( Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPDiv
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#Parameter float z D1
    IEEEE single precision floating point
#/Parameter
#LibOffset 14
#AutoDoc
    FUNCTION
        Divide two IEEE single precision floating point numbers
        x = y / z;

    RESULT

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is out of range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO


    INTERNALS
      ALGORITHM:<br/>
        Check if fnum2 == 0: result = 0;<br/>
        Check if fnum1 == 0: result = overflow;<br/>
        The further algorithm comes down to a pen &amp; paper division.
    HISTORY

#/AutoDoc
#Code
  LONG Res = 0;
  LONG Exponent = (y & IEEESPExponent_Mask) -
                  (z & IEEESPExponent_Mask) + 0x3f800000;

  LONG Mant2 = ((y & IEEESPMantisse_Mask) | 0x00800000) << 8;
  LONG Mant1 = ((z & IEEESPMantisse_Mask) | 0x00800000) << 8;
  ULONG Bit_Mask = 0x80000000;

        if (0 == z && 0 == y)
                return 0x7f880000;

  /* check if the dividend is zero */
  if (0 == z)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (IEEESPExponent_Mask | ((y & IEEESPSign_Mask) ^ (z & IEEESPSign_Mask)));
  }

  /* check for division by zero */
  if (0 == y)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (y & IEEESPSign_Mask) ^ (z & IEEESPSign_Mask);
  }

  while (Bit_Mask >= 0x40 && Mant2 != 0)
  {
    if (Mant2 - Mant1 >= 0)
    {
      Mant2 -= Mant1;
      Res |= Bit_Mask;

      while (Mant2 > 0)
      {
        Mant2 <<= 1;
        Bit_Mask >>= 1;
      }

      while (Mant1 > 0)
      {
        Mant1 <<=1;
        Bit_Mask <<=1;
      }
    } /* if */
    else
    {
      Mant1 = (ULONG) Mant1 >> 1;
      Bit_Mask >>= 1;
    }
  } /* while */

  /* normalize the mantisse */
  while (Res > 0)
  {
    Res += Res;
    Exponent -=0x00800000;
  }

        if ((char) Res < 0)
    Res += 0x00000100;

        Res >>= 8;

  Res &= IEEESPMantisse_Mask;
  Res |= Exponent;
  Res |= (y & IEEESPSign_Mask) ^ (z & IEEESPSign_Mask);

  if (Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);

  if (Exponent < 0)
    SetSR(Overflow_Bit, Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPFloor
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 15
#AutoDoc
    FUNCTION
        Calculate the largest integer ieeesp-number less than or equal to
        fnum

    RESULT
	IEEE single precision floating point

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0 (???)

    NOTES

    EXAMPLE
       floor(10.5) = 10
       floor(0.5)  = 0
       floor(-0.5) = -1
       floor(-10.5)= -11

    BUGS

    SEE ALSO
        @Math.Floor@

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Mask = 0x80000000;

  if (0x7f880000 == y)
        return y;

  if ((y & IEEESPExponent_Mask)  < 0x3f800000)
  {
    if (y < 0) /* negative sign? */
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0xbf800000; /* -1 */
    }
    else
    {
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0;
    }
  }
  /* |fnum| >= 1 */
  Mask >>= ((y & IEEESPExponent_Mask) >> 23) - 0x77;

  /* y is negative */
  if (y < 0)
  /* is there anything behind the decimal dot? */
    if (0 != (y & (~Mask)) )
    {
      y    = IEEESPAdd(y, 0xbf800000 ); /* fnum = fnum -1; */
      Mask = 0x80000000;
      Mask >>= ((y & IEEESPExponent_Mask) >> 23) - 0x77;
    }

  if(y < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return y & Mask;
#/Code
#/Function


#Function float IEEESPCeil
#Parameter float y D0
    IEEEE single precision floating point
#/Parameter
#LibOffset 16
#AutoDoc
    FUNCTION
        Calculate the least integer ieeesp-number greater than or equal to
        y

    RESULT
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO
        @Math.Floor@

    INTERNALS
      ALGORITHM:
         Ceil(y) = - Floor(-y)

    HISTORY

#/AutoDoc
#Code
  if (y == 0x7f880000)
    return y;

  /* Ceil(y) = -Floor(-y); */
  y = IEEESPFloor(y ^ IEEESPSign_Mask);
  if (y == 0)
    return 0;
  else
    return (y ^ IEEESPSign_Mask);
#/Code
#/Function

#/Archive

