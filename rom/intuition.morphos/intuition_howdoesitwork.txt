This documents describes how internals work, the meaning of switches and how tricks are implemented.

1. intuition_intern.h switches:

#define GADTOOLSCOMPATIBLE

This turns on gadtools compatibility mode. Gadtools 68k seems to be refreshing it's gadgets in reverse order
(from last to 1st gadget). You can easily check this by making a test app with 2 overlapping gadtools and 2
overlapping boopsi gadgets.

boopsi gadgets would look like

-----
|   |
|  -----
---|   |
   |___|

While gadtools gads (same, sizes coords) will look like this

-----
|   |
|   |---
----   |
   |___|

With this option switched on intuition tries to refresh all gadgets with gad->GadgetType & 0x100 in
reversed direction.

#define BEGINUPDATEGADGETREFRESH
#define DAMAGECACHE

Those are refresh mode switches. original aros implementation as well as intuition 68k does gadgets
and border refreshing on input.device context. This eats a lot of cpu time and causes gadgets and frames
to redraw whenever intuiton checks damage, so if app is too busy to call BeginRefresh intuition might
keep refreshing stuff because the damage in layer is still there. This made for eg opaque window moving
impossible.

BEGINUPDATEGADGETREFRESH turns on a specific mode in which gadgets and window frame is refreshed only when
BeginRefresh is called. This is very very fast :)

DAMAGECACHE shouldn't be used anymore. Intuition used it to buffer the damage done to layer and clear it.
The code was reworked only to cache damage done to window borders - this fixes some minor compatibility problems
with Magellan, but it's not worth using really.

#define USEWINDOWLOCK
To protect intuition against opening windows in some cases this kind of lock was introduced. It basicly protects
us against a window opening while another window is dragged or menus are opened. To protect against deadlocks
this lock must not be used when OpenWindow was called from input.device context.
 
 //#define USEGADGETLOCK
#ifdef USEGADGETLOCK
#define LOCKGADGET ObtainSemaphore(&GetPrivIBase(IntuitionBase)->GadgetLock);
#define UNLOCKGADGET ReleaseSemaphore(&GetPrivIBase(IntuitionBase)->GadgetLock);
#define LOCKWINDOWLAYERS(w) ;
#define UNLOCKWINDOWLAYERS(w) ;
#else
#define LOCKGADGET
#define UNLOCKGADGET
#define LOCKWINDOWLAYERS(w) LockLayerInfo(&w->WScreen->LayerInfo);	\
		if (((struct IntWindow *)(w))->borderlayer) {LockLayer(0,((struct IntWindow *)(w))->borderlayer);};	  \
		if (((struct IntWindow *)(w))->wlayer) {LockLayer(0,((struct IntWindow *)(w))->wlayer);};
#define UNLOCKWINDOWLAYERS(w) if (((struct IntWindow *)(w))->wlayer) {UnlockLayer(((struct IntWindow *)(w))->wlayer);};	\
		if (((struct IntWindow *)(w))->borderlayer) {UnlockLayer(((struct IntWindow *)(w))->borderlayer);}	  \
		UnlockLayerInfo(&w->WScreen->LayerInfo);
#endif

Original AROS implementation used a gadgetlock to protect against simultaneous access to static structs and
rendering few gadgets at the same time. This way of locking caused many lockup problems. Current implementation
is based on having a lock on window's layers & layerinfo. This is a very stable solution but unfortunatelly doesn't give
enough protection against simulataneus access to some functions.

#define TIMEVALWINDOWACTIVATION

Compare activation times instead of using window->Parent stuff.
