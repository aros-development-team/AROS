handle SIGUSR1 pass noprint nostop
handle SIGUSR2 pass noprint nostop

define liblist
    set $lib = SysBase->LibList.lh_Head

    printf "Base     OpenC   Name\n"
    printf "---------------------------------------------------------------\n"
    while ($lib->ln_Succ != 0)
	printf "%p %5d   %s\n", \
	    $lib, \
	    ((struct Library *)$lib)->lib_OpenCnt, \
	    $lib->ln_Name
	set $lib = $lib->ln_Succ
    end
end
document liblist
List the current libraries in the system
end

define devlist
    set $dev = SysBase->DeviceList.lh_Head
    printf "Base     OpenC   Name\n"
    printf "---------------------------------------------------------------\n"
    while ($dev->ln_Succ != 0)
	printf "%p %5d   %s\n", \
	    $dev, \
	    ((struct Library *)$dev)->lib_OpenCnt, \
	    $dev->ln_Name
	set $dev = $dev->ln_Succ
    end
end
document devlist
List the current devices in the system
end

define resourcelist
    set $res = SysBase->ResourceList.lh_Head
    printf "Base     Name\n"
    printf "---------------------------------------------------------------\n"
    while ($res->ln_Succ != 0)
	printf "%p %s\n", $res, $res->ln_Name
	set $res = $res->ln_Succ
    end
end
document resourcelist
List the current resources in the system
end

define residentlist
    set $resp = (struct Resident **)SysBase->ResModules
    set $i = 0

    printf "Address    Pri Flags Vers Type  Name\n"
    printf "--------------------------------------------------------------\n"
    while (($resp)[$i] != 0)
	set $res = ($resp)[$i]
	printf "%p  %4d    %02x  %3d  %3d  %s\n", \
	    $res, \
	    ((struct Resident *)$res)->rt_Pri, \
	    ((struct Resident *)$res)->rt_Flags, \
	    ((struct Resident *)$res)->rt_Version, \
	    ((struct Resident *)$res)->rt_Type, \
	    ((struct Resident *)$res)->rt_Name
	set $i = $i + 1
    end
end
document residentlist
List the system resident list
end

define taskready
    set $task = (struct Task *)SysBase->TaskReady.lh_Head

    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    while ($task->tc_Node.ln_Succ != 0)
	printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
	    $task, \
	    $task->tc_SigWait, \
	    $task->tc_SigRecvd, \
	    $task->tc_SPUpper - $task->tc_SPLower, \
	    $task->tc_SPUpper - $task->tc_SPReg, \
	    $task->tc_Node.ln_Pri, \
	    $task->tc_Node.ln_Type, \
	    $task->tc_Node.ln_Name
	set $task = (struct Task *)$task->tc_Node.ln_Succ
    end
end
document taskready
List of tasks currently ready to run
end

define taskwait
    set $task = (struct Task *)SysBase->TaskWait.lh_Head

    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    while ($task->tc_Node.ln_Succ != 0)
	printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
	    $task, \
	    $task->tc_SigWait, \
	    $task->tc_SigRecvd, \
	    $task->tc_SPUpper - $task->tc_SPLower, \
	    $task->tc_SPUpper - $task->tc_SPReg, \
	    $task->tc_Node.ln_Pri, \
	    $task->tc_Node.ln_Type, \
	    $task->tc_Node.ln_Name
	set $task = (struct Task *)$task->tc_Node.ln_Succ
    end
end
document taskwait
List of tasks currently waiting for an event
end

define thistask
    set $task = (struct Task *)SysBase->ThisTask
    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
	$task, \
	$task->tc_SigWait, \
	$task->tc_SigRecvd, \
	$task->tc_SPUpper - $task->tc_SPLower, \
	$task->tc_SPUpper - $task->tc_SPReg, \
	$task->tc_Node.ln_Pri, \
	$task->tc_Node.ln_Type, \
	$task->tc_Node.ln_Name
end
document thistask
Print out information about the currently running task.
end

define modlist
    printf "Segment           Module\n"

    if Debug_ModList
        printf "---------------------------------------------------------------------\n"
        set $segnode = (struct segment *)Debug_ModList->mlh_Head

        while ($segnode->s_node.mln_Succ != 0)
            printf "%p %12s %2u %32s\n", $segnode->s_lowest, $segnode->s_name, $segnode->s_num, $segnode->s_mod->m_name

            set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end
    end

    printf "---------------------------------------------------------------------\n"
    set $kicknode = Debug_KickList

    while ($kicknode != 0)
        set $eh = $kicknode->eh
        set $sh = $kicknode->sh
        set $shnum = $eh->shnum

        set $i = 0
        while ($i < $shnum)
            if ($sh->addr != 0) && ($sh->size != 0)
		printf "%p %12s %2u %32s\n", $sh->addr, $i, $kicknode->Name
	    end
	    $sh++
	    $i++
	end
        set $kicknode = $kicknode->Next
    end
end
document modlist
List of all the modules currently loaded in memory
end

define findaddr
    set $cont = 1

    #first search in modules loaded from disk
    printf "Searching in the loaded modules...\n"
    if Debug_ModList
        set $segnode = (struct segment *)Debug_ModList->mlh_Head

        while ($segnode->s_node.mln_Succ != 0) && $cont
	    if $arg0 >= $segnode->s_lowest && $arg0 <= $segnode->s_highest
                printf "Address found in %s, in segment %p.\nIf this is an executable, its .text section starts at %p.\n", $segnode->s_mod->m_name, $segnode->s_seg, $segnode->s_lowest

                set $cont = 0
            end
            set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end
    end

    if $cont
	printf "Searching in the kickstart list...\n"
    	set $kicknode = Debug_KickList
        
	while ($kicknode != 0) && $cont
            set $eh = $kicknode->eh
            set $sh = $kicknode->sh
            set $shnum = $eh->shnum

            set $i = 0
            while ($i < $shnum) && $cont
            	if ($sh->addr != 0) && (sh->size != 0)
		    set $lowest  = $sh->addr
		    set $highest = $sh->addr + $sh->size - 1

		    if $arg0 >= $lowest && $arg0 <= $highest
		    	printf "Address found in %s in section number %d starting at %p.\n", $kicknode->Name, $i, $lowest
                    	set $cont = 0
                    end
                end

		$sh++
		$i++
	    end
            set $kicknode = $kicknode->Next
        end
    end

    #then in the resident list
    if $cont
        printf "Searching in the resident list...\n"
    end

    set $resp = (struct Resident **)SysBase->ResModules
    set $i = 0

    while (($resp)[$i] != 0) && $cont
	set $res = ($resp)[$i]

        if ($arg0 >= $res) && ($arg0 <= $res->rt_EndSkip)
            printf "Address found in %s, which resides at %p\n", $res->rt_Name, $res
            set $cont = 0
        end

        set $i = $i + 1
    end

    if $cont
        printf "No matching module for this address\n"
    end
end
document findaddr
-Shows the module that contains the given address
-
-To debug a problem in AROS, do the following:
-
-1. Get a stacktrace with bt or similar.
-2. Use findaddr with such an address to find out in which
-   module it is:
-3. Use add-symbol-file to load that modules symbols.
-4. Now you can run bt (or similar) again and you should see the
-   addresses resolved as symbols.
-
-Example:
-
-0x4058d45b in ?? ()
-
-(gdb) findaddr 0x4058d45b
-
-Searching in the loaded modules...
-Address found in Workbench:contrib/Zune/Libs/muimaster.library, which is loaded at 0x405379a4.
-If this is an executable, its .text section starts at 0x405379b0.
-(gdb) add-symbol-file contrib/Zune/Libs/muimaster.library 0x405379b0
-add symbol table from file "contrib/Zune/Libs/muimaster.library" at
-        .text_addr = 0x405379b0
-(y or n) y
-Reading symbols from contrib/Zune/Libs/muimaster.library...done.
-(gdb) bt
-#0  0x4058d45b in strlen (ptr=0x80 <Address 0x80 out of bounds>) at strlen.c:45
-#1  0x00000000 in lastx.78 ()
end

define printtaglist
    set $list = (struct TagItem *)$arg0

    printf "Tag         Data (Hex)     Data (Dec)\n"
    printf "--------------------------------------\n"

    while $list->ti_Tag != 0
	# Handle the possible control tag...
	if $list->ti_Tag == 1
	    printf "TAG_IGNORE\n"
	else if $list->ti_Tag == 2
	    printf "TAG_MORE    %p\n", $list->ti_Data
	    set $list = (struct TagItem *)$list->ti_Data
	else if $list->ti_Tag == 3
	    printf "TAG_SKIP    %d\n", $list->ti_Data
	    set $list = $list + $list->ti_Tag + 1
	else
	    printf "%p  %p      %9lu\n", $list->ti_Tag, $list->ti_Data, $list->ti_Data
	    set $list = $list + 1
	end
    end
    printf "TAG_DONE\n"
end
document printtaglist
end
    
define log_to_file
  set logging file $arg0
  set logging redirect on
  set logging overwrite $arg1
  set logging on
end

define end_log
  set logging off
end

define loadseg
  dont-repeat
  if Debug_ModList
  set $step = 1
  set $segnode = (struct segment *)Debug_ModList->mlh_Head
  while ($segnode->s_node.mln_Succ != 0) && $step == 1
    if $arg0 >= $segnode->s_lowest && $arg0 <= $segnode->s_highest
      log_to_file segname.tmp on
      printf "%s", $segnode->s_mod->m_name
      end_log
      shell sed -i 's/.*:\(.*\)/\1/' segname.tmp
      log_to_file loadseg.tmp on
      printf "add-symbol-file "
      end_log
      shell head -n1 segname.tmp >>loadseg.tmp
      log_to_file loadseg.tmp off
      printf " %p", $segnode->s_lowest
      if $segnode->s_node.mln_Succ != 0
        set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        while ($segnode->s_node.mln_Succ != 0) && $step < 5
          if strcmp($segnode->s_name, ".text") == 0
            loop_break
          end
          printf " -s %s %p", $segnode->s_name, $segnode->s_lowest
          set $step = $step + 1
          set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end
      end
      end_log
      source loadseg.tmp
      loop_break
    end
    set $segnode = (struct segment *)$segnode->s_node.mln_Succ
  end
  if $step < 2
    set $kicknode = Debug_KickList

    while ($kicknode != 0) && $step == 1
	set $eh = $kicknode->eh
        set $sh = $kicknode->sh
        set $shnum = $eh->shnum

        set $i = 0
        while ($i < $shnum) && $cont
            if ($sh->addr != 0) && (sh->size != 0)
		set $lowest  = $sh->addr
		set $highest = $sh->addr + $sh->size - 1

		if $arg0 >= $lowest && $arg0 <= $highest
		    log_to_file segname.tmp on
		    printf "%s", $kicknode->s_module.m_name
		    end_log
		    shell sed -i 's/.*:\(.*\)/\1/' segname.tmp
		    log_to_file loadseg.tmp on
		    printf "add-symbol-file "
		    end_log
		    shell head -n1 segname.tmp >>loadseg.tmp
		    log_to_file loadseg.tmp off
		    printf " %p", $s_lowest

# FIXME!!! This won't work, format changed.
#        if $kicknode->s_next != 0
#          set $kicknode = $kicknode->s_next
#          while ($kicknode != 0) && $step < 5
#            if strcmp($kicknode->s_name, ".text") == 0
#              loop_break
#            end
#            printf " -s %s %p", $kicknode->s_name, $kicknode->s_lowest
#            set $step = $step + 1
#            set $kicknode = $kicknode->s_next
#          end
#        end
		    end_log
		    source loadseg.tmp
		    loop_break
                end
            end

	    $sh++
	    $i++
	end
        set $kicknode = $kicknode->Next
    end
  end
  if $step < 2
    printf "no matching module for this address\n"
  end
  else
    printf "no debug symbols found\n"
  end
end
document loadseg
Loads the module that contains the given address
end

define seglistdump
    set $nextseg = $arg0
    set $count   = 1

    printf "Hunk num. | Start addr | Size       \n"
    printf "----------+------------+------------\n"
    while $nextseg
        printf "%9d | %p | %10d\n", $count, $nextseg + sizeof(BPTR), *((ULONG *)$nextseg - 1) - sizeof(BPTR)

        set $nextseg = *(BPTR *)$nextseg
        set $count = $count+1
    end
end
document seglistdump
Shows the segments chain of the given seglist
end
