handle SIGUSR1 pass noprint nostop
handle SIGUSR2 pass noprint nostop
set follow-fork-mode child

define _debug_init
    init-if-undefined $AbsExecBase = (struct ExecBase *)SysBase

    if AbsExecBase != 0
        set $AbsExecBase = *(struct IntExecBase **)&AbsExecBase
        set $_debug_DebugBase = (struct DebugBase *)($AbsExecBase->DebugBase)

        if $_debug_DebugBase != 0
            set $_debug_ModList = $_debug_DebugBase->db_Modules
            set $_debug_KickList = $_debug_DebugBase->db_KernelModules
        end
    else
        init-if-undefined $_debug_ModList = Debug_ModList
        init-if-undefined $_debug_KickList = Debug_KickList
    end
end
document _debug_init
Initialize debugging convenience variables
end

define liblist
    _debug_init
    set $lib = ((struct ExecBase *)$AbsExecBase)->LibList.lh_Head

    printf "Base     OpenC   Name\n"
    printf "---------------------------------------------------------------\n"
    while ($lib->ln_Succ != 0)
    printf "%p %5d   %s\n", \
        $lib, \
        ((struct Library *)$lib)->lib_OpenCnt, \
        $lib->ln_Name
    set $lib = $lib->ln_Succ
    end
end
document liblist
List the current libraries in the system
end

define devlist
    _debug_init
    set $dev = ((struct ExecBase *)$AbsExecBase)->DeviceList.lh_Head
    printf "Base     OpenC   Name\n"
    printf "---------------------------------------------------------------\n"
    while ($dev->ln_Succ != 0)
    printf "%p %5d   %s\n", \
        $dev, \
        ((struct Library *)$dev)->lib_OpenCnt, \
        $dev->ln_Name
    set $dev = $dev->ln_Succ
    end
end
document devlist
List the current devices in the system
end

define resourcelist
    _debug_init
    set $res = ((struct ExecBase *)$AbsExecBase)->ResourceList.lh_Head
    printf "Base     Name\n"
    printf "---------------------------------------------------------------\n"
    while ($res->ln_Succ != 0)
    printf "%p %s\n", $res, $res->ln_Name
    set $res = $res->ln_Succ
    end
end
document resourcelist
List the current resources in the system
end

define residentlist
    _debug_init
    set $resp = (struct Resident **)((struct ExecBase *)$AbsExecBase)->ResModules
    set $i = 0

    printf "Address    Pri Flags Vers Type  Name\n"
    printf "--------------------------------------------------------------\n"
    while (($resp)[$i] != 0)
    set $res = ($resp)[$i]
    printf "%p  %4d    %02x  %3d  %3d  %s\n", \
        $res, \
        ((struct Resident *)$res)->rt_Pri, \
        ((struct Resident *)$res)->rt_Flags, \
        ((struct Resident *)$res)->rt_Version, \
        ((struct Resident *)$res)->rt_Type, \
        ((struct Resident *)$res)->rt_Name
    set $i = $i + 1
    end
end
document residentlist
List the system resident list
end

define taskready
    _debug_init
    set $task = (struct Task *)((struct ExecBase *)$AbsExecBase)->TaskReady.lh_Head

    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    while ($task->tc_Node.ln_Succ != 0)
    printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
        $task, \
        $task->tc_SigWait, \
        $task->tc_SigRecvd, \
        $task->tc_SPUpper - $task->tc_SPLower, \
        $task->tc_SPUpper - $task->tc_SPReg, \
        $task->tc_Node.ln_Pri, \
        $task->tc_Node.ln_Type, \
        $task->tc_Node.ln_Name
    set $task = (struct Task *)$task->tc_Node.ln_Succ
    end
end
document taskready
List of tasks currently ready to run
end

define taskwait
    _debug_init
    set $task = (struct Task *)((struct ExecBase *)$AbsExecBase)->TaskWait.lh_Head

    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    while ($task->tc_Node.ln_Succ != 0)
    printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
        $task, \
        $task->tc_SigWait, \
        $task->tc_SigRecvd, \
        $task->tc_SPUpper - $task->tc_SPLower, \
        $task->tc_SPUpper - $task->tc_SPReg, \
        $task->tc_Node.ln_Pri, \
        $task->tc_Node.ln_Type, \
        $task->tc_Node.ln_Name
    set $task = (struct Task *)$task->tc_Node.ln_Succ
    end
end
document taskwait
List of tasks currently waiting for an event
end

define thistask
    _debug_init
    set $task = (struct Task *)((struct ExecBase *)$AbsExecBase)->ThisTask
    printf "Task     SigWait  SigRecvd StkSize   StkUsed Pri Type Name\n"
    printf "-----------------------------------------------------------------------------\n"
    printf "%p %p %p %8d %8d %3d  %3ld %s\n", \
    $task, \
    $task->tc_SigWait, \
    $task->tc_SigRecvd, \
    $task->tc_SPUpper - $task->tc_SPLower, \
    $task->tc_SPUpper - $task->tc_SPReg, \
    $task->tc_Node.ln_Pri, \
    $task->tc_Node.ln_Type, \
    $task->tc_Node.ln_Name
end
document thistask
Print out information about the currently running task.
end

define modlist
    _debug_init
    printf "Segment           Module\n"

    if $_debug_ModList
        printf "---------------------------------------------------------------------\n"
        set $segnode = (struct segment *)$_debug_ModList->mlh_Head

        while ($segnode->s_node.mln_Succ != 0)
            printf "%p %12s %2u %32s\n", $segnode->s_lowest, $segnode->s_name, $segnode->s_num, $segnode->s_mod->m_name

            set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end
    end

    printf "---------------------------------------------------------------------\n"
    set $kicknode = $_debug_KickList

    while ($kicknode != 0)
        set $eh = $kicknode->eh
        set $sh = $kicknode->sh
        set $shnum = $eh->shnum

        set $i = 0
        while ($i < $shnum)
            if ($sh->addr != 0) && ($sh->size != 0)
        printf "%p              %2u %32s\n", $sh->addr, $i, $kicknode->Name
        end
        set $sh = $sh + 1
        set $i = $i + 1
    end
        set $kicknode = $kicknode->Next
    end
end
document modlist
List of all the modules currently loaded in memory
end

define findaddr
    _debug_init
    set $cont = 1

    #first search in modules loaded from disk
    printf "Searching in the loaded modules...\n"
    if $_debug_ModList
        set $segnode = (struct segment *)$_debug_ModList->mlh_Head

        while ($segnode->s_node.mln_Succ != 0) && $cont
        if $arg0 >= $segnode->s_lowest && $arg0 <= $segnode->s_highest
                printf "Address found in %s, in segment %p.\nIf this is an executable, its .text section starts at %p.\n", $segnode->s_mod->m_name, $segnode->s_seg, $segnode->s_lowest

                set $cont = 0
            end
            set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end
    end

    if $cont
    printf "Searching in the kickstart list...\n"
        set $kicknode = $_debug_KickList

    while ($kicknode != 0) && $cont
            set $eh = $kicknode->eh
            set $sh = $kicknode->sh
            set $shnum = $eh->shnum

            set $i = 0
            while ($i < $shnum) && $cont
                if ($sh->addr != 0) && ($sh->size != 0)
            set $lowest  = $sh->addr
            set $highest = $sh->addr + $sh->size - 1

            if $arg0 >= $lowest && $arg0 <= $highest
                printf "Address found in %s in section number %d starting at %p.\n", $kicknode->Name, $i, $lowest
                        set $cont = 0
                    end
                end

        set $sh = $sh + 1
        set $i = $i + 1
        end
            set $kicknode = $kicknode->Next
        end
    end

    #then in the resident list
    if $cont
        printf "Searching in the resident list...\n"
    end

    set $resp = (struct Resident **)((struct ExecBase *)$AbsExecBase)->ResModules
    set $i = 0

    while (($resp)[$i] != 0) && $cont
    set $res = ($resp)[$i]

        if ($arg0 >= $res) && ($arg0 <= $res->rt_EndSkip)
            printf "Address found in %s, which resides at %p\n", $res->rt_Name, $res
            set $cont = 0
        end

        set $i = $i + 1
    end

    if $cont
        printf "No matching module for this address\n"
    end
end
document findaddr
-Shows the module that contains the given address
-
-To debug a problem in AROS, do the following:
-
-1. Get a stacktrace with bt or similar.
-2. Use findaddr with such an address to find out in which
-   module it is:
-3. Use add-symbol-file to load that modules symbols.
-4. Now you can run bt (or similar) again and you should see the
-   addresses resolved as symbols.
-
-Example:
-
-0x4058d45b in ?? ()
-
-(gdb) findaddr 0x4058d45b
-
-Searching in the loaded modules...
-Address found in Workbench:contrib/Zune/Libs/muimaster.library, which is loaded at 0x405379a4.
-If this is an executable, its .text section starts at 0x405379b0.
-(gdb) add-symbol-file contrib/Zune/Libs/muimaster.library 0x405379b0
-add symbol table from file "contrib/Zune/Libs/muimaster.library" at
-        .text_addr = 0x405379b0
-(y or n) y
-Reading symbols from contrib/Zune/Libs/muimaster.library...done.
-(gdb) bt
-#0  0x4058d45b in strlen (ptr=0x80 <Address 0x80 out of bounds>) at strlen.c:45
-#1  0x00000000 in lastx.78 ()
end

define printtaglist
    set $list = (struct TagItem *)$arg0

    printf "Tag         Data (Hex)     Data (Dec)\n"
    printf "--------------------------------------\n"

    while $list->ti_Tag != 0
    # Handle the possible control tag...
    if $list->ti_Tag == 1
        printf "TAG_IGNORE\n"
    else if $list->ti_Tag == 2
        printf "TAG_MORE    %p\n", $list->ti_Data
        set $list = (struct TagItem *)$list->ti_Data
    else if $list->ti_Tag == 3
        printf "TAG_SKIP    %d\n", $list->ti_Data
        set $list = $list + $list->ti_Tag + 1
    else
        printf "%p  %p      %9lu\n", $list->ti_Tag, $list->ti_Data, $list->ti_Data
        set $list = $list + 1
    end
    end
    printf "TAG_DONE\n"
end
document printtaglist
end

define log_to_file
  set logging file $arg0
  set logging redirect on
  set logging overwrite $arg1
  set logging on
end

define end_log
  set logging off
end

define loadseg
    _debug_init
    dont-repeat
    if $_debug_ModList
        set $step = 1
        set $segnode = (struct segment *)$_debug_ModList->mlh_Head
        while ($segnode->s_node.mln_Succ != 0) && $step == 1
            if $arg0 >= $segnode->s_lowest && $arg0 <= $segnode->s_highest
                log_to_file segname.tmp on
                printf "%s", $segnode->s_mod->m_name
                end_log
                shell sed -i 's/.*:\(.*\)/\1/' segname.tmp
                log_to_file loadseg.tmp on
                printf "add-symbol-file "
                end_log
                shell head -n1 segname.tmp >>loadseg.tmp
                log_to_file loadseg.tmp off
                printf " %p", $segnode->s_lowest
                if $segnode->s_node.mln_Succ != 0
                    set $segnode = (struct segment *)$segnode->s_node.mln_Succ
                    while ($segnode->s_node.mln_Succ != 0) && $step < 5
                        if strcmp($segnode->s_name, ".text") == 0
                            loop_break
                        end
                        printf " -s %s %p", $segnode->s_name, $segnode->s_lowest
                        set $step = $step + 1
                        set $segnode = (struct segment *)$segnode->s_node.mln_Succ
                    end
                end
                end_log
                source loadseg.tmp
                loop_break
            end
            set $segnode = (struct segment *)$segnode->s_node.mln_Succ
        end


        if $step < 2
            set $kicknode = $_debug_KickList

            while ($kicknode != 0) && $step == 1
                set $eh = $kicknode->eh
                set $sh = $kicknode->sh
                set $shnum = $eh->shnum

                set $i = 0
                while ($i < $shnum)
                    if ($sh->addr != 0) && ($sh->size != 0)
                        set $lowest  = $sh->addr
                        set $highest = $sh->addr + $sh->size - 1

                        if $arg0 >= $lowest && $arg0 <= $highest
                            set $shstrndx = $eh->shstrndx
                            set $shstr = 0

                            if ($shstrndx < 0xFF00)
                                set $shstr = $shstrndx
                            end
                            if ($shstrndx > 0xFFFF)
                                set $shstr = $shstrndx - (0x10000 - 0xFF00)
                            end

                            log_to_file segname.tmp on
                            printf "%s", $kicknode->Name
                            end_log
                            shell sed -i 's/.*:\(.*\)/\1/' segname.tmp
                            log_to_file loadseg.tmp on
                            printf "add-symbol-file "
                            end_log
                            shell head -n1 segname.tmp >>loadseg.tmp
                            log_to_file loadseg.tmp off
                            printf " %p", $lowest

                            set $sh = $sh + 1
                            set $i = $i + 1

                            while ($i < $shnum)
                                if ($sh->addr != 0) && ($sh->size != 0)
#                                   This code does not work, cause error. I have no knowledge on how to make it work.
#                                    set $segname = $kicknode->sh[$shstr] + $sh->name
#                                    printf " -s %s %p", $segname, $sh->addr
                                end
                                set $step = $step + 1
                                set $sh = $sh + 1
                                set $i = $i + 1
                            end

                            end_log
                            source loadseg.tmp
                            loop_break
                        end
                    end

                    set $sh = $sh + 1
                    set $i = $i + 1
                end
                set $kicknode = $kicknode->Next
            end
        end

        if $step < 2
            printf "No matching module for this address\n"
        end


    end
end
document loadseg
Loads the module that contains the given address
end

define seglistdump
    _debug_init
    set $nextseg = $arg0
    set $count   = 1

    printf "Hunk num. | Start addr | Size       \n"
    printf "----------+------------+------------\n"
    while $nextseg
        printf "%9d | %p | %10d\n", $count, $nextseg + sizeof(BPTR), *((ULONG *)$nextseg - 1) - sizeof(BPTR)

        set $nextseg = *(BPTR *)$nextseg
        set $count = $count+1
    end
end
document seglistdump
Shows the segments chain of the given seglist
end

define bttask
    set $task = (struct Task *)$arg0
    if ($task->tc_Node.ln_Type != 1) && ($task->tc_Node.ln_Type != 13)
        printf "ERROR: Given address does not look like a task or process!\n"
    else
        #FIXME: The following assumes Linux x86
        set $old_esp = $esp
        set $old_eip = $eip
        
        if $task->tc_State == 2
            printf "WARNING: TS_RUN Task. Showing normal backtrace!\n"
        else
            set $esp = $task->tc_SPReg
            set $taskcontext = (struct AROSCPUContext *)$task->tc_UnionETask.tc_ETask.et_RegFrame
            set $eip = $taskcontext.regs.eip
        end
        
        bt
 
        set $esp = $old_esp
        set $eip = $old_eip
    end
end
document bttask
Shows the backtrace of the given TS_READY/TS_WAIT task
end

define semowner
    set $sem = (struct SignalSemaphore *)$arg0
    if $sem->ss_Link.ln_Type != 15
        printf "ERROR: Given address does not look like a semaphore!\n"
    else
        if $sem->ss_QueueCount == -1
            printf "The semaphore is free\n"
        else
            if $sem->ss_Owner == 0
                printf "The semaphore is locked in shared mode by one or more tasks\n"
            else
                    printf "The semaphore is owned by task %p (%s)\n", $sem->ss_Owner, $sem->ss_Owner->tc_Node.ln_Name
            end

            printf "\nWait Queue:\n\n"

            set $waitnode = (struct SemaphoreRequest *)$sem->ss_WaitQueue.mlh_Head

            while ($waitnode->sr_Link.mln_Succ != 0)
                set $waitertask = $waitnode->sr_Waiter
                if (int)$waitertask & 1
                    set $waitertask = $waitertask & ~1
                    printf " SHARED    "
                else
                    printf " EXCLUSIVE "
                end
                printf"%p %s\n", $waitertask, $waitertask->tc_Node.ln_Name
                set $waitnode = (struct SemaphoreRequest *)$waitnode->sr_Link.mln_Succ
            end
        end
    end
end
document semowner
Shows the owner of the given Exec Semaphore and the Wait Queue
end
