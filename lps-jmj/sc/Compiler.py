# File: compiler.py
# Author: Oliver Steele, P T Withington
# Description: JavaScript -> SWF bytecode compiler

# P_LZ_COPYRIGHT_BEGIN
#############################################################################
## Copyright (c) 2001-2004 Laszlo Systems, Inc.  All Rights Reserved.       #
## Use is subject to license terms                                          #
#############################################################################
# P_LZ_COPYRIGHT_END


#
# Imports
#

from __future__ import nested_scopes
from types import *
False, True = 0, 1

#
# Utility functions
#

def nconc(*a):
    l = len(a)
    if l == 0:
        return a
    elif l == 1:
        return list(a[0])
    else:
        l = list(a[0])
        l.extend(a[1])
        return nconc(l, *a[2:])

#
# Compiler Options
#

# TODO [2004-03-11 ptw] share with CompilationEnvironment.java
ACTIVATION_OBJECT = 'createActivationObject'
COMPUTE_METAREFERENCES = 'computeMetaReferences'
CONDITIONAL_COMPILATION = 'conditionalCompilation'
ALLOW_ROOT = 'allowRoot'
CACHE_COMPILES = 'cacheCompiles'
COMPILE_TRACE = 'compileTrace'
COMPILE_TIME_CONSTANTS = 'compileTimeConstants'
CONSTRAINT_FUNCTION = 'constraintFunction'
DEBUG = 'debug'
DISABLE_CONSTANT_POOL = 'disableConstantPool'
ELIMINATE_DEAD_EXPRESSIONS = 'eliminateDeadExpressions'
FLASH_COMPILER_COMPATABILITY = 'flashCompilerCompatability'
GENERATE_FUNCTION_2 = 'generateFunction2'
GENERATE_FUNCTION_2_FOR_LZX = 'generateFunction2ForLZX'
INCLUDES = 'processIncludes'
INSTR_STATS = 'instrStats'
KRANK = 'krank'
RUNTIME = 'runtime'
METHOD_NAME = 'methodName'
NAME_FUNCTIONS = 'nameFunctions'
OBFUSCATE = 'obfuscate'
PROFILE = 'profile'
PROFILE_COMPILER = 'profileCompiler'
PROGRESS = 'progress'
PRINT_COMPILER_OPTIONS = 'printCompilerOptions'
PRINT_CONSTRAINTS = 'printConstraints'
PRINT_INSTRUCTIONS = 'printInstructions'
RESOLVER = 'resolver'
SCRIPT_ELEMENT = 'scriptElement'
WARN_UNDEFINED_REFERENCES = 'warnUndefinedReferences'
WARN_GLOBAL_ASSIGNMENTS = 'warnGlobalAssignments'
WARN_UNUSED_LOCALS = 'warnUnusedLocals'
WARN_UNUSED_PARAMETERS = 'warnUnusedParameters'
WITH_THIS = 'withThis'

# Options that don't affect code generation.  This is used to decide
# what it's okay to cache across LFC build versions.  It's okay if
# it's too small.
NonCodeGenerationOptions = [
    CACHE_COMPILES,PROFILE_COMPILER,INSTR_STATS,
    PROFILE_COMPILER,
    PROGRESS,PRINT_COMPILER_OPTIONS,PRINT_CONSTRAINTS,PROGRESS,
    RESOLVER,
    # These affect the default settings for the options above, but
    # do not themselves make a difference.
    DEBUG,KRANK]

#
# Parser
#

# A scanner and parser generated by JavaCC and jjtree are used to
# create a Java AST of the input, with literals annotated by Java
# objects (instances of String and the numeric types).

# jythonc has special support for 'import...as'.  It's necessary to use
# it for importing classes from the same JAR that this file is compiled
# into.
# TODO: [2002-12-11 ows] remove the need in jythonc for this special-casing
import org.openlaszlo.sc.parser.Parser as _Parser
import org.openlaszlo.sc.parser.ParseException as ParseException
import org.openlaszlo.sc.parser.ParserConstants as Ops

# Bind a global variable {Name} to each Java class
# org.openlaszlo.sc.parser.AST{Name}

# jythonc has special support for 'import...as'.  It's necessary to use
# it for importing classes from the same JAR that this file is compiled
# into.
import org.openlaszlo.sc.parser.ASTAndExpressionSequence as AndExpressionSequence
import org.openlaszlo.sc.parser.ASTArrayLiteral as ArrayLiteral
import org.openlaszlo.sc.parser.ASTAssignmentExpression as AssignmentExpression
import org.openlaszlo.sc.parser.ASTBinaryExpressionSequence as BinaryExpressionSequence
import org.openlaszlo.sc.parser.ASTBreakStatement as BreakStatement
import org.openlaszlo.sc.parser.ASTCallExpression as CallExpression
import org.openlaszlo.sc.parser.ASTCaseClause as CaseClause
import org.openlaszlo.sc.parser.ASTClassDefinition as ClassDefinition
import org.openlaszlo.sc.parser.ASTConditionalExpression as ConditionalExpression
import org.openlaszlo.sc.parser.ASTContinueStatement as ContinueStatement
import org.openlaszlo.sc.parser.ASTDefaultClause as DefaultClause
import org.openlaszlo.sc.parser.ASTDirectiveBlock as DirectiveBlock
import org.openlaszlo.sc.parser.ASTDoWhileStatement as DoWhileStatement
import org.openlaszlo.sc.parser.ASTEmptyExpression as EmptyExpression
import org.openlaszlo.sc.parser.ASTExpressionList as ExpressionList
import org.openlaszlo.sc.parser.ASTExtends as Extends
import org.openlaszlo.sc.parser.ASTForInStatement as ForInStatement
import org.openlaszlo.sc.parser.ASTForStatement as ForStatement
import org.openlaszlo.sc.parser.ASTForVarInStatement as ForVarInStatement
import org.openlaszlo.sc.parser.ASTForVarStatement as ForVarStatement
import org.openlaszlo.sc.parser.ASTFormalParameterList as FormalParameterList
import org.openlaszlo.sc.parser.ASTFunctionCallParameters as FunctionCallParameters
import org.openlaszlo.sc.parser.ASTFunctionDeclaration as FunctionDeclaration
import org.openlaszlo.sc.parser.ASTFunctionExpression as FunctionExpression
import org.openlaszlo.sc.parser.ASTIdentifier as Identifier
import org.openlaszlo.sc.parser.ASTIfDirective as IfDirective
import org.openlaszlo.sc.parser.ASTIfStatement as IfStatement
import org.openlaszlo.sc.parser.ASTIncludeDirective as IncludeDirective
import org.openlaszlo.sc.parser.ASTLabeledStatement as LabeledStatement
import org.openlaszlo.sc.parser.ASTLiteral as Literal
import org.openlaszlo.sc.parser.ASTNewExpression as NewExpression
import org.openlaszlo.sc.parser.ASTObjectLiteral as ObjectLiteral
import org.openlaszlo.sc.parser.ASTOperator as Operator
import org.openlaszlo.sc.parser.ASTOrExpressionSequence as OrExpressionSequence
import org.openlaszlo.sc.parser.ASTPostfixExpression as PostfixExpression
import org.openlaszlo.sc.parser.ASTPragmaDirective as PragmaDirective
import org.openlaszlo.sc.parser.ASTProgram as Program
import org.openlaszlo.sc.parser.ASTPropertyIdentifierReference as PropertyIdentifierReference
import org.openlaszlo.sc.parser.ASTPropertyValueReference as PropertyValueReference
import org.openlaszlo.sc.parser.ASTReturnStatement as ReturnStatement
import org.openlaszlo.sc.parser.ASTStatement as Statement
import org.openlaszlo.sc.parser.ASTStatementList as StatementList
import org.openlaszlo.sc.parser.ASTSuperCallExpression as SuperCallExpression
import org.openlaszlo.sc.parser.ASTSwitchStatement as SwitchStatement
import org.openlaszlo.sc.parser.ASTThisReference as ThisReference
import org.openlaszlo.sc.parser.ASTThrowStatement as ThrowStatement
import org.openlaszlo.sc.parser.ASTTryStatement as TryStatement
import org.openlaszlo.sc.parser.ASTUnaryExpression as UnaryExpression
import org.openlaszlo.sc.parser.ASTVariableDeclaration as VariableDeclaration
import org.openlaszlo.sc.parser.ASTVariableStatement as VariableStatement
import org.openlaszlo.sc.parser.ASTWhileStatement as WhileStatement
import org.openlaszlo.sc.parser.ASTWithStatement as WithStatement


class Splice:
    """Wrapper for values that Parser.substitute should splice into place,
    instead of substituting at the level of the template variable."""
    def __init__(self, value):
        self.value = value

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, self.value)

class Parser:
    """Wrapper for the Java parser.  Returns a tuple-tree."""

    def parse0(self, str, type='Program'):
        from java.io import StringReader
        p = _Parser(StringReader(str))
        return getattr(p, type)()

    def parse(self, str):
        node = self.parse0(str)
        return self.refactorAST(node) or node

    def refactorAST(self, n):
        """ Modify the AST tree rooted at n so that its branching
        structure matches evaluation order.  This is necessary because
        the parser is right-recursive, and generates flat trees for
        a+b+c and a.b.c. """
        if n.children:
            for i in range(len(n.children)):
                x = self.refactorAST(n.children[i])
                if x: n.children[i] = x
        k = n.class
        ptp = ParseTreePrinter();
        # This test works around a problem that k.name produces an
        # error when k is Literal.
        if n.children:
            # The transforms in this branch insure that each binary
            # expression sequence has exactly two children (not
            # counting the operator).
            def fold(n, ar):
                # Transform K(a0,a1,a2) -> K(K(a0,a1),a2), such that no K node
                # has an arity greater than ar.
                if len(n.children) > ar:
                    child = n.class(0)
                    child.setBeginLocation(n.filename, n.lineNumber, n.columnNumber)
                    child.setChildren(n.children[:-(ar-1)])
                    if len(child.children) > ar:
                        fold(child, ar)
                    n.setChildren([child] + list(n.children[-(ar-1):]))
            if k.name.endswith('BinaryExpressionSequence'):
                # Transform a flat sequence of subexpressions with
                # alternating operators into a right-branching binary
                # tree.  This corrects the fact that the parser, being
                # recursive-descent, is right-factored, but the operators
                # are left-associative.
                #
                # For example:
                # K(a, o1, b, o2, c) -> K(K(a, o1, b), o2, c)
                # K(a, o1, b, o2, c, o3, d) -> K(K(K(a, o1, b), o2, c), o3, d)
                fold(n, 3)
            elif k.name.endswith('ExpressionSequence'):
                # Transforms K(a, b, c) -> K(K(a, b), c),
                # where n is in (AndExpressionSequence, OrExpressionSequence)
                fold(n, 2)
        if k is CallExpression:
            # C(a, P(b)) -> P(a, b)
            # C(a, P(b), P(c)) -> P(P(a, b), c)
            # C(a, P(b), A) -> C(P(a, b), A)
            # C(a, P(b), P(c), A) -> C(P(P(a, b), c), A)
            # C(a, A) -> C(a, A)
            # C(a, A, P(b)) -> P(C(a, A), b)
            # where
            #   C = CallExpression
            #   P = PropertyIdentifierReference
            #   A = FunctionCallParameters
            while len(n.children) > 1:
                if n[1].class is FunctionCallParameters:
                    if len(n.children) > 2:
                        c = n.class(0)
                        c.setBeginLocation(n.filename, n.lineNumber, n.columnNumber)
                        c.setChildren(n.children[:2])
                        n.setChildren([c] + list(n.children[2:]))
                        continue
                    else:
                        break
                p = n[1]
                assert p.class in (PropertyIdentifierReference,
                                   PropertyValueReference), p
                p.setChildren((n[0], p[0]))
                n.setChildren(n.children[1:])
            if len(n.children) == 1:
                return n[0]
        # After refactoring, assure each function has a name
        if n.class is AssignmentExpression:
            if n[2].class is FunctionExpression:
                # fn children are [(name), arglist, body]
                if len(n[2].children) == 2:
                    # TODO: [2003-06-19 ptw] (krank) Sanitization of
                    # name to identifier moved to krank user, remove
                    # #- when it works
                    #- from string import replace
                    #- name = replace(ptp.visit(n[0]), ".", "_")
                    name = ptp.visit(n[0])
                    n[2].setChildren([Identifier(name)] + list(n[2].children))

    def build(self, *tuple):
        """Build a node out of an AST tuple-tree."""
        node = tuple[0]
        assert not node.children
        for child in tuple[1:]:
            if isinstance(child, TupleType):
                child = self.build(*child)
            node.jjtAddChild(child, len(node.children))
        return node

    def substitute(self, str, **keys):
        """Parse an expression and replace any identifier with the same
        name as a keyword argument to this function, with the value of
        that key.  If the value has type Splice, it's spliced into place
        instead of substituting at the same level.

        >>> s = Parser().substitute
        >>> s('[0,1,2]')
        (ASTArrayLiteral, Literal(0.0), Literal(1), Literal(2))
        >>> s('[_0,1,2]', _0=Literal("sub"))
        (ASTArrayLiteral, Literal(sub), Literal(1), Literal(2))
        >>> s('[_0,1,2]', _0=s('[a,b,c]'))
        (ASTArrayLiteral, (ASTArrayLiteral, ASTIdentifier(a), ASTIdentifier(b), ASTIdentifier(c)), Literal(1), Literal(2))
        >>> s('[_0,1,2]', _0=Splice(s('[a,b,c]')))
        (ASTArrayLiteral, ASTArrayLiteral, ASTIdentifier(a), ASTIdentifier(b), ASTIdentifier(c), Literal(1), Literal(2))

        N.B., there is no attempt to enforce macro hygiene
        """
        # Since the parser can't parse an Expression, turn the source
        # into a Program, and extract the Expression from the parse tree.
        node = self.parse('x = ' + str)[0][0][2]
        def visit(node):
            result = []
            for child in node.children:
                if child.class is Identifier:
                    value = keys.get(child.name)
                    if value:
                        if isinstance(value, Splice):
                            result.extend(value.value)
                        else:
                            result.append(value)
                        continue
                result.append(visit(child))
            node.children = result
            return node
        return visit(node)

class Visitor:
    def getVisitor(self, node):
        # trim the module name, and the initial 'AST'
        if node.class is Identifier:
            name = 'Identifier'
        else:
            name = node.class.name
            name = name[name.rfind('.')+4:]
        return getattr(self, 'visit' + name, None)

def getSourceLocation(node):
    """ASTNode -> fname, lineno"""
    # Kranking requires unique names, so uniquify unknown with UID
    return node.filename or 'unknown file', node.lineNumber


#
# Parse Tree Printer
#

# This class is only used in testing.
# TODO: [2002-12-17 ows] This only handles the parse node types that
# I've needed in debugging.
# FIXME: [2002-12-21 ows] the parenthesizing mechanism doesn't work for
# non-binary operators (unary '-', typeof, void, ?:, etc.)
class ParseTreePrinter(Visitor):
    def print(self, node):
        print self.visit(node)

    def visit(self, node):
        children = map(self.visit, node.children)
        nt = node.class
        if self.Joins.get(nt):
            return self.Joins[nt].join(children)
        elif self.FormatStrings.get(nt):
            return self.FormatStrings[nt] % tuple(children)
        fn = self.getVisitor(node)
        if fn:
            return fn(node, *children)
        else:
            return '#\u00AB%r(%s)\u00BB' % (node, ','.join(children))

    Joins = {FormalParameterList: ', ',
             FunctionCallParameters: ', ',
             Program: '\n',
             AndExpressionSequence: ' && ',
             OrExpressionSequence: ' || ',
             Statement: '\n',
             VariableStatement: '\n',
             StatementList: '\n',
             }

    # Copied (and massaged) from Parser.jjt
    OperatorNames = {
        Ops.ASSIGN: "=",
        Ops.GT: ">",
        Ops.LT: "<",
        Ops.BANG: "!",
        Ops.TILDE: "~",
        Ops.HOOK: "?",
        Ops.COLON: ":",
        Ops.EQ: "==",
        Ops.LE: "<=",
        Ops.GE: ">=",
        Ops.NE: "!=",
        Ops.SEQ: "===",
        Ops.SNE: "!==",
        Ops.SC_OR: "||",
        Ops.SC_AND: "&&",
        Ops.INCR: "++",
        Ops.DECR: "--",
        Ops.PLUS: "+",
        Ops.MINUS: "-",
        Ops.STAR: "*",
        Ops.SLASH: "/",
        Ops.BIT_AND: "&",
        Ops.BIT_OR: "|",
        Ops.XOR: "^",
        Ops.REM: "%",
        Ops.LSHIFT: "<<",
        Ops.RSIGNEDSHIFT: ">>",
        Ops.RUNSIGNEDSHIFT: ">>>",
        Ops.PLUSASSIGN: "+=",
        Ops.MINUSASSIGN: "-=",
        Ops.STARASSIGN: "*=",
        Ops.SLASHASSIGN: "/=",
        Ops.ANDASSIGN: "&=",
        Ops.ORASSIGN: "|=",
        Ops.XORASSIGN: "^=",
        Ops.REMASSIGN: "%=",
        Ops.LSHIFTASSIGN: "<<=",
        Ops.RSIGNEDSHIFTASSIGN: ">>=",
        Ops.RUNSIGNEDSHIFTASSIGN: ">>>=",

        Ops.TYPEOF: "typeof",
        Ops.DELETE: "delete",
        Ops.VOID: "void"
    }

    FormatStrings = {
        AssignmentExpression: '%s %s %s',
        CallExpression: '%s(%s)',
        ConditionalExpression: '%s ? %s : %s',
        EmptyExpression: 'undefined',
        NewExpression: 'new %s',
        PragmaDirective: '#pragma %s',
        PostfixExpression: '%s%s',
        PropertyIdentifierReference: '%s.%s',
        PropertyValueReference: '%s[%s]',
        ReturnStatement: 'return %s',
        ThisReference: 'this',
        UnaryExpression: '%s %s',
        VariableDeclaration: 'var %s = %s',
        WithStatement: 'with (%s) {%s}',
        }

    def prec(self, op):
        n = self.OperatorNames[op]
        classes = ['() [] .',
                   '! ~ - ++ -- typeof new void',
                   '* / %',
                   '+ -',
                   '<< >> >>>',
                   '< <= > >=',
                   '== !=',
                   '&', '^', '|', '&&', '||', '?:',
                   ' = += -= *= /= %= <<= >>= >>>= &= ^= |=']
        for i in range(len(classes)):
            for name in classes[i].split():
                if n == name:
                    return -i
        raise "unknown operator"

    def visitArrayLiteral(self, n, *args):
        return '[' + ', '.join(args) + ']'

    def visitBinaryExpressionSequence(self, n, a, op, *args):
        args = [a] + list(args)
        for i in range(len(args)):
            c = n[i+(i>0)]
            if c.class is BinaryExpressionSequence:
                if self.prec(c[1].operator) < self.prec(n[1].operator):
                    args[i] = '(' + args[i] + ')'
        return op.join(args)

    def visitFunctionDeclaration(self, n, *args):
        if len(args) == 2:
            name = ''
            args, body = args
        else:
            name, args, body = args
        return 'function %s(%s) {%s}' % (name, args, body)

    visitFunctionExpression = visitFunctionDeclaration

    def visitIdentifier(self, n):
        return n.name

    def visitLiteral(self, n):
        str = `n.value`
        if type(n.value) is LongType and str[-1] == 'L':
            str = str[:-1]
        return str

    def visitObjectLiteral(self, n, *args):
        s = '{'
        for i in range(len(args)):
            s += args[i]
            if i % 2:
                if i+1 < len(args):
                    s += ', '
            else:
                s += ': '
        return s + '}'

    def visitOperator(self, op):
        return self.OperatorNames.get(op.operator, '<%d>' % op.operator)

    def visitVariableDeclaration(self, n, var, *init):
        if init:
            return 'var %s = %s' % (var, init[0])
        else:
            return 'var %s' % var

def nodeString(node):
    return ParseTreePrinter().visit(node)

#
# Errors
#

def getLocationString(node):
    location = ''
    if node:
        if node.filename:
            location = node.filename + ':'
        if node.lineNumber:
            location += `node.lineNumber` + ':'
            location += `node.columnNumber` + ':'
        location += ' '
    return location

class CompilerError:
    def __init__(self, msg, node=None):
        self.msg = msg
        self.node = node

    def attachNode(self, node):
        assert not self.node
        self.node = node

    def __repr__(self):
        return getLocationString(self.node) + self.msg

class SemanticError(CompilerError):
    pass

class UnimplementedError(CompilerError):
    pass

class CompilerImplementationError:
    def __init__(self, msg, node):
        self.node = node
        self.msg = msg

    def __repr__(self):
        return getLocationString(self.node) + self.msg

#
# Code Generation
#

# The CodeGenerator recurses over the parse tree, sending instructions
# to an InstructionCollector.  The entry point is translate(), and it
# does its work by calling two mutually recursive functions,
# visitStatement and visitExpression, which dispatch to visitor
# functions for specific statement and expression types based on the
# name of the class of the parser node.  (A declaration or definition
# is considered to be a statement.)

import org.openlaszlo.sc.Values as Values
import org.openlaszlo.sc.Instructions as Instructions

# TODO [2004-03-09 ptw] Fix jython import * to import static members
NONE = Instructions.NONE
NextFrame = Instructions.NextFrame
PreviousFrame = Instructions.PreviousFrame
PLAY = Instructions.PLAY
STOP = Instructions.STOP
ToggleQuality = Instructions.ToggleQuality
StopSounds = Instructions.StopSounds
NumericAdd = Instructions.NumericAdd
SUBTRACT = Instructions.SUBTRACT
MULTIPLY = Instructions.MULTIPLY
DIVIDE = Instructions.DIVIDE
OldEquals = Instructions.OldEquals
OldLessThan = Instructions.OldLessThan
LogicalAnd = Instructions.LogicalAnd
LogicalOr = Instructions.LogicalOr
NOT = Instructions.NOT
StringEqual = Instructions.StringEqual
StringLength = Instructions.StringLength
SUBSTRING = Instructions.SUBSTRING
POP = Instructions.POP
INT = Instructions.INT
GetVariable = Instructions.GetVariable
SetVariable = Instructions.SetVariable
SetTargetExpression = Instructions.SetTargetExpression
StringConcat = Instructions.StringConcat
GetProperty = Instructions.GetProperty
SetProperty = Instructions.SetProperty
DuplicateMovieClip = Instructions.DuplicateMovieClip
RemoveClip = Instructions.RemoveClip
TRACE = Instructions.TRACE
StartDragMovie = Instructions.StartDragMovie
StopDragMovie = Instructions.StopDragMovie
StringLessThan = Instructions.StringLessThan
RANDOM = Instructions.RANDOM
MBLENGTH = Instructions.MBLENGTH
ORD = Instructions.ORD
CHR = Instructions.CHR
GetTimer = Instructions.GetTimer
MBSUBSTRING = Instructions.MBSUBSTRING
MBORD = Instructions.MBORD
MBCHR = Instructions.MBCHR
GotoFrame = Instructions.GotoFrame
GetUrl = Instructions.GetUrl
WaitForFrame = Instructions.WaitForFrame
SetTarget = Instructions.SetTarget
GotoLabel = Instructions.GotoLabel
WaitForFrameExpression = Instructions.WaitForFrameExpression
PUSH = Instructions.PUSH
BRANCH = Instructions.BRANCH
GetURL2 = Instructions.GetURL2
BranchIfTrue = Instructions.BranchIfTrue
CallFrame = Instructions.CallFrame
GotoExpression = Instructions.GotoExpression
DELETE = Instructions.DELETE
DELETE2 = Instructions.DELETE2
VarEquals = Instructions.VarEquals
CallFunction = Instructions.CallFunction
RETURN = Instructions.RETURN
MODULO = Instructions.MODULO
NEW = Instructions.NEW
VAR = Instructions.VAR
InitArray = Instructions.InitArray
InitObject = Instructions.InitObject
TypeOf = Instructions.TypeOf
TargetPath = Instructions.TargetPath
ENUMERATE = Instructions.ENUMERATE
ADD = Instructions.ADD
LessThan = Instructions.LessThan
EQUALS = Instructions.EQUALS
ObjectToNumber = Instructions.ObjectToNumber
ObjectToString = Instructions.ObjectToString
DUP = Instructions.DUP
SWAP = Instructions.SWAP
GetMember = Instructions.GetMember
SetMember = Instructions.SetMember
Increment = Instructions.Increment
Decrement = Instructions.Decrement
CallMethod = Instructions.CallMethod
NewMethod = Instructions.NewMethod
BitwiseAnd = Instructions.BitwiseAnd
BitwiseOr = Instructions.BitwiseOr
BitwiseXor = Instructions.BitwiseXor
ShiftLeft = Instructions.ShiftLeft
ShiftRight = Instructions.ShiftRight
UShiftRight = Instructions.UShiftRight
SetRegister = Instructions.SetRegister
CONSTANTS = Instructions.CONSTANTS
WITH = Instructions.WITH
DefineFunction = Instructions.DefineFunction
DefineFunction2 = Instructions.DefineFunction2
InstanceOf = Instructions.InstanceOf
EnumerateValue = Instructions.EnumerateValue
StrictEquals = Instructions.StrictEquals
GreaterThan = Instructions.GreaterThan
StringGreaterThan = Instructions.StringGreaterThan
BranchIfFalse = Instructions.BranchIfFalse
LABEL = Instructions.LABEL
COMMENT = Instructions.COMMENT
CHECKPOINT = Instructions.CHECKPOINT
BLOB = Instructions.BLOB

# A linked list of TranslationContexts stores information that is used
# for break, continue, and return.  The TranslationContext is threaded
# through calls to the statement visitors, as the context argument.
#
# There are two views of the context list: the abstract view, which
# the abrupt completion code uses, and the concrete view, which is
# what's constructed and what's threaded through the statement
# visitors.  In the abstract view, each item in the list represents an
# iteration context (a context for an iteration construct such as for
# or do statement), except for the outermost context which either
# represents a program or a function; and each context is labelled
# with a list of labels.  In the concrete view, each context has a
# single, optional, label, and there are contexts representing labeled
# statements as well.  In order to produce the first view from the
# second, the accessor methods consider a context to have as labels
# all the labels of it labeled statement ancestors as well, up to the
# closest ancestor that's not a labeled statement; and a context's
# parent is considered to be the closest ancestor that's not a labeled
# statement.

class TranslationContext:
    FLASM = 'flasm'
    VARIABLES = 'variables'
    LOWERVARIABLES = 'lowerVariables'    
    REGISTERS = 'registers'
    LOWERREGISTERS = 'lowerRegisters'    

    def __init__(self, type, parent, label=None):
        if type == FunctionDeclaration:
            type = FunctionExpression
        self.type = type
        self.parent = parent # : TranslationContext
        self.label = label # : string | None
        # if isEnumeration is true, this context represents a
        # 'for...in', and unused values need to be popped from the
        # stack during an abrupt completion
        self.isEnumeration = False
        self.targets = {} # 'break'|'continue' -> label (string)
        self.properties = {}

    def clone(self):
        copy = self.__class__(self.type, self.parent, self.label)
        copy.__dict__.update(self.__dict__)
        copy.targets = {}
        copy.targets.update(self.targets)
        copy.properties = {}
        copy.properties.update(self.properties)
        return copy

    def getProperty(self, key):
        if self.properties.has_key(key):
            return self.properties[key]
        else:
            return self.parent and self.parent.getProperty(key)

    def setProperty(self, key, value):
        self.properties[key] = value

    def isFunctionBoundary(self):
        return self.type == FunctionExpression

    def getLabelSet(self):
        """Returns a set of labels for this statement."""
        labels = []
        if self.label:
            labels.append(self.label)
        parent = self.parent
        while parent and parent.type is LabeledStatement:
            if parent.label:
                labels.append(parent.label)
            parent = parent.parent
        return labels

    def getParentStatement(self):
        parent = self.parent
        while parent and parent.type is LabeledStatement:
            parent = parent.parent
        return parent

    def findLabeledContext(self, label):
        """Returns the innermost context labelled with the specified label,
        or None."""
        if label is None:
            return self
        if label in self.getLabelSet():
            return self
        parent = self.getParentStatement()
        if parent and not parent.isFunctionBoundary():
            return parent.findLabeledContext(label)

    def setTarget(self, type, instrs):
        assert type in ('break', 'continue')
        self.targets[type] = instrs

    def getTarget(self, type):
        assert type in ('break', 'continue')
        return self.targets.get(type)

    def emitBreakPreamble(self, receiver):
        """Emit the code necessary to abruptly leave a context (not
        including the jump statement itself)."""
        # TODO: [2003-01-14 ptw, ows] This could break if null can be
        # used as a key: {null 0: 1}.  It might also break because of
        # the semantics of the equals opcode: {function(){}: 1}.
        if self.isEnumeration:
            label = receiver.newLabel()
            receiver.emit(LABEL(label))
            receiver.push(Values.Null)
            receiver.emit(EQUALS)
            receiver.emit(NOT)
            receiver.emit(BranchIfTrue(label))


# A Reference represents a variable, property, or array reference ---
# a LeftHandSide in the grammar.  References can be retrieved or
# assigned.

class Reference:
    """The abstract base class."""
    def __init__(self, translator, node, referenceCount):
        self.translator = translator
        self.node = node
        self.referenceCount = referenceCount

    def _pop(self):
        """Check that the reference count supplied at initialization
        time was large enough."""
        assert self.referenceCount, CompilerImplementationError('underflow', self.node)
        self.referenceCount -= 1

    def get(self):
        """Emit instructions that push this reference's value onto the
        stack."""
        raise "Subclass responsibility"

    def preset(self):
        """Emit instructions that set the stack up to set this
        reference's value.  Example use:
          reference.preset()
          generator.push(1)
          reference.set().
        """
        raise "Subclass responsibility"

    def set(self):
        """Emit instructions that set the value of this object.  See
        self.preset() for an example."""
        raise "Subclass responsibility"

    def declare(self):
        """Emit instructions that will declare this object.  E.g.,
        create an uninitialized variable in a particular context"""
        raise "Subclass responsibility"


    def init(self):
        """Emit instructions that will initialize this object.  E.g.,
        create a variable in a particular context"""
        # Same as set, for most subclasses
        self.set()

class VariableReference(Reference):
    def __init__(self, translator, node, referenceCount, name):
        Reference.__init__(self, translator, node, referenceCount)
        import sys
        fname, lineno = getSourceLocation(self.node)
        self.name = name
        registers = translator.context.getProperty(TranslationContext.REGISTERS)
        lowerRegisters = translator.context.getProperty(TranslationContext.LOWERREGISTERS)
        self.register = lowerRegisters and lowerRegisters.get(name.lower(), None)
        if self.register and not registers.get(name, None):
            print >> sys.stderr, "Warning: Different case used for %s in %s(%s)" % (self.name, fname, lineno)
        known = translator.context.getProperty(TranslationContext.VARIABLES)
        lowerKnown = translator.context.getProperty(TranslationContext.LOWERVARIABLES)
        selfknown = lowerKnown and self.name.lower() in lowerKnown
        if selfknown and not self.name in known:
            print >> sys.stderr, "Warning: Different case used for %s in %s(%s)" % (self.name, fname, lineno)
        # Ensure undefined is "defined"
        self.check = name != 'undefined' and \
                     (not known or not selfknown)

    def get(self, checkUndefined=True):
        self._pop()
        if self.register:
            self.translator.emit(PUSH(Values.Register(self.register.regno)))
        else:
            self.translator.push(self.name)
            self.translator.emit(GetVariable)
        if checkUndefined and self.check:
            checkUndefinedVariable(self.translator, self.node, self.name)
        return self

    def preset(self):
        self._pop()
        if not self.register:
            if (self.name == 'undefined'):
                raise SemanticError("Invalid l-value", self.node)
            self.translator.push(self.name)
        return self

    def set(self, warnGlobal=None):
        if warnGlobal is None:
            warnGlobal = self.translator.context.type is not Program and \
                         self.translator.options.get(WARN_GLOBAL_ASSIGNMENTS)
        if warnGlobal and self.check:
            import sys
            fname, lineno = getSourceLocation(self.node)
            print >> sys.stderr, "Warning: Assignment to free variable %s in %s(%s)" % (self.name, fname, lineno)
        if self.register:
            self.translator.emit(SetRegister(self.register.regno))
            # TODO: [2004-03-24 ptw] Optimize this away if the value is used
            self.translator.emit(POP)
        else:
            self.translator.emit(SetVariable)
        return self

    def declare(self):
        # If activation object or register, already declared or allocated
        assert not self.translator.options.get(ACTIVATION_OBJECT)
        if not self.register:
            self.translator.emit(VAR)
        return self

    def init(self):
        if self.register or self.translator.options.get(ACTIVATION_OBJECT):
            self.set()
        else:
            self.translator.emit(VarEquals)
        return self

# NOTE: [2002-10-24 ptw] Not completely right, this handles the case
# where a literal is the target of a method operation.  It is like a
# reference but it is not an lvalue.
class LiteralReference(Reference):
    def __init__(self, translator, node, referenceCount):
        Reference.__init__(self, translator, node, referenceCount)

    def get(self, checkUndefined=True):
        self._pop()
        self.translator.visitExpression(self.node)
        return self

    def preset(self):
        raise SemanticError("Invalid literal operation", self.node)

    def set(self):
        raise SemanticError("Invalid literal operation", self.node)

# TODO: [2004-03-25 ptw] Use auto-reg for arguments in swf7, allocate
# temp registers for tick recording
def meterFunctionEvent(translator, node, event, name):
    """Emits code to meter a function call.  If name is set, uses
    that, otherwise uses arguments.callee.name"""
    if translator.options.get(PROFILE):
        # Get the name of a function object
        if name:
            getname = [ PUSH(name) ]
        else:
            getname = [ PUSH('arguments'),
                        GetVariable,
                        PUSH('callee'),
                        GetMember,
                        PUSH('name'),
                        GetMember]
        # Note that this does not check for undefined methods -- the
        # methods are purposely undefined to disable profiling at run
        # time.
        #
        # N.B., According to the Javascript spec, getTime() returns
        # the time in milliseconds, but we have observed that the
        # Flash player on some platforms tries to be accurate to
        # microseconds (by including fractional milliseconds).  On
        # other platforms, the time is not even accurate to
        # milliseconds, hence the kludge to manually increment the
        # clock by microseconds to create a monotonic ordering.
        #
        # The choice of 0.01 to increment by is based on the
        # observation that when floats are used as member names in an
        # object they are coerced to strings with only 15 significant
        # digits.  This should suffice for the next (10^13)-1
        # microseconds (about 300 years).
        translator.translateControlStructure(
            [PUSH('_root'),             # '_root'
             GetVariable,               # _root
             PUSH('$lzprofiler'),       # _root '$lzprofiler'
             GetMember,                 # _r.$lzp
             SetRegister(0),            # _r.$lzp -> r0
             PUSH ('tick'),             # _r.$lzp 'tick'
             PUSH(Values.Register(0)),  # _r.$lzp 'tick' _r.$lzp
             PUSH ('tick'),             # _r.$lzp 'tick' _r.$lzp 'tick'
             GetMember,                 # _r.$lzp 'tick' _r.$lzp.tick
             SetRegister(1),            # _r.$lzp.tick -> r1
             PUSH((0, 0, 'Date')),      # _r.$lzp 'tick' _r.$lzp.tick 0 0 'Date'
             NEW,                       # _r.$lzp 'tick' _r.$lzp.tick 0 (new Date)
             PUSH('getTime'),           # _r.$lzp 'tick' _r.$lzp.tick 0 (n D) 'getTime'
             CallMethod,                # _r.$lzp 'tick' _r.$lzp.tick (n D).getTime()
             0,                         # 0:
             SetRegister(2),            # (n D).getTime() -> r2
             LessThan,                  # _r.$lzp 'tick' _r.$lzp.tick < (n D).gT()
             BranchIfTrue(1),           # _r.$lzp 'tick'
             PUSH(Values.Register(1)),  # _r.$lzp 'tick' _r.$lzp.tick
             PUSH(Values.Register(2)),  # _r.$lzp 'tick' _r.$lzp.tick (n D).getTime()
             PUSH(0.01),                # _r.$lzp 'tick' _r.$lzp.tick (n D).getTime() 0.0001
             ADD,                       # _r.$lzp 'tick' _r.$lzp.tick (n D).getTime() + 0.0001
             BRANCH(0),                 # _r.$lzp 'tick' _r.$lzp.tick (n D).getTime() + 0.0001
             1,                         # 1:
             PUSH(Values.Register(2)),  # _r.$lzp 'tick' (n D).getTime()
             SetMember,                 #
             PUSH(Values.Register(0)),  # _r.$lzp
             PUSH(event),               # _r.$lzp event
             GetMember,                 # _r.$lzp[event]
             PUSH(Values.Register(2))] + \
            getname + \
            [SetMember])

def checkUndefinedFunction(translator, node, reference):
    """Emits code to check that a function is defined.  If reference is
    set, expects the function reference to be at the top of the stack
    when called, otherwise expects the function object."""
    if translator.options.get(WARN_UNDEFINED_REFERENCES) and node.filename:
        t = translator
        fname, lineno = getSourceLocation(node)
        label = translator.newLabel()
        t.emit(DUP)                     # ref ref
        # Get the value of a function reference
        if reference:
            t.emit(GetVariable)         # ref val
        t.emit(DUP)                     # ref val val
        t.emit(TypeOf)                  # ref val type
        t.push("function")              # ref val type "function"
        t.emit(StringEqual)             # ref val type=="function"
        t.emit(BranchIfTrue(label))
        t.emitCall('$reportNotFunction', fname, lineno, reference, DUP)
        t.emit(LABEL(label))
        t.emit(POP)                     # pop error return or extra value

def checkUndefinedObjectProperty(translator, node, propertyName):
    """Emits code to check that the object exists before making a
    property reference.  Expects the object to be at the top of stack
    when called."""
    if translator.options.get(WARN_UNDEFINED_REFERENCES) and node.filename:
        t = translator
        fname, lineno = getSourceLocation(node)
        label = t.newLabel()
        t.emit(DUP)
        t.emit(TypeOf)
        t.push("undefined")
        t.emit(EQUALS)
        t.emit(NOT)
        t.emit(BranchIfTrue(label))
        t.emitCall('$reportUndefinedObjectProperty',
                   fname, lineno, propertyName)
        t.emit(POP)                     # pop error return
        t.emit(LABEL(label))

def checkUndefinedProperty(translator, node, propertyName):
    """Emits code to check that an object property is defined.
    Expects the object member to be at the top of stack when
    called."""
    if translator.options.get(WARN_UNDEFINED_REFERENCES) and node.filename:
        t = translator
        fname, lineno = getSourceLocation(node)
        label = t.newLabel()
        t.emit(DUP)
        t.emit(TypeOf)
        t.push("undefined")
        t.emit(EQUALS)
        t.emit(NOT)
        t.emit(BranchIfTrue(label))
        t.emitCall('$reportUndefinedProperty',
                   fname, lineno, propertyName)
        t.emit(POP)                     # pop error return
        t.emit(LABEL(label))

def checkUndefinedVariable(translator, node, variableName):
    """Emits code to check that an object variable is defined.
    Expects the value of the variable to be at the top of stack when
    called."""
    if translator.options.get(WARN_UNDEFINED_REFERENCES) and node.filename:
        t = translator
        fname, lineno = getSourceLocation(node)
        label = t.newLabel()
        t.emit(DUP)
        t.emit(TypeOf)
        t.push("undefined")
        t.emit(EQUALS)
        t.emit(NOT)
        t.emit(BranchIfTrue(label))
        t.emitCall('$reportUndefinedVariable',
                   fname, lineno, variableName)
        t.emit(POP)                     # pop error return
        t.emit(LABEL(label))

def checkUndefinedMethod(translator, node, methodName):
    """Emits code to check that an object method is defined.  Expects
    the object to be at the top of stack when called and does a trial
    GetMember on methodName to verify that it is a function.  Object
    is left on the stack."""
    if translator.options.get(WARN_UNDEFINED_REFERENCES) and node.filename:
        t = translator
        fname, lineno = getSourceLocation(node)
        # Check that object is not undefined
        isUndefined = t.newLabel()      # stack: object
        t.emit(DUP)                     # stack: object, object
        t.emit(TypeOf)                  # stack: object, TypeOf(object)
        t.push("undefined")             # stack object, TypeOf(object), 'undefined'
        t.emit(EQUALS)                  #  stack: object, TypeOf(object) == 'undefined'
        t.emit(BranchIfTrue(isUndefined)) # stack: object
        # Check that property is a function (i.e., it is a method)
        isMethod = t.newLabel()
        t.emit(DUP)                     # stack: object, object
        t.push(methodName)              # stack: object, object, method
        t.emit(GetMember)               # stack: object, object.method
        t.emit(DUP)                     # stack object, object.method, object.method
        t.emit(TypeOf)                  # stack object, object.method, TypeOf(object.method)
        t.push("function")              # stack object, object.method, TypeOf(object.method), 'function'
        t.emit(EQUALS)                  # stack object, object.method, TypeOf(object.method) == 'function'
        t.emit(BranchIfTrue(isMethod))  # stack object, object.method
        t.emitCall('$reportUndefinedMethod',
                   fname,
                   lineno,
                   methodName,
                   DUP)                 # stack: object, None
        t.emit(BRANCH(isMethod))
        t.emit(LABEL(isUndefined))      # stack: object
        t.emitCall('$reportUndefinedObjectProperty',
                   fname,
                   lineno,
                   methodName)          # stack: object, None
        t.emit(LABEL(isMethod))
        t.emit(POP)                     # stack: object

class PropertyReference(Reference):
    def __init__(self, translator, node, referenceCount, object, propertyName):
        Reference.__init__(self, translator, node, referenceCount)
        self.object = object
        self.propertyName = propertyName.name

    def __repr__(self):
        return "PropertyReference(%s, %s)" % (self.object, self.propertyName)

    def pushObject(self, checkUndefined=True):
        # incorrect semantics, but compatible with Flash
        self.translator.visitExpression(self.object)
        if checkUndefined:
            checkUndefinedObjectProperty(self.translator, self.node, self.propertyName)
            if (self.propertyName == 'undefined'):
                raise SemanticError("Invalid l-value", self.node)
        self.translator.push(self.propertyName)

    def get(self, checkUndefined=True):
        self._pop()
        self.pushObject(checkUndefined)
        self.translator.emit(GetMember)
        if checkUndefined:
            checkUndefinedProperty(self.translator, self.node, self.propertyName)
        return self

    def preset(self):
        self._pop()
        self.pushObject()
        return self

    def set(self):
        self.translator.emit(SetMember)
        return self

class IndexReference(Reference):
    def __init__(self, translator, node, referenceCount, object, indexExpr):
        Reference.__init__(self, translator, node, referenceCount)
        self.object = object
        self.indexExpr = indexExpr

    def pushObject(self, checkUndefined=True):
        self.translator.visitExpression(self.object)
        if checkUndefined:
            checkUndefinedObjectProperty(self.translator, self.node, "[]")
        self.translator.visitExpression(self.indexExpr)
        if checkUndefined:
            checkUndefinedProperty(self.translator, self.node, "[]")

    def get(self, checkUndefined=True):
        self._pop()
        self.pushObject(checkUndefined)
        self.translator.emit(GetMember)
        # TODO: [2003-05-14 ptw] checkUndefined
        if False: # checkUndefined:
            checkUndefinedProperty(self.translator, self.node, "[]")
        return self

    def preset(self):
        self._pop()
        self.pushObject()
        return self

    def set(self):
        self.translator.emit(SetMember)
        self.onstack = False
        return self

# The code generator dispatches a node whose class is named ASTName to
# a method visitName, passing the node, a context, and the node's
# children as arguments.  The context for a statement visitor is a
# TranslationContext, defined above.  The context for an expression
# visitor is a boolean value, that is true iff the value of the
# expression is used.  The return value of a statement visitor is
# ignored.  The return value of an expression visitor is true iff it
# generated code that did NOT leave a value on the stack.  (This is so
# that an expression visitor that ignores its context need do nothing
# special to indicate that it ignored it: the default return value of
# None signals this.)
#
# Methods of the form visitName are AST node visitors, and follow the
# protocol described above.  Methods of the form translateName are
# helper functions for the visitors, and have arbitrary parameter
# lists and return values.

XfixInstrs = {Ops.INCR: Increment,
              Ops.DECR: Decrement}

UnopInstrs = {Ops.PLUS: [],
              Ops.MINUS: [PUSH(-1), MULTIPLY],
              Ops.BANG: [NOT],
              Ops.TILDE: [PUSH(-1), BitwiseXor],
              Ops.TYPEOF: [TypeOf],
              Ops.VOID: [POP, (PUSH(Values.Undefined))],
              }

# Binop translation for swf6.  visitBinaryExpression handles swf5
# exceptions.
BinopInstrs = {Ops.PLUS: [ADD],
               Ops.MINUS: [SUBTRACT],
               Ops.STAR: [MULTIPLY],
               Ops.SLASH: [DIVIDE],
               Ops.REM: [MODULO],
               Ops.BIT_AND: [BitwiseAnd],
               Ops.BIT_OR: [BitwiseOr],
               Ops.XOR: [BitwiseXor],
               Ops.LSHIFT: [ShiftLeft],
               Ops.RSIGNEDSHIFT: [ShiftRight],
               Ops.RUNSIGNEDSHIFT: [UShiftRight],
               # swf6 returns undefined for comparisons with NaN, it
               # is supposed to return false (note that you cannot
               # eliminate one NOT by inverting the sense of the
               # comparison
               Ops.LT: [LessThan, NOT, NOT],
               Ops.GT: [GreaterThan, NOT, NOT],
               # swf6 does not have GE or LE, but inverting the
               # complement operator does not work for NaN ordering
               # Luckily, LogicalOr coerces undefined to false, so we
               # don't have to play the NOT NOT trick above
               Ops.LE: [SetRegister(0), # a b
                        POP,            # a
                        DUP,            # a a
                        PUSH(Values.Register(0)), # a a b
                        EQUALS,         # a a==b
                        SWAP,           # a==b a
                        PUSH(Values.Register(0)), # a==b a b
                        LessThan,       # a==b a<b
                        LogicalOr       # a==b||a<b
                        ],
               Ops.GE: [SetRegister(0), # a b
                        POP,            # a
                        DUP,            # a a
                        PUSH(Values.Register(0)), # a a b
                        EQUALS,         # a a==b
                        SWAP,           # a==b a
                        PUSH(Values.Register(0)), # a==b a b
                        GreaterThan,    # a==b a>b
                        LogicalOr       # a==b||a>b
                        ],
               Ops.EQ: [EQUALS],
               Ops.SEQ: [StrictEquals],
               # swf6 does not have NE or SNE either, but inverting
               # the complement is correct for NaN
               Ops.NE: [EQUALS, NOT],
               Ops.SNE: [StrictEquals, NOT],
               Ops.INSTANCEOF: [InstanceOf]
               }

AssignOpTable = {Ops.PLUSASSIGN: Ops.PLUS,
                 Ops.MINUSASSIGN: Ops.MINUS,
                 Ops.STARASSIGN: Ops.STAR,
                 Ops.SLASHASSIGN: Ops.SLASH,
                 Ops.ANDASSIGN: Ops.BIT_AND,
                 Ops.ORASSIGN: Ops.BIT_OR,
                 Ops.XORASSIGN: Ops.XOR,
                 Ops.REMASSIGN: Ops.REM,
                 Ops.LSHIFTASSIGN: Ops.LSHIFT,
                 Ops.RSIGNEDSHIFTASSIGN: Ops.RSIGNEDSHIFT,
                 Ops.RUNSIGNEDSHIFTASSIGN: Ops.RUNSIGNEDSHIFT,
                 }

import org.openlaszlo.sc.InstructionCollector as InstructionCollector

# Replace instruction subsequences by a BLOB instruction that
# represents the same bytes.  By default, the BLOB instructions are
# separated by PUSH's (which depend on the constant pool), and
# branches and targets (since they can't be resolved until the size of
# the PUSH instructions is known).  When noConstantPool=True, PUSH's
# are compiled against a null constant pool, and branches and targets
# are compiled, so the instructions combine to a single BLOB.
import java.nio.ByteBuffer as ByteBuffer
def combineInstructions(instrsIn, noConstantPool=False):
    instrsOut = []
    buffer = ByteBuffer.allocate(64000)
    def flush(instrsOut=instrsOut,buffer=buffer):
        if buffer.position():
            import jarray
            bytes = jarray.zeros(buffer.position(), 'b')
            buffer.flip()
            buffer.get(bytes)
            buffer.clear()
            instrsOut.append(BLOB('bytes', bytes))
    for instr in instrsIn:
        if noConstantPool or instr.isPush or instr.isLabel or instr.hasTarget:
            flush();
            instrsOut.append(instr)
        else:
            instr.writeBytes(buffer, None)
    flush()
    return instrsOut

# Each entry has three parts:
# - a key, used to store and retrieve it
# - a checksum, which tells whether the value is current
# - a value
import org.openlaszlo.cache.PersistentMap as PersistentMap
class ScriptCompilerCache:
    def __init__(self, useDisk=False):
        self.cache = {}
        self.useDisk = useDisk
        if useDisk:
            from java.util import Properties
            from java.io import File
            import os
            cacheFileName = os.path.join(os.getenv('LPS_HOME'), 'WEB-INF/lps/lfc/build/cache', useDisk)
            self.cache = PersistentMap(
                'buildlfc' + useDisk, File(cacheFileName), Properties())

    def getItem(self, key, checksum):
        entry = self.cache.get(key)
        if entry and entry[0] == checksum:
            return entry[1]
        #if entry and entry[0] != checksum:
        #    print 'checksum failed', entry[0], checksum

    def setItem(self, key, checksum, value):
        if not self.useDisk:
            self.cache[key] = (checksum, value)
            return
        from java.util import Vector
        v = Vector()
        v.add(checksum)
        v.add(value)
        self.cache.put(key, v)

class CodeGenerator(Visitor):
    # The parse tree is stored with the key (fname) and the
    # value (ASTProgram, hasIncludes).
    # It doesn't save any time to persist this cache to disk.
    CachedParses = ScriptCompilerCache()
    # The instructions are stored with the keys (fname, cpass) where
    # cpass is one of the compiler passes (1 or 2).  The checksum in
    # both cases is the file content string.
    # It costs 10s to persist this to disk, but speeds up subsequent
    # compiles.
    # Instantiate this lazily, so that we don't construct it in server
    # mode (since the call to os.getenv in the cache constructor won't
    # work there).
    CachedInstructions = None
    
    def __init__(self, collector=None, **options):
        self.options = options
        if not collector:
            collector = InstructionCollector(not not self.options.get(DISABLE_CONSTANT_POOL), True)
        self.collector = collector
        self.emit = self.collector.emit
        self.push = self.collector.push
        self.newLabel = self.collector.newLabel
        runtime = self.options.get(RUNTIME)
        assert runtime in ("swf5", "swf6", "swf7"), 'uknown runtime %r' % runtime
        Instructions.setRuntime(runtime)

    # Only used by warning generator, hence not metered.
    def emitCall(self, name, *args):
        args = list(args)
        args.reverse()
        for arg in args:
            if type(arg) == IntType:
                self.push(arg)
            elif type(arg) == StringType:
                self.push(arg)
            elif type(arg) == TupleType:
                self.push(*arg)
            elif arg is DUP:
                pass
            else:
                raise "unknown type for %r" % arg
        self.push(len(args))
        self.push(name)
        self.emit(CallFunction)

    def translate(self, program, cpass='b'):
        nodeType = program.class
        assert nodeType == Program
        self.context = TranslationContext(Program, None)
        self.visitProgram(program, program.children, cpass)

    def showStats(self, node=None):
        if not self.options.get(INSTR_STATS): return
        prev = getattr(self, 'previousStatLoc', None)
        if node:
            loc = node.filename, node.lineNumber
        elif prev:
            loc = prev[0], prev[1]+1
        else:
            return
        if loc == prev: return
        self.emit(CHECKPOINT('%s:%d:' % loc))
        self.previousStatLoc = loc

    def evaluateCompileTimeConditional(self, node):
        if node.class is Identifier:
            name = node.name
            constants = self.options.get(COMPILE_TIME_CONSTANTS, {})
            return constants.get(name)

    def visitProgram(self, node, directives, cpass):
        # cpass is 'b'oth, 1, or 2
        if cpass == 'b':
            self.visitProgram(node, directives, 1)
            self.visitProgram(node, directives, 2)
            return
        index = 0
        while index < len(directives):
            node = directives[index]
            index += 1
            children = node.children
            if node.class is Statement:
                # Statements are processed in pass 2
                if cpass == 2:
                    newIndex = compileAssignments(self, directives, index-1, self.options.get(OBFUSCATE))
                    #newIndex = False
                    if newIndex:
                        index = newIndex
                    else:
                        self.visitStatement(node)
            elif node.class is DirectiveBlock:
                savedOptions = self.options
                try:
                    self.options = self.options.copy()
                    self.visitProgram(node, node.children, cpass)
                finally:
                    self.options = savedOptions
            elif node.class is IfDirective:
                if not self.options.get(CONDITIONAL_COMPILATION):
                    # TBD: different type; change to CONDITIONALS
                    raise CompilerError("'if' at top level")
                value = self.evaluateCompileTimeConditional(node[0])
                if value is None:
                    raise CompilerError("undefined compile-time conditional %s" % nodeString(node[0]))
                if value:
                    #print node, node.children[:]
                    self.visitProgram(node, node[1].children, cpass)
                elif len(node) > 2:
                    self.visitProgram(node, node[2].children, cpass)
            elif node.class is IncludeDirective:
                # Disabled by default, since it isn't supported in the
                # product.  (It doesn't go through the compilation
                # manager for dependency tracking.)
                if not self.options.get(INCLUDES):
                    raise UnimplementedError("unimplemented: #include", node)
                userfname = node[0].value
                self.compileInclude(userfname, cpass)
            elif node.class is PragmaDirective:
                self.visitPragmaDirective(node, *node.children)
            elif cpass == 2:
                # Ignore everything else on pass 2
                continue
            elif node.class is FunctionDeclaration:
                self.visitStatement(node)
            elif node.class is ClassDefinition:
                self.visitClassDefinition(node, *node.children)
            else:
                self.visitExpression(node, False)
        self.showStats()

    def getCodeGenerationOptionsKey(self, ignore=[]):
        def mapToString(map):
            items = map.items()
            items.sort()
            return '{' + ', '.join(['%r: %r' % item
                                    for item in items]) + '}'
        options = {}
        options.update(self.options)
        for key in NonCodeGenerationOptions+ignore:
            if options.has_key(key):
                del options[key]
        for key, value in options.items():
            if type(value) == type({}):
                options[key] = mapToString(value)
        return mapToString(options)
    
    def parseFile(self, fname, userfname, source):
        sourceKey = fname
        sourceChecksum = source
        entry = self.CachedParses.getItem(sourceKey, sourceChecksum)
        if not entry:
            if self.options.get(PROGRESS):
                # Even though code generation is re-run
                # for every file, just print this for
                # files that are re-parsed, to indicate
                # what's being changed.
                print 'Compiling %s...' % userfname
            import re
            hasIncludes = false
            for line in source.split('\n'):
                if re.match(r'\s*#\s*include\s*"', line):
                    hasIncludes = True
                    break
            program = Parser().parse(source)
            # Always cache the parse tree, since this
            # helps even when the compilation is only one
            # once.  This is because each pass processes
            # the #include again.
            entry = program, hasIncludes
            self.CachedParses.setItem(sourceKey, sourceChecksum, entry)
        return entry
    
    def compileInclude(self, userfname, cpass):
        if not CodeGenerator.CachedInstructions:
            CodeGenerator.CachedInstructions = ScriptCompilerCache()
        fname = userfname
        if self.options.get('resolver'):
            fname = self.options['resolver'].resolve(fname)
        f = open(fname)
        try:
            source = ('#file "%s"\n#line 1\n' % userfname) + f.read()
        finally:
            f.close()
        try:
            optionsKey = self.getCodeGenerationOptionsKey([
                # The constant pool isn't cached, so it doesn't affect code
                # generation so far as the cache is concerned.
                DISABLE_CONSTANT_POOL])
            # If these could be omitted from the key for files that didn't
            # reference them, then the cache could be shared between krank
            # and krank debug.  (The other builds differ either on OBFUSCATE,
            # RUNTIME, NAMEFUNCTIONS, or PROFILE, so there isn't any other
            # possible sharing.)
            instrsKey = fname, optionsKey, cpass
            #from java.security import MessageDigest
            #md = MessageDigest.getInstance('MD5')
            #md.update(source)
            #instrsChecksum = md.digest()
            instrsChecksum = source
            instrs = self.options.get(CACHE_COMPILES) and \
                     self.CachedInstructions.getItem(instrsKey, instrsChecksum)
            if instrs and instrs is not None:
                self.collector.appendInstructions(instrs)
            else:
                program, hasIncludes = self.parseFile(fname, userfname, source)
                startpos = self.collector.size()
                self.translate(program, cpass)
                if not hasIncludes: # and self.collector.size() != startpos:
                    # and not :
                    assert not self.collector.constantsGenerated
                    instrs = self.collector.subList(startpos, self.collector.size())
                    instrs = list(instrs)
                    # The following line only speeds up buildlfc when
                    # noConstantPool=True, which produces vastly
                    # larger binaries.
                    #instrs = combineInstructions(instrs, True)
                    if self.options.get(CACHE_COMPILES):
                        self.CachedInstructions.setItem(
                            instrsKey, instrsChecksum, instrs)
        except ParseException, e:
            import sys
            print >> sys.stderr, "while compiling " + fname
            raise

    def visitPragmaDirective(self, node, value):
        key, value = value.value, True
        if '=' in key:
            key, value = key.split('=', 1)
        if value in ('false', 'true'):
            value = value == 'true'
        self.options[key] = value

    def visitClassDefinition(self, node, classname, super, *defs):
        # Flatten nested StatementList structures
        def flatten(src):
            dst = []
            for node in src:
                if node.class is StatementList:
                    dst += flatten(node.children)
                else:
                    dst.append(node)
            return dst
        defs = flatten(defs)
        # Separate the defs into constructors, instance variable
        # declarations, and methods
        ctors = []
        instancevars = []
        methods = []
        for node in defs:
            if node.class is FunctionDeclaration:
                if node[0].name == classname.name:
                    ctors.append(node)
                else:
                    methods.append(node)
            elif node.class is VariableDeclaration:
                # make sure there's an initializer, for ease of
                # downstream processing
                if len(node) == 1:
                    node.jjtAddChild(EmptyExpression(0), len(node.children))
                instancevars.append(node)
            else:
                # TODO: [2002 ows] move this error into the parser,
                # once the spec has settled
                raise UnimplementedError("unimplemented class block directive", node)
        # Get a constructor, to attach the other definitions to.
        if len(ctors) > 1:
            raise UnimplementedError("duplicate constructors for %s" %
                                     classname, node)
        if ctors:
            ctor = ctors[0]
        else:
            ctor = Parser().build(FunctionDeclaration(0), classname, \
                                  (FormalParameterList(0),), \
                                  (StatementList(0),))
        self.visitStatement(ctor)
        # If it's a subclass, extend the superclass
        if super.class is Identifier:
            stmt = Parser().parse("Object.class.extends(%s, %s)" %
                                  (super.name, classname.name))[0][0]
            self.visitStatement(stmt)
        # Add the instance variable definitions
        assign = Operator(0)
        assign.operator = Ops.ASSIGN
        def makePrototype():
            return Parser().build(PropertyIdentifierReference(0), classname,
                                  Identifier('prototype'))
        for node in instancevars:
            var, init = node.children
            n = Parser().build(
                AssignmentExpression(0),
                (PropertyIdentifierReference(0), makePrototype(), var),
                assign,
                init)
            self.visitStatement(n)
        # Add the member functions
        for node in methods:
            if node.class is FunctionDeclaration:
                n = Parser().build(
                    AssignmentExpression(0),
                    (PropertyIdentifierReference(0), makePrototype(), node[0]),
                    assign,
                    (FunctionExpression(0),) + tuple(node.children[1:]))
                #n = Parser().substitute('_0.prototype._1 = function (_3) {_4}',
                #                        _0=Identifier(classname),
                #                        _1=node[1],
                #                        _2=Splice(node[2].children),
                #                        _3=Splice(node[3].children))
                self.visitStatement(n)

    # This will only work in the jython interpreter, not from the jar,
    # because this style of import is broken for jythonc code running
    # in a jar.
    def testStaticCoverage(self):
        """Check that a visitor exists for each node type."""
        missingFunctions = []
        # These are handled specially, within other visitors
        unnecessaryVisitors = ['visit' + s for s in 'CaseClause DefaultClause FormalParameterList FunctionCallParameters Identifier Literal Operator Program'.split()]
        import org.openlaszlo.sc.parser
        for name in dir(org.openlaszlo.sc.parser):
            if name.startswith('AST'):
                fnname = 'visit' + name[3:]
                if not getattr(self, fnname, None) and \
                       fnname not in unnecessaryVisitors:
                    missingFunctions.append(fnname)
        assert not missingFunctions, \
               "Missing the following visitor functions: " + `missingFunctions`

    def visitStatementList(self, node, *stmts):
        i = 0
        inFlasm = self.context.getProperty(self.context.FLASM)
        newContext = self.context.clone()
        newContext.setProperty(newContext.FLASM, False)
        prevContext = self.context
        while i < len(stmts):
            stmt = stmts[i]
            if stmt.children:
                node = stmt[0]
                nt = node.class
                newIndex = None
                if nt is AssignmentExpression:
                    newIndex = compileAssignments(self, stmts, i)
                elif nt is Identifier and node.name == "$flasm" and \
                         self.options.get(FLASH_COMPILER_COMPATABILITY):
                    newIndex = self.compileInlineAssembly(stmts, i)
                elif nt is Literal and type(node.value) is StringType and \
                         inFlasm:
                    instructions = parseInstructions(node.value)
                    if self.options.get(PROFILE):
                        def profiled_emit(instr):
                            if instr is RETURN:
                                self.emit(BRANCH(self.context.label))
                            else:
                                self.emit(instr)
                        map(profiled_emit, instructions)
                    else:
                        for instr in instructions:
                            self.emit(instr)
                    newIndex = i+1
                if newIndex:
                    i = newIndex
                    continue
            # TODO: [2003-04-15 ptw] bind context slot macro
            try:
                self.context = newContext
                self.visitStatement(stmts[i])
            finally:
                self.context = prevContext
            i += 1

    def visitFunctionDeclaration(self, node, *ast):
        if self.context.type == Program or \
               not self.options.get(ACTIVATION_OBJECT):
            savedOptions = self.options
            try:
                self.options = self.options.copy()
                self.options[CONSTRAINT_FUNCTION] = False
                self.translateFunction(node, True, *ast)
            finally:
                self.options = savedOptions

    #
    # Statements
    #

    def visitStatement(self, node):
        """This function, unlike the other statement visitors, can be
        applied to any statement node, so it dispatches based on the
        node's class.""" #' <- make emacs happy
        assert self.context.__class__ == TranslationContext
        children = node.children
        self.showStats(node)
        fn = self.getVisitor(node)
        assert fn, "missing visitor for %r" % node
        # if it's an expression, unset fn so that we fall through
        # to the visitExpression case
        name = fn.__name__
        if self.isExpressionType(name):
            fn = None
        if fn == self.visitStatement:
            # an empty statement, introduced by an extra ';', has no children
            if children:
                fn(children[0])
        elif fn:
            fn(node, *children)
        else:
            self.visitExpression(node, False)

    def visitLabeledStatement(self, node, name, stmt):
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            self.context = TranslationContext(LabeledStatement, self.context, name.name)
            # TODO: [2002 ows] throw semantic error for duplicate label
            self.visitStatement(stmt)
        finally:
            self.context = self.context.parent

    def visitVariableDeclaration(self, node, id, initValue=None):
        if initValue:
            ref = self.translateReference(id).preset()
            self.visitExpression(initValue)
            ref.init()
        elif not self.options.get(ACTIVATION_OBJECT):
            # TODO: [2004-04-5 ptw] Shouldn't this happen at the top
            # of the fn?
            ref = self.translateReference(id).preset()
            ref.declare()

    def visitVariableStatement(self, node, *children):
        for child in children:
            self.visitStatement(child)

    def visitIfStatement(self, node, test, a, b=None):
        if test.class is Identifier and test.name == "$flasm" and \
           self.options.get(FLASH_COMPILER_COMPATABILITY):
            prevContext = self.context
            newContext = self.context.clone()
            # TODO: [2003-04-15 ptw] bind context slot macro
            try:
                if not false: #self.options.get(RUNTIME) == "swf7":
                    newContext.setProperty(self.context.FLASM, True)
                    self.context = newContext
                    assert a.class is Statement and a[0].class is StatementList
                    self.visitStatementList(a[0], *a[0].children)
                else:
                    newContext.setProperty(self.context.FLASM, False)
                    self.context = newContext
                    assert b.class is Statement and b[0].class is StatementList
                    self.visitStatementList(b[0], *b[0].children)
            finally:
                self.context = prevContext
            return
        value = self.evaluateCompileTimeConditional(test)
        if value is not None:
            if value:
                self.visitStatement(a)
            elif b:
                self.visitStatement(b)
        elif b:
            self.translateControlStructure(
                [('expr', test),
                 BranchIfFalse(0),
                 ('stmt', a),
                 BRANCH(1),
                 0,
                 ('stmt', b),
                 1])
        else:
            self.translateControlStructure(
                [('expr', test),
                 BranchIfFalse(0),
                 ('stmt', a),
                 0])

    def visitWhileStatement(self, node, test, body):
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            self.context = TranslationContext(WhileStatement, self.context)
            self.context.setTarget('break', 1)
            self.context.setTarget('continue', 0)
            self.translateControlStructure(
                [0,
                 ('expr', test),
                 BranchIfFalse(1),
                 ('stmt', body),
                 BRANCH(0),
                 1])
        finally:
            self.context = self.context.parent

    def visitDoWhileStatement(self, node, body, test):
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            self.context = TranslationContext(DoWhileStatement, self.context)
            self.context.setTarget('break', 1)
            self.context.setTarget('continue', 0)
            self.translateControlStructure(
                [0,
                 ('stmt', body),
                 ('expr', test),
                 BranchIfTrue(0),
                 1])
        finally:
            self.context = self.context.parent

    def visitForStatement(self, node, init, test, step, body):
        self.translateForStatement(node, init, test, step, body)

    def visitForVarStatement(self, node, init, test, step, body):
        self.translateForStatement(node, init, test, step, body)

    def translateForStatement(self, node, init, test, step, body):
        # TODO: [2003-04-15 ptw] bind context slot macro
        savedOptions = self.options
        try:
            self.options = self.options.copy()
            self.context = TranslationContext(ForStatement, self.context)
            if self.options.get(OBFUSCATE):
                # an arbitrarily different (and less efficient) block order,
                # to confuse decompilers
                enterLabel = self.newLabel()
                testLabel = self.newLabel()
                topLabel = self.newLabel()
                continueLabel = self.newLabel()
                breakLabel = self.newLabel()
                self.context.setTarget('break', breakLabel)
                self.context.setTarget('continue', continueLabel)
                self.translateControlStructure(
                    [BRANCH(enterLabel),
                     LABEL(topLabel),
                     ('stmt', body),
                     LABEL(continueLabel),
                     ('stmt', step),
                     BRANCH(testLabel),
                     LABEL(enterLabel)])
                self.options[WARN_GLOBAL_ASSIGNMENTS] = True
                self.visitStatement(init)
                self.options[WARN_GLOBAL_ASSIGNMENTS] = False
                self.translateControlStructure(
                    [LABEL(testLabel),
                     ('expr', test),
                     BranchIfTrue(topLabel),
                     LABEL(breakLabel),
                     ])
            else:
                self.context.setTarget('break', 2)
                self.context.setTarget('continue', 1)
                self.options[WARN_GLOBAL_ASSIGNMENTS] = True
                self.visitStatement(init)
                self.options[WARN_GLOBAL_ASSIGNMENTS] = False
                self.translateControlStructure(
                    [0,
                     ('expr', test),
                     BranchIfFalse(2),
                     ('stmt', body),
                     1,
                     ('stmt', step),
                     BRANCH(0),
                     2])
        finally:
            self.context = self.context.parent
            self.options = savedOptions

    def visitForInStatement(self, node, var, obj, body):
        self.translateForInStatement(node, var, SetVariable, obj, body)

    def visitForVarInStatement(self, node, var, _, obj, body):
        if self.options.get(ACTIVATION_OBJECT):
            self.translateForInStatement(node, var, SetVariable, obj, body)
            return
        self.translateForInStatement(node, var, VarEquals, obj, body)

    def translateForInStatement(self, node, var, varset, obj, body):
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            continueLabel = self.newLabel()
            breakLabel = self.newLabel()
            self.context = TranslationContext(ForInStatement, self.context)
            self.context.setTarget('break', breakLabel)
            self.context.setTarget('continue', continueLabel)
            self.context.isEnumeration = True
            r0 = 0
            if self.options.get(RUNTIME) == "swf5":
                def propertyChain(object):
                    # TODO: [2002-11-29 ows] Syntax for a[b], a[1]
                    if object.class is Identifier:
                        return [object.name]
                    if object.class is ThisReference:
                        return ['this']
                    if object.class is PropertyIdentifierReference:
                        object, prop = object.children
                        chain = propertyChain(object)
                        if chain:
                            return chain + [prop.name]
                chain = propertyChain(obj)
                # TODO: [2002-11-29 ows] Test a.b.c.d
                if chain and len(chain) <= 3:
                    # a -> a
                    # a.b -> a:b
                    # a.b.c -> a/b:c
                    if len(chain) > 2:
                        name = chain[0] + '/' + ':'.join(chain[1:])
                    else:
                        name = ':'.join(chain)
                    enumerate = [PUSH(name), ENUMERATE]
                else:
                    name = '$lzsc$e'
                    self.push(name)
                    self.visitExpression(obj)
                    self.emit(VarEquals)
                    enumerate = [PUSH(name), ENUMERATE, PUSH(name), DELETE2, POP]
            else:
                self.visitExpression(obj)
                enumerate = [EnumerateValue]
            self.translateControlStructure(
                enumerate +
                [
                 LABEL(continueLabel),
                 SetRegister(r0),
                 PUSH(Values.Null),
                 EQUALS,
                 BranchIfTrue(breakLabel)])
            ref = self.translateReference(var).preset()
            self.emit(PUSH(Values.Register(0)))
            if varset is VarEquals:
                ref.init()
            else:
                ref.set(True)
            self.translateControlStructure(
                 [('stmt', body),
                 BRANCH(continueLabel),
                 LABEL(breakLabel)])
        finally:
            self.context = self.context.parent

    def translateAbruptCompletion(self, node, type, label):
        targetContext = self.context.findLabeledContext(label and label.name)
        if not targetContext:
            if label:
                raise SemanticError("unknown %s target: %s" %
                                    (type, label.name), node)
            else:
                raise SemanticError("can't %s from current statement" % type,
                                    node)
        targetLabel = targetContext.getTarget(type)
        if targetLabel is None:
            raise SemanticError("can't %s from current statement" % type, node)
        # For each intervening enumeration, pop the stack
        c = self.context
        while c is not targetContext:
            c.emitBreakPreamble(self.collector)
            c = c.getParentStatement()
        if type == 'break':
            targetContext.emitBreakPreamble(self.collector)
        self.emit(BRANCH(targetLabel))

    def visitContinueStatement(self, node, label=None):
        self.translateAbruptCompletion(node, 'continue', label)

    def visitBreakStatement(self, node, label=None):
        self.translateAbruptCompletion(node, 'break', label)

    def visitReturnStatement(self, node, value):
        c = self.context
        while not c.isFunctionBoundary():
            c.emitBreakPreamble(self.collector)
            c = c.getParentStatement()
            if not c:
                raise SemanticError("return not within a function body")
        self.visitExpression(value)
        if self.options.get(PROFILE):
            self.emit(BRANCH(c.label))
        else:
            self.emit(RETURN)

    def visitWithStatement(self, node, expr, stmt):
        self.translateControlStructure(
            [('expr', expr),
             WITH(0),
             ('stmt', stmt),
             0])

    def visitSwitchStatement(self, node, expr, *clauses):
        tests = []
        targets = []
        defaultLabel = None
        label = self.newLabel()
        for clause in clauses:
            if clause.class is DefaultClause:
                assert not defaultLabel, \
                       SemanticError("duplicate default clause")
                defaultLabel = label
                # Empty cases share label with subsequent
                if len(clause) > 0:
                    targets.append((label, clause[0]))
                    label = self.newLabel()
            else:
                assert clause.class is CaseClause, 'case clause expected'
                tests.append((clause[0], label))
                # Empty cases share label with subsequent
                if len(clause) > 1:
                    targets.append((label, clause[1]))
                    label = self.newLabel()
        finalLabel = self.newLabel()
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            self.context = TranslationContext(SwitchStatement, self.context)
            self.context.setTarget('break', finalLabel)
            self.visitExpression(expr)
            # TODO: [2002 ows] warn on duplicate tests
            for value, label in tests:
                self.emit(DUP)
                self.visitExpression(value)
                self.emit(EQUALS)
                self.emit(BranchIfTrue(label))
            self.emit(POP)
            self.emit(BRANCH(defaultLabel or finalLabel))
            nextLabel = None
            for label, stmt in targets:
                self.emit(LABEL(label))
                if label is not defaultLabel:
                    self.emit(POP)
                else:
                    defaultLabel = None
                if nextLabel:
                    self.emit(LABEL(nextLabel))
                    nextLabel = None
                self.visitStatement(stmt)
                if self.collector[len(self.collector)-1] not in \
                       (BRANCH, RETURN):
                    nextLabel = self.newLabel()
                    self.emit(BRANCH(nextLabel))
            # Handle fall-though in last clause
            if nextLabel:
                self.emit(LABEL(nextLabel))
            # Handle empty default as last clause
            if defaultLabel:
                self.emit(LABEL(defaultLabel))
            self.emit(LABEL(finalLabel))
        finally:
            self.context = self.context.parent

    def translateControlStructure(self, seq):
        # seq is a list whose items are interpreted thus:
        # - numbers are turned into labels
        # - target instructions have their targets, which are numbers,
        #   resolved to labels
        # - statements, expressions, and references are compiled
        #   as in fnmap
        # - all other instructions are emitted as is
        fnmap = {'stmt': lambda n:self.visitStatement(n),
                 'expr': self.visitExpression,
                 'ref': self.visitReference}
        # no control structure uses more than 10 labels (and we'll get a
        # signalled exception if one ever does, so this is safe)
        labels = [None] * 10
        def lookupLabel(n): # integer -> label
            l = labels[n]
            if l == None:
                l = labels[n] = self.newLabel()
            return l
        def resolveLocalLabel(instr):
            if type(instr) == type(0):
                return LABEL(lookupLabel(instr))
            if instr.getHasTarget() and type(instr.getTarget()) == type(0):
                return instr.replaceTarget(lookupLabel(instr.getTarget()))
            return instr
        for k, v in self.context.targets.items():
            if type(v) == type(0):
                self.context.targets[k] = lookupLabel(v)
        for item in seq:
            if type(item) is TupleType:
                fnmap[item[0]](item[1])
            else:
                # TODO [2004-03-04 ptw] Handle this in the assembler
                if type(item) is type(BranchIfFalse) and item.getIsBranchIfFalse():
                    self.emit(NOT)
                    item = BranchIfTrue(item.target)
                self.emit(resolveLocalLabel(item))

    #
    # Expressions
    #

    def isExpressionType(self, name):
        # There are several AST types that end with each of the names that
        # endswith tests for.
        return name.endswith('Expression') \
               or name[5:] in ('ExpressionList', 'Identifier') \
               or name.endswith('ExpressionSequence') \
               or name.endswith('Literal') \
               or name.endswith('Reference')

    def visitExpression(self, node, isReferenced=True):
        """This function, unlike the other expression visitors, can be
        applied to any expression node, so it dispatches based on the
        node's class.""" #'
        fn = self.getVisitor(node)
        self.showStats(node)
        if fn:
            name = fn.__name__
            assert self.isExpressionType(name), \
                   '%s is not an expression visitor' % name
            suppressed = fn(node, isReferenced, *node.children)
            if not isReferenced and not suppressed:
                self.emit(POP)
        else:
            raise CompilerImplementationError('unknown expression: %r' % node, node)

    def visitIdentifier(self, node, isReferenced):
        # Following is disabled by default for regression testing.
        # TODO: [2003-02-17 ows] enable this
        if not isReferenced and self.options.get(ELIMINATE_DEAD_EXPRESSIONS):
            return True
        if node.name == '_root' and not self.options.get(ALLOW_ROOT):
            raise SemanticError('Illegal variable name: %s' % node.name, node)
        self.translateReference(node).get()

    def visitLiteral(self, node, isReferenced):
        # Following is disabled by default for regression testing.
        # TODO: [2003-02-17 ows] enable this
        if not isReferenced and self.options.get(ELIMINATE_DEAD_EXPRESSIONS):
            return True
        value = self.translateLiteralNode(node)
        self.push(value)

    def visitExpressionList(self, node, isReferenced, *exprs):
        while exprs:
            expr = exprs[0]
            exprs = exprs[1:]
            suppressed = self.visitExpression(expr, not exprs)
        return suppressed

    def visitEmptyExpression(self, node, isReferenced):
        self.push(Values.Undefined)

    def visitThisReference(self, node, isReferenced):
        self.translateReference(node).get()

    def visitArrayLiteral(self, node, isReferenced, *items):
        items = list(items)
        items.reverse()
        for item in items:
            if item.class is EmptyExpression:
                self.push(Values.Undefined)
            else:
                self.visitExpression(item)
        self.push(len(items))
        self.emit(InitArray)

    def visitObjectLiteral(self, node, isReferenced, *items):
        isKey = True
        for item in items:
            if isKey and item.class is Identifier:
                self.push(item.name)
            else:
                self.visitExpression(item)
            isKey = not isKey
        self.push(len(items)/2)
        self.emit(InitObject)

    def visitFunctionExpression(self, node, isReferenced, *ast):
        savedOptions = self.options
        try:
            self.options = self.options.copy()
            self.options[CONSTRAINT_FUNCTION] = False
            self.translateFunction(node, False, *ast)
        finally:
            self.options = savedOptions

    def visitCallParameters(self, node, isReferenced, args):
        args = list(args)
        # FIXME: [2002-01-07 ows] This evaluates function call
        # parameters in the wrong order.
        args.reverse()
        for expr in args:
            self.visitExpression(expr)
        self.push(len(args))

    # TODO: [2002-01-06 ows] Factor this and the visitCallParameters;
    # why are they both necessary?
    def visitFunctionCallParameters(self, node, isReferenced, *args):
        args = list(args)
        # FIXME: [2002-01-07 ows] This visits function call parameters
        # in the wrong order.
        args.reverse()
        for expr in args:
            self.visitExpression(expr)
        self.push(len(args))

    def visitPropertyIdentifierReference(self, node, isReferenced, *args):
        # TODO: [2002-12-12 ows] consolidate with the code in for..in
        # TODO: [2002-12-12 ows] find out how this generalizes to a.b.c
        # TODO: [2002-12-18 ows] enabling this saves 2K of the LFC, but
        # doesn't seem to improve speed, and changes the background color
        # of the menu items in contacts to white (don't know why).
        if False and args[0].class is Identifier and args[1].class is Identifier:
            self.push(args[0].name + ':' + args[1].name)
            self.emit(GetVariable)
            return
        self.translateReference(node).get()

    def visitPropertyValueReference(self, node, isReferenced, *args):
        self.translateReference(node).get()

    def visitCallExpression(self, node, isReferenced, fnexpr, args):
        nt = fnexpr.class
        arglen = len(args)
        if nt == Identifier:
            name = fnexpr.name
            # Expose getTimer at our API
            #
            # FIXME: [2002-12-23 ows] This substitution is not correct
            # because it assumes that the value for 'getTimer' that's
            # in scope is the global variable.
            if name == 'getTimer' and arglen == 0:
                self.emit(GetTimer)
                return
            if self.options.get(FLASH_COMPILER_COMPATABILITY):
                if name == 'trace':
                    if self.options.get(COMPILE_TRACE) == 'flash':
                        # FIXME: [2003-01-08 ows] Nicer warning for trace()
                        # FIXME: [2003-01-08 ows] Warn, at least, when
                        # there's more than one arg.
                        self.visitExpression(args[0])
                        # FIXME: [2003-03-13 ptw] Why doesn't the trace instruction work?
                        self.push(1)
                        self.push('trace')
                        self.emit(CallFunction)
                        return True
                    elif self.options.get(COMPILE_TRACE) == 'debug':
                        self.visitExpression(args[0])
                        self.push('_root')
                        self.emit(GetVariable)
                        self.push('Debug')
                        self.emit(GetMember)
                        self.push('write')
                        self.emit(CallMethod)
                        return
                    # else fall through
                    return True
                if name == 'fscommand' and arglen == 2:
                    assert args[0].class is Literal and StringType
                    v = self.translateLiteralNode(args[0])
                    assert isinstance(v, StringType)
                    self.push('FSCommand:' + v)
                    self.visitExpression(args[1])
                    self.emit(GetURL2)
                    return True
                if name == 'removeMovieClip' and arglen == 1:
                    self.visitExpression(args[0])
                    self.emit(RemoveClip)
                    return True         # no return value
                if name == 'ord' and arglen ==1:
                    self.visitExpression(args[0])
                    self.emit(ORD)
                    return
                if name == 'targetPath' and arglen == 1:
                    self.visitExpression(args[0])
                    self.emit(TargetPath)
                    return
                # TODO: [2002-11-30 ows] The following clause needs to
                # swap the arguments.  To preserve evaluation order,
                # it could visit them in reverse order if they don't
                # have side effects, otherwise emit SWAP.
                #- if name == 'getURL' and arglen == 2:
                #-    self.emit(GetURL2); return
                if name == 'getVersion' and arglen == 0:
                    self.push('/:$version')
                    self.emit(GetVariable)
                    return
                if name == 'eval' and arglen == 1:
                    self.visitExpression(args[0])
                    self.emit(GetVariable)
                    return

        # TODO: [2002-12-03 ptw] There should be a more general
        # mechanism for matching patterns against AST's and replacing
        # them.
        # FIXME: [2002-12-03 ptw] This substitution is not correct
        # because it does not verify that the method being inlined is
        # actually ViewsystemNode.setAttribute.
        # TODO: [2004-03-29 ptw] Enable this optimization for swf 7 by
        # allocating some temp registers if it is worth it
        if nt == PropertyIdentifierReference and \
           fnexpr[1].name == "setAttribute" and \
           arglen == 2 and \
           not self.options.get(FLASH_COMPILER_COMPATABILITY) and \
           not self.options.get(GENERATE_FUNCTION_2):
            onprop = [PUSH(('on', Values.Register(1))),
                      ADD]
            # Optimize literal property name
            # TODO: [2002-12-03 ptw] Should check for constant expression
            if args[0].class == Literal:
                v = self.translateLiteralNode(args[0])
                if isinstance(v, StringType):
                    onprop = [PUSH('on' + v)]
            self.translateControlStructure(
                # exprs are evaluated first, in proper order, and
                # before any registers are set (as they might be
                # clobbered by expression evaluation).
                [('expr', fnexpr[0]),   # : obj
                 DUP,                   # : obj, obj
                 ('expr', args[0]),     # : obj, obj, prop
                 ('expr', args[1]),     # : obj, obj, prop, val
                 SetRegister(3),        # r3 = val
                 POP,                   # : obj, obj, prop
                 SetRegister(1),        # r1 = prop
                 SWAP,                  # : obj, prop, obj
                 PUSH('setters'),       # : obj, prop, obj, setters
                 GetMember,             # : obj, prop, obj.setters
                 SWAP,                  # : obj, obj.setters, prop
                 GetMember,             # : obj, obj.setters[prop]
                 SetRegister(2),        # r2 = obj.setters[prop]
                 PUSH(Values.Null),     # : obj, obj.setters[prop], null
                 EQUALS,                # : obj, null == obj.setters[prop]
                 BranchIfTrue(0),       # : obj
                 SetRegister(0),        # r0 = obj
                 POP,                   # :
                 PUSH((Values.Register(3), # : val
                      1,                # : val, 1
                      Values.Register(0), # : val, 1, obj
                      Values.Register(2))), # : val, 1, obj, setter
                 BRANCH(1),
                 0,                     # : obj
                 SetRegister(0),        # r0 = obj
                 PUSH((Values.Register(1), # : obj, prop
                      Values.Register(3))), # : obj, prop, val
                 SetMember,             # :
                 PUSH((Values.Register(3), # : val
                      1,                # : val, 1
                      Values.Register(0)))] + \
                onprop + \
                [GetMember,             # : val, 1, obj['on'+prop]
                 PUSH('sendEvent'),     # : val, 1, obj['on'+prop], 'sendEvent'
                 1,
                 CallMethod,            # : result
                 POP])                  # :
            return True                 # no return value

        self.visitCallParameters(node, isReferenced, args)
        isref = self.visitReference(fnexpr, checkDefined=True, node=node)
        if isref:
            if nt in (PropertyIdentifierReference,
                      PropertyValueReference):
                self.emit(CallMethod)
            else:
                self.emit(CallFunction)
        else:
            # This is how you invoke a function value
            self.push(Values.Undefined)
            self.emit(CallMethod)

    def visitSuperCallExpression(self, node, isReferenced, fname, args):
        if fname.class is EmptyExpression:
            name = 'constructor'
        else:
            name = fname.name
        methodName = self.options.get(METHOD_NAME)
        if not methodName == name:
            supplement = ''
            if methodName.lower() == name.lower():
                supplement = ".  The method names must have the same capitalization."
            raise UnimplementedError("unimplemented: calling super.%s from %s%s" % (name, methodName, supplement), node)
        n = Parser().substitute("this.callInherited(_1, arguments.callee, _2)",
                                _1=Literal(name),
                                _2=Splice(args.children))
        self.visitCallExpression(n, isReferenced, *n.children)

    def visitNewExpression(self, node, isReferenced, ref):
        args = ()
        if ref.class is CallExpression:
            ref, args = ref.children
        self.visitCallParameters(node, isReferenced, args)
        isref = self.visitReference(ref, checkDefined=True, node=node)
        if isref:
            if ref.class in (PropertyIdentifierReference,
                             PropertyValueReference):
                self.emit(NewMethod)
            else:
                self.emit(NEW)
        else:
            self.push(Values.Undefined)
            self.emit(NewMethod)

    def visitPrefixExpression(self, node, isReferenced, op, ref):
        return self.translateXfixExpression(ref, op, isPrefix=True,
                                            isReferenced=isReferenced)

    def visitPostfixExpression(self, node, isReferenced, ref, op):
        return self.translateXfixExpression(ref, op, isPrefix=False,
                                            isReferenced=isReferenced)

    def translateXfixExpression(self, ref, op, isPrefix, isReferenced):
        newValueIsUsed = isReferenced and isPrefix
        oldValueIsUsed = isReferenced and not isPrefix
        op = XfixInstrs[op.operator]
        if oldValueIsUsed:
            ref = self.translateReference(ref, 3).get().preset().get()
            self.emit(op)
            ref.set()
        elif newValueIsUsed:
            ref = self.translateReference(ref, 2).preset().get()
            self.emit(op)
            self.emit(SetRegister(0))
            ref.set()
            self.push(Values.Register(0))
        else:
            ref = self.translateReference(ref, 2).preset().get()
            self.emit(op)
            ref.set()
            return True

    def visitUnaryExpression(self, node, isReferenced, op_, a):
        op = op_.operator
        if op in (Ops.INCR, Ops.DECR):
            return self.visitPrefixExpression(node, isReferenced, op_, a)
        # a little bit of constant-folding, so that '-1' looks like a constant
        if op == Ops.MINUS and a.class is Literal:
            v = self.translateLiteralNode(a)
            if isinstance(v, IntType) or isinstance(v, LongType) \
                   or isinstance(v, FloatType):
                self.push(-v)
                return
        # special-cased, since this operates on a ref rather than a value
        if op == Ops.DELETE:
            isref = self.visitReference(a)
            if isref:
                self.emit(DELETE)
            else:
                self.emit(DELETE2)
            return
        if self.options.get(FLASH_COMPILER_COMPATABILITY) and op == Ops.MINUS:
            self.push(0)
            self.visitExpression(a)
            self.emit(SUBTRACT)
            return
        # special-case typeof(variable) to not emit undefined-variable
        # checks so there is a warning-free way to check for undefined
        if op == Ops.TYPEOF and a.class in \
               (Identifier, PropertyValueReference, PropertyIdentifierReference):
            self.translateReference(a).get(False)
        else:
            self.visitExpression(a)
        instrs = UnopInstrs[op]
        if op == Ops.TILDE and \
               self.options.get(FLASH_COMPILER_COMPATABILITY):
            instrs = [PUSH(0xffffffffL),
                      BitwiseXor]
        for instr in instrs:
            self.emit(instr)

    def visitBinaryExpressionSequence(self, node, isReferenced, a, op, b):
        return self.visitBinaryExpression(node, isReferenced, op, a, b)

    def visitBinaryExpression(self, node, isReferenced, op, a, b):
        op = op.operator
        instrs = BinopInstrs[op]
        # Handle swf5 deficiencies.  swf5 does not have GreaterThan,
        # InstanceOf, or StrictEquals
        if self.options.get(RUNTIME) == "swf5":
            if op == Ops.GT:
                instrs = [SWAP]
                instrs.extend(BinopInstrs[Ops.LT])
            elif op == Ops.GE:
                instrs = [SWAP]
                instrs.extend(BinopInstrs[Ops.LE])
            elif op == Ops.INSTANCEOF:
                instrs = [PUSH((2, '$instanceof')),
                          CallFunction]
            elif op == Ops.SEQ or op == Ops.SNE:
                # Flash5 does not implement ===, but:
                # a === b <=> a == b && typeof(a) == typeof(b)
                self.translateControlStructure(
                    [('expr', a),           # a
                     SetRegister(0),        # a
                     ('expr', b),           # a b
                     SetRegister(1),        # a b
                     EQUALS,                # a==b
                     DUP,                   # a==b a==b
                     BranchIfFalse(0),      # true
                     POP,                   #
                     PUSH(Values.Register(0)), # a
                     TypeOf,                # typeof(a)
                     PUSH(Values.Register(1)), # typeof(a) b
                     TypeOf,                # typeof(a) typeof(b)
                     EQUALS,                # typeof(a)==typeof(b)
                     0])                    # a==b&&typeof(a)==typeof(b)
                if op == Ops.SNE:
                    self.emit(NOT)
                return
        self.visitExpression(a)
        self.visitExpression(b)
        for instr in instrs:
            self.emit(instr)

    def visitAndExpressionSequence(self, node, isReferenced, a, b):
        self.translateAndOrExpression(True, a, b)

    def visitOrExpressionSequence(self, node, isReferenced, a, b):
        self.translateAndOrExpression(False, a, b)

    def translateAndOrExpression(self, isand, a, b):
        self.visitExpression(a)
        self.emit(DUP)
        if isand:
            self.emit(NOT)
        label = self.newLabel()
        self.emit(BranchIfTrue(label))
        self.emit(POP)
        self.visitExpression(b)
        self.emit(LABEL(label))

    def visitConditionalExpression(self, node, isReferenced, test, a, b):
        l1 = self.newLabel()
        l2 = self.newLabel()
        self.visitExpression(test)
        self.emit(BranchIfTrue(l1))
        self.visitExpression(b)
        self.emit(BRANCH(l2))
        self.emit(LABEL(l1))
        self.visitExpression(a)
        self.emit(LABEL(l2))

    def visitAssignmentExpression(self, node, isReferenced, lhs, op, rhs):
        op = op.operator
        if op == Ops.ASSIGN:
            ref = self.translateReference(lhs).preset()
            self.visitExpression(rhs)
            if isReferenced:
                self.emit(SetRegister(0))
        else:
            op = AssignOpTable[op]
            ref = self.translateReference(lhs, 2).preset()
            ref.get()
            self.visitExpression(rhs)
            for instr in BinopInstrs[op]:
                self.emit(instr)
            if isReferenced:
                self.emit(SetRegister(0))
        ref.set()
        if isReferenced:
            self.push(Values.Register(0))
        return True

    def translateFunction(self, node, useName, *children):
        # label for profiling return
        label = self.newLabel()
        # TODO: [2003-04-15 ptw] bind context slot macro
        try:
            # --- shouldn't nested functions see their parent context?
            previousContext = self.context
            self.context = TranslationContext(FunctionExpression, None, label)
            dependencies = self.translateFunctionInternal(node, useName, *children)
        finally:
            self.context = previousContext
        # Dependency function is not compiled in the function context
        if dependencies:
            self.emit(DUP)
            self.push('dependencies')
            self.visitExpression(dependencies)
            self.emit(SetMember)

    # Internal helper function for above
    def translateFunctionInternal(self, node, useName, *children):
        # ast can be any of:
        #   FunctionDefinition(name, args, body)
        #   FunctionDeclaration(name, args, body)
        #   FunctionDeclaration(args, body)
        # Handle the two arities:
        if len(children) == 3:
            functionNameIdentifier, params, stmts = children
            functionName = functionNameIdentifier.name
        else:
            params, stmts = children
            functionName = None

        # function block
        block = self.newLabel()
        if functionName:
            userFunctionName = functionName
            self.options[METHOD_NAME] = functionName[functionName.rfind('.')+1:]
        else:
            # TODO: [2003-06-19 ptw] (krank) Sanitization of names to
            # identifiers moved to krank user, remove #- when it works
            #- from string import translate, maketrans
            #- trans = maketrans(" /.", "___")
            #- filename = translate(node.filename or 'unknown file', trans, '"');
            # Why do .as filenames have quotes around the string?
            filename = node.filename or 'unknown file'
            #- userFunctionName = '%s$%d_%d' % (filename, node.lineNumber, node.columnNumber)
            userFunctionName = '%s#%d/%d' % (filename, node.lineNumber, node.columnNumber)
        if not useName:
            functionName = None
        # For warnings
        import sys
        filename, lineno = getSourceLocation(node)
        pnames = [p.name for p in params.children]
        # Pull all the pragmas from the beginning of the
        # statement list: process them, and remove them
        assert stmts.class == StatementList
        stmts = list(stmts.children)
        while stmts and stmts[0].class is PragmaDirective:
            self.visitStatement(stmts[0])
            del stmts[0]
        stmts = tuple(stmts)

        # Analyze local variables (and functions)
        analyzer = VariableAnalyzer()
        for stmt in stmts:
            analyzer.visit(stmt)
        # Apparently you can re-declare parameters and not shadow them?
        variables = [n for n in analyzer.getDeclaredVariables() if n not in pnames]
        functions = analyzer.getFunctionDefinitions()
        used = analyzer.getUsedReferences()
        closed = analyzer.getClosedReferences()
        # Calculate free references
        free = [v for (v, u) in used.items() if u > 0 and v not in pnames and \
                v not in variables and \
                v not in Instructions.Register.AUTO_REG]
        # Note usage due to activation object and withThis
        if free:
            if self.options.get(ACTIVATION_OBJECT):
                used['_root'] = used.get('_root', 0) + 1
            if self.options.get(WITH_THIS):
                used['this'] = used.get('this', 0) + 1
        ## print 'pnames', pnames, 'used', used, 'functions', functions, 'variables', variables
        known = list(pnames) + variables
        lowerKnown = [v.lower() for v in known]
        self.context.setProperty(TranslationContext.VARIABLES, known)
        self.context.setProperty(TranslationContext.LOWERVARIABLES, lowerKnown)

        scriptElement = self.options.get(SCRIPT_ELEMENT)
        registerMap = {}
        lowerRegisterMap = {}
        # TODO: [2004-03-23 ptw] Analyze free variables in inner
        # functions and do not register them
        # TODO: [2004-03-24] Analyze register usage in $flasm and
        # account for it (or rename $flasm regs?)
        # NB: Only Flash Player 6r65 or better understands function2
        if self.options.get(GENERATE_FUNCTION_2) and \
           (self.options.get(FLASH_COMPILER_COMPATABILITY) or \
            self.options.get(GENERATE_FUNCTION_2_FOR_LZX)) and \
           not scriptElement and \
           not closed and \
           not used.has_key('eval') and \
           not used.has_key('$flasm'):
            autoRegisters = [Instructions.Register.make(n) for n in Instructions.Register.AUTO_REG if used.get(n, 0) > 0]
            fnArgs = [] + autoRegisters
            paramRegisters = []
            varRegisters = []
            # TODO: [2004-03-27 ptw] Should use threshold for
            # parameters be 0 or 1?  Presumably there is a getVariable
            # cost to loading the register.
            for v in pnames:
                use = used.get(v,0)
                if use > 0:
                    reg = Instructions.Register.make(v)
                    fnArgs.append(reg)
                    paramRegisters.append(reg)
                else:
                    if self.options.get(WARN_UNUSED_PARAMETERS):
                        print >> sys.stderr, \
                              "Warning: parameter %s of %s unused in %s(%s)" % \
                              (v, userFunctionName, filename, lineno)
                    fnArgs.append(v)
            # For determinism
            if variables:
                variables.sort()
            # Makes ths sort below stable
            index = 0
            for v in variables:
                use = used.get(v,0)
                if use > 0:
                    reg = Instructions.Register.make(v)
                    varRegisters.append((use, index, reg))
                    index = index + 1
                else:
                    if self.options.get(WARN_UNUSED_LOCALS):
                        print >> sys.stderr, \
                              "Warning: variable %s of %s unused in %s(%s)" % \
                              (v, userFunctionName, filename, lineno)
                    pass
            if autoRegisters or paramRegisters or varRegisters:
                # Don't know how Flash assigns registers (one would
                # have thought the parameters should be in stack order
                # and others by frequency of use), but we do know the
                # auto registers always come first in order and r:0 is
                # never assigned.  It appears the parameters are
                # assigned last.
                # TODO: [2004-03-29 ptw] Measure the cost of loading a
                # parameter register so we know whether to weight them
                # the same as var registers when there aren't enough
                # registers
                paramRegisters.reverse()
                varRegisters.sort()
                varRegisters.reverse()
                registers = list(autoRegisters) + [ v for (u, i, v) in varRegisters] + paramRegisters
                # Assign register numbers [1, 255]
                registers = registers[:254]
                regno = 1
                for r in registers:
                    r.regno = regno
                    regno = regno + 1
                    registerMap[r.name] = r
                    lowerRegisterMap[r.name.lower()] = r
                self.context.setProperty(TranslationContext.REGISTERS, registerMap)
                self.context.setProperty(TranslationContext.LOWERREGISTERS, lowerRegisterMap)                
                # It appears you have to always allocate r:0, hence
                # regno, not len(registers)
                self.emit(DefineFunction2((block, functionName, regno, ) + tuple(fnArgs)))
            else:
                self.emit(DefineFunction((block, functionName, ) + tuple(pnames)))
        else:
            self.emit(DefineFunction((block, functionName, ) + tuple(pnames)))

        if self.options.get(PROFILE):
            meterFunctionEvent(self, node, 'calls', userFunctionName)

        # TODO: [2003-03-23 ptw] Could we eliminate this by re-writing global references?
        if not self.options.get(FLASH_COMPILER_COMPATABILITY):
            activationObjectSize = 0
            if self.options.get(ACTIVATION_OBJECT):
                if scriptElement:
                    # Create variables in global scope
                    for variable in variables:
                        self.push('_root')
                        self.emit(GetVariable)
                        self.push(variable)
                        self.push(Values.Undefined)
                        self.emit(SetMember)
                else:
                    # create variables in activation object
                    for variable in variables:
                        # but not registered variables
                        if not registerMap.has_key(variable):
                            if closed or used.get(variable, 0) > 0:
                                self.push(variable)
                                self.push(Values.Undefined)
                                activationObjectSize += 1
                            else:
                                if self.options.get(WARN_UNUSED_LOCALS):
                                    print >> sys.stderr, \
                                          "Warning: variable %s of %s unused in %s(%s)" % \
                                          (variable, userFunctionName, filename, lineno)
                                pass
                for param in pnames:
                    # but not for registered parameters
                    if not registerMap.has_key(param):
                        if closed or used.get(param, 0) > 0:
                            self.push(param)
                            self.push(param)
                            self.emit(GetVariable)
                            activationObjectSize += 1
                        else:
                            if self.options.get(WARN_UNUSED_PARAMETERS):
                                print >> sys.stderr, \
                                      "Warning: parameter %s of %s unused in %s(%s)" % \
                                      (param, userFunctionName, filename, lineno)
                            pass
                if activationObjectSize > 0:
                    self.push(activationObjectSize)
                    self.emit(InitObject)
            if free:
                if registerMap.has_key('_root'):
                    self.push(Values.Register(registerMap['_root'].regno))
                else:
                    self.push('_root')
                    self.emit(GetVariable)
                self.emit(WITH(block))
                if self.options.get(WITH_THIS):
                    if registerMap.has_key('this'):
                        self.push(Values.Register(registerMap['this'].regno))
                    else:
                        self.push('this')
                        self.emit(GetVariable)
                    self.emit(WITH(block))
            if activationObjectSize > 0:
                self.emit(WITH(block))
            # inner functions do not get scriptElement treatment
            self.options[SCRIPT_ELEMENT] = False
            if self.options.get(ACTIVATION_OBJECT) and functions:
                if scriptElement:
                    # create functions in global scope
                    for name, fun in functions.items():
                        self.push('_root')
                        self.emit(GetVariable)
                        self.push(name)
                        self.translateFunction(fun, False, *fun.children)
                        self.emit(SetMember)
                else:
                    # TODO: [2004-03-30 ptw] Could functions be registered too?
                    for name, fun in functions.items():
                        self.push(name)
                        self.translateFunction(fun, False, *fun.children)
                    self.push(len(functions.items()))
                    self.emit(InitObject)
                    self.emit(WITH(block))
        # end of if not FLASH_COMPILER_COMPATABILITY
        self.visitStatementList(node, *stmts)
        # runtime handles implicit return except in profiling case
        if self.options.get(PROFILE):
            self.push(Values.Undefined)
            self.emit(LABEL(self.context.label))
            meterFunctionEvent(self, node, 'returns', userFunctionName)
            self.emit(RETURN)
        # close function
        self.emit(LABEL(block))
        if self.options.get(NAME_FUNCTIONS):
            if functionName:
                self.push(functionName)
                self.emit(GetVariable)
            else:
                self.emit(DUP)
            self.push('name')
            self.push(userFunctionName)
            self.emit(SetMember)
        if self.options.get(CONSTRAINT_FUNCTION):
            assert not functionName
            if ReferenceCollector.DebugConstraints:
                print 'stmts: ', stmts
            # Find dependencies.
            #
            # The job of a constraint function is to compute a value.
            # The current implementation inlines the call to set the
            # attribute that the constraint is attached to, within the
            # constraint function itself.  Walking the statements of
            # the function will process the expression that computes
            # the value; it will also process the call to
            # setAttribute, but ReferenceCollector knows to ignore
            # this.
            dependencies = ReferenceCollector(self.options.get(COMPUTE_METAREFERENCES))
            for stmt in stmts:
                dependencies.visit(stmt)
            expr = dependencies.computeReferences(userFunctionName)
            if self.options.get(PRINT_CONSTRAINTS):
                ParseTreePrinter().print(expr)
            return expr
        return None
    
    def translateLiteralNode(self, node):
        value = node.value
        if value is None:
            return Values.Null
        elif isinstance(value, IntType):
            return {0: Values.False, 1: Values.True}[value]
        return value

    def visitReference(self, ast, checkDefined=False, node=None):
        """Contract is to leave a reference on the stack that will be
        dereferenced by CallFunction, etc.  Returns true if it
        succeeds.  Returns false if the ast is such that only the
        value of the reference can be pushed.  In this case, the
        callee, must use 'CallMethod UNDEF' to call the value
        instead"""
        if checkDefined:
            assert node!=None, 'Must supply node for checkDefined'
        nodeType = ast.class
        if nodeType is PropertyIdentifierReference:
            self.translateReference(ast[0]).get()
            if checkDefined:
                checkUndefinedMethod(
                    self,
                    node,
                    ast[1].name)
            self.push(ast[1].name)
            return true
        if nodeType is PropertyValueReference:
            # TODO: [2002-10-26 ptw] (undefined reference coverage) Check
            self.translateReference(ast[0]).get()
            self.visitExpression(ast[1])
            return true
        # The only other reason you visit a reference is to make a funcall
        isref = true
        if nodeType == Identifier:
            ref = self.translateReference(ast)
            if ref.register:
                ref.get()
                isref = false
            else:
                ref.preset()
        elif nodeType == CallExpression:
            self.visitCallExpression(ast, True, *ast.children)
            isref = false
        else:
            raise CompilerImplementationError('unknown reference type: %s' % ast.class, node)
        if checkDefined:
            checkUndefinedFunction(
                self,
                node,
                isref and nodeType == Identifier and  ast.name)
        return isref

    def translateReference(self, node, referenceCount=1):
        if node.class is Identifier:
            return VariableReference(self, node, referenceCount, node.name)
        if node.class is ThisReference:
            return VariableReference(self, node, referenceCount, "this")
        if node.class in (ArrayLiteral, Literal, ObjectLiteral, CallExpression, NewExpression):
            return LiteralReference(self, node, referenceCount)
        args = node.children
        if node.class == PropertyIdentifierReference:
            return PropertyReference(self, node, referenceCount, *args)
        elif node.class == PropertyValueReference:
            return IndexReference(self, node, referenceCount, *args)
        else:
            raise SemanticError('Invalid reference expression: %s' % ParseTreePrinter().visit(node), node)

    def compileInlineAssembly(self, statements, index):
        # skip $flasm
        i = index + 1
        while True:
            stmt = i < len(statements) and statements[i]
            i = i + 1
            if stmt and stmt.class is Statement:
                pass
            else:
                raise SemanticError("Unterminated $flasm block", node)
            node = stmt[0]
            nt = node.class
            if nt is Identifier and node.name == "$end":
                # skip $end
                i = i + 1
                break
            if nt is Literal and type(node.value) is StringType:
                pass
            else:
                raise SemanticError("Invalid flasm statement %s" %
                                    node, node)
            instructions = parseInstructions(node.value)
            if self.options.get(PROFILE):
                def profiled_emit(instr):
                    if instr is RETURN:
                        self.emit(BRANCH(self.context.label))
                    else:
                        self.emit(instr)
                for instr in instructions:
                    profiled_emit(instr)
            else:
                for instr in instructions:
                    self.emit(instr)
        return i

# Compiles a sequences of assignment statements, starting at
# statements[index], and returns the index of the first statement not
# compiled, or None if no statement was compiled.  (This will be the
# case if statements[index] is not an appropriate (see below)
# assignment statement).
#
# All the statements in the sequence must be to properties with the
# same base, e.g. a.b and a.c, or a.b.c and a.b.d.
#
# If obfuscate is true, the values are pushed onto the stack inside a
# call to an anonymous function that's placed on the stack,, but
# consumed outside the function.  This foils the ASV ActionScript
# decompiler.  For example, 'a.b = 1' is compiled as:
#
# function () {push 'a', 'b', 1}() # leaves values on stack
# setMember # consumes the values

# Only called with obfuscate=True for top-level assignments.  Since
# this hides most of the functions, additionally obfuscation is
# unnecessary and also has greater performance costs.
def compileAssignments(generator, statements, index, obfuscate=False):
    # TODO: [2004-03-26 ptw] Does not work in the presence of registers
    # because of the GetVariable optimization
    if generator.options.get(GENERATE_FUNCTION_2):
        return None
    node = statements[index]
    children = node.children
    if not children:
        return None
    def getAssignmentBase(node):
        if node.class is AssignmentExpression \
               and node[1].operator == Ops.ASSIGN \
               and node[0].class is PropertyIdentifierReference:
            return node[0][0]
    def nodeEquals(a, b):
        # TODO: [2002-12-02 ows] The Java AST classes should
        # implement this instead.
        if not a or not b:
            return False
        type = a.class
        if type is not b.class:
            return False
        if type is Identifier:
            return a.name == b.name
        if type is ThisReference:
            return True
        if type is PropertyIdentifierReference:
            return nodeEquals(a[0], b[0]) and a[1].name == b[1].name
    base = getAssignmentBase(children[0])
    if not base:
        return None
    # A stable expression is one whose value won't be changed by an
    # assignment to a property reference, that doesn't modify r0, and
    # that doesn't have side effects.  False negatives are okay.
    def isStableExpression(node):
        nt = node.class
        return nt in (Identifier, Literal, FunctionExpression)
    # Collect the assignments of values returned by stable
    # expressions, to the same base.  j is left pointing one past the
    # last assignment.
    j = index+1
    while True:
        next = j < len(statements) and statements[j]
        nextbase = next and next.class is Statement and \
                   next.children and getAssignmentBase(next[0])
        if not nodeEquals(base, nextbase):
            break
        value = next[0][2]
        if not isStableExpression(value):
            break
        j = j + 1
    # As an optimization, this is only worthwhile if there's more than
    # one assignment to the same base.  As an obfuscation, it's worth
    # doing even if there's only one.
    if not obfuscate and j - index < 2: return None
    if obfuscate:
        label = generator.newLabel()
        generator.emit(DefineFunction((label, None, )))
    generator.visitExpression(base)
    # : base
    generator.emit(SetRegister(0))
    # : base
    # visit values, in reverse order
    getvars = [] # array of flags for whether to call GetVariable
    firstTime = True
    for i in range(j-1, index-1, -1):
        # ...
        if firstTime:
            firstTime = False
        else:
            generator.push(Values.Register(0))
        # : ..., base
        prop = statements[i][0][0][1].name
        generator.push(prop)
        # : ..., base, prop
        value = statements[i][0][2]
        if value.class is Identifier:
            # Special-case this so that the GetVariable can be done
            # later, where it doesn't break up a sequence of push
            # arguments
            generator.push(value.name)
            getvars.append(True)
        else:
            generator.visitExpression(value)
            getvars.append(False)
        # : ..., base, prop, value
    if obfuscate:
        generator.emit(LABEL(label))
        # : fn
        # This is how you invoke a function value
        generator.push(Values.Undefined)
        # : fn, Undefined
        generator.emit(CallMethod)
        # : base, prop, value, ..., Undefined
        generator.emit(POP)
    # : base, prop, value, base, prop, value, ...
    for i in range(index, j):
        if getvars.pop():
            generator.emit(GetVariable)
        # : ..., base, prop, value
        generator.emit(SetMember)
        # : ...
    # : [empty]
    return j

class VariableAnalyzer:
    def __init__(self):
        self.locals = []
        self.fundefs = {}
        self.used = {}
        self.closed = False

    def getDeclaredVariables(self):
        return self.locals

    def getFunctionDefinitions(self):
        return self.fundefs

    def getUsedReferences(self):
        return self.used

    def getClosedReferences(self):
        return self.closed

    def visit(self, node):
        t = node.class
        children = node.children
        # ForVar has a VariableDeclaration as a child, so we don't
        # need to handle it specially, but ForVarIn does not.
        if t in (VariableDeclaration, ForVarInStatement):
            v = children[0].name
            if v not in self.locals:
                self.locals.append(v)
        elif t == FunctionDeclaration:
            self.fundefs[children[0].name] = node
        elif t in (ThisReference, Identifier):
            if t is ThisReference:
                v = 'this'
            else:
                v = node.name
            self.used[v] = self.used.get(v, 0) + 1
        if t in (FunctionDeclaration, FunctionExpression):
            # TODO: [2004-03-24 ptw] find closed over variables
            self.closed = True
            return
        for child in children:
            self.visit(child)


class ReferenceCollector:
    DebugConstraints = False

    def __init__(self, computeMetaReferences=False):
        self.computeMetaReferences = computeMetaReferences
        self.references = []
        self.functions = []
        self.metareferences = []
        self.metafunctions = []
        self.depth = ''

    def computeReferences(self, name):
        name = name.replace('#', '_').replace(' ', '_').replace('/', '_')
        def rsubst(r):
            return Parser().substitute(
                '[_1]',
                _1=Splice(
                nconc(*[(n[0], Literal(n[1].name))
                        for n in r])))
        def fsubst(node):
            # f(args...) -> f["dependencies"](this, undefined, args...)
            # a.f(args...) -> f["dependencies"](this, a, args...)
            fn = node[0]
            callee = EmptyExpression(0)
            if fn.class is PropertyIdentifierReference:
                callee = fn[0]
            # the function uses #pragma "warnUndefinedReferences=false"
            # to avoid warnings for non-existent dependencies
            return Parser().substitute(
                '_1.dependencies(this, _2, _3)',
                _1=fn,
                _2=callee,
                _3=Splice(node[1].children))
        def c(a, b):
            # (a, b) -> a.concat(b || [])
            return Parser().substitute(
                '_1.concat(_2 || [])',
                _1=a,
                _2=b)
        r = rsubst(self.references)
        f = [fsubst(fn) for fn in self.functions]
        a = [r]
        a.extend(f)
        d = reduce(c, a)
        if self.metareferences or self.metafunctions:
            # The LFC guarantees that these won't change.
            immutableProperties = ('parent', 'immediateParent', 'classroot', 'canvas')
            metareferences = [r for r in self.metareferences
                              if r.class != PropertyIdentifierReference or
                              r[1].class != Identifier or
                              r[1].name not in immutableProperties]
            mr = rsubst(metareferences)
            mf = [fsubst(fn) for fn in self.metafunctions]
            ma = [mr]
            ma.extend(mf)
            md = reduce(c, ma)
            # store metadependencies as a property of deps
            return Parser().substitute(
                # TODO: [2003-06-19 ptw] (krank) Have to use sanitized
                # name here, so that substitute does not try to name
                # the function 'x'
                # Note: Since substitute does not enforce macro
                # hygiene, arguments.callee.d is used as a temp var
                # (rather than declaring a var) so as not to shadow
                # any free references in the dependencies expression
                'function %s_dependencies () {\n#pragma "warnUndefinedReferences=false"\nwith (this) { arguments.callee.d = _1; arguments.callee.d.metadependencies = _2; return arguments.callee.d;}}' % name, _1=d, _2=md)
        else:
            return Parser().substitute(
                # TODO: [2003-06-19 ptw] (krank) Have to use sanitized
                # name here, so that substitute does not try to name
                # the function 'x'
                'function %s_dependencies () {\n#pragma "warnUndefinedReferences=false"\nwith (this) return _1;}' % name, _1=d)

    def visit(self, node):
        self.visitInternal(node, self.references, self.functions)

    def visitInternal(self, node, references=None, functions=None):
        if self.DebugConstraints:
            print self.depth, 'node: ', node
        try:
            if self.DebugConstraints:
                self.depth = self.depth + '    '
            t = node.class
            if t in (FunctionDeclaration, FunctionExpression):
                # Don't traverse inside nested functions
                pass
            elif t is Identifier:
                p = PropertyIdentifierReference(0)
                p.setChildren([ThisReference(0), node])
                references.append(p)
            elif t is PropertyIdentifierReference:
                # Visit the base for meta-dependencies
                if self.computeMetaReferences:
                    self.visitInternal(node[0], self.metareferences, self.metafunctions)
                # If the base is a function, collect its dependency function
                if node[0].class == CallExpression:
                    functions.append(node[0])
                references.append(node)
            elif t is CallExpression:
                # Optimization: ignore this.setAttribute(...),
                # since it's used in every constraint expression
                # and doesn't have a dependency function (and if
                # it did, it would always return null.
                if node[0].class is PropertyIdentifierReference and \
                       node[0][0].class is ThisReference and \
                       node[0][1].class is Identifier and \
                       node[0][1].name == "setAttribute":
                    pass
                else:
                    # Visit the function for meta-dependencies
                    if self.computeMetaReferences:
                        self.visitInternal(node[0], self.metareferences, self.metafunctions)
                    # Collect the function's dependency function
                    functions.append(node)
                # Visit the arguments.
                self.visitInternal(node[1], references, functions)
            else:
                for n in node.children:
                    self.visitInternal(n, references, functions)
        finally:
            if self.DebugConstraints:
                self.depth = self.depth[:-4]
                print self.depth, 'references: ', self.references
                print self.depth, 'functions: ', self.functions
                print self.depth, 'metareferences: ', self.metareferences
                print self.depth, 'metafunctions: ', self.metafunctions


#
# Profiler for hand-instrumentation
#

class Profiler:
    class Block:
        def __init__(self, name):
            import time
            self.startTime = time.clock()
            self.name = name
            self.children = []

        def make(self, name):
            block = self.__class__(name)
            block.parent = self
            self.children.append(block)
            return block

    def __init__(self):
        self.names = []
        block = self.Block("__main__")
        self.main = block
        self.current = block

    def enter(self, name):
        block = self.current.make(name)
        self.current = block

    def exit(self):
        import time
        self.current.elapsed = time.clock() - self.current.startTime
        self.current = self.current.parent

    def switch(self, name):
        self.exit()
        self.enter(name)

    def pprint(self):
        import operator
        total = reduce(operator.add, [block.elapsed for block in self.current.children])
        total = max(total, 1) # avoid /0 error below
        for block in self.current.children:
            time = block.elapsed
            print '%s\t%2.3fs\t%2.2f%%' % (block.name, time, 100*time/total)

#
# Compiler Facade
#

# TODO: [2002-12-11 ows] remove the need in jythonc for this special-casing
import org.openlaszlo.sc.CompilerException as CompilerException

import java.lang.Object
import org.openlaszlo.sc.Assembler as Assembler
import org.openlaszlo.sc.Optimizer as Optimizer
from parseinstructions import *

class Compiler(java.lang.Object):
    def __init__(self, **options):
        self.options = options
        self.options.setdefault(ACTIVATION_OBJECT,
                                not self.options.get(FLASH_COMPILER_COMPATABILITY))
        self.options.setdefault(COMPILE_TIME_CONSTANTS, {})
        # TODO: [2002-1-05 ows] enable this instead of the line that
        # follows it, once the sources comply
        #- self.options.setdefault(ALLOW_ROOT,
        #-                        options.get(FLASH_COMPILER_COMPATABILITY))
        self.options.setdefault(ALLOW_ROOT, True)
        self.options.setdefault(OBFUSCATE, True)
        import org.openlaszlo.server.LPS as LPS
        self.options.setdefault(RUNTIME, LPS.getProperty("compiler.runtime.default", "swf6"))
        self.defaultProperties()
        if self.options.get(PRINT_COMPILER_OPTIONS):
            print 'init compiler options', self.options

    # Set internal flags that depend on external flags
    def defaultProperties(self):
        import org.openlaszlo.server.LPS as LPS
        if self.options.get(DEBUG):
            self.options[WARN_UNDEFINED_REFERENCES] = True
            self.options[WARN_GLOBAL_ASSIGNMENTS] = \
                LPS.getProperty("compiler.warn.globalassignments", "false") == "true"
            self.options[WARN_UNUSED_LOCALS] = \
                LPS.getProperty("compiler.warn.unusedlocals", "false") == "true"
            self.options[WARN_UNUSED_PARAMETERS] = \
                LPS.getProperty("compiler.warn.unusedparameters", "false") == "true"
            self.options[NAME_FUNCTIONS] = True
        if self.options.get(PROFILE):
            self.options[NAME_FUNCTIONS] = True
        elif self.options.get(RUNTIME) != "swf5":
            # TODO: [2004-04-27 ptw] Make function2 work with profiling
            self.options[GENERATE_FUNCTION_2] = True
        if self.options.get(KRANK):
            self.options[NAME_FUNCTIONS] = True
            self.options[DISABLE_CONSTANT_POOL] = True
            self.options[OBFUSCATE] = False
            self.options[COMPILE_TRACE] = 'flash'
    
    def setProperties(self, properties):
        "@sig public void setProperties(java.util.Map m)"
        for e in properties.entrySet().toArray():
            k, v = e.key, e.value
            if v in ('true', 'false'):
                v = v == 'true'
            self.options[k] = v
        self.defaultProperties()
        if self.options.get(PRINT_COMPILER_OPTIONS):
            print 'set compiler options', self.options

    def compile(self, source):
        "@sig public byte[] compile(java.lang.String s)"
        try:
            profiler = Profiler()
            profiler.enter('parse')
            program = Parser().parse(source)
            profiler.switch('generate')
            cg = CodeGenerator(**self.options)
            cg.translate(program)
            if self.options.get(PROGRESS):
                print 'Assembling...',
            profiler.switch('collect')
            instrs = cg.collector.getInstructions(True)
            if self.options.get(PRINT_INSTRUCTIONS):
                Optimizer(InstructionPrinter()).assemble(instrs)
            profiler.switch('assemble')
            asm = Optimizer(Assembler())
            # end marker
            instrs.add(NONE)
            bytes = asm.assemble(instrs)
            profiler.exit()
            if self.options.get(PROFILE_COMPILER):
                profiler.pprint()
                print
            if self.options.get(PROGRESS):
                print 'done.'
            return bytes
        except CompilerImplementationError, e:
            ellipses = len(source.strip()) > 80 and '...' or ''
            print "while compiling %r" % (source.strip()[:80] + ellipses)
            raise
        except CompilerError, e:
            raise CompilerException(str(e))

#
# Testing
#
def testStaticCoverage():
    CodeGenerator().testStaticCoverage()
