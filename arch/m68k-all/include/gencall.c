/*
 * Copyright (C) 2010, Jason S. McMullan. All rights reserved.
 * Author: Jason S. McMullan <jason.mcmullan@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 *
 * This program generates the libcall.h macroset for gcc-4.5.1 m68k-elf
 *
 * WARNING: The header generated by this program is designed
 *          to work with GCC 4.5.1 m68k-elf ONLY, and even
 *          then it has only been very lightly tested with
 *          "-O2 -fomit-frame-pointer -ffixed-a6"
 *
 * If it breaks, you get to keep both pieces.
 */

#include <stdio.h>

#define GENCALL_MAX	(13 + 1)	/* Max number of arguments */

//#define CLOBBER_ALL	"\"%d0\", \"%d1\", \"%a0\", \"%a1\", \"cc\", \"memory\""
#define CLOBBER_ALL	"\"cc\", \"memory\""

/* NOTE: For all 'call' macros, ie AROS_LC5(), the
 *       'bt' parameter is frequently garbled by
 *       callers who use '#define's like:
 *
 * #define UtilityBase mydata->utilitybase
 *
 *       this makes a 'bt' parameter of 'struct UtilityBase *'
 *       turn into 'struct mydata->utilitybase *'. 
 *
 *       Unhappiness ensues. So, we must use 'void *'
 *       for all 'bt' arguments in the call macros.
 */
void aros_ufp(int id, int is_static)
{
	int i;

	printf("#define AROS_UFP%d%s(t,n", id, is_static ? "S" : "");
	for (i = 0; i < id; i++)
		printf(",a%d", i + 1);
	printf(") \\\n");
	printf("\t%st n (void)\n", is_static ? "static " : "");
}

void aros_ufh(int id, int is_static)
{
	int i;

	printf("#define AROS_UFH%d%s(t,n", id, is_static ? "S" : "");
	for (i = 0; i < id; i++)
		printf(",a%d", i + 1);
	printf(") \\\n");
	printf("\t%st n (void) {%s\n", is_static ? "static " : "", (i==0) ? "" : " \\");
	for (i = 0; i < id; i++)
		printf("\tregister __AROS_UFPA(a%d) __AROS_UFTA(a%d) asm(__AROS_UFSA(a%d)); \\\n", i+1, i+1, i+1);
	for (i = 0; i < id; i++)
		printf("\t__AROS_UFPA(a%d) __attribute__((unused)) __AROS_UFCA(a%d) = __AROS_UFTA(a%d);%s\n", i+1, i+1, i+1, (i == (id-1)) ? "" : " \\");
}

static void aros_ufc(int id)
{
	int i;
	printf("#define AROS_UFC%d(t,n", id);
	for (i = 0; i < id; i++)
		printf(",a%d", i + 1);
	printf(") \\\n");
	printf("\t({ \\\n");
	for (i = 0; i < id; i++)
		printf("\t   __AROS_UFPA(a%d) __AROS_UFTA(a%d) = __AROS_UFCA(a%d); \\\n", i + 1, i + 1, i + 1);
	printf("\t   (t)({\\\n");
	for (i = 0; i < id; i++)
		printf("\t     register __AROS_UFPA(a%d) __AROS_UFRA(a%d) asm(__AROS_UFSA(a%d)) = __AROS_UFTA(a%d); \\\n", i + 1, i + 1, i + 1, i + 1);
	printf("\t     register ULONG _ret asm(\"%%d0\"); \\\n");
	printf("\t     asm volatile (\"jsr (%%1)\\n\" : \\\n");
	printf("\t             \"=r\" (_ret) : \\\n");
	printf("\t              \"a\" (n), \\\n");
	for (i = 0; i < id; i++)
		printf("\t              \"r\" (__AROS_UFRA(a%d))%s \\\n", i + 1, (i == (id-1)) ? "" : ",");
	printf("\t     : %s ); \\\n", CLOBBER_ALL);
	printf("\t     _ret;});})\n\n");
}


void aros_lc(int id)
{
	int i;
	printf("#define AROS_LC%d(t,n,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\t({ void *bt_tmp = bn; \\\n");
	for (i = 0; i < id; i++)
		printf("\t   __AROS_LPA(a%d) __AROS_LTA(a%d) = __AROS_LCA(a%d); \\\n", i + 1, i + 1, i + 1);
	printf("\t   (t)({\\\n");
	for (i = 0; i < id; i++)
		printf("\t     register __AROS_LPA(a%d) __AROS_LRA(a%d) asm(__AROS_LSA(a%d)) = __AROS_LTA(a%d); \\\n", i + 1, i + 1, i + 1, i + 1);
	printf("\t     register void *_bt asm(\"%%a6\") = bt_tmp; \\\n");
	printf("\t     register ULONG _ret asm(\"%%d0\"); \\\n");
	printf("\t     asm volatile (\"jsr %%c1(%%%%a6)\\n\" : \\\n");
	printf("\t             \"=r\" (_ret) : \\\n");
	printf("\t              \"i\" (-1 * o * LIB_VECTSIZE), \\\n");
	for (i = 0; i < id; i++)
		printf("\t              \"r\" (__AROS_LRA(a%d)), \\\n", i + 1);
	printf("\t              \"r\" (_bt) \\\n");
	printf("\t     : %s ); \\\n", CLOBBER_ALL);
	printf("\t     _ret;});})\n\n");
}

void aros_lh(int id, int is_ignored)
{
	int i;

	printf("#define AROS_LH%d%s(t,n,", id, is_ignored ? "I" : "");
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\tt AROS_SLIB_ENTRY(n,s) (void) { \\\n");
	for (i = 0; i < id; i++)
		printf("\t__AROS_LPA(a%d) __attribute__((unused)) __AROS_LCA(a%d) = ({register ULONG __r asm(__AROS_LSA(a%d));(__AROS_LPA(a%d))__r;}); \\\n", i+1, i+1, i+1, i+1);
	printf("\tregister bt __attribute__((unused)) bn = ({register ULONG __r asm(\"%%a6\");(bt)__r;});\n");
}

static void aros_lcnr(int id)
{
	printf("#define AROS_LC%dNR AROS_LC%d\n", id, id);
}

static void aros_call(int id)
{
	int i;
	printf("#define AROS_CALL%d(t,addr,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn) \\\n");
	printf("\t({ void *bt_tmp = bn; \\\n");
	for (i = 0; i < id; i++)
		printf("\t   __AROS_LPA(a%d) __AROS_LTA(a%d) = __AROS_LCA(a%d); \\\n", i + 1, i + 1, i + 1);
	printf("\t   (t)({\\\n");
	printf("\t     register void *_bt asm(\"%%a6\") = bt_tmp; \\\n");
	for (i = 0; i < id; i++)
		printf("\t     register __AROS_LPA(a%d) __AROS_LRA(a%d) asm(__AROS_LSA(a%d)) = __AROS_LTA(a%d); \\\n", i + 1, i + 1, i + 1, i + 1);
	printf("\t     register ULONG _ret asm(\"%%d0\"); \\\n");
	printf("\t     asm volatile (\"jsr (%%1)\\n\" : \\\n");
	printf("\t             \"=r\" (_ret) : \\\n");
	printf("\t              \"a\" (addr), \\\n");
	for (i = 0; i < id; i++)
		printf("\t              \"r\" (__AROS_LRA(a%d)), \\\n", i + 1);
	printf("\t              \"r\" (_bt) \\\n");
	printf("\t     : %s ); \\\n", CLOBBER_ALL);
	printf("\t     _ret;});})\n\n");
}

static void aros_callnr(int id)
{
	printf("#define AROS_CALL%dNR AROS_CALL%d\n", id, id);
}

static void aros_lvo_call(int id)
{
	int i;
	printf("#define AROS_LVO_CALL%d(t,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\tAROS_CALL%d(t,__AROS_GETVECADDR(bn,o), \\\n", id);
	for (i = 0; i < id; i++)
		printf("\t\tAROS_LCA(a%d), \\\n", i + 1);
	printf("\t\tbt,bn)\n");
}

static void aros_lvo_callnr(int id)
{
	int i;
	printf("#define AROS_LVO_CALL%dNR(t,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\tAROS_CALL%dNR(t,__AROS_GETVECADDR(bn,o), \\\n", id);
	for (i = 0; i < id; i++)
		printf("\t\tAROS_LCA(a%d), \\\n", i + 1);
	printf("\t\tbt,bn)\n");
}

static void aros_ld(int id)
{
	int i;

	printf("#define AROS_LD%d(t,n,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\t__AROS_LD_PREFIX t AROS_SLIB_ENTRY(n,s) (void)\n");
}

static void aros_ldi(int id)
{
	int i;

	printf("#define AROS_LD%dI(t,n,", id);
	for (i = 0; i < id; i++)
		printf("a%d,", i + 1);
	printf("bt,bn,o,s) \\\n");
	printf("\t__AROS_LD_PREFIX t AROS_SLIB_ENTRY(n,s)(void)\n");
}

int main(int argc, char **argv)
{
	int i;

	printf("/* AUTOGENERATED by arch/m68k-all/include/gencall.c */\n");
	printf("/* If you can get this to work for anything other   */\n");
	printf("/* than gcc-4.5.1 m68k-elf, it would be surprising. */\n");
	printf("\n");
	printf("#ifndef AROS_M68K_LIBCALL_H\n");
	printf("#define AROS_M68K_LIBCALL_H\n");
	printf("\n");
	printf("/* Call a libary function which requires the libbase */\n");
	printf("\n");
	printf("#define __AROS_CPU_SPECIFIC_ASMCALLS\n\n");

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ufp(i, 0);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ufp(i, 1);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ufh(i, 0);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ufh(i, 1);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ufc(i);

	printf("#define __AROS_CPU_SPECIFIC_LH\n\n");
	
	for (i = 0; i < GENCALL_MAX; i++)
		aros_lh(i, 0);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_lh(i, 1);

	printf("\n");
	printf("#define __AROS_CPU_SPECIFIC_LC\n\n");
	
	for (i = 0; i < GENCALL_MAX; i++)
		aros_lc(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_lcnr(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_call(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_callnr(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_lvo_call(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_lvo_callnr(i);

	printf("\n");
	printf("#define __AROS_CPU_SPECIFIC_LD\n\n");
	
	for (i = 0; i < GENCALL_MAX; i++)
		aros_ld(i);

	for (i = 0; i < GENCALL_MAX; i++)
		aros_ldi(i);

	printf("#endif /* AROS_M68K_LIBCALL_H */\n");
	return 0;
}
