*	$NetBSD: slogn.sa,v 1.4 2000/03/13 23:52:32 soren Exp $

*	MOTOROLA MICROPROCESSOR & MEMORY TECHNOLOGY GROUP
*	M68000 Hi-Performance Microprocessor Division
*	M68040 Software Package 
*
*	M68040 Software Package Copyright (c) 1993, 1994 Motorola Inc.
*	All rights reserved.
*
*	THE SOFTWARE is provided on an "AS IS" basis and without warranty.
*	To the maximum extent permitted by applicable law,
*	MOTOROLA DISCLAIMS ALL WARRANTIES WHETHER EXPRESS OR IMPLIED,
*	INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
*	PARTICULAR PURPOSE and any warranty against infringement with
*	regard to the SOFTWARE (INCLUDING ANY MODIFIED VERSIONS THEREOF)
*	and any accompanying written materials. 
*
*	To the maximum extent permitted by applicable law,
*	IN NO EVENT SHALL MOTOROLA BE LIABLE FOR ANY DAMAGES WHATSOEVER
*	(INCLUDING WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS
*	PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR
*	OTHER PECUNIARY LOSS) ARISING OF THE USE OR INABILITY TO USE THE
*	SOFTWARE.  Motorola assumes no responsibility for the maintenance
*	and support of the SOFTWARE.  
*
*	You are hereby granted a copyright license to use, modify, and
*	distribute the SOFTWARE so long as this entire notice is retained
*	without alteration in any modified and/or redistributed versions,
*	and that such modified versions are clearly identified as such.
*	No licenses are granted by implication, estoppel or otherwise
*	under any patents or trademarks of Motorola, Inc.

*
*	slogn.sa 3.1 12/10/90
*
*	slogn computes the natural logarithm of an
*	input value. slognd does the same except the input value is a
*	denormalized number. slognp1 computes log(1+X), and slognp1d
*	computes log(1+X) for denormalized X.
*
*	Input: Double-extended value in memory location pointed to by address
*		register a0.
*
*	Output:	log(X) or log(1+X) returned in floating-point register Fp0.
*
*	Accuracy and Monotonicity: The returned result is within 2 ulps in
*		64 significant bit, i.e. within 0.5001 ulp to 53 bits if the
*		result is subsequently rounded to double precision. The 
*		result is provably monotonic in double precision.
*
*	Speed: The program slogn takes approximately 190 cycles for input 
*		argument X such that |X-1| >= 1/16, which is the usual 
*		situation. For those arguments, slognp1 takes approximately
*		 210 cycles. For the less common arguments, the program will
*		 run no worse than 10% slower.
*
*	Algorithm:
*	LOGN:
*	Step 1. If |X-1| < 1/16, approximate log(X) by an odd polynomial in
*		u, where u = 2(X-1)/(X+1). Otherwise, move on to Step 2.
*
*	Step 2. X = 2**k * Y where 1 <= Y < 2. Define F to be the first seven
*		significant bits of Y plus 2**(-7), i.e. F = 1.xxxxxx1 in base
*		2 where the six "x" match those of Y. Note that |Y-F| <= 2**(-7).
*
*	Step 3. Define u = (Y-F)/F. Approximate log(1+u) by a polynomial in u,
*		log(1+u) = poly.
*
*	Step 4. Reconstruct log(X) = log( 2**k * Y ) = k*log(2) + log(F) + log(1+u)
*		by k*log(2) + (log(F) + poly). The values of log(F) are calculated
*		beforehand and stored in the program.
*
*	lognp1:
*	Step 1: If |X| < 1/16, approximate log(1+X) by an odd polynomial in
*		u where u = 2X/(2+X). Otherwise, move on to Step 2.
*
*	Step 2: Let 1+X = 2**k * Y, where 1 <= Y < 2. Define F as done in Step 2
*		of the algorithm for LOGN and compute log(1+X) as
*		k*log(2) + log(F) + poly where poly approximates log(1+u),
*		u = (Y-F)/F. 
*
*	Implementation Notes:
*	Note 1. There are 64 different possible values for F, thus 64 log(F)'s
*		need to be tabulated. Moreover, the values of 1/F are also 
*		tabulated so that the division in (Y-F)/F can be performed by a
*		multiplication.
*
*	Note 2. In Step 2 of lognp1, in order to preserved accuracy, the value
*		Y-F has to be calculated carefully when 1/2 <= X < 3/2. 
*
*	Note 3. To fully exploit the pipeline, polynomials are usually separated
*		into two parts evaluated independently before being added up.
*	

slogn	IDNT	2,1 Motorola 040 Floating Point Software Package

	section	8

	include fpsp.h

BOUNDS1  DC.L $3FFEF07D,$3FFF8841
BOUNDS2  DC.L $3FFE8000,$3FFFC000

LOGOF2	DC.L $3FFE0000,$B17217F7,$D1CF79AC,$00000000

one	DC.L $3F800000
zero	DC.L $00000000
infty	DC.L $7F800000
negone	DC.L $BF800000

LOGA6	DC.L $3FC2499A,$B5E4040B
LOGA5	DC.L $BFC555B5,$848CB7DB

LOGA4	DC.L $3FC99999,$987D8730
LOGA3	DC.L $BFCFFFFF,$FF6F7E97

LOGA2	DC.L $3FD55555,$555555A4
LOGA1	DC.L $BFE00000,$00000008

LOGB5	DC.L $3F175496,$ADD7DAD6
LOGB4	DC.L $3F3C71C2,$FE80C7E0

LOGB3	DC.L $3F624924,$928BCCFF
LOGB2	DC.L $3F899999,$999995EC

LOGB1	DC.L $3FB55555,$55555555
TWO	DC.L $40000000,$00000000

LTHOLD	DC.L $3f990000,$80000000,$00000000,$00000000

LOGTBL:
	DC.L  $3FFE0000,$FE03F80F,$E03F80FE,$00000000
	DC.L  $3FF70000,$FF015358,$833C47E2,$00000000
	DC.L  $3FFE0000,$FA232CF2,$52138AC0,$00000000
	DC.L  $3FF90000,$BDC8D83E,$AD88D549,$00000000
	DC.L  $3FFE0000,$F6603D98,$0F6603DA,$00000000
	DC.L  $3FFA0000,$9CF43DCF,$F5EAFD48,$00000000
	DC.L  $3FFE0000,$F2B9D648,$0F2B9D65,$00000000
	DC.L  $3FFA0000,$DA16EB88,$CB8DF614,$00000000
	DC.L  $3FFE0000,$EF2EB71F,$C4345238,$00000000
	DC.L  $3FFB0000,$8B29B775,$1BD70743,$00000000
	DC.L  $3FFE0000,$EBBDB2A5,$C1619C8C,$00000000
	DC.L  $3FFB0000,$A8D839F8,$30C1FB49,$00000000
	DC.L  $3FFE0000,$E865AC7B,$7603A197,$00000000
	DC.L  $3FFB0000,$C61A2EB1,$8CD907AD,$00000000
	DC.L  $3FFE0000,$E525982A,$F70C880E,$00000000
	DC.L  $3FFB0000,$E2F2A47A,$DE3A18AF,$00000000
	DC.L  $3FFE0000,$E1FC780E,$1FC780E2,$00000000
	DC.L  $3FFB0000,$FF64898E,$DF55D551,$00000000
	DC.L  $3FFE0000,$DEE95C4C,$A037BA57,$00000000
	DC.L  $3FFC0000,$8DB956A9,$7B3D0148,$00000000
	DC.L  $3FFE0000,$DBEB61EE,$D19C5958,$00000000
	DC.L  $3FFC0000,$9B8FE100,$F47BA1DE,$00000000
	DC.L  $3FFE0000,$D901B203,$6406C80E,$00000000
	DC.L  $3FFC0000,$A9372F1D,$0DA1BD17,$00000000
	DC.L  $3FFE0000,$D62B80D6,$2B80D62C,$00000000
	DC.L  $3FFC0000,$B6B07F38,$CE90E46B,$00000000
	DC.L  $3FFE0000,$D3680D36,$80D3680D,$00000000
	DC.L  $3FFC0000,$C3FD0329,$06488481,$00000000
	DC.L  $3FFE0000,$D0B69FCB,$D2580D0B,$00000000
	DC.L  $3FFC0000,$D11DE0FF,$15AB18CA,$00000000
	DC.L  $3FFE0000,$CE168A77,$25080CE1,$00000000
	DC.L  $3FFC0000,$DE1433A1,$6C66B150,$00000000
	DC.L  $3FFE0000,$CB8727C0,$65C393E0,$00000000
	DC.L  $3FFC0000,$EAE10B5A,$7DDC8ADD,$00000000
	DC.L  $3FFE0000,$C907DA4E,$871146AD,$00000000
	DC.L  $3FFC0000,$F7856E5E,$E2C9B291,$00000000
	DC.L  $3FFE0000,$C6980C69,$80C6980C,$00000000
	DC.L  $3FFD0000,$82012CA5,$A68206D7,$00000000
	DC.L  $3FFE0000,$C4372F85,$5D824CA6,$00000000
	DC.L  $3FFD0000,$882C5FCD,$7256A8C5,$00000000
	DC.L  $3FFE0000,$C1E4BBD5,$95F6E947,$00000000
	DC.L  $3FFD0000,$8E44C60B,$4CCFD7DE,$00000000
	DC.L  $3FFE0000,$BFA02FE8,$0BFA02FF,$00000000
	DC.L  $3FFD0000,$944AD09E,$F4351AF6,$00000000
	DC.L  $3FFE0000,$BD691047,$07661AA3,$00000000
	DC.L  $3FFD0000,$9A3EECD4,$C3EAA6B2,$00000000
	DC.L  $3FFE0000,$BB3EE721,$A54D880C,$00000000
	DC.L  $3FFD0000,$A0218434,$353F1DE8,$00000000
	DC.L  $3FFE0000,$B92143FA,$36F5E02E,$00000000
	DC.L  $3FFD0000,$A5F2FCAB,$BBC506DA,$00000000
	DC.L  $3FFE0000,$B70FBB5A,$19BE3659,$00000000
	DC.L  $3FFD0000,$ABB3B8BA,$2AD362A5,$00000000
	DC.L  $3FFE0000,$B509E68A,$9B94821F,$00000000
	DC.L  $3FFD0000,$B1641795,$CE3CA97B,$00000000
	DC.L  $3FFE0000,$B30F6352,$8917C80B,$00000000
	DC.L  $3FFD0000,$B7047551,$5D0F1C61,$00000000
	DC.L  $3FFE0000,$B11FD3B8,$0B11FD3C,$00000000
	DC.L  $3FFD0000,$BC952AFE,$EA3D13E1,$00000000
	DC.L  $3FFE0000,$AF3ADDC6,$80AF3ADE,$00000000
	DC.L  $3FFD0000,$C2168ED0,$F458BA4A,$00000000
	DC.L  $3FFE0000,$AD602B58,$0AD602B6,$00000000
	DC.L  $3FFD0000,$C788F439,$B3163BF1,$00000000
	DC.L  $3FFE0000,$AB8F69E2,$8359CD11,$00000000
	DC.L  $3FFD0000,$CCECAC08,$BF04565D,$00000000
	DC.L  $3FFE0000,$A9C84A47,$A07F5638,$00000000
	DC.L  $3FFD0000,$D2420487,$2DD85160,$00000000
	DC.L  $3FFE0000,$A80A80A8,$0A80A80B,$00000000
	DC.L  $3FFD0000,$D7894992,$3BC3588A,$00000000
	DC.L  $3FFE0000,$A655C439,$2D7B73A8,$00000000
	DC.L  $3FFD0000,$DCC2C4B4,$9887DACC,$00000000
	DC.L  $3FFE0000,$A4A9CF1D,$96833751,$00000000
	DC.L  $3FFD0000,$E1EEBD3E,$6D6A6B9E,$00000000
	DC.L  $3FFE0000,$A3065E3F,$AE7CD0E0,$00000000
	DC.L  $3FFD0000,$E70D785C,$2F9F5BDC,$00000000
	DC.L  $3FFE0000,$A16B312E,$A8FC377D,$00000000
	DC.L  $3FFD0000,$EC1F392C,$5179F283,$00000000
	DC.L  $3FFE0000,$9FD809FD,$809FD80A,$00000000
	DC.L  $3FFD0000,$F12440D3,$E36130E6,$00000000
	DC.L  $3FFE0000,$9E4CAD23,$DD5F3A20,$00000000
	DC.L  $3FFD0000,$F61CCE92,$346600BB,$00000000
	DC.L  $3FFE0000,$9CC8E160,$C3FB19B9,$00000000
	DC.L  $3FFD0000,$FB091FD3,$8145630A,$00000000
	DC.L  $3FFE0000,$9B4C6F9E,$F03A3CAA,$00000000
	DC.L  $3FFD0000,$FFE97042,$BFA4C2AD,$00000000
	DC.L  $3FFE0000,$99D722DA,$BDE58F06,$00000000
	DC.L  $3FFE0000,$825EFCED,$49369330,$00000000
	DC.L  $3FFE0000,$9868C809,$868C8098,$00000000
	DC.L  $3FFE0000,$84C37A7A,$B9A905C9,$00000000
	DC.L  $3FFE0000,$97012E02,$5C04B809,$00000000
	DC.L  $3FFE0000,$87224C2E,$8E645FB7,$00000000
	DC.L  $3FFE0000,$95A02568,$095A0257,$00000000
	DC.L  $3FFE0000,$897B8CAC,$9F7DE298,$00000000
	DC.L  $3FFE0000,$94458094,$45809446,$00000000
	DC.L  $3FFE0000,$8BCF55DE,$C4CD05FE,$00000000
	DC.L  $3FFE0000,$92F11384,$0497889C,$00000000
	DC.L  $3FFE0000,$8E1DC0FB,$89E125E5,$00000000
	DC.L  $3FFE0000,$91A2B3C4,$D5E6F809,$00000000
	DC.L  $3FFE0000,$9066E68C,$955B6C9B,$00000000
	DC.L  $3FFE0000,$905A3863,$3E06C43B,$00000000
	DC.L  $3FFE0000,$92AADE74,$C7BE59E0,$00000000
	DC.L  $3FFE0000,$8F1779D9,$FDC3A219,$00000000
	DC.L  $3FFE0000,$94E9BFF6,$15845643,$00000000
	DC.L  $3FFE0000,$8DDA5202,$37694809,$00000000
	DC.L  $3FFE0000,$9723A1B7,$20134203,$00000000
	DC.L  $3FFE0000,$8CA29C04,$6514E023,$00000000
	DC.L  $3FFE0000,$995899C8,$90EB8990,$00000000
	DC.L  $3FFE0000,$8B70344A,$139BC75A,$00000000
	DC.L  $3FFE0000,$9B88BDAA,$3A3DAE2F,$00000000
	DC.L  $3FFE0000,$8A42F870,$5669DB46,$00000000
	DC.L  $3FFE0000,$9DB4224F,$FFE1157C,$00000000
	DC.L  $3FFE0000,$891AC73A,$E9819B50,$00000000
	DC.L  $3FFE0000,$9FDADC26,$8B7A12DA,$00000000
	DC.L  $3FFE0000,$87F78087,$F78087F8,$00000000
	DC.L  $3FFE0000,$A1FCFF17,$CE733BD4,$00000000
	DC.L  $3FFE0000,$86D90544,$7A34ACC6,$00000000
	DC.L  $3FFE0000,$A41A9E8F,$5446FB9F,$00000000
	DC.L  $3FFE0000,$85BF3761,$2CEE3C9B,$00000000
	DC.L  $3FFE0000,$A633CD7E,$6771CD8B,$00000000
	DC.L  $3FFE0000,$84A9F9C8,$084A9F9D,$00000000
	DC.L  $3FFE0000,$A8489E60,$0B435A5E,$00000000
	DC.L  $3FFE0000,$83993052,$3FBE3368,$00000000
	DC.L  $3FFE0000,$AA59233C,$CCA4BD49,$00000000
	DC.L  $3FFE0000,$828CBFBE,$B9A020A3,$00000000
	DC.L  $3FFE0000,$AC656DAE,$6BCC4985,$00000000
	DC.L  $3FFE0000,$81848DA8,$FAF0D277,$00000000
	DC.L  $3FFE0000,$AE6D8EE3,$60BB2468,$00000000
	DC.L  $3FFE0000,$80808080,$80808081,$00000000
	DC.L  $3FFE0000,$B07197A2,$3C46C654,$00000000

ADJK	equ	L_SCR1

X	equ	FP_SCR1
XDCARE	equ	X+2
XFRAC	equ	X+4

F	equ	FP_SCR2
FFRAC	equ	F+4

KLOG2	equ	FP_SCR3

SAVEU	equ	FP_SCR4

	xref	t_frcinx
	xref	t_extdnrm
	xref	t_operr
	xref	t_dz

	xdef	slognd
slognd:
*--ENTRY POINT FOR LOG(X) FOR DENORMALIZED INPUT

	MOVE.L		#-100,ADJK(a6)	...INPUT = 2^(ADJK) * FP0

*----normalize the input value by left shifting k bits (k to be determined
*----below), adjusting exponent and storing -k to  ADJK
*----the value TWOTO100 is no longer needed.
*----Note that this code assumes the denormalized input is NON-ZERO.

     MoveM.L	D2-D7,-(A7)		...save some registers 
     Clr.L	D3			...D3 is exponent of smallest norm. #
     Move.L	4(A0),D4
     Move.L	8(A0),D5		...(D4,D5) is (Hi_X,Lo_X)
     Clr.L	D2			...D2 used for holding K

     Tst.L	D4
     BNE.B	HiX_not0

HiX_0:
     Move.L	D5,D4
     Clr.L	D5
     Move.L	#32,D2
     Clr.L	D6
     BFFFO      D4{0:32},D6
     LSL.L      D6,D4
     Add.L	D6,D2			...(D3,D4,D5) is normalized

     Move.L	D3,X(a6)
     Move.L	D4,XFRAC(a6)
     Move.L	D5,XFRAC+4(a6)
     Neg.L	D2
     Move.L	D2,ADJK(a6)
     FMove.X	X(a6),FP0
     MoveM.L	(A7)+,D2-D7		...restore registers
     LEA	X(a6),A0
     Bra.B	LOGBGN			...begin regular log(X)


HiX_not0:
     Clr.L	D6
     BFFFO	D4{0:32},D6		...find first 1
     Move.L	D6,D2			...get k
     LSL.L	D6,D4
     Move.L	D5,D7			...a copy of D5
     LSL.L	D6,D5
     Neg.L	D6
     AddI.L	#32,D6
     LSR.L	D6,D7
     Or.L	D7,D4			...(D3,D4,D5) normalized

     Move.L	D3,X(a6)
     Move.L	D4,XFRAC(a6)
     Move.L	D5,XFRAC+4(a6)
     Neg.L	D2
     Move.L	D2,ADJK(a6)
     FMove.X	X(a6),FP0
     MoveM.L	(A7)+,D2-D7		...restore registers
     LEA	X(a6),A0
     Bra.B	LOGBGN			...begin regular log(X)


	xdef	slogn
slogn:
*--ENTRY POINT FOR LOG(X) FOR X FINITE, NON-ZERO, NOT NAN'S

	FMOVE.X		(A0),FP0	...LOAD INPUT
	CLR.L		ADJK(a6)

LOGBGN:
*--FPCR SAVED AND CLEARED, INPUT IS 2^(ADJK)*FP0, FP0 CONTAINS
*--A FINITE, NON-ZERO, NORMALIZED NUMBER.

	move.l	(a0),d0
	move.w	4(a0),d0

	move.l	(a0),X(a6)
	move.l	4(a0),X+4(a6)
	move.l	8(a0),X+8(a6)

	TST.L	D0		...CHECK IF X IS NEGATIVE
	BLT.W	LOGNEG		...LOG OF NEGATIVE ARGUMENT IS INVALID
	CMP2.L	BOUNDS1,D0	...X IS POSITIVE, CHECK IF X IS NEAR 1
	BCC.W	LOGNEAR1	...BOUNDS IS ROUGHLY [15/16, 17/16]

LOGMAIN:
*--THIS SHOULD BE THE USUAL CASE, X NOT VERY CLOSE TO 1

*--X = 2^(K) * Y, 1 <= Y < 2. THUS, Y = 1.XXXXXXXX....XX IN BINARY.
*--WE DEFINE F = 1.XXXXXX1, I.E. FIRST 7 BITS OF Y AND ATTACH A 1.
*--THE IDEA IS THAT LOG(X) = K*LOG2 + LOG(Y)
*--			 = K*LOG2 + LOG(F) + LOG(1 + (Y-F)/F).
*--NOTE THAT U = (Y-F)/F IS VERY SMALL AND THUS APPROXIMATING
*--LOG(1+U) CAN BE VERY EFFICIENT.
*--ALSO NOTE THAT THE VALUE 1/F IS STORED IN A TABLE SO THAT NO
*--DIVISION IS NEEDED TO CALCULATE (Y-F)/F. 

*--GET K, Y, F, AND ADDRESS OF 1/F.
	ASR.L	#8,D0
	ASR.L	#8,D0		...SHIFTED 16 BITS, BIASED EXPO. OF X
	SUBI.L	#$3FFF,D0 	...THIS IS K
	ADD.L	ADJK(a6),D0	...ADJUST K, ORIGINAL INPUT MAY BE  DENORM.
	LEA	LOGTBL,A0 	...BASE ADDRESS OF 1/F AND LOG(F)
	FMOVE.L	D0,FP1		...CONVERT K TO FLOATING-POINT FORMAT

*--WHILE THE CONVERSION IS GOING ON, WE GET F AND ADDRESS OF 1/F
	MOVE.L	#$3FFF0000,X(a6)	...X IS NOW Y, I.E. 2^(-K)*X
	MOVE.L	XFRAC(a6),FFRAC(a6)
	ANDI.L	#$FE000000,FFRAC(a6) ...FIRST 7 BITS OF Y
	ORI.L	#$01000000,FFRAC(a6) ...GET F: ATTACH A 1 AT THE EIGHTH BIT
	MOVE.L	FFRAC(a6),D0	...READY TO GET ADDRESS OF 1/F
	ANDI.L	#$7E000000,D0	
	ASR.L	#8,D0
	ASR.L	#8,D0
	ASR.L	#4,D0		...SHIFTED 20, D0 IS THE DISPLACEMENT
	ADDA.L	D0,A0		...A0 IS THE ADDRESS FOR 1/F

	FMOVE.X	X(a6),FP0
	move.l	#$3fff0000,F(a6)
	clr.l	F+8(a6)
	FSUB.X	F(a6),FP0		...Y-F
	FMOVEm.X FP2/fp3,-(sp)	...SAVE FP2 WHILE FP0 IS NOT READY
*--SUMMARY: FP0 IS Y-F, A0 IS ADDRESS OF 1/F, FP1 IS K
*--REGISTERS SAVED: FPCR, FP1, FP2

LP1CONT1:
*--AN RE-ENTRY POINT FOR LOGNP1
	FMUL.X	(A0),FP0	...FP0 IS U = (Y-F)/F
	FMUL.X	LOGOF2,FP1	...GET K*LOG2 WHILE FP0 IS NOT READY
	FMOVE.X	FP0,FP2
	FMUL.X	FP2,FP2		...FP2 IS V=U*U
	FMOVE.X	FP1,KLOG2(a6)	...PUT K*LOG2 IN MEMEORY, FREE FP1

*--LOG(1+U) IS APPROXIMATED BY
*--U + V*(A1+U*(A2+U*(A3+U*(A4+U*(A5+U*A6))))) WHICH IS
*--[U + V*(A1+V*(A3+V*A5))]  +  [U*V*(A2+V*(A4+V*A6))]

	FMOVE.X	FP2,FP3
	FMOVE.X	FP2,FP1	

	FMUL.D	LOGA6,FP1	...V*A6
	FMUL.D	LOGA5,FP2	...V*A5

	FADD.D	LOGA4,FP1	...A4+V*A6
	FADD.D	LOGA3,FP2	...A3+V*A5

	FMUL.X	FP3,FP1		...V*(A4+V*A6)
	FMUL.X	FP3,FP2		...V*(A3+V*A5)

	FADD.D	LOGA2,FP1	...A2+V*(A4+V*A6)
	FADD.D	LOGA1,FP2	...A1+V*(A3+V*A5)

	FMUL.X	FP3,FP1		...V*(A2+V*(A4+V*A6))
	ADDA.L	#16,A0		...ADDRESS OF LOG(F)
	FMUL.X	FP3,FP2		...V*(A1+V*(A3+V*A5)), FP3 RELEASED

	FMUL.X	FP0,FP1		...U*V*(A2+V*(A4+V*A6))
	FADD.X	FP2,FP0		...U+V*(A1+V*(A3+V*A5)), FP2 RELEASED

	FADD.X	(A0),FP1	...LOG(F)+U*V*(A2+V*(A4+V*A6))
	FMOVEm.X  (sp)+,FP2/fp3	...RESTORE FP2
	FADD.X	FP1,FP0		...FP0 IS LOG(F) + LOG(1+U)

	fmove.l	d1,fpcr
	FADD.X	KLOG2(a6),FP0	...FINAL ADD
	bra	t_frcinx


LOGNEAR1:
*--REGISTERS SAVED: FPCR, FP1. FP0 CONTAINS THE INPUT.
	FMOVE.X	FP0,FP1
	FSUB.S	one,FP1		...FP1 IS X-1
	FADD.S	one,FP0		...FP0 IS X+1
	FADD.X	FP1,FP1		...FP1 IS 2(X-1)
*--LOG(X) = LOG(1+U/2)-LOG(1-U/2) WHICH IS AN ODD POLYNOMIAL
*--IN U, U = 2(X-1)/(X+1) = FP1/FP0

LP1CONT2:
*--THIS IS AN RE-ENTRY POINT FOR LOGNP1
	FDIV.X	FP0,FP1		...FP1 IS U
	FMOVEm.X FP2/fp3,-(sp)	 ...SAVE FP2
*--REGISTERS SAVED ARE NOW FPCR,FP1,FP2,FP3
*--LET V=U*U, W=V*V, CALCULATE
*--U + U*V*(B1 + V*(B2 + V*(B3 + V*(B4 + V*B5)))) BY
*--U + U*V*(  [B1 + W*(B3 + W*B5)]  +  [V*(B2 + W*B4)]  )
	FMOVE.X	FP1,FP0
	FMUL.X	FP0,FP0	...FP0 IS V
	FMOVE.X	FP1,SAVEU(a6) ...STORE U IN MEMORY, FREE FP1
	FMOVE.X	FP0,FP1	
	FMUL.X	FP1,FP1	...FP1 IS W

	FMOVE.D	LOGB5,FP3
	FMOVE.D	LOGB4,FP2

	FMUL.X	FP1,FP3	...W*B5
	FMUL.X	FP1,FP2	...W*B4

	FADD.D	LOGB3,FP3 ...B3+W*B5
	FADD.D	LOGB2,FP2 ...B2+W*B4

	FMUL.X	FP3,FP1	...W*(B3+W*B5), FP3 RELEASED

	FMUL.X	FP0,FP2	...V*(B2+W*B4)

	FADD.D	LOGB1,FP1 ...B1+W*(B3+W*B5)
	FMUL.X	SAVEU(a6),FP0 ...FP0 IS U*V

	FADD.X	FP2,FP1	...B1+W*(B3+W*B5) + V*(B2+W*B4), FP2 RELEASED
	FMOVEm.X (sp)+,FP2/fp3 ...FP2 RESTORED

	FMUL.X	FP1,FP0	...U*V*( [B1+W*(B3+W*B5)] + [V*(B2+W*B4)] )

	fmove.l	d1,fpcr
	FADD.X	SAVEU(a6),FP0		
	bra	t_frcinx
	rts

LOGNEG:
*--REGISTERS SAVED FPCR. LOG(-VE) IS INVALID
	bra	t_operr

	xdef	slognp1d
slognp1d:
*--ENTRY POINT FOR LOG(1+Z) FOR DENORMALIZED INPUT
* Simply return the denorm

	bra	t_extdnrm

	xdef	slognp1
slognp1:
*--ENTRY POINT FOR LOG(1+X) FOR X FINITE, NON-ZERO, NOT NAN'S

	FMOVE.X	(A0),FP0	...LOAD INPUT
	fabs.x	fp0		;test magnitude
	fcmp.x	LTHOLD,fp0	;compare with min threshold
	fbgt.w	LP1REAL		;if greater, continue
	fmove.l	#0,fpsr		;clr N flag from compare
	fmove.l	d1,fpcr
	fmove.x	(a0),fp0	;return signed argument
	bra	t_frcinx

LP1REAL:
	FMOVE.X	(A0),FP0	...LOAD INPUT
	CLR.L	ADJK(a6)
	FMOVE.X	FP0,FP1	...FP1 IS INPUT Z
	FADD.S	one,FP0	...X := ROUND(1+Z)
	FMOVE.X	FP0,X(a6)
	MOVE.W	XFRAC(a6),XDCARE(a6)
	MOVE.L	X(a6),D0
	TST.L	D0
	BLE.W	LP1NEG0	...LOG OF ZERO OR -VE
	CMP2.L	BOUNDS2,D0
	BCS.W	LOGMAIN	...BOUNDS2 IS [1/2,3/2]
*--IF 1+Z > 3/2 OR 1+Z < 1/2, THEN X, WHICH IS ROUNDING 1+Z,
*--CONTAINS AT LEAST 63 BITS OF INFORMATION OF Z. IN THAT CASE,
*--SIMPLY INVOKE LOG(X) FOR LOG(1+Z).

LP1NEAR1:
*--NEXT SEE IF EXP(-1/16) < X < EXP(1/16)
	CMP2.L	BOUNDS1,D0
	BCS.B	LP1CARE

LP1ONE16:
*--EXP(-1/16) < X < EXP(1/16). LOG(1+Z) = LOG(1+U/2) - LOG(1-U/2)
*--WHERE U = 2Z/(2+Z) = 2Z/(1+X).
	FADD.X	FP1,FP1	...FP1 IS 2Z
	FADD.S	one,FP0	...FP0 IS 1+X
*--U = FP1/FP0
	BRA.W	LP1CONT2

LP1CARE:
*--HERE WE USE THE USUAL TABLE DRIVEN APPROACH. CARE HAS TO BE
*--TAKEN BECAUSE 1+Z CAN HAVE 67 BITS OF INFORMATION AND WE MUST
*--PRESERVE ALL THE INFORMATION. BECAUSE 1+Z IS IN [1/2,3/2],
*--THERE ARE ONLY TWO CASES.
*--CASE 1: 1+Z < 1, THEN K = -1 AND Y-F = (2-F) + 2Z
*--CASE 2: 1+Z > 1, THEN K = 0  AND Y-F = (1-F) + Z
*--ON RETURNING TO LP1CONT1, WE MUST HAVE K IN FP1, ADDRESS OF
*--(1/F) IN A0, Y-F IN FP0, AND FP2 SAVED.

	MOVE.L	XFRAC(a6),FFRAC(a6)
	ANDI.L	#$FE000000,FFRAC(a6)
	ORI.L	#$01000000,FFRAC(a6)	...F OBTAINED
	CMPI.L	#$3FFF8000,D0	...SEE IF 1+Z > 1
	BGE.B	KISZERO

KISNEG1:
	FMOVE.S	TWO,FP0
	move.l	#$3fff0000,F(a6)
	clr.l	F+8(a6)
	FSUB.X	F(a6),FP0	...2-F
	MOVE.L	FFRAC(a6),D0
	ANDI.L	#$7E000000,D0
	ASR.L	#8,D0
	ASR.L	#8,D0
	ASR.L	#4,D0		...D0 CONTAINS DISPLACEMENT FOR 1/F
	FADD.X	FP1,FP1		...GET 2Z
	FMOVEm.X FP2/fp3,-(sp)	...SAVE FP2 
	FADD.X	FP1,FP0		...FP0 IS Y-F = (2-F)+2Z
	LEA	LOGTBL,A0	...A0 IS ADDRESS OF 1/F
	ADDA.L	D0,A0
	FMOVE.S	negone,FP1	...FP1 IS K = -1
	BRA.W	LP1CONT1

KISZERO:
	FMOVE.S	one,FP0
	move.l	#$3fff0000,F(a6)
	clr.l	F+8(a6)
	FSUB.X	F(a6),FP0		...1-F
	MOVE.L	FFRAC(a6),D0
	ANDI.L	#$7E000000,D0
	ASR.L	#8,D0
	ASR.L	#8,D0
	ASR.L	#4,D0
	FADD.X	FP1,FP0		...FP0 IS Y-F
	FMOVEm.X FP2/fp3,-(sp)	...FP2 SAVED
	LEA	LOGTBL,A0
	ADDA.L	D0,A0	 	...A0 IS ADDRESS OF 1/F
	FMOVE.S	zero,FP1	...FP1 IS K = 0
	BRA.W	LP1CONT1

LP1NEG0:
*--FPCR SAVED. D0 IS X IN COMPACT FORM.
	TST.L	D0
	BLT.B	LP1NEG
LP1ZERO:
	FMOVE.S	negone,FP0

	fmove.l	d1,fpcr
	bra t_dz

LP1NEG:
	FMOVE.S	zero,FP0

	fmove.l	d1,fpcr
	bra	t_operr

	end
