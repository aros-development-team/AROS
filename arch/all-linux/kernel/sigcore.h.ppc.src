/*
    Copyright © 1995-2010, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Macros to handle unix signals, PPC version
    Lang: english
*/

#ifndef _SIGCORE_H
#define _SIGCORE_H

#ifdef __AROS_EXEC_LIBRARY__

struct pt_regs
{
    unsigned long gpr[32];
    unsigned long nip;
    unsigned long msr;
    unsigned long orig_gpr3;
    unsigned long ctr;
    unsigned long link;
    unsigned long xer;
    unsigned long ccr;
    unsigned long mq;
    unsigned long trap;
    unsigned long dar;
    unsigned long dsisr;
    unsigned long result;
};

#else

/*
 * We support 14 exceptions for PPC (see arch/all-unix/kernel/cpu_ppc.c).
 * Note that krnRunExceptionHandlers() does not check exception number,
 * so increase this if you use higher numbers.
 */
#define EXCEPTIONS_COUNT 14

/* We don't use any hacks any more. With modern kernel and libc it's okay */
#define SIGCORE_NEED_SA_SIGINFO 1

#include <ucontext.h>
#include <signal.h>

#ifndef _SIGNAL_H
#define _SIGNAL_H
#endif
#ifndef __KERNEL_STRICT_NAMES
#define __KERNEL_STRICT_NAMES
#endif
#include <bits/sigcontext.h>

/* regs_t is the type of the signals' context */
typedef @sighandler@ SignalHandler;
typedef struct ucontext regs_t;

/* name and type of the signal handler */
#define SIGHANDLER	linux_sighandler
#define SIGHANDLER_T	SignalHandler

#define GLOBAL_SIGNAL_INIT(sighandler) \
	static void sighandler ## _gate (int sig, siginfo_t *blub, struct ucontext *u) 	\
	{ 										\
	    sighandler(sig, u); 							\
	}

/* Macros to access the stack pointer and program counter,
   PC is the current address in the program code. */

#define SP(uc)	(uc->uc_mcontext.regs->gpr[1])
#define PC(uc)	(uc->uc_mcontext.regs->nip)

/* Macros to enable or disable all signals after the signal handler
   has returned and the normal execution commences.
   On PowerPC this is the same as on x86-64. */
#define SC_DISABLE(uc) uc->uc_sigmask = PD(KernelBase).sig_int_mask
#define SC_ENABLE(uc)  sigemptyset(&uc->uc_sigmask)

/* This stuff is not used on Linux/m68k, because the signal handler context
   doesn't contain enough registers. Some assembler is needed for the signal
   handler instead. */

#define SAVE_CPU(cc, uc)					\
{								\
    long i;							\
    for (i = 0; i < 32; i++)					\
	cc->regs.gpr[i] = uc->uc_mcontext.regs->gpr[i];		\
    cc->regs.nip 	= uc->uc_mcontext.regs->nip;		\
    cc->regs.msr	= uc->uc_mcontext.regs->msr;		\
    cc->regs.orig_gpr3	= uc->uc_mcontext.regs->orig_gpr3;	\
    cc->regs.ctr	= uc->uc_mcontext.regs->ctr;		\
    cc->regs.link	= uc->uc_mcontext.regs->link;		\
    cc->regs.xer	= uc->uc_mcontext.regs->xer;		\
    cc->regs.ccr	= uc->uc_mcontext.regs->ccr;		\
    cc->regs.trap	= uc->uc_mcontext.regs->trap;		\
    cc->regs.dar	= uc->uc_mcontext.regs->dar;		\
    cc->regs.dsisr	= uc->uc_mcontext.regs->dsisr;		\
    cc->regs.result	= uc->uc_mcontext.regs->result;		\
}

#define SAVE_FPU(cc, uc) \
{\
    long i;\
    for (i = 0; i < 32; i++)\
	cc->fpregs[i] = *(double*)&(uc->uc_mcontext.regs->gpr[PT_FPR0 + 2 * i]);\
}

#define RESTORE_CPU(cc, uc)			\
{						\
    long i;					\
    for (i = 0; i < 32; i++)			\
	uc->uc_mcontext.regs->gpr[i] = cc->regs.gpr[i];		\
    uc->uc_mcontext.regs->nip	= cc->regs.nip; 		\
    uc->uc_mcontext.regs->msr	= cc->regs.msr;			\
    uc->uc_mcontext.regs->orig_gpr3 = cc->regs.orig_gpr3;	\
    uc->uc_mcontext.regs->ctr	= cc->regs.ctr;			\
    uc->uc_mcontext.regs->link	= cc->regs.link;		\
    uc->uc_mcontext.regs->xer	= cc->regs.xer;			\
    uc->uc_mcontext.regs->ccr	= cc->regs.ccr;			\
    uc->uc_mcontext.regs->trap	= cc->regs.trap;		\
    uc->uc_mcontext.regs->dar	= cc->regs.dar;			\
    uc->uc_mcontext.regs->dsisr	= cc->regs.dsisr;		\
    uc->uc_mcontext.regs->result = cc->regs.result;		\
}

#define RESTORE_FPU(cc, uc)\
{\
    long i;\
    for (i = 0; i < 32; i++)\
	*(double*)&(uc->uc_mcontext.regs->gpr[PT_FPR0 + 2 * i]) = cc->fpregs[i];\
}

#define PREPARE_RETURN_ADDRESS(cc, addr)                      \
    do                                                        \
    {                                                         \
        cc->regs.link = (unsigned long) addr;\
    } while (0)

#define PREPARE_INITIAL_ARGS(sp, cc, args, numargs)\
{\
    long i;\
    for (i = 0; i < numargs; i++)\
	cc->regs.gpr[3+i] = args[i];\
}

/* Prepare the cpu context
   Sys V PPC ABI says r2 is reserved
   so we copy the current one and it
   will never be changed again */
#define PREPARE_INITIAL_CONTEXT(cc)               \
{                                                 \
    __asm__ __volatile__ (                        \
    "stw 2,%0 \n\t"                               \
    : "=m"(cc->regs.gpr[2])			  \
    :                                             \
    : "memory");                                  \
    {                                             \
        long i;                                   \
        for (i = 0; i < 32; i++)                  \
            cc->fpregs[i] = 0.0;		  \
    }                                             \
}

/* This macro is similar to PREPARE_INITIAL_FRAME() but also saves
   all general purpose registers. Use this macro when you want to
   leave the current tasks' context to save the registers. Note that
   the argument "sp" of the macro is just the name of the stack
   pointer. The macro will load it from the sigcontext "sc". You
   must store the value of "sp" after the macro and hand it to
   RESTOREREGS() below to restore this context. */

#define SAVEREGS(cc, uc)           \
    do                             \
    {                              \
        SAVE_CPU((cc), uc);        \
        SAVE_FPU((cc), uc);        \
    } while(0)

/* This macro does the opposite to SAVEREGS(). It restores all
   general purpose registers. After that, you can enter the new
   tasks' context. Both "sp" and "sc" must be initialized.
   The macro will save the new SP into the sigcontext "sc". */

#define RESTOREREGS(cc, uc)           \
    do                                \
    {                                 \
	RESTORE_FPU((cc), uc);        \
        RESTORE_CPU((cc), uc);        \
    } while(0)

/* This macro prints the current signals' context */

#define PRINT_SC(sc) \
	bug ("SC: SP=%08lx  PC=%08lx\n" \
	    , SP(sc), PC(sc) \
	)

#endif /* __AROS_EXEC_LIBRARY__ */

/* This structure is used to save/restore registers */

struct AROSCPUContext
{
    struct pt_regs            regs;
    double                    fpregs[32];
    int			      errno_backup;
    struct AROSCPUContext * sc;
};

#define GET_PC(ctx) ((APTR)ctx->regs.nip)
#define SET_PC(ctx, val) ctx->regs.nip = (IPTR)val

#define PREPARE_INITIAL_FRAME(cc, sp, pc)     \
    do                                        \
    {                                         \
        cc->regs.gpr[1] = (unsigned long) sp; \
        cc->regs.nip    = (unsigned long) pc; \
    } while (0)

#endif /* _SIGCORE_H */
