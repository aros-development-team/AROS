/*
    Copyright © 1995-2010, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Macros to handle unix signals, ARM version
    Lang: english
*/

#ifndef _SIGCORE_H
#define _SIGCORE_H

/*
 * WARNING! Initial version, highly untested!!!
 */

#include <exec/types.h>
#include <aros/arm/cpucontext.h>

#ifndef __AROS_EXEC_LIBRARY__

/*
 * This part is included only in host-specific code because it relies
 * on host includes! __AROS_EXEC_LIBRARY__ definition is used to indicate
 * host-independent code
 */

/* We don't use any hacks any more. With modern kernel and libc it's okay
   Schulz: NO, it's NOT in case of ARM! */
//#define SIGCORE_NEED_SA_SIGINFO 0

#include <ucontext.h>
#include <signal.h>

#ifndef _SIGNAL_H
#define _SIGNAL_H
#endif
#ifndef __KERNEL_STRICT_NAMES
#define __KERNEL_STRICT_NAMES
#endif
#include <bits/sigcontext.h>

/* regs_t is the type of the signals' context */
typedef @sighandler@ SignalHandler;

/* name and type of the signal handler */
#define SIGHANDLER	linux_sighandler
#define SIGHANDLER_T	SignalHandler

/* This blob is quite strange on ARM. The ucontext frame is not passed to any register, but rather created on stack.
   I will use gcc builtin here, to get that value... */
   
#define GLOBAL_SIGNAL_INIT(sighandler) \
	static void sighandler ## _gate (int sig) 					\
	{ 										\
	    struct ucontext *u = (struct ucontext *)(__builtin_frame_address(0)+4);     \
	    sighandler(sig, u); 							\
	}

#define SP(uc)	(uc->uc_mcontext.arm_sp)
#define PC(uc)	(uc->uc_mcontext.arm_pc)

/* Macros to enable or disable all signals after the signal handler
   has returned and the normal execution commences. */
//#define SC_DISABLE(uc) uc->uc_sigmask = PD(KernelBase).sig_int_mask
//#define SC_ENABLE(uc)  sigemptyset(&uc->uc_sigmask)
/* Macros to enable or disable all signals after the signal handler
   has returned and the normal execution commences.
   On PowerPC this is the same as on x86-64. */
#define SC_DISABLE(uc) uc->uc_sigmask = KernelBase->kb_PlatformData->sig_int_mask
#define SC_ENABLE(uc)  KernelIFace.SigEmptySet(&uc->uc_sigmask)


/* This macro is similar to PREPARE_INITIAL_FRAME() but also saves
   all general purpose registers. Use this macro when you want to
   leave the current tasks' context to save the registers. Note that
   the argument "sp" of the macro is just the name of the stack
   pointer. The macro will load it from the sigcontext "sc". You
   must store the value of "sp" after the macro and hand it to
   RESTOREREGS() below to restore this context. */

#define SAVEREGS(cc, uc)           						\
do {										\
    CopyMemQuick(&uc->uc_mcontext.arm_r0, (cc)->regs.r, sizeof(ULONG) * 17);	\
    int i = 0;									\
    while(i < 128) {								\
	if (uc->uc_regspace[i] == 0x56465001)					\
	{									\
	    CopyMemQuick(&uc->uc_regspace[i], (cc)->regs.fpuContext, uc->uc_regspace[i+1]);	\
	    break;								\
	} else i = i + uc->uc_regspace[i+1]/4;					\
    } 										\
} while(0);

/* This macro does the opposite to SAVEREGS(). It restores all
   general purpose registers. After that, you can enter the new
   tasks' context. Both "sp" and "sc" must be initialized.
   The macro will save the new SP into the sigcontext "sc". */

#define RESTOREREGS(cc, uc)							\
do {										\
    CopyMemQuick((cc)->regs.r, &uc->uc_mcontext.arm_r0, sizeof(ULONG) * 17);	\
    int i = 0;									\
    while(i < 128) {								\
	if (uc->uc_regspace[i] == 0x56465001)					\
	{									\
	    CopyMemQuick((cc)->regs.fpuContext, &uc->uc_regspace[i], uc->uc_regspace[i+1]);	\
	    break;								\
	} else i = i + uc->uc_regspace[i+1]/4;					\
    }										\
} while(0);

/* This macro prints the current signals' context */
#define PRINT_SC(sc) \
	bug ("SC: SP=%08lx  PC=%08lx\n" \
	    , SP(sc), PC(sc) \
	)

#endif /* __AROS_EXEC_LIBRARY__ */

/* We emulate 6 exceptions of ARM CPU (all but softint) */
#define EXCEPTIONS_COUNT 6

typedef struct ucontext regs_t;

/* This structure is used to save/restore registers */
struct AROSCPUContext
{
    struct ExceptionContext regs;		/* Public portion	       */
    int		            errno_backup;	/* Host-specific magic follows */
    struct AROSCPUContext * sc;
};

/* Macros to access the program counter */

#define GET_PC(ctx) ((APTR)ctx->regs.pc)
#define SET_PC(ctx, val) ctx->regs.pc = (IPTR)val

#endif /* _SIGCORE_H */
