/*
    Copyright © 1995-2010, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Macros to handle unix signals, ARM version
    Lang: english
*/

#ifndef _SIGCORE_H
#define _SIGCORE_H

/*
 * WARNING! Initial version, highly untested!!!
 */

#include <exec/types.h>
#include <aros/arm/cpucontext.h>

#ifndef __AROS_EXEC_LIBRARY__

/*
 * This part is included only in host-specific code because it relies
 * on host includes! __AROS_EXEC_LIBRARY__ definition is used to indicate
 * host-independent code
 */

/* We don't use any hacks any more. With modern kernel and libc it's okay */
#define SIGCORE_NEED_SA_SIGINFO 1

#include <ucontext.h>
#include <signal.h>

#ifndef _SIGNAL_H
#define _SIGNAL_H
#endif
#ifndef __KERNEL_STRICT_NAMES
#define __KERNEL_STRICT_NAMES
#endif
#include <bits/sigcontext.h>

/* regs_t is the type of the signals' context */
typedef @sighandler@ SignalHandler;

/* name and type of the signal handler */
#define SIGHANDLER	linux_sighandler
#define SIGHANDLER_T	SignalHandler

/* This blob is quite strange on ARM. The ucontext frame is not passed to any register, but rather created on stack.
   I will use gcc builtin here, to get that value... */
   
#define GLOBAL_SIGNAL_INIT(sighandler) \
        static void sighandler ## _gate (int sig, siginfo_t *blub, struct ucontext *u)  \
        {                                                                               \
            sighandler(sig, u);                                                         \
        }

#define SP(uc)	(uc->uc_mcontext.arm_sp)
#define PC(uc)	(uc->uc_mcontext.arm_pc)

/* Macros to enable or disable all signals after the signal handler
   has returned and the normal execution commences. */
#define SC_DISABLE(uc) uc->uc_sigmask = KernelBase->kb_PlatformData->sig_int_mask
#define SC_ENABLE(uc)  KernelIFace.SigEmptySet(&uc->uc_sigmask)

/*
 * This macro saves all registers. Use this macro when you want to
 * leave the current tasks' context. Note that fpuContext area can
 * be absent, this happens at least in trap handler.
 */
#define SAVEREGS(cc, uc)           							\
do {											\
    CopyMemQuick(&uc->uc_mcontext.arm_r0, (cc)->regs.r, sizeof(ULONG) * 17);		\
    if ((cc)->regs.fpuContext))								\
    {											\
	CopyMemQuick(&uc->uc_regspace[0], (cc)->regs.fpuContext, 128*sizeof(ULONG));	\
	(cc)->regs.Flags |= ECF_FPU;							\
    }											\
} while(0);

/*
 * This macro does the opposite to SAVEREGS(). It restores all
 * registers which are present in the context (depending on its flags).
 * After that, you can enter the new tasks' context.
 */
#define RESTOREREGS(cc, uc)								\
do {											\
    CopyMemQuick((cc)->regs.r, &uc->uc_mcontext.arm_r0, sizeof(ULONG) * 17);		\
    if ((cc)->regs.Flags & ECF_FPU)							\
	CopyMemQuick((cc)->regs.fpuContext, &uc->uc_regspace[0], 128*sizeof(ULONG));	\
} while(0);


/* This macro prints the current signals' context */
#define PRINT_SC(sc) \
	bug ("SC: SP=%08lx  PC=%08lx\n" \
	    , SP(sc), PC(sc) \
	)

#endif /* __AROS_EXEC_LIBRARY__ */

/* We emulate 6 exceptions of ARM CPU (all but softint) */
#define EXCEPTIONS_COUNT 6

typedef struct ucontext regs_t;

/* This structure is used to save/restore registers */
struct AROSCPUContext
{
    struct ExceptionContext regs;		/* Public portion	       */
    int		            errno_backup;	/* Host-specific magic follows */
    struct AROSCPUContext * sc;
};

/*
 * ARM FPU context under Linux is currently private.
 * So we set type to FPU_NONE (so that noone tries to mess with it).
 */
#define ARM_FPU_TYPE FPU_NONE
#define ARM_FPU_SIZE (128*sizeof(ULONG))

/* Macros to access the program counter */

#define GET_PC(ctx) ((APTR)ctx->regs.pc)
#define SET_PC(ctx, val) ctx->regs.pc = (IPTR)val

#endif /* _SIGCORE_H */
