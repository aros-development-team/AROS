This is grub.info, produced by makeinfo version 4.0 from grub.texi.

INFO-DIR-SECTION Kernel
START-INFO-DIR-ENTRY
* GRUB: (grub).                 The GRand Unified Bootloader
* grub-install: (grub)Invoking grub-install.    Install GRUB on your drive
* mbchk: (grub)Invoking mbchk.  Check for the format of a Multiboot kernel
END-INFO-DIR-ENTRY

   Copyright (C) 1996 Erich Boleyn Copyright (C) 1999, 2000 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: grub.info,  Node: Top,  Next: Overview,  Up: (dir)

GRUB
****

   This is the documentation of GNU GRUB, the GRand Unified Bootloader,
a flexible and powerful boot loader program for PCs.

   This edition documents version 0.5.96.1.

* Menu:

Part I: The Tutorial Manual

* Overview::                    What exactly GRUB is and how to use it
* Naming convention::           Names of your drives in GRUB
* Installation::                Installing GRUB on your drive
* Booting::                     How to boot different operating systems
* Configuration::               Writing your own configuration file
* Network::                     Downloading OS images from a network
* Serial terminal::             Using GRUB via a serial line
* Security::                    Improving the security

Part II: The User Reference Manual

* Introduction::                Capturing the spirit of GRUB
* GRUB images::                 GRUB images
* Filesystem::                  Filesystem syntax and semantics
* Interface::                   The menu and the command-line
* Commands::                    The list of available builtin commands
* Troubleshooting::             Error messages produced by GRUB
* Invoking the grub shell::     How to use the grub shell
* Invoking grub-install::       How to use the GRUB installer
* Invoking mbchk::              How to use the Multiboot checker

Part III: The Programmer Reference Manual

* Hacking::                     Implementation details
* Memory map::                  The memory map of various components
* Embedded data::               Embedded variables in GRUB
* Filesystem interface::        The generic interface for the fs code
* Bootstrap tricks::            The bootstrap mechanism used in GRUB
* I/O ports detection::         INT 13H tracking technique
* Memory detection::            How to detect all installed RAM
* Low-level disk I/O::          INT 13H disk I/O interrupts
* MBR::                         The structure of Master Boot Record
* Partition table::             The format of partition table

Appendices and Indices

* FAQ::                         Frequently asked questions
* Obtaining and Building GRUB:: How to obtain and build GRUB
* Reporting bugs::              Where you should send a bug report
* Index::


File: grub.info,  Node: Overview,  Next: Naming convention,  Prev: Top,  Up: Top

Overview
********

   Briefly, a "boot loader" is the first software program that runs when
a computer starts.  It is responsible for loading and transferring
control to an operating system "kernel" software (such as the Linux or
GNU Hurd kernel).  The kernel, in turn, initializes the rest of the
operating system (e.g. a GNU system).

   GNU GRUB is a very powerful boot loader, which can load a wide
variety of free operating systems, as well as proprietary operating
systems with chain-loading(1) (*note Overview-Footnote-1::). GRUB is
designed to address the complexity of booting a personal computer; both
the program and this manual are tightly bound to that computer platform,
although porting to other platforms may be addressed in the future.

   One of the important features in GRUB is flexibility; GRUB
understands filesystems and kernel executable formats, so you can load
an arbitrary operating system the way you like, without recording the
physical position of your kernel on the disk.

   Thus you can load the kernel just by specifying its filename and the
drive (and the partition) where the kernel resides. To let GRUB know the
drive and the filename, you can either type in them manually via the
command-line interface (*note Command line::), or use the nice menu
interface (*note Menu interface::) through which you can easily select
which OS it boots. To allow you to customize the menu, GRUB will load a
preexisting configuration file (*note Configuration::). Note that you
can not only enter the command-line interface whenever you like, but
also you can edit specific menu entries prior to using them.

   In the following chapters, you will learn how to specify a drive or a
partition, and a file name (*note Naming convention::) to GRUB, how to
install GRUB on your drive (*note Installation::), and how to boot your
OSes (*note Booting::), step by step.


File: grub.info,  Node: Overview-Footnotes,  Up: Overview

   (1) "chain-load" is the mechanism for loading unsupported operating
systems by loading another boot loader. It is typically used for
loading DOS or Windows.


File: grub.info,  Node: Naming convention,  Next: Installation,  Prev: Overview,  Up: Top

Naming convention
*****************

   The device syntax used in GRUB is a wee bit different from what you
may have seen before in your operating system(s), and you need to know
it so that you can specify a drive/partition.

   Look at the following examples and explanations:

     (fd0)

   First of all, GRUB requires that the device name is enclosed with
`(' and `)'. The `fd' part means that it is a floppy disk. The number
`0' is the drive number, which is counted from _zero_. This expression
means that GRUB will use the whole floppy disk.

     (hd0,1)

   Here, `hd' means it is a hard disk drive. The first integer `0'
indicates the drive number, that is, the first hard disk, while the
second integer, `1', indicates the partition number (or the PC slice
number in the BSD terminology). Once again, please note that the
partition numbers are counted from _zero_, not from one. This
expression means the second partition of the first hard disk drive. In
this case, GRUB uses one partition of the disk, instead of the whole
disk.

     (hd0,4)

   This specifies the first "extended partition" of the first hard disk
drive. Note that the partition numbers for extended partitions are
counted from `4', regardless of the actual number of primary partitions
on your hard disk.

     (hd1,a)

   This means the BSD `a' partition of the second hard disk. If you
need to specify which PC slice number should be used, use something
like this: `(hd1,0,a)'. If the PC slice number is omitted, GRUB
searches for the first PC slice which has a BSD `a' partition.

   Of course, to actually access the disks or partitions with GRUB, you
need to use the device specification in a command, like `root (fd0)' or
`unhide (hd0,2)'. To help you find out which number is a partition you
want, the GRUB command-line (*note Command line::) options have
argument completion. That means that, for example, you only need to
type `root (', followed by a <TAB>, and GRUB will display the list of
drives, partitions, or filenames, so it should be quite easy to
determine the name of your target partition, even with minimal knowledge
of the syntax.

   Note that GRUB does _not_ distinguish IDE from SCSI - it simply
counts the drive numbers from zero, regardless of their type. Normally,
any IDE drive number is less than any SCSI drive number, although that
is not true if you change the boot sequence by swapping IDE and SCSI
drives in your BIOS.

   Now the question is, how to specify a file? Again, see this example:

     (hd0,0)/vmlinuz

   This specifies the file named `vmlinuz', found on the first
partition of the first hard disk drive. Note that the argument
completion works with file names, too.

   That was easy, admit it. Do read the next chapter, to find out how to
actually install GRUB on your drive.


File: grub.info,  Node: Installation,  Next: Booting,  Prev: Naming convention,  Up: Top

Installation
************

   First, you need to have GRUB itself properly installed on your
system, (*note Obtaining and Building GRUB::) either from the source
tarball, or as a package for your OS.

   To use GRUB, you need to install it on your drive. There are two
ways of doing that - either using the utility `grub-install' (*note
Invoking grub-install::) on a UNIX-like OS, or by using the native
Stage 2. These are quite similar, however, the utility might probe a
wrong BIOS drive, so better be careful.

   Also, if you install GRUB on a UNIX-like OS, please make sure that
you have an emergency boot disk ready, so that you can rescue your
computer if, by any chance, your hard drive becomes unusable
(unbootable).

   GRUB comes with boot images, which are normally installed in the
`/usr/share/grub/i386-pc' directory. You need to copy the files
`stage1', `stage2', and `*stage1_5' to the directory `/boot/grub'.

* Menu:

* Creating a GRUB boot floppy::
* Installing GRUB natively::
* Installing GRUB using grub-install::


File: grub.info,  Node: Creating a GRUB boot floppy,  Next: Installing GRUB natively,  Up: Installation

Creating a GRUB boot floppy
===========================

   To create a GRUB boot floppy, you need to take the files `stage1'
and `stage2' from `/boot/grub' directory, and write them to the first
and the second block of the floppy disk, respectively.

     *Caution:* This procedure will destroy any data currently stored
     on the floppy.

   On a UNIX-like operating system, that is done with the following
commands:

     # cd /boot/grub
     # dd if=stage1 of=/dev/fd0 bs=512 count=1
     1+0 records in
     1+0 records out
     # dd if=stage2 of=/dev/fd0 bs=512 seek=1
     153+1 records in
     153+1 records out
     #

   The device filename may be different. Consult the manual for your OS.


File: grub.info,  Node: Installing GRUB natively,  Next: Installing GRUB using grub-install,  Prev: Creating a GRUB boot floppy,  Up: Installation

Installing GRUB natively
========================

     *Caution:* Installing GRUB's stage1 in this manner will erase the
     normal boot-sector used by an OS.

   GRUB can currently boot GNU Mach, Linux, FreeBSD, NetBSD, and OpenBSD
directly, so using it on a boot sector should be okay. But generally, it
would be a good idea to back up the first sector of the partition on
which you are installing GRUB's stage1. This isn't as important if you
are installing GRUB on the first sector of a hard disk, since it's easy
to reinitialize it (e.g. by running `FDISK /MBR' from DOS).

   If you decide to install GRUB in the native environment, which is
definitely desirable, you'll need to create the GRUB boot disk, and
reboot your computer with it. Otherwise, see *Note Installing GRUB
using grub-install::, for more details.

   Once started, GRUB will show the command-line interface (*note
Command line::). First, set the GRUB's "root device"(1) (*note
Installing GRUB natively-Footnote-1::) to the partition which has your
GRUB images, like this:

     grub> root (hd0,0)

   If you are not sure which partition actually holds these files, use
the `find' command, like this:

     grub> find /boot/grub/stage1

   This will search for the filename `/boot/grub/stage1' and show the
devices which contain the file.

   Once you've set the root device correctly, run the command `setup':

     grub> setup (hd0)

   This command will install GRUB on the MBR (*note MBR::) in the first
drive. If you want to install GRUB into the "boot sector" of a
partition instead of the MBR, specify a partition into which you want to
install GRUB:

     grub> setup (hd0,0)

   If you install GRUB into a partition or a drive other than the first
one, you must chain-load GRUB from another boot loader. Refer to the
manual for the boot loader to know how to chain-load GRUB.

   Now you can boot GRUB without a GRUB floppy. See the chapter *Note
Booting:: to find out how to boot your operating systems from GRUB.


File: grub.info,  Node: Installing GRUB natively-Footnotes,  Up: Installing GRUB natively

   (1) Note that GRUB's root device doesn't necessarily mean your OS's
root partition; if you need to specify a root partition for your OS,
add the argument into the command `kernel'.


File: grub.info,  Node: Installing GRUB using grub-install,  Prev: Installing GRUB natively,  Up: Installation

Installing GRUB using grub-install
==================================

   Unfortunately, if you do want to install GRUB under a UNIX-like OS
(such as GNU), invoke the program `grub-install' as the superuser
("root").

   The usage is basically very easy. You only need to specify one
argument to the program, namely, where to install GRUB. The argument
can be either of a device file or a GRUB's drive/partition. So, this
will install GRUB into the MBR of the first IDE disk under Linux:

     # grub-install /dev/hda

   Likewise, under Hurd, this has the same effect:

     # grub-install /dev/hd0

   If it is the first BIOS drive, this is the same as well:

     # grub-install '(hd0)'

   But all the above examples assume that you use GRUB images under the
root directory. If you want GRUB to use images under a directory other
than the root directory, you need to specify the option
`--root-directory'. The typical usage is that you create a GRUB boot
floppy with a filesystem. Here is an example:

     # mke2fs /dev/fd0
     # mount -t ext2 /dev/fd0 /mnt
     # grub-install --root-directory=/mnt '(fd0)'
     # umount /mnt

   Another example is in case that you have a separate boot partition
which is mounted at `/boot'. Since GRUB is a boot loader, it doesn't
know anything about mountpoints at all. Thus, you need to run
`grub-install' like this:

     # grub-install --root-directory=/boot /dev/hda

   By the way, as you may already know, it is quite difficult to guess
BIOS drives correctly under a UNIX-like OS. Thus, `grub-install' will
prompt you to check if it could really guess the correct mappings, after
the installation. The format is defined in *Note Device map::. Please be
careful enough. If the output is wrong, it is unlikely that your
computer can boot with no problem.

   Note that `grub-install' is actually just a shell script and the
real task is done by the grub shell `grub' (*note Invoking the grub
shell::). Therefore, you may run `grub' directly to install GRUB,
without using `grub-install'. Don't do that, however, unless you are
very familiar with the internals of GRUB. Installing a boot loader on a
running OS may be dangerous.


File: grub.info,  Node: Booting,  Next: Configuration,  Prev: Installation,  Up: Top

Booting
*******

   For Multiboot-compliant kernels, GRUB can load them in a consistent
way, but, for some free operating systems, you need to use some
OS-specific magic.

* Menu:

* General boot methods::
* OS-specific notes::


File: grub.info,  Node: General boot methods,  Next: OS-specific notes,  Up: Booting

How to boot operating systems
=============================

   GRUB has two distinct boot methods. One of the two is to load an
operating system directly, and the other is to chain-load another boot
loader which then will load an operating system actually. Generally
speaking, the former is desirable, because you don't need to install or
maintain other boot loaders and GRUB is flexible enough to load an
operating system from an arbitrary disk/partition. However, the latter
is sometimes required, since GRUB doesn't support all the existing
operating systems natively.

* Menu:

* Loading an operating system directly::
* Chain-loading::


File: grub.info,  Node: Loading an operating system directly,  Next: Chain-loading,  Up: General boot methods

How to boot an OS directly by GRUB
----------------------------------

   Multiboot (*note Multiboot Specification: (multiboot)Top.) is the
native format supported by GRUB.  For the sake of convenience, there
are also support for Linux, FreeBSD, NetBSD and OpenBSD. If you want to
boot other operating systems, you will have to chain-load them (*note
Chain-loading::).

   Generally, GRUB can boot any Multiboot-compliant OS in the following
steps:

  1. Set GRUB's root device to the drive where the OS images are stored
     by the command `root'.

  2. Load the kernel image by the command `kernel'.

  3. If you need modules, load them with the command `module' or
     `modulenounzip'.

  4. Run the command `boot'.

   Linux, FreeBSD, NetBSD and OpenBSD can be booted in a similar
manner. You can load a kernel image by the command `kernel' and then
run the command `boot'. If the kernel requires some parameters, just
append the parameters to `kernel', after the filename of the kernel.
Also, please refer to *Note OS-specific notes::, for the information on
your OS-specific issues.


File: grub.info,  Node: Chain-loading,  Prev: Loading an operating system directly,  Up: General boot methods

Load another boot loader to boot unsupported operating systems
--------------------------------------------------------------

   If you want to boot an unsupported operating system (e.g. Windows
95), chain-load a boot loader for the operating system. Normally, the
boot loader is embedded in the "boot sector" of the partition on which
the operating system is installed.

   First, set GRUB's root device to the partition by the command
`rootnoverify':

     grub> rootnoverify (hd0,0)

   Second, set the "active" flag in the partition by the command
`makeactive'(1) (*note Chain-loading-Footnote-1::):

     grub> makeactive

   Third, load the boot loader by the command `chainloader':

     grub> chainloader +1

   `+1' indicates that GRUB should read one sector from the start of
the partition. The complete description about this syntax can be found
in *Note Filesystem::. If this succeeds, run the command `boot'.

   However, DOS and Windows have a deficiency, so you might have to use
more complicated instructions. *Note OS-specific notes::, for more
information.


File: grub.info,  Node: Chain-loading-Footnotes,  Up: Chain-loading

   (1) This is not necessary for most of the modern operating systems.


File: grub.info,  Node: OS-specific notes,  Prev: General boot methods,  Up: Booting

Some caveats on OS-specific issues
==================================

   Here, we describe some caveats on several operating systems.

* Menu:

* GNU/Hurd::
* GNU/Linux::
* FreeBSD::
* NetBSD::
* OpenBSD::
* DOS/Windows::
* SCO UnixWare::


File: grub.info,  Node: GNU/Hurd,  Next: GNU/Linux,  Up: OS-specific notes

GNU/Hurd
--------

   Since GNU/Hurd is Multiboot-compliant, it is easy to boot it; there
is nothing special about it. But do not forget that you have to specify
a root partition to the kernel.

  1. Set GRUB's root device to the same drive as GNU/Hurd's. Probably
     the command `find /boot/gnumach' or similar can help you.

  2. Load the kernel and the module, like this:

          grub> kernel /boot/gnumach root=hd0s1
          grub> module /boot/serverboot

  3. Run the command `boot'.


File: grub.info,  Node: GNU/Linux,  Next: FreeBSD,  Prev: GNU/Hurd,  Up: OS-specific notes

GNU/Linux
---------

   It is relatively easy to boot GNU/Linux from GRUB, because it
somewhat resembles to boot a Multiboot-compliant OS.

  1. Set GRUB's root device to the same drive as GNU/Linux's. Probably
     the command `find /vmlinuz' or similar can help you.

  2. Load the kernel:

          grub> kernel /vmlinuz root=/dev/hda1

     If you need to specify some kernel parameters, just append them to
     the command. For example, to set `vga' to `ext', do this:

          grub> kernel /vmlinuz root=/dev/hda1 vga=ext

     See the documentation in the Linux source tree for the complete
     information on the available options.

  3. If you use an initrd, execute the command `initrd' after `kernel':

          grub> initrd /initrd

  4. Finally, run the command `boot'.

   *Caution:* If you use an initrd and specify the `mem=' option to the
kernel, to let it use less than actual memory size, you will also have
to specify the same memory size to GRUB. To let GRUB know the size, run
the command `uppermem' _before_ loading the kernel. *Note Command-line
and menu entry commands::, for more information.


File: grub.info,  Node: FreeBSD,  Next: NetBSD,  Prev: GNU/Linux,  Up: OS-specific notes

FreeBSD
-------

   GRUB can load the kernel directly, either in ELF or a.out format. But
this is not recommended, since FreeBSD's bootstrap interface sometimes
changes heavily, so GRUB can't guarantee to pass kernel parameters
correctly.

   Thus, we'd recommend loading the very flexible loader `/boot/loader'
instead. See this example:

     grub> root (hd0,a)
     grub> kernel /boot/loader
     grub> boot


File: grub.info,  Node: NetBSD,  Next: OpenBSD,  Prev: FreeBSD,  Up: OS-specific notes

NetBSD
------

   GRUB can load NetBSD a.out and ELF directly, follow these steps:

  1. Set GRUB's root device with `root'.

  2. Load the kernel with `kernel'. You should append the ugly option
     `--type=netbsd', if you want to load an ELF kernel, like this:

          grub> kernel --type=netbsd /netbsd-elf

  3. Run `boot'.

   For now, however, GRUB doesn't allow you to pass kernel parameters,
so it may be better to chain-load it instead, for more information
please see *Note Chain-loading::.


File: grub.info,  Node: OpenBSD,  Next: DOS/Windows,  Prev: NetBSD,  Up: OS-specific notes

OpenBSD
-------

   The booting instruction is exactly the same as for NetBSD (*note
NetBSD::).


File: grub.info,  Node: DOS/Windows,  Next: SCO UnixWare,  Prev: OpenBSD,  Up: OS-specific notes

DOS/Windows
-----------

   GRUB cannot boot DOS or Windows directly, so you must chain-load them
(*note Chain-loading::). However, their boot loaders have some critical
deficiencies, so it may not work to just chain-load them. To overcome
the problems, GRUB provides you with two helper functions.

   If you have installed DOS (or Windows) on a non-first hard disk, you
have to use the disk swapping technique, because that OS cannot boot
from any disks but the first one. The workaround used in GRUB is the
command `map' (*note Commands::), like this:

     grub> map (hd0) (hd1)
     grub> map (hd1) (hd0)

   This performs a "virtual" swap between your first and second hard
drive.

   *Caution:* This is effective only if DOS (or Windows) uses BIOS to
access the swapped disks. If that OS uses a special driver for the
disks, this probably won't work.

   Another problem arises if you installed more than one set of
DOS/Windows onto one disk, because they could be confused if there are
more than one primary partitions for DOS/Windows. Certainly you should
avoid doing this, but there is a solution if you do want to do so. Use
the partition hiding/unhiding technique.

   If GRUB "hide"s a DOS (or Windows) partition, it ignores the
partition. If GRUB "unhide"s a DOS (or Windows) partition, it detects
the partition. Thus, if you have installed DOS (or Windows) on the
first partition and the second of the first hard disk, and boot the
first copy, do the following:

     grub> unhide (hd0,0)
     grub> hide (hd0,1)
     grub> rootnoverify (hd0,0)
     grub> chainloader +1
     grub> makeactive
     grub> boot


File: grub.info,  Node: SCO UnixWare,  Prev: DOS/Windows,  Up: OS-specific notes

SCO UnixWare
------------

   It is known that the signature in the boot loader for SCO UnixWare is
wrong, so you will have to specify the option `--force' to
`chainloader', like this:

     grub> rootnoverify (hd1,0)
     grub> chainloader --force +1
     grub> makeactive
     grub> boot


File: grub.info,  Node: Configuration,  Next: Network,  Prev: Booting,  Up: Top

Configuration
*************

   You probably noticed that you need to type several commands to boot
your OS. There's a solution to that - GRUB provides a menu interface
(*note Menu interface::) from which you can select an item (using arrow
keys) that will do everything to boot an OS.

   To enable the menu, you need a configuration file,
`/boot/grub/menu.lst'. We'll analyze an example file.

   The file first contains some general settings, the menu interface
related options. You can put these commands (*note Menu-specific
commands::) before any of the items (starting with `title').

     #
     # Sample boot menu configuration file
     #

   As you may have guessed, these lines are comments. Lines starting
with a hash character (`#'), and blank lines, are ignored by GRUB.

     # By default, boot the first entry.
     default 0

   The first entry (here, counting starts with number zero, not one!)
will be the default choice.

     # Boot automatically after 30 secs.
     timeout 30

   As the comment says, GRUB will boot automatically in 30 seconds,
unless interrupted with a keypress.

     # Fallback to the second entry.
     fallback 1

   If, for any reason, the default entry doesn't work, fall back to the
second one (this is rarely used, for obvious reasons).

   Note that the complete descriptions of these commands, which are menu
interface specific, can be found in *note Menu-specific commands::.
Other descriptions can be found in *Note Commands::.

   Now, on to the actual OS definitions. You will see that each entry
begins with a special command, `title', and the action is described
after it. Note that there is no command `boot' at the end of each item.
That is because GRUB automatically executes `boot' if it loads other
commands successfully.

   The argument for the command `title' is used to display a short
title/description of the entry in the menu. Since `title' displays the
argument as is, you can write basically anything in there.

     # For booting the GNU Hurd
     title  GNU/Hurd
     root   (hd0,0)
     kernel /boot/gnumach.gz root=hd0s1
     module /boot/serverboot.gz

   This boots GNU/Hurd from the first hard disk.

     # For booting Linux
     title  GNU/Linux
     kernel (hd1,0)/vmlinuz root=/dev/hdb1

   This boots GNU/Linux, but from the second hard disk.

     # For booting Mach (getting kernel from floppy)
     title  Utah Mach4 multiboot
     root   (hd0,2)
     pause  Insert the diskette now^G!!
     kernel (fd0)/boot/kernel root=hd0s3
     module (fd0)/boot/bootstrap

   This boots Mach with a kernel on a floppy, but the root filesystem at
hd0s3. It also contains a `pause' line, which will cause GRUB to
display a prompt and delay, before actually executing the rest of the
commands and booting.

     # For booting FreeBSD
     title  FreeBSD
     root   (hd0,2,a)
     kernel /boot/loader

   This item will boot FreeBSD kernel loaded from the `a' partition of
the third PC slice of the first hard disk.

     # For booting OS/2
     title OS/2
     root  (hd0,1)
     makeactive
     # chainload OS/2 bootloader from the first sector
     chainloader +1
     # This is similar to "chainload", but loads a specific file
     #chainloader /boot/chain.os2

   This will boot OS/2, using a chain-loader.

     # For booting Windows NT or Windows95
     title Windows NT / Windows 95 boot menu
     root        (hd0,0)
     makeactive
     chainloader +1
     # For loading DOS if Windows NT is installed
     # chainload /bootsect.dos

   The same as the above, but for Windows.

     # For installing GRUB into the hard disk
     title Install GRUB into the hard disk
     root    (hd0,0)
     setup   (hd0)

   This will just (re)install GRUB onto the hard disk.

     # Change the colors.
     title Change the colors
     color light-green/brown blink-red/blue

   In the last entry, the command `color' is used, to change the menu
colors (try it!). This command is somewhat special, because it can be
used both in the command-line and in the menu (*note Command-line and
menu commands::). GRUB has several such commands, see the user
reference.

   We hope that you now understand how to use the basic features of
GRUB. To learn more about GRUB, see the following chapters and the User
Reference Manual (*note Introduction::).


File: grub.info,  Node: Network,  Next: Serial terminal,  Prev: Configuration,  Up: Top

Downloading OS images from a network
************************************

   Although GRUB is a disk-based boot loader, it does provide some
network support. To use the network support, you need to enable at
least one network driver in the GRUB build process. For more
information please see `netboot/README.netboot' in the source
distribution.

* Menu:

* General usage of network support::
* Diskless::


File: grub.info,  Node: General usage of network support,  Next: Diskless,  Up: Network

How to set up your network
==========================

   GRUB requires a server that will assign an IP address to the machine
on which GRUB is running, and a file server. The former is either BOOTP,
DHCP or a RARP server (RARP is deprecated, since it cannot serve much
information). For the latter, only TFTP is supported at the moment. It
is not necessary to run both the servers on one computer. How to
configure these servers is beyond the scope of this document, so please
refer to the manuals specific to those protocols/servers.

   Once you have set up the servers, run `bootp', `dhcp' or `rarp' for
BOOTP, DHCP or RARP, respectively. Each command will show an assigned
IP address, a netmask, an IP address for your TFTP server and a
gateway. If any of the addresses is wrong or it causes an error,
probably the configuration of your servers isn't set up properly.

   Finally, download your OS images from your network. The network can
be accessed using the network drive `(nd)'. Everything else is very
similar to the normal instructions (*note Booting::).

   Here is an example:

     grub> bootp
     Probing... [NE*000]
     NE2000 base ...
     Address: 192.168.110.23    Netmask: 255.255.255.0
     Server: 192.168.110.14     Gateway: 192.168.110.1
     
     grub> root (nd)
     grub> kernel /tftproot/gnumach.gz root=sd0s1
     grub> module /tftproot/serverboot.gz
     grub> boot


File: grub.info,  Node: Diskless,  Prev: General usage of network support,  Up: Network

Booting from a network
======================

   It is sometimes very useful to boot from a network, especially, when
you use a machine which has no local disk. In this case, you need to
obtain a kind of Net Boot ROM, such as a PXE ROM or a free software
package like Etherboot. Such a Boot ROM first boots the machine, sets
up the network card installed into the machine, and downloads a second
stage boot image from the network. Then, the second image will try to
boot an operating system from the network actually.

   GRUB provides two second stage images, `nbgrub' and `pxegrub'. Those
images are the same as the normal Stage 2, except that they set up a
network automatically, and try to load a configuration file from the
network, if specified. The usage is very simple: If the machine has a
PXE ROM, use `pxegrub'. If the machine has a NBI loader such as
Etherboot, use `nbgrub'. There is no difference between them but their
formats. As how to load a second stage image you want to use should be
described in the manual on your Net Boot ROM, please refer to the
manual, for more details. The topic is beyond the scope of this
documentation.

   However, there is one thing specific to GRUB. Namely, how to specify
a configuration file in a BOOTP/DHCP server. For now, GRUB uses the tag
`150', to get the name of a configuration file. This below is an
example about a BOOTP configuration:

     .allhost:hd=/tmp:bf=null:\
             :ds=145.71.35.1 145.71.32.1:\
             :sm=255.255.254.0:\
             :gw=145.71.35.1:\
             :sa=145.71.35.5:
     
     foo:ht=1:ha=63655d0334a7:ip=145.71.35.127:\
             :bf=/nbgrub:\
             :tc=.allhost:\
             :T150="/tftpboot/menu.lst.foo":

   See the manual about your BOOTP/DHCP server, for more information.
The exact syntax should differ from the example, more or less.


File: grub.info,  Node: Serial terminal,  Next: Security,  Prev: Network,  Up: Top

Using GRUB via a serial line
****************************

   This chapter describes how to use the serial terminal support in
GRUB.

   If you have many computers or computers with no display/keyboard, it
would be very useful to control the computers with serial
communications. To connect a computer with another via a serial line,
you need to prepare a null-modem (cross) serial cable, and you may need
to have multiport serial boards, if your computer doesn't have extra
serial ports. In addition, a terminal emulator is also required, such as
minicom. Refer to a manual of your operating system, for more
information.

   As for GRUB, the instruction to set up a serial terminal is quite
simple. First of all, make sure that you haven't specified the option
`--disable-serial' to the configure script when you built your GRUB
images. If you get them in binary form, probably they have serial
terminal support already.

   Then, initialize your serial terminal after GRUB starts up. Here is
an example:

     grub> serial --unit=0 --speed=9600
     grub> terminal serial

   The command `serial' initializes the serial unit 0 with the speed
9600bps. The serial unit 0 is usually called `COM1', so, if you want to
use COM2, you must specify `--unit=1' instead. This command accepts
many other options, so please refer to *Note Commands::, for more
details.

   The command `terminal' chooses which type of terminal you want to
use. In that case above, the terminal will be a serial terminal, but
you can also pass `console' to the command, like `terminal serial
console'. In this case, a terminal in which you press any key will be
selected as a GRUB terminal.

   However, note that GRUB assumes that your terminal emulator is
compatible with VT100 by default. This is true for most terminal
emulators nowadays, but you should pass the option `--dumb' to the
command, if your terminal emulator is not VT100-compatible or
implements few VT100 escape sequences. If you specify the option, then
GRUB doesn't provide you with the menu interface, because the menu
requires several fancy features for your terminal. Instead, GRUB only
gives you the hidden menu interface and the command-line interface.


File: grub.info,  Node: Security,  Next: Introduction,  Prev: Serial terminal,  Up: Top

Security
********

   You may be interested in how to prevent ordinary users from doing
whatever they like, if you share your computer with other people. So
this chapter describes how to improve the security of GRUB.

   One thing which could be a security hole is that the user can do too
many things with GRUB, because GRUB allows to modify its configuration
and run arbitrary commands at run-time. For example, the user can read
even `/etc/passwd' in the command-line interface by the command `cat'.
So it is necessary to disable all the interactive operations.

   Thus, GRUB provides "password" feature, so that only administrators
can start the interactive operations (i.e. editing menu entries and
entering the command-line interface). To use this feature, you need to
run the command `password' in your configuration file, like this:

     password PASSWORD

   If this is specified, GRUB disallows any interactive control, until
you press the key <p> and enter `PASSWORD'.

   Also, you can specify an optional argument to `password'. See this
example:

     password PASSWORD /boot/grub/menu-admin.lst

   In this case, GRUB will load `/boot/grub/menu-admin.lst' as the
configuration file when you enter the valid password.

   Another thing which may be dangerous is that any user can choose any
menu entry. Usually, this wouldn't be problematic, but you might want to
permit only administrators to run some of your menu entries, such as an
entry for booting an insecure OS like DOS.

   The solution used by GRUB is the command `lock'. This command always
fails until you enter a valid password, so you can use it, like this:

     title Boot DOS
     lock
     rootnoverify (hd0,1)
     makeactive
     chainload +1

   You should insert `lock' right after `title', because any user can
execute commands in an entry, until GRUB encounters `lock'.


File: grub.info,  Node: Introduction,  Next: GRUB images,  Prev: Security,  Up: Top

Introduction
************

   This part documents the user-visible aspect of GRUB. If you are
looking for the information on the internals, see the Programmer
Reference Manual (*note Hacking::).

* Menu:

* History::                     From maggot to house fly.
* Features::                    How GRUB is different.
* Role of a boot loader::       Judging a system by its boot loader.


File: grub.info,  Node: History,  Next: Features,  Up: Introduction

History of GRUB
===============

   GRUB originated in 1995 when Erich Boleyn was trying to boot the GNU
Hurd with the University of Utah's Mach 4 microkernel (now known as GNU
Mach).  Erich and Brian Ford designed the Multiboot Specification
(*note Multiboot Specification: (multiboot)Top.), because they were
determined not to add to the large number of mutually-incompatible PC
boot methods.

   Erich then began modifying the FreeBSD boot loader so that it would
understand Multiboot. He soon realized that it would be a lot easier to
write his own boot loader from scratch than to keep working on the
FreeBSD boot loader, and so GRUB was born.

   Erich added many features to GRUB, but other priorities prevented him
from keeping up with the demands of its quickly-expanding user base. In
1999, Gordon Matzigkeit and OKUJI Yoshinori adopted GRUB as an official
GNU package, and opened its development by making the latest sources
available via anonymous CVS. *Note Obtaining and Building GRUB::, for
more information.


File: grub.info,  Node: Features,  Next: Role of a boot loader,  Prev: History,  Up: Introduction

GRUB features
=============

   The primary requirement for GRUB is that it be compliant with the
"Multiboot Specification", which is described in *Note Multiboot
Specification: (multiboot)Top.

   The other goals, listed in approximate order of importance, are:

   * Basic functions must be straightforward for end-users.

   * Rich functionality to support kernel experts and designers.

   * Backward compatibility for booting FreeBSD, NetBSD, OpenBSD, and
     Linux. Proprietary kernels (such as DOS, Windows NT, and OS/2) are
     supported via a chain-loading function.

   Except for specific compatibility modes (chain-loading and the Linux
"piggyback" format), all kernels will be started in much the same state
as in the Multiboot Specification. Only kernels loaded at 1 megabyte or
above are presently supported. Any attempt to load below that boundary
will simply result in immediate failure and an error message reporting
the problem.

   In addition to the requirements above, GRUB has the following
features (note that the Multiboot Specification doesn't require all the
features that GRUB supports):

Multiple Executable Formats
     Supports many of the "a.out" variants plus "ELF". Symbol tables
     are also loaded.

Support Non-Multiboot Kernels
     Supports many of the various free 32-bit kernels that lack
     Multiboot compliance (primarily FreeBSD, NetBSD, OpenBSD, and
     Linux). Chain-loading of other boot loaders is also supported.

Load Multiples Modules
     GRUB fully supports the Multiboot feature of loading multiple
     modules.

Configuration File
     Supports a human-readable text configuration file with preset boot
     commands. The list of commands (*note Commands::) are a superset of
     those supported on the command line. An example configuration file
     is provided in *Note Configuration::.

Menu Interface
     A menu interface listing the preset boot commands, with a
     programmable timeout, is available. There is no fixed limit on the
     number of boot entries, and the current implementation has space
     for several hundred.

Flexible Command Line Interface
     A fairly flexible command line interface, accessible from the menu,
     is available to edit any preset commands, or write a new boot
     command set from scratch. If no configuration file is present,
     GRUB drops to the command line.

     The list of commands (*note Commands::) are a subset of those
     supported for configuration files. Editing commands closely
     resembles the Bash command line (*note Bash: (features)Command
     Line Editing.), with <TAB>-completion of commands, devices,
     partitions, and files in a directory depending on context.

Multiple Filesystem Types
     Supports multiple filesystem types transparently, plus a useful
     explicit blocklist notation. The currently supported filesystem
     types are "BSD FFS", "DOS FAT16 and FAT32", "Minix fs", "Linux
     ext2fs", and "ReiserFS". *Note Filesystem::, for more information.

Decompression Support
     Can decompress files which were compressed by `gzip'. This
     function is both automatic and transparent to the user (i.e. all
     functions operate upon the uncompressed contents of the specified
     files). This greatly reduces file size and loading time, a
     particularly major benefit for floppies.(1) (*note
     Features-Footnote-1::)

     It is conceivable that some kernel modules should be loaded in a
     compressed state, so a different module-loading command can be
     specified to avoid uncompressing the modules.

Access Data on Any Installed Device
     Supports reading data from any or all floppy or hard disk(s)
     recognized by the BIOS, independent of the setting of the root
     device.

Independent of Drive Geometry Translation
     Unlike many other boot loaders, GRUB makes the particular drive
     translation irrelevant. A drive installed and running with one
     translation may be converted to another translation without any
     adverse effects or changes in GRUB's configuration.

Detect All Installed RAM
     GRUB can generally find all the installed RAM on a PC-compatible
     machine. It uses an advanced BIOS query technique for finding all
     memory regions (*note Memory detection::). As described on the
     Multiboot Specification (*note Multiboot Specification:
     (multiboot)Top.), not all kernels make use of this information,
     but GRUB provides it for those who do.

Support Logical Block Address Mode
     In traditional disk calls (called "CHS mode"), there is a geometry
     translation problem, that is, the BIOS cannot access over 1024
     cylinders, so the accessible space is limited to at least 508 MB
     and to at most 8GB. GRUB can't universally solve this problem, as
     there is no standard interface used in all machines. However,
     several newer machines have the new interface, Logical Block
     Address ("LBA") mode. GRUB automatically detects if LBA mode is
     available and uses it if available. In LBA mode, GRUB can access
     the entire disk.

Network support
     GRUB is a disk-based boot loader but also has network support. You
     can load OS images from a network by using the "TFTP" protocol.

   Future directions might include an internal programming language for
supporting richer sets of boot options with control statements (which
would make GRUB its own kind of kernel). Support for non-PC hardware
architectures is also planned.(2) (*note Features-Footnote-2::)


File: grub.info,  Node: Features-Footnotes,  Up: Features

   (1) There are a few pathological cases where loading a very badly
organized ELF kernel might take longer, but in practice this never
happen.

   (2) There is already a port to the NEC PC-98xx series. See
<http://www.kuis.kyoto-u.ac.jp/~kmc/proj/linux98/arch/i386/boot/grub98/>,
for more information.


File: grub.info,  Node: Role of a boot loader,  Prev: Features,  Up: Introduction

The role of a boot loader
=========================

   The following is a quotation from Gordon Matzigkeit, a GRUB fanatic:

     Some people like to acknowledge both the operating system and
     kernel when they talk about their computers, so they might say
     they use "GNU/Linux" or "GNU/Hurd".  Other people seem to think
     that the kernel is the most important part of the system, so they
     like to call their GNU operating systems "Linux systems."

     I, personally, believe that this is a grave injustice, because the
     _boot loader_ is the most important software of all. I used to
     refer to the above systems as either "LILO"(1) (*note Role of a
     boot loader-Footnote-1::) or "GRUB" systems.

     Unfortunately, nobody ever understood what I was talking about;
     now I just use the word "GNU" as a pseudonym for GRUB.

     So, if you ever hear people talking about their alleged "GNU"
     systems, remember that they are actually paying homage to the best
     boot loader around... GRUB!

   We, the GRUB maintainers, do not (usually) encourage Gordon's level
of fanaticism, but it helps to remember that boot loaders deserve
recognition.  We hope that you enjoy using GNU GRUB as much as we did
writing it.


File: grub.info,  Node: Role of a boot loader-Footnotes,  Up: Role of a boot loader

   (1) The LInux LOader, a boot loader that everybody uses, but nobody
likes.


File: grub.info,  Node: GRUB images,  Next: Filesystem,  Prev: Introduction,  Up: Top

GRUB images
***********

   GRUB consists of several images: two essential stages, optional
stages called "Stage 1.5", and two network boot images. Here is a short
overview of them. See *Note Hacking::, for more details.

`stage1'
     This is an essential image used for booting up GRUB. Usually, this
     is embedded in a MBR or the boot sector of a partition. Because a
     PC boot sector is 512 bytes, the size of this image is exactly 512
     bytes.

     All `stage1' must do is to load Stage 2 or Stage 1.5 from a local
     disk. Because of the size restriction, `stage1' encodes the
     location of Stage 2 (or Stage 1.5) in a block list format, so it
     never understand any filesystem structure.

`stage2'
     This is the core image of GRUB. This does all things but booting up
     itself. Usually, this is put in a filesystem, but that is not
     required.

`e2fs_stage1_5'
`ffs_stage1_5'
`reiserfs_stage1_5'
`fat_stage1_5'
`minix_stage1_5'
     These are called "Stage 1.5", because the purpose is a bridge
     between `stage1' and `stage2', that is to say, Stage 1.5 is loaded
     by Stage 1 and Stage 1.5 loads Stage 2. The difference between
     `stage1' and `*_stage1_5' is that the former doesn't understand
     any filesystem but the latter does an filesystem (e.g.
     `e2fs_stage1_5' understands ext2fs). So you can move the location
     of Stage 2 to another safely, even after GRUB has been installed.

     While Stage 2 cannot generally be embedded in a fixed area as the
     size is so large, Stage 1.5 can be installed into the area right
     after a MBR, or the boot loader area of a ReiserFS or a FFS.

`nbgrub'
     This is a network boot image for the Network Image Proposal used
     by some network boot loaders, such as Etherboot. This is mostly
     the same as Stage 2, but this also sets up a network and loads a
     configuration file from the network.

`pxegrub'
     This is another network boot image for the Preboot Execution
     Environment used by several Netboot ROMs. This is identical to
     `nbgrub', except for the format.


File: grub.info,  Node: Filesystem,  Next: Interface,  Prev: GRUB images,  Up: Top

Filesystem syntax and semantics
*******************************

   GRUB uses a special syntax for specifying disk drives which can be
accessed by BIOS. Because of BIOS limitations, GRUB cannot distinguish
between IDE, ESDI, SCSI, or others. You must know yourself which BIOS
device is equivalent to which OS device. Normally, that will be clear if
you see the files in a device or use the command `find' (*note
Commands::).

* Menu:

* Device syntax::               How to specify devices
* Filename syntax::             How to specify files
* Blocklist syntax::            How to specify blocklists


File: grub.info,  Node: Device syntax,  Next: Filename syntax,  Up: Filesystem

How to specify devices
======================

   The device syntax is like this:

     `(BIOS-DEVICE[,PART-NUM][,BSD-SUBPART-LETTER])'

   `[]' means the parameter is optional. BIOS-DEVICE should be either
`fd' or `hd' followed by a digit, like `fd0'.  But you can also set
BIOS-DEVICE to a hexadecimal or a decimal, which is a BIOS drive
number, so the following are equivalent:

     (hd0)
     (0x80)
     (128)

   PART-NUM represents the partition number of BIOS-DEVICE, starting
from zero for primary partitions and from four for extended partitions,
and BSD-SUBPART-LETTER represents the BSD disklabel subpartition, such
as `a' or `e'.

   A shortcut for specifying BSD subpartitions is
`(BIOS-DEVICE,BSD-SUBPART-LETTER)', in this case, GRUB searches for the
first PC partition containing a BSD disklabel, then finds the
subpartition BSD-SUBPART-LETTER. Here is an example:

     (hd0,a)

   The syntax like `(hd0)' represents using the entire disk (or the MBR
when installing GRUB), while the syntax like `(hd0,0)' represents using
the partition of the disk (or the boot sector of the partition when
installing GRUB).

   If you enabled the network support, the special drive, `(nd)', is
also available. Before using the network drive, you must initialize the
network. *Note Network::, for more information.


File: grub.info,  Node: Filename syntax,  Next: Blocklist syntax,  Prev: Device syntax,  Up: Filesystem

How to specify files
====================

   There are two ways to specify files, by "absolute filename" and by
"blocklist".

   An absolute filename resembles a Unix absolute filename, using `/'
for the directory separator (not `\' as in DOS). One example is
`(hd0,0)/boot/grub/menu.lst'. This means the file `/boot/grub/menu.lst'
in the first partition of the first hard disk. If you omit the device
name in an absolute filename, GRUB uses GRUB's "root device"
implicitly. So if you set the root device to, say, `(hd1,0)' by the
command `root', then `/boot/kernel' is the same as
`(hd1,0)/boot/kernel'.

