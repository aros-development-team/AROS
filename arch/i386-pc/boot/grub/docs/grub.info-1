This is grub.info, produced by makeinfo version 4.1 from grub.texi.

INFO-DIR-SECTION Kernel
START-INFO-DIR-ENTRY
* GRUB: (grub).                 The GRand Unified Bootloader
* grub-install: (grub)Invoking grub-install.    Install GRUB on your drive
* grub-md5-crypt: (grub)Invoking grub-md5-crypt.        Encrypt a password
                                                        in MD5 format
* grub-terminfo: (grub)Invoking grub-terminfo.  Generate a terminfo
                                                command from a
                                                terminfo name
* mbchk: (grub)Invoking mbchk.  Check for the format of a Multiboot kernel
END-INFO-DIR-ENTRY

   Copyright (C) 1999,2000,2001,2002 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: grub.info,  Node: Top,  Next: Introduction,  Up: (dir)

GRUB manual
***********

   This is the documentation of GNU GRUB, the GRand Unified Bootloader,
a flexible and powerful boot loader program for PCs.

   This edition documents version 0.93.

* Menu:

* Introduction::                Capturing the spirit of GRUB
* Naming convention::           Names of your drives in GRUB
* Installation::                Installing GRUB on your drive
* Booting::                     How to boot different operating systems
* Configuration::               Writing your own configuration file
* Network::                     Downloading OS images from a network
* Serial terminal::             Using GRUB via a serial line
* Preset Menu::                 Embedding a configuration file into GRUB
* Security::                    Improving the security
* Images::                      GRUB image files
* Filesystem::                  Filesystem syntax and semantics
* Interface::                   The menu and the command-line
* Commands::                    The list of available builtin commands
* Troubleshooting::             Error messages produced by GRUB
* Invoking the grub shell::     How to use the grub shell
* Invoking grub-install::       How to use the GRUB installer
* Invoking grub-md5-crypt::     How to generate a cryptic password
* Invoking grub-terminfo::      How to generate a terminfo command
* Invoking mbchk::              How to use the Multiboot checker
* Obtaining and Building GRUB:: How to obtain and build GRUB
* Reporting bugs::              Where you should send a bug report
* Future::                      Some future plans on GRUB
* Internals::                   Hacking GRUB
* Index::


File: grub.info,  Node: Introduction,  Next: Naming convention,  Prev: Top,  Up: Top

Introduction to GRUB
********************

* Menu:

* Overview::                    What exactly GRUB is and how to use it
* History::                     From maggot to house fly
* Features::                    GRUB features
* Role of a boot loader::       The role of a boot loader


File: grub.info,  Node: Overview,  Next: History,  Up: Introduction

Overview
========

   Briefly, a "boot loader" is the first software program that runs when
a computer starts.  It is responsible for loading and transferring
control to an operating system "kernel" software (such as Linux or GNU
Mach).  The kernel, in turn, initializes the rest of the operating
system (e.g. a GNU system).

   GNU GRUB is a very powerful boot loader, which can load a wide
variety of free operating systems, as well as proprietary operating
systems with chain-loading(1) (*note Overview-Footnote-1::). GRUB is
designed to address the complexity of booting a personal computer; both
the program and this manual are tightly bound to that computer platform,
although porting to other platforms may be addressed in the future.

   One of the important features in GRUB is flexibility; GRUB
understands filesystems and kernel executable formats, so you can load
an arbitrary operating system the way you like, without recording the
physical position of your kernel on the disk.

   Thus you can load the kernel just by specifying its file name and the
drive (and the partition) where the kernel resides. To let GRUB know the
drive and the file name, you can either type in them manually via the
command-line interface (*note Command-line interface::), or use the nice
menu interface (*note Menu interface::) through which you can easily
select which OS it boots. To allow you to customize the menu, GRUB will
load a preexisting configuration file (*note Configuration::). Note that
you can not only enter the command-line interface whenever you like, but
also you can edit specific menu entries prior to using them.

   In the following chapters, you will learn how to specify a drive or a
partition, and a file name (*note Naming convention::) to GRUB, how to
install GRUB on your drive (*note Installation::), and how to boot your
OSes (*note Booting::), step by step.


File: grub.info,  Node: Overview-Footnotes,  Up: Overview

   (1) "chain-load" is the mechanism for loading unsupported operating
systems by loading another boot loader. It is typically used for
loading DOS or Windows.


File: grub.info,  Node: History,  Next: Features,  Prev: Overview,  Up: Introduction

History of GRUB
===============

   GRUB originated in 1995 when Erich Boleyn was trying to boot the GNU
Hurd with the University of Utah's Mach 4 microkernel (now known as GNU
Mach).  Erich and Brian Ford designed the Multiboot Specification
(*note Multiboot Specification: (multiboot)Top.), because they were
determined not to add to the large number of mutually-incompatible PC
boot methods.

   Erich then began modifying the FreeBSD boot loader so that it would
understand Multiboot. He soon realized that it would be a lot easier to
write his own boot loader from scratch than to keep working on the
FreeBSD boot loader, and so GRUB was born.

   Erich added many features to GRUB, but other priorities prevented him
from keeping up with the demands of its quickly-expanding user base. In
1999, Gordon Matzigkeit and Yoshinori K. Okuji adopted GRUB as an
official GNU package, and opened its development by making the latest
sources available via anonymous CVS. *Note Obtaining and Building
GRUB::, for more information.


File: grub.info,  Node: Features,  Next: Role of a boot loader,  Prev: History,  Up: Introduction

GRUB features
=============

   The primary requirement for GRUB is that it be compliant with the
"Multiboot Specification", which is described in *Note Multiboot
Specification: (multiboot)Top.

   The other goals, listed in approximate order of importance, are:

   * Basic functions must be straightforward for end-users.

   * Rich functionality to support kernel experts and designers.

   * Backward compatibility for booting FreeBSD, NetBSD, OpenBSD, and
     Linux. Proprietary kernels (such as DOS, Windows NT, and OS/2) are
     supported via a chain-loading function.

   Except for specific compatibility modes (chain-loading and the Linux
"piggyback" format), all kernels will be started in much the same state
as in the Multiboot Specification. Only kernels loaded at 1 megabyte or
above are presently supported. Any attempt to load below that boundary
will simply result in immediate failure and an error message reporting
the problem.

   In addition to the requirements above, GRUB has the following
features (note that the Multiboot Specification doesn't require all the
features that GRUB supports):

Recognize multiple executable formats
     Support many of the "a.out" variants plus "ELF". Symbol tables are
     also loaded.

Support non-Multiboot kernels
     Support many of the various free 32-bit kernels that lack Multiboot
     compliance (primarily FreeBSD, NetBSD, OpenBSD, and Linux).
     Chain-loading of other boot loaders is also supported.

Load multiples modules
     Fully support the Multiboot feature of loading multiple modules.

Load a configuration file
     Support a human-readable text configuration file with preset boot
     commands. You can also load another configuration file dynamically
     and embed a preset configuration file in a GRUB image file. The
     list of commands (*note Commands::) are a superset of those
     supported on the command-line. An example configuration file is
     provided in *Note Configuration::.

Provide a menu interface
     A menu interface listing the preset boot commands, with a
     programmable timeout, is available. There is no fixed limit on the
     number of boot entries, and the current implementation has space
     for several hundred.

Have a flexible command-line interface
     A fairly flexible command-line interface, accessible from the menu,
     is available to edit any preset commands, or write a new boot
     command set from scratch. If no configuration file is present,
     GRUB drops to the command-line.

     The list of commands (*note Commands::) are a subset of those
     supported for configuration files. Editing commands closely
     resembles the Bash command-line (*note Bash: (features)Command
     Line Editing.), with <TAB>-completion of commands, devices,
     partitions, and files in a directory depending on context.

Support multiple filesystem types
     Support multiple filesystem types transparently, plus a useful
     explicit blocklist notation. The currently supported filesystem
     types are "BSD FFS", "DOS FAT16 and FAT32", "Minix fs", "Linux
     ext2fs", "ReiserFS", "JFS", "XFS", and "VSTa fs". *Note
     Filesystem::, for more information.

Support automatic decompression
     Can decompress files which were compressed by `gzip'. This
     function is both automatic and transparent to the user (i.e. all
     functions operate upon the uncompressed contents of the specified
     files). This greatly reduces a file size and the loading time, a
     particularly major benefit for floppies.(1) (*note
     Features-Footnote-1::)

     It is conceivable that some kernel modules should be loaded in a
     compressed state, so a different module-loading command can be
     specified to avoid uncompressing the modules.

Access data on any installed device
     Support reading data from any or all floppy or hard disk(s)
     recognized by the BIOS, independent of the setting of the root
     device.

Be independent of drive geometry translations
     Unlike many other boot loaders, GRUB makes the particular drive
     translation irrelevant. A drive installed and running with one
     translation may be converted to another translation without any
     adverse effects or changes in GRUB's configuration.

Detect all installed RAM
     GRUB can generally find all the installed RAM on a PC-compatible
     machine. It uses an advanced BIOS query technique for finding all
     memory regions. As described on the Multiboot Specification (*note
     Multiboot Specification: (multiboot)Top.), not all kernels make
     use of this information, but GRUB provides it for those who do.

Support Logical Block Address mode
     In traditional disk calls (called "CHS mode"), there is a geometry
     translation problem, that is, the BIOS cannot access over 1024
     cylinders, so the accessible space is limited to at least 508 MB
     and to at most 8GB. GRUB can't universally solve this problem, as
     there is no standard interface used in all machines. However,
     several newer machines have the new interface, Logical Block
     Address ("LBA") mode. GRUB automatically detects if LBA mode is
     available and uses it if available. In LBA mode, GRUB can access
     the entire disk.

Support network booting
     GRUB is basically a disk-based boot loader but also has network
     support. You can load OS images from a network by using the "TFTP"
     protocol.

Support remote terminals
     To support computers with no console, GRUB provides remote terminal
     support, so that you can control GRUB from a remote host. Only
     serial terminal support is implemented at the moment.


File: grub.info,  Node: Features-Footnotes,  Up: Features

   (1) There are a few pathological cases where loading a very badly
organized ELF kernel might take longer, but in practice this never
happen.


File: grub.info,  Node: Role of a boot loader,  Prev: Features,  Up: Introduction

The role of a boot loader
=========================

   The following is a quotation from Gordon Matzigkeit, a GRUB fanatic:

     Some people like to acknowledge both the operating system and
     kernel when they talk about their computers, so they might say
     they use "GNU/Linux" or "GNU/Hurd".  Other people seem to think
     that the kernel is the most important part of the system, so they
     like to call their GNU operating systems "Linux systems."

     I, personally, believe that this is a grave injustice, because the
     _boot loader_ is the most important software of all. I used to
     refer to the above systems as either "LILO"(1) (*note Role of a
     boot loader-Footnote-1::) or "GRUB" systems.

     Unfortunately, nobody ever understood what I was talking about;
     now I just use the word "GNU" as a pseudonym for GRUB.

     So, if you ever hear people talking about their alleged "GNU"
     systems, remember that they are actually paying homage to the best
     boot loader around... GRUB!

   We, the GRUB maintainers, do not (usually) encourage Gordon's level
of fanaticism, but it helps to remember that boot loaders deserve
recognition.  We hope that you enjoy using GNU GRUB as much as we did
writing it.


File: grub.info,  Node: Role of a boot loader-Footnotes,  Up: Role of a boot loader

   (1) The LInux LOader, a boot loader that everybody uses, but nobody
likes.


File: grub.info,  Node: Naming convention,  Next: Installation,  Prev: Introduction,  Up: Top

Naming convention
*****************

   The device syntax used in GRUB is a wee bit different from what you
may have seen before in your operating system(s), and you need to know
it so that you can specify a drive/partition.

   Look at the following examples and explanations:

     (fd0)

   First of all, GRUB requires that the device name is enclosed with
`(' and `)'. The `fd' part means that it is a floppy disk. The number
`0' is the drive number, which is counted from _zero_. This expression
means that GRUB will use the whole floppy disk.

     (hd0,1)

   Here, `hd' means it is a hard disk drive. The first integer `0'
indicates the drive number, that is, the first hard disk, while the
second integer, `1', indicates the partition number (or the PC slice
number in the BSD terminology). Once again, please note that the
partition numbers are counted from _zero_, not from one. This
expression means the second partition of the first hard disk drive. In
this case, GRUB uses one partition of the disk, instead of the whole
disk.

     (hd0,4)

   This specifies the first "extended partition" of the first hard disk
drive. Note that the partition numbers for extended partitions are
counted from `4', regardless of the actual number of primary partitions
on your hard disk.

     (hd1,a)

   This means the BSD `a' partition of the second hard disk. If you
need to specify which PC slice number should be used, use something
like this: `(hd1,0,a)'. If the PC slice number is omitted, GRUB
searches for the first PC slice which has a BSD `a' partition.

   Of course, to actually access the disks or partitions with GRUB, you
need to use the device specification in a command, like `root (fd0)' or
`unhide (hd0,2)'. To help you find out which number is a partition you
want, the GRUB command-line (*note Command-line interface::) options
have argument completion. That means that, for example, you only need
to type `root (', followed by a <TAB>, and GRUB will display the list
of drives, partitions, or file names, so it should be quite easy to
determine the name of your target partition, even with minimal
knowledge of the syntax.

   Note that GRUB does _not_ distinguish IDE from SCSI - it simply
counts the drive numbers from zero, regardless of their type. Normally,
any IDE drive number is less than any SCSI drive number, although that
is not true if you change the boot sequence by swapping IDE and SCSI
drives in your BIOS.

   Now the question is, how to specify a file? Again, see this example:

     (hd0,0)/vmlinuz

   This specifies the file named `vmlinuz', found on the first
partition of the first hard disk drive. Note that the argument
completion works with file names, too.

   That was easy, admit it. Do read the next chapter, to find out how to
actually install GRUB on your drive.


File: grub.info,  Node: Installation,  Next: Booting,  Prev: Naming convention,  Up: Top

Installation
************

   First, you need to have GRUB itself properly installed on your
system, (*note Obtaining and Building GRUB::) either from the source
tarball, or as a package for your OS.

   To use GRUB, you need to install it on your drive. There are two
ways of doing that - either using the utility `grub-install' (*note
Invoking grub-install::) on a UNIX-like OS, or by using the native
Stage 2. These are quite similar, however, the utility might probe a
wrong BIOS drive, so better be careful.

   Also, if you install GRUB on a UNIX-like OS, please make sure that
you have an emergency boot disk ready, so that you can rescue your
computer if, by any chance, your hard drive becomes unusable
(unbootable).

   GRUB comes with boot images, which are normally installed in the
directory `/usr/share/grub/i386-pc'. You need to copy the files
`stage1', `stage2', and `*stage1_5' to the directory `/boot/grub'. Here
the directory where GRUB images are installed and the directory where
GRUB will use to find them are called "image directory" and "boot
directory", respectively.

* Menu:

* Creating a GRUB boot floppy::
* Installing GRUB natively::
* Installing GRUB using grub-install::


File: grub.info,  Node: Creating a GRUB boot floppy,  Next: Installing GRUB natively,  Up: Installation

Creating a GRUB boot floppy
===========================

   To create a GRUB boot floppy, you need to take the files `stage1'
and `stage2' from the image directory, and write them to the first and
the second block of the floppy disk, respectively.

   *Caution:* This procedure will destroy any data currently stored on
the floppy.

   On a UNIX-like operating system, that is done with the following
commands:

     # cd /usr/share/grub/i386-pc
     # dd if=stage1 of=/dev/fd0 bs=512 count=1
     1+0 records in
     1+0 records out
     # dd if=stage2 of=/dev/fd0 bs=512 seek=1
     153+1 records in
     153+1 records out
     #

   The device file name may be different. Consult the manual for your
OS.


File: grub.info,  Node: Installing GRUB natively,  Next: Installing GRUB using grub-install,  Prev: Creating a GRUB boot floppy,  Up: Installation

Installing GRUB natively
========================

   *Caution:* Installing GRUB's stage1 in this manner will erase the
normal boot-sector used by an OS.

   GRUB can currently boot GNU Mach, Linux, FreeBSD, NetBSD, and OpenBSD
directly, so using it on a boot sector should be okay. But generally, it
would be a good idea to back up the first sector of the partition on
which you are installing GRUB's stage1. This isn't as important if you
are installing GRUB on the first sector of a hard disk, since it's easy
to reinitialize it (e.g. by running `FDISK /MBR' from DOS).

   If you decide to install GRUB in the native environment, which is
definitely desirable, you'll need to create the GRUB boot disk, and
reboot your computer with it. Otherwise, see *Note Installing GRUB
using grub-install::, for more details.

   Once started, GRUB will show the command-line interface (*note
Command-line interface::). First, set the GRUB's "root device"(1)
(*note Installing GRUB natively-Footnote-1::) to the boot directory,
like this:

     grub> root (hd0,0)

   If you are not sure which partition actually holds these files, use
the command `find' (*note find::), like this:

     grub> find /boot/grub/stage1

   This will search for the file name `/boot/grub/stage1' and show the
devices which contain the file.

   Once you've set the root device correctly, run the command `setup'
(*note setup::):

     grub> setup (hd0)

   This command will install GRUB on the MBR in the first drive. If you
want to install GRUB into the "boot sector" of a partition instead of
the MBR, specify a partition into which you want to install GRUB:

     grub> setup (hd0,0)

   If you install GRUB into a partition or a drive other than the first
one, you must chain-load GRUB from another boot loader. Refer to the
manual for the boot loader to know how to chain-load GRUB.

   Now you can boot GRUB without a GRUB floppy. See the chapter *Note
Booting:: to find out how to boot your operating systems from GRUB.


File: grub.info,  Node: Installing GRUB natively-Footnotes,  Up: Installing GRUB natively

   (1) Note that GRUB's root device doesn't necessarily mean your OS's
root partition; if you need to specify a root partition for your OS,
add the argument into the command `kernel'.


File: grub.info,  Node: Installing GRUB using grub-install,  Prev: Installing GRUB natively,  Up: Installation

Installing GRUB using grub-install
==================================

   *Caution:* This procedure is definitely deprecated, because there
are several posibilities that your computer can be unbootable. For
example, most operating systems don't tell GRUB how to map BIOS drives
to OS devices correctly, GRUB merely "guesses" the mapping. This will
succeed in most cases, but not always. So GRUB provides you with a
user-defined map file called "device map", which you must fix, if it is
wrong. *Note Device map::, for more details.

   Unfortunately, if you do want to install GRUB under a UNIX-like OS
(such as GNU), invoke the program `grub-install' (*note Invoking
grub-install::) as the superuser ("root").

   The usage is basically very easy. You only need to specify one
argument to the program, namely, where to install GRUB. The argument
can be either of a device file or a GRUB's drive/partition. So, this
will install GRUB into the MBR of the first IDE disk under Linux:

     # grub-install /dev/hda

   Likewise, under GNU/Hurd, this has the same effect:

     # grub-install /dev/hd0

   If it is the first BIOS drive, this is the same as well:

     # grub-install '(hd0)'

   But all the above examples assume that you use GRUB images under the
root directory. If you want GRUB to use images under a directory other
than the root directory, you need to specify the option
`--root-directory'. The typical usage is that you create a GRUB boot
floppy with a filesystem. Here is an example:

     # mke2fs /dev/fd0
     # mount -t ext2 /dev/fd0 /mnt
     # grub-install --root-directory=/mnt '(fd0)'
     # umount /mnt

   Another example is in case that you have a separate boot partition
which is mounted at `/boot'. Since GRUB is a boot loader, it doesn't
know anything about mountpoints at all. Thus, you need to run
`grub-install' like this:

     # grub-install --root-directory=/boot /dev/hda

   By the way, as noted above, it is quite difficult to guess BIOS
drives correctly under a UNIX-like OS. Thus, `grub-install' will prompt
you to check if it could really guess the correct mappings, after the
installation. The format is defined in *Note Device map::. Please be
careful enough. If the output is wrong, it is unlikely that your
computer can boot with no problem.

   Note that `grub-install' is actually just a shell script and the
real task is done by the grub shell `grub' (*note Invoking the grub
shell::). Therefore, you may run `grub' directly to install GRUB,
without using `grub-install'. Don't do that, however, unless you are
very familiar with the internals of GRUB. Installing a boot loader on a
running OS may be extremely dangerous.


File: grub.info,  Node: Booting,  Next: Configuration,  Prev: Installation,  Up: Top

Booting
*******

   For Multiboot-compliant kernels, GRUB can load them in a consistent
way, but, for some free operating systems, you need to use some
OS-specific magic.

* Menu:

* General boot methods::        How to boot OSes with GRUB genenerally
* OS-specific notes::           Notes on some operating systems


File: grub.info,  Node: General boot methods,  Next: OS-specific notes,  Up: Booting

How to boot operating systems
=============================

   GRUB has two distinct boot methods. One of the two is to load an
operating system directly, and the other is to chain-load another boot
loader which then will load an operating system actually. Generally
speaking, the former is desirable, because you don't need to install or
maintain other boot loaders and GRUB is flexible enough to load an
operating system from an arbitrary disk/partition. However, the latter
is sometimes required, since GRUB doesn't support all the existing
operating systems natively.

* Menu:

* Loading an operating system directly::
* Chain-loading::


File: grub.info,  Node: Loading an operating system directly,  Next: Chain-loading,  Up: General boot methods

How to boot an OS directly with GRUB
------------------------------------

   Multiboot (*note Multiboot Specification: (multiboot)Top.) is the
native format supported by GRUB.  For the sake of convenience, there
are also support for Linux, FreeBSD, NetBSD and OpenBSD. If you want to
boot other operating systems, you will have to chain-load them (*note
Chain-loading::).

   Generally, GRUB can boot any Multiboot-compliant OS in the following
steps:

  1. Set GRUB's root device to the drive where the OS images are stored
     by the command `root' (*note root::).

  2. Load the kernel image by the command `kernel' (*note kernel::).

  3. If you need modules, load them with the command `module' (*note
     module::) or `modulenounzip' (*note modulenounzip::).

  4. Run the command `boot' (*note boot::).

   Linux, FreeBSD, NetBSD and OpenBSD can be booted in a similar
manner. You can load a kernel image by the command `kernel' and then
run the command `boot'. If the kernel requires some parameters, just
append the parameters to `kernel', after the file name of the kernel.
Also, please refer to *Note OS-specific notes::, for the information on
your OS-specific issues.


File: grub.info,  Node: Chain-loading,  Prev: Loading an operating system directly,  Up: General boot methods

Load another boot loader to boot unsupported operating systems
--------------------------------------------------------------

   If you want to boot an unsupported operating system (e.g. Windows
95), chain-load a boot loader for the operating system. Normally, the
boot loader is embedded in the "boot sector" of the partition on which
the operating system is installed.

  1. Set GRUB's root device to the partition by the command
     `rootnoverify' (*note rootnoverify::):

          grub> rootnoverify (hd0,0)

  2. Set the "active" flag in the partition by the command
     `makeactive'(1) (*note Chain-loading-Footnote-1::) (*note
     makeactive::):

          grub> makeactive

  3. Load the boot loader by the command `chainloader' (*note
     chainloader::):

          grub> chainloader +1

     `+1' indicates that GRUB should read one sector from the start of
     the partition. The complete description about this syntax can be
     found in *Note Block list syntax::.

  4. Run the command `boot' (*note boot::).

   However, DOS and Windows have some deficiencies, so you might have to
use more complicated instructions. *Note DOS/Windows::, for more
information.


File: grub.info,  Node: Chain-loading-Footnotes,  Up: Chain-loading

   (1) This is not necessary for most of the modern operating systems.


File: grub.info,  Node: OS-specific notes,  Prev: General boot methods,  Up: Booting

Some caveats on OS-specific issues
==================================

   Here, we describe some caveats on several operating systems.

* Menu:

* GNU/Hurd::
* GNU/Linux::
* FreeBSD::
* NetBSD::
* OpenBSD::
* DOS/Windows::
* SCO UnixWare::
* QNX::


File: grub.info,  Node: GNU/Hurd,  Next: GNU/Linux,  Up: OS-specific notes

GNU/Hurd
--------

   Since GNU/Hurd is Multiboot-compliant, it is easy to boot it; there
is nothing special about it. But do not forget that you have to specify
a root partition to the kernel.

  1. Set GRUB's root device to the same drive as GNU/Hurd's. Probably
     the command `find /boot/gnumach' or similar can help you (*note
     find::).

  2. Load the kernel and the module, like this:

          grub> kernel /boot/gnumach root=hd0s1
          grub> module /boot/serverboot

  3. Run the command `boot' (*note boot::).


File: grub.info,  Node: GNU/Linux,  Next: FreeBSD,  Prev: GNU/Hurd,  Up: OS-specific notes

GNU/Linux
---------

   It is relatively easy to boot GNU/Linux from GRUB, because it
somewhat resembles to boot a Multiboot-compliant OS.

  1. Set GRUB's root device to the same drive as GNU/Linux's. Probably
     the command `find /vmlinuz' or similar can help you (*note find::).

  2. Load the kernel:

          grub> kernel /vmlinuz root=/dev/hda1

     If you need to specify some kernel parameters, just append them to
     the command. For example, to set `vga' to `ext', do this:

          grub> kernel /vmlinuz root=/dev/hda1 vga=ext

     See the documentation in the Linux source tree for the complete
     information on the available options.

  3. If you use an initrd, execute the command `initrd' (*note
     initrd::) after `kernel':

          grub> initrd /initrd

  4. Finally, run the command `boot' (*note boot::).

   *Caution:* If you use an initrd and specify the `mem=' option to the
kernel, to let it use less than actual memory size, you will also have
to specify the same memory size to GRUB. To let GRUB know the size, run
the command `uppermem' _before_ loading the kernel. *Note uppermem::,
for more information.


File: grub.info,  Node: FreeBSD,  Next: NetBSD,  Prev: GNU/Linux,  Up: OS-specific notes

FreeBSD
-------

   GRUB can load the kernel directly, either in ELF or a.out format. But
this is not recommended, since FreeBSD's bootstrap interface sometimes
changes heavily, so GRUB can't guarantee to pass kernel parameters
correctly.

   Thus, we'd recommend loading the very flexible loader `/boot/loader'
instead. See this example:

     grub> root (hd0,a)
     grub> kernel /boot/loader
     grub> boot


File: grub.info,  Node: NetBSD,  Next: OpenBSD,  Prev: FreeBSD,  Up: OS-specific notes

NetBSD
------

   GRUB can load NetBSD a.out and ELF directly, follow these steps:

  1. Set GRUB's root device with `root' (*note root::).

  2. Load the kernel with `kernel' (*note kernel::). You should append
     the ugly option `--type=netbsd', if you want to load an ELF
     kernel, like this:

          grub> kernel --type=netbsd /netbsd-elf

  3. Run `boot' (*note boot::).

   For now, however, GRUB doesn't allow you to pass kernel parameters,
so it may be better to chain-load it instead, for more information
please see *Note Chain-loading::.


File: grub.info,  Node: OpenBSD,  Next: DOS/Windows,  Prev: NetBSD,  Up: OS-specific notes

OpenBSD
-------

   The booting instruction is exactly the same as for NetBSD (*note
NetBSD::).


File: grub.info,  Node: DOS/Windows,  Next: SCO UnixWare,  Prev: OpenBSD,  Up: OS-specific notes

DOS/Windows
-----------

   GRUB cannot boot DOS or Windows directly, so you must chain-load them
(*note Chain-loading::). However, their boot loaders have some critical
deficiencies, so it may not work to just chain-load them. To overcome
the problems, GRUB provides you with two helper functions.

   If you have installed DOS (or Windows) on a non-first hard disk, you
have to use the disk swapping technique, because that OS cannot boot
from any disks but the first one. The workaround used in GRUB is the
command `map' (*note map::), like this:

     grub> map (hd0) (hd1)
     grub> map (hd1) (hd0)

   This performs a "virtual" swap between your first and second hard
drive.

   *Caution:* This is effective only if DOS (or Windows) uses BIOS to
access the swapped disks. If that OS uses a special driver for the
disks, this probably won't work.

   Another problem arises if you installed more than one set of
DOS/Windows onto one disk, because they could be confused if there are
more than one primary partitions for DOS/Windows. Certainly you should
avoid doing this, but there is a solution if you do want to do so. Use
the partition hiding/unhiding technique.

   If GRUB "hide"s a DOS (or Windows) partition (*note hide::), DOS (or
Windows) will ignore the partition. If GRUB "unhide"s a DOS (or
Windows) partition (*note unhide::), DOS (or Windows) will detect the
partition. Thus, if you have installed DOS (or Windows) on the first
and the second partition of the first hard disk, and you want to boot
the copy on the first partition, do the following:

     grub> unhide (hd0,0)
     grub> hide (hd0,1)
     grub> rootnoverify (hd0,0)
     grub> chainloader +1
     grub> makeactive
     grub> boot


File: grub.info,  Node: SCO UnixWare,  Next: QNX,  Prev: DOS/Windows,  Up: OS-specific notes

SCO UnixWare
------------

   It is known that the signature in the boot loader for SCO UnixWare is
wrong, so you will have to specify the option `--force' to
`chainloader' (*note chainloader::), like this:

     grub> rootnoverify (hd1,0)
     grub> chainloader --force +1
     grub> makeactive
     grub> boot


File: grub.info,  Node: QNX,  Prev: SCO UnixWare,  Up: OS-specific notes

QNX
---

   QNX seems to use a bigger boot loader, so you need to boot it up,
like this:

     grub> rootnoverify (hd1,1)
     grub> chainloader +4
     grub> boot


File: grub.info,  Node: Configuration,  Next: Network,  Prev: Booting,  Up: Top

Configuration
*************

   You probably noticed that you need to type several commands to boot
your OS. There's a solution to that - GRUB provides a menu interface
(*note Menu interface::) from which you can select an item (using arrow
keys) that will do everything to boot an OS.

   To enable the menu, you need a configuration file, `menu.lst' under
the boot directory. We'll analyze an example file.

   The file first contains some general settings, the menu interface
related options. You can put these commands (*note Menu-specific
commands::) before any of the items (starting with `title' (*note
title::)).

     #
     # Sample boot menu configuration file
     #

   As you may have guessed, these lines are comments. Lines starting
with a hash character (`#'), and blank lines, are ignored by GRUB.

     # By default, boot the first entry.
     default 0

   The first entry (here, counting starts with number zero, not one!)
will be the default choice.

     # Boot automatically after 30 secs.
     timeout 30

   As the comment says, GRUB will boot automatically in 30 seconds,
unless interrupted with a keypress.

     # Fallback to the second entry.
     fallback 1

   If, for any reason, the default entry doesn't work, fall back to the
second one (this is rarely used, for obvious reasons).

   Note that the complete descriptions of these commands, which are menu
interface specific, can be found in *Note Menu-specific commands::.
Other descriptions can be found in *Note Commands::.

   Now, on to the actual OS definitions. You will see that each entry
begins with a special command, `title' (*note title::), and the action
is described after it. Note that there is no command `boot' (*note
boot::) at the  end of each item. That is because GRUB automatically
executes `boot' if it loads other commands successfully.

   The argument for the command `title' is used to display a short
title/description of the entry in the menu. Since `title' displays the
argument as is, you can write basically anything in there.

     # For booting GNU/Hurd
     title  GNU/Hurd
     root   (hd0,0)
     kernel /boot/gnumach.gz root=hd0s1
     module /boot/serverboot.gz

   This boots GNU/Hurd from the first hard disk.

     # For booting GNU/Linux
     title  GNU/Linux
     kernel (hd1,0)/vmlinuz root=/dev/hdb1

   This boots GNU/Linux, but from the second hard disk.

     # For booting Mach (getting kernel from floppy)
     title  Utah Mach4 multiboot
     root   (hd0,2)
     pause  Insert the diskette now^G!!
     kernel (fd0)/boot/kernel root=hd0s3
     module (fd0)/boot/bootstrap

   This boots Mach with a kernel on a floppy, but the root filesystem at
hd0s3. It also contains a `pause' line (*note pause::), which will
cause GRUB to display a prompt and delay, before actually executing the
rest of the commands and booting.

     # For booting FreeBSD
     title  FreeBSD
     root   (hd0,2,a)
     kernel /boot/loader

   This item will boot FreeBSD kernel loaded from the `a' partition of
the third PC slice of the first hard disk.

     # For booting OS/2
     title OS/2
     root  (hd0,1)
     makeactive
     # chainload OS/2 bootloader from the first sector
     chainloader +1
     # This is similar to "chainload", but loads a specific file
     #chainloader /boot/chain.os2

   This will boot OS/2, using a chain-loader (*note Chain-loading::).

     # For booting Windows NT or Windows95
     title Windows NT / Windows 95 boot menu
     root        (hd0,0)
     makeactive
     chainloader +1
     # For loading DOS if Windows NT is installed
     # chainload /bootsect.dos

   The same as the above, but for Windows.

     # For installing GRUB into the hard disk
     title Install GRUB into the hard disk
     root    (hd0,0)
     setup   (hd0)

   This will just (re)install GRUB onto the hard disk.

     # Change the colors.
     title Change the colors
     color light-green/brown blink-red/blue

   In the last entry, the command `color' is used (*note color::), to
change the menu colors (try it!). This command is somewhat special,
because it can be used both in the command-line and in the menu. GRUB
has several such commands, see *Note General commands::.

   We hope that you now understand how to use the basic features of
GRUB. To learn more about GRUB, see the following chapters.


File: grub.info,  Node: Network,  Next: Serial terminal,  Prev: Configuration,  Up: Top

Downloading OS images from a network
************************************

   Although GRUB is a disk-based boot loader, it does provide network
support. To use the network support, you need to enable at least one
network driver in the GRUB build process. For more information please
see `netboot/README.netboot' in the source distribution.

* Menu:

* General usage of network support::
* Diskless::


File: grub.info,  Node: General usage of network support,  Next: Diskless,  Up: Network

How to set up your network
==========================

   GRUB requires a file server and optionally a server that will assign
an IP address to the machine on which GRUB is running. For the former,
only TFTP is supported at the moment. The latter is either BOOTP, DHCP
or a RARP server(1) (*note General usage of network
support-Footnote-1::). It is not necessary to run both the servers on
one computer. How to configure these servers is beyond the scope of this
document, so please refer to the manuals specific to those
protocols/servers.

   If you decided to use a server to assign an IP address, set up the
server and run `bootp' (*note bootp::), `dhcp' (*note dhcp::) or `rarp'
(*note rarp::) for BOOTP, DHCP or RARP, respectively. Each command will
show an assigned IP address, a netmask, an IP address for your TFTP
server and a gateway. If any of the addresses is wrong or it causes an
error, probably the configuration of your servers isn't set up properly.

   Otherwise, run `ifconfig', like this:

     grub> ifconfig --address=192.168.110.23 --server=192.168.110.14

   You can also use `ifconfig' in conjugation with `bootp', `dhcp' or
`rarp' (e.g. to reassign the server address manually). *Note
ifconfig::, for more details.

   Finally, download your OS images from your network. The network can
be accessed using the network drive `(nd)'. Everything else is very
similar to the normal instructions (*note Booting::).

   Here is an example:

     grub> bootp
     Probing... [NE*000]
     NE2000 base ...
     Address: 192.168.110.23    Netmask: 255.255.255.0
     Server: 192.168.110.14     Gateway: 192.168.110.1
     
     grub> root (nd)
     grub> kernel /tftproot/gnumach.gz root=sd0s1
     grub> module /tftproot/serverboot.gz
     grub> boot


File: grub.info,  Node: General usage of network support-Footnotes,  Up: General usage of network support

   (1) RARP is deprecated, since it cannot serve much information


File: grub.info,  Node: Diskless,  Prev: General usage of network support,  Up: Network

Booting from a network
======================

   It is sometimes very useful to boot from a network, especially, when
you use a machine which has no local disk. In this case, you need to
obtain a kind of Net Boot ROM, such as a PXE ROM or a free software
package like Etherboot. Such a Boot ROM first boots the machine, sets
up the network card installed into the machine, and downloads a second
stage boot image from the network. Then, the second image will try to
boot an operating system from the network actually.

   GRUB provides two second stage images, `nbgrub' and `pxegrub' (*note
Images::). Those images are the same as the normal Stage 2, except that
they set up a network automatically, and try to load a configuration
file from the network, if specified. The usage is very simple: If the
machine has a PXE ROM, use `pxegrub'. If the machine has a NBI loader
such as Etherboot, use `nbgrub'. There is no difference between them
but their formats. As how to load a second stage image you want to use
should be described in the manual on your Net Boot ROM, please refer to
the manual, for more information.

   However, there is one thing specific to GRUB. Namely, how to specify
a configuration file in a BOOTP/DHCP server. For now, GRUB uses the tag
`150', to get the name of a configuration file. This below is an
example about a BOOTP configuration:

     .allhost:hd=/tmp:bf=null:\
             :ds=145.71.35.1 145.71.32.1:\
             :sm=255.255.254.0:\
             :gw=145.71.35.1:\
             :sa=145.71.35.5:
     
     foo:ht=1:ha=63655d0334a7:ip=145.71.35.127:\
             :bf=/nbgrub:\
             :tc=.allhost:\
             :T150="(nd)/tftpboot/menu.lst.foo":

   Note that you should specify the drive name `(nd)' in the name of
the configuration file. That is because you can change the root drive
before downloading the configuration from the TFTP server, when the
preset menu feature is used (*note Preset Menu::).

   See the manual about your BOOTP/DHCP server, for more information.
The exact syntax should differ from the example, more or less.


File: grub.info,  Node: Serial terminal,  Next: Preset Menu,  Prev: Network,  Up: Top

Using GRUB via a serial line
****************************

   This chapter describes how to use the serial terminal support in
GRUB.

   If you have many computers or computers with no display/keyboard, it
would be very useful to control the computers with serial
communications. To connect a computer with another via a serial line,
you need to prepare a null-modem (cross) serial cable, and you may need
to have multiport serial boards, if your computer doesn't have extra
serial ports. In addition, a terminal emulator is also required, such as
minicom. Refer to a manual of your operating system, for more
information.

   As for GRUB, the instruction to set up a serial terminal is quite
simple. First of all, make sure that you haven't specified the option
`--disable-serial' to the configure script when you built your GRUB
images. If you get them in binary form, probably they have serial
terminal support already.

   Then, initialize your serial terminal after GRUB starts up. Here is
an example:

     grub> serial --unit=0 --speed=9600
     grub> terminal serial

   The command `serial' initializes the serial unit 0 with the speed
9600bps. The serial unit 0 is usually called `COM1', so, if you want to
use COM2, you must specify `--unit=1' instead. This command accepts
many other options, so please refer to *Note serial::, for more details.

   The command `terminal' (*note terminal::) chooses which type of
terminal you want to use. In that case above, the terminal will be a
serial terminal, but you can also pass `console' to the command, like
`terminal serial console'. In this case, a terminal in which you press
any key will be selected as a GRUB terminal.

   However, note that GRUB assumes that your terminal emulator is
compatible with VT100 by default. This is true for most terminal
emulators nowadays, but you should pass the option `--dumb' to the
command, if your terminal emulator is not VT100-compatible or
implements few VT100 escape sequences. If you specify the option, then
GRUB provides you with an alternative menu interface, because the normal
menu requires several fancy features for your terminal.


File: grub.info,  Node: Preset Menu,  Next: Security,  Prev: Serial terminal,  Up: Top

Embedding a configuration file into GRUB
****************************************

   GRUB supports "preset menu" which is always loaded before starting.
The preset menu feature is useful, for example, when your computer has
no console but a serial cable. In this case, it is critical to set up
the serial terminal as soon as possible, since you cannot see any
message until the serial terminal begins to work. So it is nice to run
the commands `serial' (*note serial::) and `terminal' (*note
terminal::) sooner than anything else at the start-up time.

   It is slightly complicated how the preset menu works:

  1. GRUB checks if the preset menu feature is used, and loads the
     preset menu, if available. This includes running commands and
     reading boot entries, like an ordinary configuration file.

  2. GRUB checks if the configuration file is available. Note that this
     check is performed *regardless of the existence of the preset
     menu*. The configuration file is loaded, even after the preset
     menu was loaded.

  3. When the preset menu includes any boot entries, they are cleared
     when the configuration file is loaded. It doesn't matter whether
     the configuration file has any entries or no entry. The boot
     entries in the preset menu are used only when GRUB fails in
     loading the configuration file.

   To enable the preset menu feature, you must specify a file to the
configure script with the option `--enable-preset-menu'. The file has
the same semantics as normal configuration files (*note
Configuration::).

   Another point you should take care is that the diskless support
(*note Diskless::) diverts the preset menu. Diskless images embed a
preset menu to execute the command `bootp' (*note bootp::)
automatically, unless you specify your own preset menu to the configure
script. This means that you must put commands to initialize a network in
the preset menu yourself, because diskless images don't set it up
implicitly, when you use the preset menu explicitly.

   Therefore, a typical preset menu used with diskless support would be
like this:

     # Set up the serial terminal, first of all.
     serial --unit=0 --speed=19200
     terminal --timeout=0 serial
     
     # Initialize the network.
     dhcp


File: grub.info,  Node: Security,  Next: Images,  Prev: Preset Menu,  Up: Top

Protecting your computer from cracking
**************************************

   You may be interested in how to prevent ordinary users from doing
whatever they like, if you share your computer with other people. So
this chapter describes how to improve the security of GRUB.

   One thing which could be a security hole is that the user can do too
many things with GRUB, because GRUB allows to modify its configuration
and run arbitrary commands at run-time. For example, the user can read
even `/etc/passwd' in the command-line interface by the command `cat'
(*note cat::). So it is necessary to disable all the interactive
operations.

   Thus, GRUB provides "password" feature, so that only administrators
can start the interactive operations (i.e. editing menu entries and
entering the command-line interface). To use this feature, you need to
run the command `password' in your configuration file (*note
password::), like this:

     password --md5 PASSWORD

   If this is specified, GRUB disallows any interactive control, until
you press the key <p> and enter a correct password.  The option `--md5'
tells GRUB that `PASSWORD' is in MD5 format.  If it is omitted, GRUB
assumes the `PASSWORD' is in clear text.

   You can encrypt your password with the command `md5crypt' (*note
md5crypt::). For example, run the grub shell (*note Invoking the grub
shell::), and enter your password:

     grub> md5crypt
     Password: **********
     Encrypted: $1$U$JK7xFegdxWH6VuppCUSIb.

   Then, cut and paste the encrypted password to your configuration
file.

   Also, you can specify an optional argument to `password'. See this
example:

     password PASSWORD /boot/grub/menu-admin.lst

   In this case, GRUB will load `/boot/grub/menu-admin.lst' as a
configuration file when you enter the valid password.

   Another thing which may be dangerous is that any user can choose any
menu entry. Usually, this wouldn't be problematic, but you might want to
permit only administrators to run some of your menu entries, such as an
entry for booting an insecure OS like DOS.

   GRUB provides the command `lock' (*note lock::). This command always
fails until you enter a valid password, so you can use it, like this:

     title Boot DOS
     lock
     rootnoverify (hd0,1)
     makeactive
     chainload +1

   You should insert `lock' right after `title', because any user can
execute commands in an entry, until GRUB encounters `lock'.

   You can also use the command `password' instead of `lock'. In this
case the boot process will ask for the password and stop if it was
entered incorrectly.  Since the `password' takes its own PASSWORD
argument this is useful if you want different passwords for different
entries.

