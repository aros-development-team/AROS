This is grub.info, produced by makeinfo version 4.0 from grub.texi.

INFO-DIR-SECTION Kernel
START-INFO-DIR-ENTRY
* GRUB: (grub).                 The GRand Unified Bootloader
* grub-install: (grub)Invoking grub-install.    Install GRUB on your drive
* grub-md5-crypt: (grub)Invoking grub-md5-crypt.        Encrypt a password
                                                        in MD5 format
* mbchk: (grub)Invoking mbchk.  Check for the format of a Multiboot kernel
END-INFO-DIR-ENTRY

   Copyright (C) 1996 Erich Boleyn Copyright (C) 1999, 2000, 2001 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: grub.info,  Node: Stage2 errors,  Prev: Stage1.5 errors,  Up: Troubleshooting

Errors reported by the Stage 2
==============================

   The general way that the Stage 2 handles errors is to abort the
operation in question, print an error string, then (if possible) either
continue based on the fact that an error occurred or wait for the user
to deal with the error.

   The following is a comprehensive list of error messages for the
Stage 2 (error numbers for the Stage 1.5 are listed before the colon in
each description):

1 : Filename must be either an absolute filename or blocklist
     This error is returned if a file name is requested which doesn't
     fit the syntax/rules listed in the *Note Filesystem::.

2 : Bad file or directory type
     This error is returned if a file requested is not a regular file,
     but something like a symbolic link, directory, or FIFO.

3 : Bad or corrupt data while decompressing file
     This error is returned if the run-length decompression code gets an
     internal error. This is usually from a corrupt file.

4 : Bad or incompatible header in compressed file
     This error is returned if the file header for a supposedly
     compressed file is bad.

5 : Partition table invalid or corrupt
     This error is returned if the sanity checks on the integrity of the
     partition table fail. This is a bad sign.

6 : Mismatched or corrupt version of stage1/stage2
     This error is returned if the install command is pointed to
     incompatible or corrupt versions of the stage1 or stage2. It can't
     detect corruption in general, but this is a sanity check on the
     version numbers, which should be correct.

7 : Loading below 1MB is not supported
     This error is returned if the lowest address in a kernel is below
     the 1MB boundary. The Linux zImage format is a special case and
     can be handled since it has a fixed loading address and maximum
     size.

8 : Kernel must be loaded before booting
     This error is returned if GRUB is told to execute the boot sequence
     without having a kernel to start.

9 : Unknown boot failure
     This error is returned if the boot attempt did not succeed for
     reasons which are unknown.

10 : Unsupported Multiboot features requested
     This error is returned when the Multiboot features word in the
     Multiboot header requires a feature that is not recognized. The
     point of this is that the kernel requires special handling which
     GRUB is likely unable to provide.

11 : Unrecognized device string
     This error is returned if a device string was expected, and the
     string encountered didn't fit the syntax/rules listed in the *Note
     Filesystem::.

12 : Invalid device requested
     This error is returned if a device string is recognizable but does
     not fall under the other device errors.

13 : Invalid or unsupported executable format
     This error is returned if the kernel image being loaded is not
     recognized as Multiboot or one of the supported native formats
     (Linux zImage or bzImage, FreeBSD, or NetBSD).

14 : Filesystem compatibility error, cannot read whole file
     Some of the filesystem reading code in GRUB has limits on the
     length of the files it can read. This error is returned when the
     user runs into such a limit.

15 : File not found
     This error is returned if the specified file name cannot be found,
     but everything else (like the disk/partition info) is OK.

16 : Inconsistent filesystem structure
     This error is returned by the filesystem code to denote an internal
     error caused by the sanity checks of the filesystem structure on
     disk not matching what it expects. This is usually caused by a
     corrupt filesystem or bugs in the code handling it in GRUB.

17 : Cannot mount selected partition
     This error is returned if the partition requested exists, but the
     filesystem type cannot be recognized by GRUB.

18 : Selected cylinder exceeds maximum supported by BIOS
     This error is returned when a read is attempted at a linear block
     address beyond the end of the BIOS translated area. This generally
     happens if your disk is larger than the BIOS can handle (512MB for
     (E)IDE disks on older machines or larger than 8GB in general).

19 : Linux kernel must be loaded before initrd
     This error is returned if the initrd command is used before
     loading a Linux kernel. Similar to the above error, it only makes
     sense in that case anyway.

20 : Multiboot kernel must be loaded before modules
     This error is returned if the module load command is used before
     loading a Multiboot kernel. It only makes sense in this case
     anyway, as GRUB has no idea how to communicate the presence of
     location of such modules to a non-Multiboot-aware kernel.

21 : Selected disk does not exist
     This error is returned if the device part of a device- or full
     file name refers to a disk or BIOS device that is not present or
     not recognized by the BIOS in the system.

22 : No such partition
     This error is returned if a partition is requested in the device
     part of a device- or full file name which isn't on the selected
     disk.

23 : Error while parsing number
     This error is returned if GRUB was expecting to read a number and
     encountered bad data.

24 : Attempt to access block outside partition
     This error is returned if a linear block address is outside of the
     disk partition. This generally happens because of a corrupt
     filesystem on the disk or a bug in the code handling it in GRUB
     (it's a great debugging tool).

25 : Disk read error
     This error is returned if there is a disk read error when trying to
     probe or read data from a particular disk.

26 : Too many symbolic links
     This error is returned if the link count is beyond the maximum
     (currently 5), possibly the symbolic links are looped.

27 : Unrecognized command
     This error is returned if an unrecognized command is entered into
     the command-line or in a boot sequence section of a configuration
     file and that entry is selected.

28 : Selected item cannot fit into memory
     This error is returned if a kernel, module, or raw file load
     command is either trying to load its data such that it won't fit
     into memory or it is simply too big.

29 : Disk write error
     This error is returned if there is a disk write error when trying
     to write to a particular disk. This would generally only occur
     during an install of set active partition command.

30 : Invalid argument
     This error is returned if an argument specified to a command is
     invalid.

31 : File is not sector aligned
     This error may occur only when you access a ReiserFS partition by
     block-lists (e.g. the command `install'). In this case, you should
     mount the partition with the `-o notail' option.

32 : Must be authenticated
     This error is returned if you try to run a locked entry. You should
     enter a correct password before running such an entry.

33 : Serial device not configured
     This error is returned if you try to change your terminal to a
     serial one before initializing any serial device.


File: grub.info,  Node: Invoking the grub shell,  Next: Invoking grub-install,  Prev: Troubleshooting,  Up: Top

Invoking the grub shell
***********************

   This chapter documents the grub shell `grub'. Note that the grub
shell is an emulator; it doesn't run under the native environment, so it
sometimes does something wrong. Therefore, you shouldn't trust it too
much. If there is anything wrong with it, don't hesitate to try the
native GRUB environment, especially when it guesses a wrong map between
BIOS drives and OS devices.

* Menu:

* Basic usage::                 How to use the grub shell
* Installation under UNIX::     How to install GRUB via `grub'
* Device map::                  The map between BIOS drives and OS devices


File: grub.info,  Node: Basic usage,  Next: Installation under UNIX,  Up: Invoking the grub shell

Introduction into the grub shell
================================

   You can use the command `grub' for installing GRUB under your
operating systems and for a testbed when you add a new feature into GRUB
or when fix a bug. `grub' is almost the same as the Stage 2, and, in
fact, it shares the source code with the Stage 2 and you can use the
same commands (*note Commands::) in `grub'. It is emulated by replacing
BIOS calls with UNIX system calls and libc functions.

   The command `grub' accepts the following options:

`--help'
     Print a summary of the command-line options and exit.

`--version'
     Print the version number of GRUB and exit.

`--verbose'
     Print some verbose messages for debugging purpose.

`--device-map=FILE'
     Use the device map file FILE. The format is described in *Note
     Device map::.

`--no-floppy'
     Do not probe any floppy drive. This option has no effect if the
     option `--device-map' is specified (*note Device map::).

`--probe-second-floppy'
     Probe the second floppy drive. If this option is not specified,
     the grub shell does not probe it, as that sometimes takes a long
     time. If you specify the device map file (*note Device map::), the
     grub shell just ignores this option.

`--config-file=FILE'
     Read the configuration file FILE instead of `/boot/grub/menu.lst'.
     The format is the same as the normal GRUB syntax. See *Note
     Filesystem::, for more information.

`--boot-drive=DRIVE'
     Set the stage2 BOOT_DRIVE to DRIVE. This argument should be an
     integer (decimal, octal or hexadecimal).

`--install-partition=PAR'
     Set the stage2 INSTALL_PARTITION to PAR. This argument should be
     an integer (decimal, octal or hexadecimal).

`--no-config-file'
     Do not use the configuration file even if it can be read.

`--no-curses'
     Do not use the curses interface even if it is available.

`--batch'
     This option has the same meaning as `--no-config-file --no-curses'.

`--read-only'
     Disable writing to any disk.

`--hold'
     Wait until a debugger will attach. This option is useful when you
     want to debug the startup code.


File: grub.info,  Node: Installation under UNIX,  Next: Device map,  Prev: Basic usage,  Up: Invoking the grub shell

How to install GRUB via `grub'
==============================

   The installation procedure is the same as under the "native" Stage
2. *Note Installation::, for more information. The command
`grub'-specific information is described here.

   What you should be careful about is "buffer cache". `grub' makes use
of raw devices instead of filesystems that your operating systems
serve, so there exists a potential problem that some cache
inconsistency may corrupt your filesystems. What we recommend is:

   * If you can unmount drives to which GRUB may write any amount of
     data, unmount them before running `grub'.

   * If a drive cannot be unmounted but can be mounted with the
     read-only flag, mount it in read-only mode. That should be secure.

   * If a drive must be mounted with the read-write flag, make sure
     that any activity is not being done on it during running the
     command `grub'.

   * Reboot your operating system as soon as possible. Probably that is
     not required if you follow these rules above, but reboot is the
     most secure way.

   In addition, enter the command `quit' when you finish the
installation. That is _very important_ because `quit' makes the buffer
cache consistent. Do not push <C-c>.

   If you want to install GRUB non-interactively, specify `--batch'
option in the command-line. This is a simple example:

     #!/bin/sh
     
     # Use /usr/sbin/grub if you are on an older system.
     /sbin/grub --batch <<EOT 1>/dev/null 2>/dev/null
     root (hd0,0)
     setup (hd0)
     quit
     EOT


File: grub.info,  Node: Device map,  Prev: Installation under UNIX,  Up: Invoking the grub shell

The map between BIOS drives and OS devices
==========================================

   When you specify the option `--device-map' (*note Basic usage::),
the grub shell creates the "device map file" automatically unless it
already exists. The file name `/boot/grub/device.map' is preferred.

   If the device map file exists, the grub shell reads it to map BIOS
drives to OS devices. This file consists of lines like this:

     DEVICE FILE

   DEVICE is a drive, which syntax is the same as the one in GRUB
(*note Device syntax::), and FILE is an OS's file, which is normally a
device file.

   The reason why the grub shell gives you the device map file is that
it cannot guess the map between BIOS drives and OS devices correctly in
some environments. For example, if you exchange the boot sequence
between IDE and SCSI in your BIOS, it mistakes the order.

   Thus, edit the file if the grub shell makes a mistake. You can put
any comments in the file if needed, as the grub shell assumes that a
line is just a comment if the first character is `#'.


File: grub.info,  Node: Invoking grub-install,  Next: Invoking grub-md5-crypt,  Prev: Invoking the grub shell,  Up: Top

Invoking grub-install
*********************

   The program `grub-install' installs GRUB on your drive by the grub
shell (*note Invoking the grub shell::). You must specify the device
name on which you want to install GRUB, like this:

     grub-install INSTALL_DEVICE

   The device name INSTALL_DEVICE is an OS device name or a GRUB device
name.

   `grub-install' accepts the following options:

`--help'
     Print a summary of the command-line options and exit.

`--version'
     Print the version number of GRUB and exit.

`--force-lba'
     Force GRUB to use LBA mode even for a buggy BIOS. Use this option
     only if your BIOS doesn't work in LBA mode even though it supports
     LBA mode.

`--root-directory=DIR'
     Install GRUB images under the directory DIR instead of the root
     directory. This option is useful when you want to install GRUB
     into a separate partition or a removable disk. Here is an example
     when you have a separate "boot" partition which is mounted on
     `/boot':

          grub-install --root-directory=/boot '(hd0)'

`--grub-shell=FILE'
     Use FILE as the grub shell. You can append arbitrary options to
     FILE after the file name, like this:

          grub-install --grub-shell="grub --read-only" /dev/fd0

`--recheck'
     Recheck the device map, even if `/boot/grub/device.map' already
     exists. You should use this option whenever you add/remove a disk
     into/from your computer.


File: grub.info,  Node: Invoking grub-md5-crypt,  Next: Invoking mbchk,  Prev: Invoking grub-install,  Up: Top

Invoking grub-md5-crypt
***********************

   The program `grub-md5-crypt' encrypts a password in MD5 format.
This is just a frontend of the grub shell (*note Invoking the grub
shell::). Passwords encrypted by this program can be used with the
command `password' (*note password::).

   `grub-md5-crypt' accepts the following options:

`--help'
     Print a summary of the command-line options and exit.

`--version'
     Print the version information and exit.

`--grub-shell=FILE'
     Use FILE as the grub shell.


File: grub.info,  Node: Invoking mbchk,  Next: FAQ,  Prev: Invoking grub-md5-crypt,  Up: Top

Invoking mbchk
**************

   The program `mbchk' checks for the format of a Multiboot kernel. We
recommend using this program before booting your own kernel by GRUB.

   `mbchk' accepts the following options:

`--help'
     Print a summary of the command-line options and exit.

`--version'
     Print the version number of GRUB and exit.

`--quiet'
     Suppress all normal output.


File: grub.info,  Node: FAQ,  Next: Obtaining and Building GRUB,  Prev: Invoking mbchk,  Up: Top

Frequently asked questions
**************************

How does GNU GRUB differ from Erich's original GRUB?
     GNU GRUB is the successor of Erich's great GRUB. He couldn't work
     on GRUB because of some other tasks, so the current maintainers
     OKUJI Yoshinori and Gordon Matzigkeit took over the
     maintainership, and opened the development in order for everybody
     to participate it.

     Technically speaking, GNU GRUB has many features that are not seen
     in the original GRUB. For example, GNU GRUB can be installed on
     UNIX-like operating system (such as GNU/Hurd) via the grub shell
     `/sbin/grub' (or `/usr/sbin/grub' on older systems), it supports
     Logical Block Address (LBA) mode that solves the 1024 cylinders
     problem, and `<TAB>' completes a file name when it's unique. Of
     course, many bug fixes are done as well, so it is recommended to
     use GNU GRUB.

Can GRUB boot my operating system from over 8GB hard disks?
     That depends on your BIOS and your operating system. You must make
     sure that your drive is accessible in LBA mode. Generally, that is
     configurable in BIOS setting utility. Read the manual for your BIOS
     for more information.

     Furthermore, some operating systems (i.e. DOS) cannot access any
     large disk, so the problem is not solved by any kind of boot
     loader. GNU/Hurd and GNU/Linux can surely boot from such a large
     disk.

Can I put Stage2 into a partition which is over 1024 cylinders?
     Yes, if your BIOS supports the LBA mode.

How to create a GRUB boot floppy with the menu interface?
     The easiest way is:

       1. Create filesystem in your floppy disk. For example:

               $ mke2fs /dev/fd0

       2. Mount it on somewhere, say, `/mnt'.

       3. Copy the GRUB images to `/mnt/boot/grub'. Only `stage1',
          `stage2' and `menu.lst' are necessary. You may not copy
          "stage1.5"s.

       4. Run the following command (substitute `/usr/sbin/grub' for
          `/sbin/grub' if you are using an older system):

               $ /sbin/grub --batch <<EOT
               root (fd0)
               setup (fd0)
               quit
               EOT

How to specify a partition?
     *Note Device syntax::.

GRUB does not recognize my GNU/Hurd partition.
     I don't know why, but the authors of FDISK programs have assigned
     the partition type `0x63' to GNU Hurd incorrectly. A partition type
     should mean what format is used in the partition, such as
     filesystem and BSD slices, and should not be used to represent
     what operating system owns the partition. So use `0x83' if the
     partition contains ext2fs filesystem, and use `0xA5' if the
     partition contains ffs filesystem, whether the partition owner is
     Hurd or not. We will use `0x63' for GNU Hurd filesystem that has
     not been implemented yet.

I've installed a recent version of binutils, but GRUB still crashes.
     Please check for the version of your binutils by this command:

          ld -v

     This will show two versions, but only the latter is important. If
     the version is identical with what you have installed, the
     installation was not bad.

     Well, please try:

          gcc -Wl,-v 2>&1 | grep "GNU ld"

     If this is not identical with the result above, you should specify
     the directory where you have installed binutils for the script
     configure, like this:

          ./configure --with-binutils=/usr/local/bin

     If you follow the instructions above but GRUB still crashes,
     probably there is a serious bug in GRUB. *Note Reporting bugs::.

GRUB hangs up when accessing my SCSI disk.
     Check if you have turned on the support for INT 13 extension
     (LBA). If so, disable the support and see if GRUB can now access
     your SCSI disk. This will make it clear that your SCSI BIOS sucks.

     For now, we know the following doesn't provide working LBA mode:


          Adaptec AIC-7880

     In the case where you have such a SCSI controller unfortunately,
     you cannot use the LBA mode, though GRUB still works fine in the
     CHS mode (so the well-known 1024 cylinders problem comes again to
     you).

     *Caution:* Actually it has not been verified yet if this bug is
     due to the SCSI BIOS or GRUB itself, frankly speaking. Because the
     developers haven't seen it by their own eyes. This is why it is
     desirable that you investigate the cause seriously if you have the
     skill.

How can I specify an arbitrary memory size to Linux?
     Pass a `mem=' option to your Linux kernel, like this:

          grub> kernel /vmlinuz mem=128M

     You may pass other options in the same way. See *Note GNU/Linux::,
     for more details.

I have a separate boot partition and GRUB doesn't recognize it.
     This is often reported as a "bug", but this is not a bug really.
     This is a feature.

     Because GRUB is a boot loader and it normally runs under no
     operating system, it doesn't know where a partition is mounted
     under your operating systems. So, if you have the partition
     `/boot' and you install GRUB images into the directory
     `/boot/grub', GRUB recognizes that the images lies under the
     directory `/grub' but not `/boot/grub'. That's fine, since there
     is no guarantee that all of your operating systems mount the same
     partition as `/boot'.

     There are several solutions for this situation.

       1. Install GRUB into the directory `/boot/boot/grub' instead of
          `/boot/grub'. This may sound ugly but should work fine.

       2. Create a symbolic link before installing GRUB, like `cd /boot
          && ln -s . boot'. This works only if the filesystem of the
          boot partition supports symbolic links and GRUB supports the
          feature as well.

       3. Install GRUB with the command `install', to specify the paths
          of GRUB images explicitly. Here is an example:

               grub> root (hd0,1)
               grub> install /grub/stage1 d (hd0) /grub/stage2 p /grub/menu.lst

How to uninstall GRUB from my hard disk drive?
     There is no concept "uninstall" in boot loaders, because if you
     "uninstall" a boot loader, an unbootable machine would simply
     remain. So all you need to do is overwrite another boot loader you
     like to your disk, that is, install the boot loader without
     uninstalling GRUB.

     For example, if you want to install the boot loader for Windows,
     just run `FDISK /MBR' on Windows. If you want to install LILO(1)
     (*note FAQ-Footnote-1::), run `/sbin/lilo' on GNU/Linux.

GRUB hangs when accessing my large IDE disk.
     If your disk is bigger than 32GB, probably updating your mainboard
     BIOS will solve your problem. This bug is well-known and most
     vendors should provide fixed versions. For example, if you have
     ASUS-P3BF, upgrading the BIOS to V1007beta1 or later can fix it.
     Please ask your vendor, for more information.

Why don't Linux, FreeBSD, NetBSD, etc. become Multiboot-compliant?
     Please ask the relevant maintainers. If all free kernels were
     Multiboot-compliant (*note Multiboot Specification:
     (multiboot)Top.), the world would be an utopia...


File: grub.info,  Node: FAQ-Footnotes,  Up: FAQ

   (1) I can't imagine why you want to do such a thing, though


File: grub.info,  Node: Obtaining and Building GRUB,  Next: Reporting bugs,  Prev: FAQ,  Up: Top

How to obtain and build GRUB
****************************

     *Caution:* GRUB requires binutils-2.9.1.0.23 or later because the
     GNU assembler has been changed so that it can produce real 16bits
     machine code between 2.9.1 and 2.9.1.0.x. See
     `http://sourceware.cygnus.com/binutils/', to obtain information on
     how to get the latest version.

   GRUB is available from the GNU alpha archive site
`ftp://alpha.gnu.org/gnu/grub' or any of its mirrors. The file will be
named grub-version.tar.gz. The current version is 0.90, so the file you
should grab is:

   `ftp://alpha.gnu.org/gnu/grub/grub-0.90.tar.gz'

   To unbundle GRUB use the instruction:

     zcat grub-0.90.tar.gz | tar xvf -

   which will create a directory called `grub-0.90' with all the
sources. You can look at the file `INSTALL' for detailed instructions
on how to build and install GRUB, but you should be able to just do:

     cd grub-0.90
     ./configure
     make install

   This will install the grub shell `grub' (*note Invoking the grub
shell::), the Multiboot checker `mbchk' (*note Invoking mbchk::), and
the GRUB images. This will also install the GRUB manual.

   Also, the latest version is available from the CVS. The repository
is:

   `:pserver:anoncvs@subversions.gnu.org:/cvsroot/grub'

   and the module is:

   `grub'

   The password for anoncvs is empty. So the instruction is:

     cvs -d :pserver:anoncvs@subversions.gnu.org:/cvsroot/grub login
     Password: <ENTER>
     cvs -d :pserver:anoncvs@subversions.gnu.org:/cvsroot/grub co grub


File: grub.info,  Node: Reporting bugs,  Next: Future,  Prev: Obtaining and Building GRUB,  Up: Top

Reporting bugs
**************

   This is the guideline of how to report bugs. Take a look at this list
below before you send e-mail to <bug-grub@gnu.org>:

  1. Before unsettled, read this manual through and through, in
     particular *Note FAQ::.

  2. Always mention the information on your GRUB. The version number
     and the configuration are quite important. If you build it
     yourself, write the options specified to the configure script and
     your operating system, including the versions of gcc and binutils.

  3. If you get troubled with the installation, inform us of how you
     installed GRUB. Don't omit error messages, if any. Just `GRUB hangs
     up when it boots' is not enough.

     The information on your hardware is also essential. These are
     especially important: the geometries and the partition tables of
     your hard disk drives and your BIOS.

  4. If GRUB cannot boot your operating system, write down _all_ on the
     screen. Don't paraphrase them, like `The foo OS crashes with GRUB,
     even though it can boot with the bar boot loader fine'. Mention the
     commands you executed, the messages printed by them, and
     information on your operating system including the version number.

  5. Explain what you wanted to do. It is very useful to know your
     purpose and your wish, and how GRUB didn't satisfy you.

  6. If you can investigate the problem yourself, please do. That will
     give you and us much more information on the problem. Attaching a
     patch is even better.

     When you attach a patch, make the patch in unified diff format, and
     write ChangeLog entries. But, even when you make a patch, don't
     forget to explain the problem, so that we can understand what your
     patch is for.

  7. Write down anything that you think might be related. Please
     understand that we often need to reproduce the same problem you
     encounterred in our environment. So your information should be
     sufficient for us to do the same thing--Don't forget that we
     cannot see your computer directly. If you are not sure whether to
     state a fact or leave it out, state it!  Reporting too many things
     is quite better than omitting an important thing.

   If you realize the guideline above, send e-mail to
<bug-grub@gnu.org>, and we will try to fix the bugs.


File: grub.info,  Node: Future,  Next: Internals,  Prev: Reporting bugs,  Up: Top

Where GRUB will go
******************

   Here are some ideas that might happen in the future:

   * Support dynamic loading.

   * Add real memory management.

   * Add a real scripting language.

   * Support internationalization.

   * Support other architectures than i386-pc.

   See the file `TODO' in the source distribution, for more information.


File: grub.info,  Node: Internals,  Next: Index,  Prev: Future,  Up: Top

Hacking GRUB
************

   This chapter documents the user-invisible aspect of GRUB.

   As a general rule of software development, it is impossible to keep
the descriptions of the internals up-to-date, and it is quite hard to
document everything. So refer to the source code, whenever you are not
satisfied with this documentation.  Please assume that this gives just
hints to you.

* Menu:

* Memory map::                  The memory map of various components
* Embedded data::               Embedded variables in GRUB
* Filesystem interface::        The generic interface for filesystems
* Command interface::           The generic interface for built-ins
* Bootstrap tricks::            The bootstrap mechanism used in GRUB
* I/O ports detection::         How to probe I/O ports used by INT 13H
* Memory detection::            How to detect all installed RAM
* Low-level disk I/O::          INT 13H disk I/O interrupts
* MBR::                         The structure of Master Boot Record
* Partition table::             The format of partition tables
* Submitting patches::          Where and how you should send patches


File: grub.info,  Node: Memory map,  Next: Embedded data,  Up: Internals

The memory map of various components
====================================

   GRUB consists of two distinct components, called "stages", which are
loaded at different times in the boot process. Because they run
mutual-exclusively, sometimes a memory area overlaps with another
memory area. And, even in one stage, a single memory area can be used
for various purposes, because their usages are mutually exclusive.

   Here is the memory map of the various components:

0 to 4K-1
     BIOS and real mode interrupts

0x07BE to 0x07FF
     Partition table passed to another boot loader

down from 8K-1
     Real mode stack

0x2000 to ?
     The optional Stage 1.5 is loaded here

0x2000 to 0x7FFF
     Command-line buffer for Multiboot kernels and modules

0x7C00 to 0x7DFF
     Stage 1 is loaded here by BIOS or another boot loader

0x7F00 to 0x7F42
     LBA drive parameters

0x8000 to ?
     Stage2 is loaded here

The end of Stage 2 to 416K-1
     Heap, in particular used for the menu

down from 416K-1
     Protected mode stack

416K to 448K-1
     Filesystem buffer

448K to 479.5K-1
     Raw device buffer

479.5K to 480K-1
     512-byte scratch area

480K to 512K-1
     Buffers for various functions, such as password, command-line, cut
     and paste, and completion.

The last 1K of lower memory
     Disk swapping code and data

   See the file `stage2/shared.h', for more information.


File: grub.info,  Node: Embedded data,  Next: Filesystem interface,  Prev: Memory map,  Up: Internals

Embedded variables in GRUB
==========================

   Stage 1 and Stage 2 have embedded variables whose locations are
well-defined, so that the installation can patch the binary file
directly without recompilation of the stages.

   In Stage 1, these are defined:

`0x3E'
     The version number (not GRUB's, but the installation mechanism's).

`0x40'
     The boot drive. If it is 0xFF, use a drive passed by BIOS.

`0x41'
     The flag for if forcing LBA.

`0x42'
     The starting address of Stage 2.

`0x44'
     The first sector of Stage 2.

`0x48'
     The starting segment of Stage 2.

`0x1FE'
     The signature (`0xAA55').

   See the file `stage1/stage1.S', for more information.

   In the first sector of Stage 1.5 and Stage 2, the block lists are
recorded between `firstlist' and `lastlist'. The address of `lastlist'
is determined when assembling the file `stage2/start.S'.

   The trick here is that it is actually read backward, and the first
8-byte block list is not read here, but after the pointer is decremented
8 bytes, then after reading it, it decrements again, reads, and so on,
until it is finished. The terminating condition is when the number of
sectors to be read in the next block list is zero.

   The format of a block list can be seen from the example in the code
just before the `firstlist' label. Note that it is always from the
beginning of the disk, but _not_ relative to the partition boundaries.

   In the second sector of Stage 1.5 and Stage 2, these are defined:

`0x6'
     The version number (likewise, the installation mechanism's).

`0x8'
     The installed partition.

`0xC'
     The saved entry number.

`0x10'
     The identifier.

`0x11'
     The flag for if forcing LBA.

`0x12'
     The version string (GRUB's).

`0x12' + "the length of the version string"
     The name of a configuration file.

   See the file `stage2/asm.S', for more information.


File: grub.info,  Node: Filesystem interface,  Next: Command interface,  Prev: Embedded data,  Up: Internals

The generic interface for filesystems
=====================================

   For any particular partition, it is presumed that only one of the
"normal" filesystems such as FAT, FFS, or ext2fs can be used, so there
is a switch table managed by the functions in `disk_io.c'. The notation
is that you can only "mount" one at a time.

   The block list filesystem has a special place in the system. In
addition to the "normal" filesystem (or even without one mounted), you
can access disk blocks directly (in the indicated partition) via the
block list notation. Using the block list filesystem doesn't effect any
other filesystem mounts.

   The variables which can be read by the filesystem backend are:

`current_drive'
     The current BIOS drive number (numbered from 0, if a floppy, and
     numbered from 0x80, if a hard disk).

`current_partition'
     The current partition number.

`current_slice'
     The current partition type.

`saved_drive'
     The "drive" part of the root device.

`saved_partition'
     The "partition" part of the root device.

`part_start'
     The current partition starting address, in sectors.

`part_length'
     The current partition length, in sectors.

`print_possibilities'
     True when the `dir' function should print the possible completions
     of a file, and false when it should try to actually open a file of
     that name.

`FSYS_BUF'
     Filesystem buffer which is 32K in size, to use in any way which the
     filesystem backend desires.

   The variables which need to be written by a filesystem backend are:

`filepos'
     The current position in the file, in sectors.

     *Caution:* the value of FILEPOS can be changed out from under the
     filesystem code in the current implementation. Don't depend on it
     being the same for later calls into the backend code!

`filemax'
     The length of the file.

`disk_read_func'
     The value of DISK_READ_HOOK _only_ during reading of data for the
     file, not any other fs data, inodes, FAT tables, whatever, then
     set to `NULL' at all other times (it will be `NULL' by default).
     If this isn't done correctly, then the `testload' and `install'
     commands won't work correctly.

   The functions expected to be used by the filesystem backend are:

`devread'
     Only read sectors from within a partition. Sector 0 is the first
     sector in the partition.

`grub_read'
     If the backend uses the block list code, then `grub_read' can be
     used, after setting BLOCK_FILE to 1.

`print_a_completion'
     If PRINT_POSSIBILITIES is true, call `print_a_completion' for each
     possible file name. Otherwise, the file name completion won't work.

   The functions expected to be defined by the filesystem backend are
described at least moderately in the file `filesys.h'. Their usage is
fairly evident from their use in the functions in `disk_io.c', look for
the use of the FSYS_TABLE array.

   *Caution:* The semantics are such that then `mount'ing the
filesystem, presume the filesystem buffer `FSYS_BUF' is corrupted, and
(re-)load all important contents. When opening and reading a file,
presume that the data from the `mount' is available, and doesn't get
corrupted by the open/read (i.e. multiple opens and/or reads will be
done with only one mount if in the same filesystem).


File: grub.info,  Node: Command interface,  Next: Bootstrap tricks,  Prev: Filesystem interface,  Up: Internals

The generic interface for built-ins
===================================

   GRUB built-in commands are defined in a uniformal interface, whether
they are menu-specific or can be used anywhere. The definition of a
builtin command consists of two parts: the code itself and the table of
the information.

   The code must be a function which takes two arguments, a command-line
string and flags, and returns an `int' value. The "flags" argument
specifies how the function is called, using a bit mask. The return
value must be zero if successful, otherwise non-zero. So it is normally
enough to return ERRNUM.

   The table of the information is represented by the structure `struct
builtin', which contains the name of the command, a pointer to the
function, flags, a short description of the command and a long
description of the command. Since the descriptions are used only for
help messages interactively, you don't have to define them, if the
command may not be called interactively (such as `title').

   The table is finally registered in the table BUILTIN_TABLE, so that
`run_script' and `enter_cmdline' can find the command. See the files
`cmdline.c' and `builtins.c', for more details.


File: grub.info,  Node: Bootstrap tricks,  Next: I/O ports detection,  Prev: Command interface,  Up: Internals

The bootstrap mechanism used in GRUB
====================================

   The disk space can be used in a boot loader is very restricted
because a MBR (*note MBR::) is only 512 bytes but it also contains a
partition table (*note Partition table::) and a BPB. So the question is
how to make a boot loader code enough small to be fit in a MBR.

   However, GRUB is a very large program, so we break GRUB into 2 (or 3)
distinct components, "Stage 1" and "Stage 2" (and optionally "Stage
1.5"). *Note Memory map::, for more information.

   We embed Stage 1 in a MBR or in the boot sector of a partition, and
place Stage 2 in a filesystem. The optional Stage 1.5 can be installed
in a filesystem, in the "boot loader" area in a FFS or a ReiserFS, and
in the sectors right after a MBR, because Stage 1.5 is enough small and
the sectors right after a MBR is normally an unused region. The size of
this region is the number of sectors per head minus 1.

   Thus, all Stage1 must do is just load Stage2 or Stage1.5. But even if
Stage 1 needs not to support the user interface or the filesystem
interface, it is impossible to make Stage 1 less than 400 bytes, because
GRUB should support both the CHS mode and the LBA mode (*note Low-level
disk I/O::).

   The solution used by GRUB is that Stage 1 loads only the first
sector of Stage 2 (or Stage 1.5) and Stage 2 itself loads the rest. The
flow of Stage 1 is:

  1. Initialize the system briefly.

  2. Detect the geometry and the accessing mode of the "loading drive".

  3. Load the first sector of Stage 2.

  4. Jump to the starting address of the Stage 2.

   The flow of Stage 2 (and Stage 1.5) is:

  1. Load the rest of itself to the real starting address, that is, the
     starting address plus 512 bytes. The block lists are stored in the
     last part of the first sector.

  2. Long jump to the real starting address.

   Note that Stage 2 (or Stage 1.5) does not probe the geometry or the
accessing mode of the "loading drive", since Stage 1 has already probed
them.


File: grub.info,  Node: I/O ports detection,  Next: Memory detection,  Prev: Bootstrap tricks,  Up: Internals

How to probe I/O ports used by INT 13H
======================================

   FIXME: I will write this chapter after implementing the new
technique.


File: grub.info,  Node: Memory detection,  Next: Low-level disk I/O,  Prev: I/O ports detection,  Up: Internals

How to detect all installed RAM
===============================

   FIXME: I doubt if Erich didn't write this chapter only himself
wholly, so I will rewrite this chapter.


File: grub.info,  Node: Low-level disk I/O,  Next: MBR,  Prev: Memory detection,  Up: Internals

INT 13H disk I/O interrupts
===========================

   FIXME: I'm not sure where some part of the original chapter is
derived, so I will rewrite this chapter.


File: grub.info,  Node: MBR,  Next: Partition table,  Prev: Low-level disk I/O,  Up: Internals

The structure of Master Boot Record
===================================

   FIXME: Likewise.


File: grub.info,  Node: Partition table,  Next: Submitting patches,  Prev: MBR,  Up: Internals

The format of partition tables
==============================

   FIXME: Probably the original chapter is derived from "How It Works",
so I will rewrite this chapter.


File: grub.info,  Node: Submitting patches,  Prev: Partition table,  Up: Internals

Where and how you should send patches
=====================================

   When you write patches for GRUB, please send them to the mailing list
<bug-grub@gnu.org>. Here is the list of items of which you should take
care:

   * Please make your patch as small as possible. Generally, it is not
     a good thing to make one big patch which changes many things.
     Instead, segregate features and produce many patches.

   * Use as late code as possible, for the original code. The CVS
     repository always has the current version (*note Obtaining and
     Building GRUB::).

   * Write ChangeLog entries. *Note Change Logs: (standards)Change
     Logs, if you don't know how to write ChangeLog.

   * Make patches in unified diff format. `diff -urN' is appropriate in
     most cases.

   * Don't make patches reversely. Reverse patches are difficult to
     read and use.

   * Be careful enough of the license term and the copyright. Because
     GRUB is under GNU General Public License, you may not steal code
     from software whose license is incompatible against GPL. And, if
     you copy code written by others, you must not ignore their
     copyrights. Feel free to ask GRUB maintainers, whenever you are
     not sure what you should do.

   * If your patch is too large to send in e-mail, put it at somewhere
     we can see. Usually, you shouldn't send e-mail over 20K.


File: grub.info,  Node: Index,  Prev: Internals,  Up: Top

Index
*****

* Menu:

* blocklist:                             blocklist.
* boot:                                  boot.
* bootp:                                 bootp.
* cat:                                   cat.
* chainloader:                           chainloader.
* cmp:                                   cmp.
* color:                                 color.
* configfile:                            configfile.
* current_drive:                         Filesystem interface.
* current_partition:                     Filesystem interface.
* current_slice:                         Filesystem interface.
* debug:                                 debug.
* default:                               default.
* device:                                device.
* devread:                               Filesystem interface.
* dhcp:                                  dhcp.
* disk_read_func:                        Filesystem interface.
* displayapm:                            displayapm.
* displaymem:                            displaymem.
* embed:                                 embed.
* fallback:                              fallback.
* filemax:                               Filesystem interface.
* filepos:                               Filesystem interface.
* find:                                  find.
* fstest:                                fstest.
* FSYS_BUF:                              Filesystem interface.
* geometry:                              geometry.
* grub_read:                             Filesystem interface.
* halt:                                  halt.
* help:                                  help.
* hiddenmenu:                            hiddenmenu.
* hide:                                  hide.
* ifconfig:                              ifconfig.
* impsprobe:                             impsprobe.
* initrd:                                initrd.
* install:                               install.
* ioprobe:                               ioprobe.
* kernel:                                kernel.
* lock:                                  lock.
* makeactive:                            makeactive.
* map:                                   map.
* md5crypt:                              md5crypt.
* module:                                module.
* modulenounzip:                         modulenounzip.
* part_length:                           Filesystem interface.
* part_start:                            Filesystem interface.
* partnew:                               partnew.
* parttype:                              parttype.
* password:                              password.
* pause:                                 pause.
* print_a_completion:                    Filesystem interface.
* print_possibilities:                   Filesystem interface.
* quit:                                  quit.
* rarp:                                  rarp.
* read:                                  read.
* reboot:                                reboot.
* root:                                  root.
* rootnoverify:                          rootnoverify.
* saved_drive:                           Filesystem interface.
* saved_partition:                       Filesystem interface.
* savedefault:                           savedefault.
* serial:                                serial.
* setkey:                                setkey.
* setup:                                 setup.
* terminal:                              terminal.
* testload:                              testload.
* testvbe:                               testvbe.
* tftpserver:                            tftpserver.
* timeout:                               timeout.
* title:                                 title.
* unhide:                                unhide.
* uppermem:                              uppermem.
* vbeprobe:                              vbeprobe.


