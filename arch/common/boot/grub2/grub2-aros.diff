diff -pruN -x .svn grub2.old/INSTALL grub2/INSTALL
--- grub2.old/INSTALL	2009-09-05 19:38:16.000000000 +0100
+++ grub2/INSTALL	2009-09-04 16:13:52.000000000 +0100
@@ -54,7 +54,7 @@ The simplest way to compile this package
      of System V, you might need to type `sh ./configure' instead to
      prevent `csh' from trying to execute `configure' itself.
 
-     Running `configure' takes awhile.  While running, it prints some
+     Running `configure' takes a while.  While running, it prints some
      messages telling which features it is checking for.
 
   2. Type `make' to compile the package.
diff -pruN -x .svn grub2.old/disk/i386/pc/biosdisk.c grub2/disk/i386/pc/biosdisk.c
--- grub2.old/disk/i386/pc/biosdisk.c	2009-08-26 16:25:33.000000000 +0100
+++ grub2/disk/i386/pc/biosdisk.c	2009-09-05 19:41:22.000000000 +0100
@@ -142,8 +142,8 @@ grub_biosdisk_open (const char *name, gr
 	      if (drp->total_sectors)
 		total_sectors = drp->total_sectors;
 	      else
-                /* Some buggy BIOSes doesn't return the total sectors
-                   correctly but returns zero. So if it is zero, compute
+                /* Some buggy BIOSes don't return the total sectors
+                   correctly but return zero. So if it is zero, compute
                    it by C/H/S returned by the LBA BIOS call.  */
                 total_sectors = drp->cylinders * drp->heads * drp->sectors;
 	    }
diff -pruN -x .svn grub2.old/font/font.c grub2/font/font.c
--- grub2.old/font/font.c	2009-08-26 16:25:49.000000000 +0100
+++ grub2/font/font.c	2009-08-30 19:02:07.000000000 +0100
@@ -865,7 +865,7 @@ grub_font_get_string_width (grub_font_t 
 }
 
 /* Get the glyph for FONT corresponding to the Unicode code point CODE.
-   Returns a pointer to an glyph indicating there is no glyph available
+   Returns a pointer to a glyph indicating there is no glyph available
    if CODE does not exist in the font.  The glyphs are cached once loaded.  */
 struct grub_font_glyph *
 grub_font_get_glyph (grub_font_t font, grub_uint32_t code)
diff -pruN -x .svn grub2.old/fs/affs.c grub2/fs/affs.c
--- grub2.old/fs/affs.c	2009-08-26 16:25:36.000000000 +0100
+++ grub2/fs/affs.c	2009-09-01 19:24:42.000000000 +0100
@@ -25,6 +25,7 @@
 #include <grub/dl.h>
 #include <grub/types.h>
 #include <grub/fshelp.h>
+#include <grub/partition.h>
 
 /* The affs bootblock.  */
 struct grub_affs_bblock
@@ -164,6 +165,8 @@ grub_affs_mount (grub_disk_t disk)
   struct grub_affs_data *data;
   grub_uint32_t *rootblock = 0;
   struct grub_affs_rblock *rblock;
+  grub_uint64_t rdb_blockcount, rdb_reserved;
+  grub_disk_addr_t rblknum;
 
   int checksum = 0;
   int checksumr = 0;
@@ -208,8 +211,16 @@ grub_affs_mount (grub_disk_t disk)
   rblock = (struct grub_affs_rblock *) rootblock;
 
   /* Read the rootblock.  */
-  grub_disk_read (disk, (disk->total_sectors >> 1) + blocksize, 0,
-		  GRUB_DISK_SECTOR_SIZE * 16, rootblock);
+  rdb_blockcount = disk->total_sectors;
+  rdb_reserved = 2;
+
+  if (disk->partition)
+    rdb_blockcount = disk->partition->len;
+
+  rblknum = (rdb_blockcount - 1 + rdb_reserved) >> 1;
+
+  grub_disk_read (disk, rblknum, 0,
+                 GRUB_DISK_SECTOR_SIZE * 16, (char *) rootblock);
   if (grub_errno)
     goto fail;
 
@@ -240,7 +251,7 @@ grub_affs_mount (grub_disk_t disk)
   data->disk = disk;
   data->htsize = grub_be_to_cpu32 (rblock->htsize);
   data->diropen.data = data;
-  data->diropen.block = (disk->total_sectors >> 1);
+  data->diropen.block = rblknum;
 
   grub_free (rootblock);
 
diff -pruN -x .svn grub2.old/include/grub/msdos_partition.h grub2/include/grub/msdos_partition.h
--- grub2.old/include/grub/msdos_partition.h	2009-08-26 16:25:39.000000000 +0100
+++ grub2/include/grub/msdos_partition.h	2009-08-31 00:55:19.000000000 +0100
@@ -208,4 +208,10 @@ grub_msdos_partition_is_bsd (int type)
 	  || type == GRUB_PC_PARTITION_TYPE_NETBSD);
 }
 
+static inline int
+grub_msdos_partition_is_rdb(int type)
+{
+  return (type == 0x30 || type == 0x76);
+}
+
 #endif /* ! GRUB_PC_PARTITION_HEADER */
diff -pruN -x .svn grub2.old/partmap/amiga.c grub2/partmap/amiga.c
--- grub2.old/partmap/amiga.c	2009-08-26 16:25:46.000000000 +0100
+++ grub2/partmap/amiga.c	2009-09-01 20:00:28.000000000 +0100
@@ -76,20 +76,17 @@ amiga_partition_map_iterate (grub_disk_t
 {
   struct grub_partition part;
   struct grub_amiga_rdsk rdsk;
-  struct grub_disk raw;
   int partno = 0;
   int next = -1;
   unsigned pos;
 
-  /* Enforce raw disk access.  */
-  raw = *disk;
-  raw.partition = 0;
+  part.data = NULL;
 
   /* The RDSK block is one of the first 15 blocks.  */
   for (pos = 0; pos < 15; pos++)
     {
       /* Read the RDSK block which is a descriptor for the entire disk.  */
-      if (grub_disk_read (&raw, pos, 0, sizeof (rdsk), &rdsk))
+      if (grub_disk_read (disk, pos, 0, sizeof (rdsk), &rdsk))
 	return grub_errno;
 
       if (grub_strcmp ((char *) rdsk.magic, "RDSK") == 0)
@@ -110,7 +107,7 @@ amiga_partition_map_iterate (grub_disk_t
       struct grub_amiga_partition apart;
 
       /* Read the RDSK block which is a descriptor for the entire disk.  */
-      if (grub_disk_read (&raw, next, 0, sizeof (apart), &apart))
+      if (grub_disk_read (disk, next, 0, sizeof (apart), &apart))
 	return grub_errno;
 
       /* Calculate the first block and the size of the partition.  */
@@ -206,6 +203,8 @@ static struct grub_partition_map grub_am
 
 GRUB_MOD_INIT(amiga_partition_map)
 {
+  extern struct grub_partition_map *grub_rdb_partition_map;
+  grub_rdb_partition_map = &grub_amiga_partition_map;
   grub_partition_map_register (&grub_amiga_partition_map);
 }
 
diff -pruN -x .svn grub2.old/partmap/msdos.c grub2/partmap/msdos.c
--- grub2.old/partmap/msdos.c	2009-08-26 16:25:46.000000000 +0100
+++ grub2/partmap/msdos.c	2009-09-01 20:49:14.000000000 +0100
@@ -24,6 +24,9 @@
 #include <grub/misc.h>
 #include <grub/dl.h>
 
+/* For access to nested Amiga-style RDB tables.  */
+struct grub_partition_map *grub_rdb_partition_map = NULL;
+
 static struct grub_partition_map grub_msdos_partition_map;
 
 
@@ -198,6 +201,41 @@ pc_partition_map_iterate (grub_disk_t di
 			  return 1;
 		    }
 		}
+
+	      /* Check if this is an RDB partition table.  */
+	      if (grub_rdb_partition_map && grub_msdos_partition_is_rdb(e->type))
+	        {
+		struct grub_partition p2;
+		struct grub_disk raw2;
+		int ok = 0;
+
+		auto int rdb_hook(grub_disk_t disk, const grub_partition_t p);
+
+		int rdb_hook(grub_disk_t disk __attribute__((unused)),
+			     const grub_partition_t part)
+		  {
+		    p2 = *part;
+		    pcdata.bsd_part = part->index;
+
+		    p2.start  += p.start;
+		    p2.offset += p.offset;
+		    p2.data    = &pcdata;
+		    p2.partmap = &grub_msdos_partition_map;
+
+		    grub_dprintf("partition", "RDB part %c start=%ld\n",
+				 (char)('a' + part->index), (long)p2.start);
+
+		    ok = hook(disk, &p2);
+		    return ok;
+		  }
+
+		raw2 = raw;
+		raw2.partition = &p;
+
+		grub_rdb_partition_map->iterate(&raw2, rdb_hook);
+		if (ok)
+		    goto finish;
+	      }
 	    }
 	  else if (pcdata.dos_part < 4)
 	    /* If this partition is a logical one, shouldn't increase the
