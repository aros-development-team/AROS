<chapter title="The AROS Filesystem Interface">

<p>Normally, as an application programmer, you don't have to worry about the
filesystem interface -- you can do everything you want via simple calls
to DOS. However you may need to know how to interface with a filesystem 
if you</p>

<ul>
<li>Need to write your own filesystem,</li>
<li>Wish to asynchronous I/O,</li>
<li>Are writing a console driver,</li>
<li>Don't trust DOS.</li>
</ul>

<p>Of the above the most useful of these would be doing asynchronous I/O, although
it is in many cases better to use one of the publically available libraries
to do this, as it will hide from you the implementation of the filesystems.</p>

<section title="It's Completely Different">

<p>The interface to filesystems is different under AROS compared to AmigaOS in
many ways</p>

<ul>
<li>Filesystems are exec devices not process's |MsgPort|'s. This gives
	two main benefits -- it is possible to do some work on the callers
	schedule, which for simple requests can save on two context switches;
	and it gives us a way to abort a request, which is an important 
	feature for a network filesystem.</li>
<li>There is no difference between locks and filehandles anymore. This
	avoids requiring redundant methods such as <code>ACTION_FH_FROM_LOCK</code>.</li>
<li>No BCPL -- everything is a C data type or a string. A side effect
	of this is that there is no limit on string size which translates
	to no limit on filename size either.</li>
</ul>

<p>Obviously this change renders the filesystem incompatible to the current
AmigaOS filesystems and DOS implementation. However it should be possible
to build a bridge between the filesystems if necessary.</p>

</section>
<section title="Filesystem Devices">

<p>The major API change with filesystems is that they now use the Exec Device
API. You can use the normal device functions (<code>DoIO()</code>, <code>AbortIO()</code>, etc).
The I/O Request structure is defined in <filename>dos/filesystems.h</filename>:</p>

<code>
/* IORequest from &lt;exec/io.h&gt; */
struct IORequest 
{
    struct Message  io_Message;
    struct Device  *io_Device;  /* filesystem base pointer */
    struct Unit	   *io_Unit;    /* file or directory handle */
    UWORD           io_Command; /* the command */
    UBYTE           io_Flags;   /* normal device flags (IOF_QUICK) */
    BYTE            io_Error;   /* error code from device functions */
};

struct IOFileSys
{
    struct IORequest IOFS;
    LONG             io_DosError; /* secondary error code (IoErr()) */
    union {}         io_Union;    /* arguments - command dependant */
};

</code>

<p>The <code>io_DosError</code> field is used to return the secondary error
code to the caller. This is the code that is returned by the
<filename>dos.library</filename> function <code>IoErr()</code>. The 
<code>io_Error</code>
field of <code>struct IORequest</code> should
only be used to return a simple failure/success for filesystem commands, and
should have the normal effect for the device open/close commands.</p>

<p>The <code>io_Union</code> field is an union containing different structures for each of the
commands. This field has a variable length depending upon the command. The 
fields listed in the INPUTS sections of the autodocs below refer to a specific
member of this union.</p>

</section>
<section title="Command Documentation">

<subsection title="OpenDevice">

<autodoc>
<name><code>OpenDevice("*.handler", 0, iofs, 0);</code></name>

<function>
	<p>Mount a new filesystem. The <code>IOFileSys</code>
	structure passed in <code>iofs</code> to the
	handler should contain enough information for the handler to mount
	the filesystem.</p>

	<p>If there is a volume mounted in this device, it is the responsibility
	of the handler to add the required volume nodes to the DOS device
	list before returning to the caller. Note here that the DOS device
	list is already locked, so you do not need to lock it yourself.</p>

	<p>The filesystem must return a handle to the device in the
	<code>io_Unit</code> pointer of the <code>struct IOFileSys</code>. The
	<code>io_Error</code> and <code>io_DosError</code> fields should be set
	appropriately for success or failure.</p>
</function>

<input>
    <parameter name="iofs">
	<p>The union field <code>io_OpenDevice</code> is being used.
	Fill it with these values:</p>

	<description>
	<li><item><code>io_DeviceName</code></item>
		Name of the exec device to mount the filesystem 
		upon. This device is the underlying hardware of
		the device. Note that this field may not be valid
		for some special types of handlers (for example
		network filesystems or special devices
		<shell>AUX:</shell>, <shell>SER:</shell>).
	</li>
	
	<li><item><code>io_Unit</code></item>
		Unit number for the exec device. Note this is the
		<code>io_Union.io_DeviceName.io_Unit</code> field,
		not <code>io_Unit</code>.
	
	</li>
	<li><item><code>io_Environ</code></item>
	    This is a pointer to the struct DosEnvec which 
	    describes this device.
	</li>
	</description>
    </parameter>
</input>

<result>
    <description>
    <li><item><code>io_Device</code></item>device base pointer.</li>
    <li><item><code>io_Unit</code></item>logical device handle.</li>
    <li><item><code>io_Error</code></item><code>IOERR_OPENFAIL</code> or <code>0</code> for no error.</li>
    <li><item>io_DosError<code></code></item>DOS error code or <code>0</code> for no error.</li>
    </description>
</result>

<seealso>
    <item><code>CloseDevice()</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="CloseDevice">
<autodoc>
<name><code>CloseDevice()</code></name>

<function>
	<p>Try and dismount a DOS device. If there are any mounted volumes in
	the device, the filesystem should remove them from the DOS device
	list. Note that the DOS device list will have already been locked
	by the caller, so you will not have to do this yourself.</p>

	<p>You should not dismount the device if there are still open files
	or outstanding locks.</p>
</function>

<input>
    <parameter name="io_Unit">
    logical device handle.
    </parameter>
</input>

<result>
    <p>The DOS device shall be dismounted if possible.</p>

    <description>
    <li><item><code>io_DosError</code></item>DOS error code or <code>0</code>
    for no error.</li>
    </description>
</result>

<seealso>
    <item><code>OpenDevice()</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="FSA_OPEN">
<autodoc>
<name><code>FSA_OPEN</code></name>

<function>
	<p>Create a handle to an existing file or directory. You can use this
	handle to read directories or read/write files.</p>

	<p>The filename <code>io_Args[0]</code>
	is relative to the path of the directory
	associated with the handle <code>io_Unit</code>. If
	<code>io_Unit</code> is <code>NULL</code> however,
	the filename should be taken as relative to the root directory of
	the device.</p>

    	<p>This command uses the <code>io_Union.io_OPEN</code> member.</p>
</function>

<input>
	<parameter name="io_Unit">
	Handle to current directory.
	</parameter>

	<parameter name="io_Filename">
    	relative file or directory name.
	</parameter>
	<parameter name="io_FileMode">
        <p>mode to open with:</p>

	<description>
	<li><item><code>FMF_LOCK</code></item>lock exclusively</li>
    	<li><item><code>FMF_READ</code></item>open for reading</li>
	<li><item><code>FMF_WRITE</code></item>open for writing</li>
    	<li><item><code>FMF_EXECUTE</code></item>open to execute</li>
	</description>
	</parameter>
</input>

<result>
    <description>
	<li><item><code>io_Unit</code></item>Freshly created handle.</li>
	<li><item><code>io_DosError</code></item>dos error code or <code>0</code> for success.</li>
    </description>
</result>

<seealso>
    <item><code>FSA_OPEN_FILE</code></item>
    <item><code>FSA_CLOSE</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="FSA_CLOSE">
<autodoc>
<name><code>FSA_CLOSE</code> - close an open file</name>

<function>
	Close a file or directory handle. You should write out any buffered
	data before returning. It is the responsibility of the filesystem
	to free the data pointed to by <code>io_Unit</code>.
</function>
<input>
	<parameter name="io_Unit">handle to file or directory</parameter>

</input>
<result>
    <description>
    <li><item><code>io_DosError</code></item>DOS error code or <code>0</code> for no error.</li>
    </description>
</result>
<seealso>
    <item><code>FSA_OPEN</code></item>
    <item><code>FSA_OPEN_FILE</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="FSA_READ">
<autodoc>
<name><code>FSA_READ</code></name>

<function>
	<p>Try and read the requested number of bytes from the filehandle.
	A handler will normally try and fulfill the request completely,
	but special handlers (such as the console) may return less than
	the requested number of bytes.</p>

	<p>If you reach the end of the file, you should return the number
	of bytes read in the current attempt. On the next call you should
	return 0 for EOF. Any further attempts to read should result in
	a return of -1 with an error code.</p>

    	<p>This function uses the <code>io_Union.io_READ_WRITE</code> field.</p>

</function>
<input>
	<parameter name="io_Unit">filehandle</parameter>

	<parameter name="io_Buffer">pointer to byte buffer</parameter>
	<parameter name="io_Length">number of bytes to read from the file</parameter>


</input>
<result>
	The buffer <code>io_Buffer</code> should contain some data if it was
	possible to read any.

    <description>
    <li><item><code>io_Length</code></item>number of bytes read</li>
    <li><item><code>io_DosError</code></item>DOS error code or <code>0</code> for no error.</li>
    </description>
</result>

<seealso>
    <item><code>FSA_WRITE</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="FSA_WRITE">
<autodoc>
<name><code>FSA_WRITE</code> - Write to a file</name>

<function>
	<p>Try to write the requested number of bytes to the filehandle.
	A handler should try and fulfill the request completely, but
	special handlers may write less than the requested number of
	bytes.</p>

	<p>If you cannot write any bytes return 0 in io_Length.</p>

    	<p>This command uses the <code>io_Union.io_READ_WRITE</code> member.</p>

</function>
<input>
	<parameter name="io_Unit">filehandle</parameter>
	<parameter name="io_Buffer">byte buffer containing data to write</parameter>
	<parameter name="io_Length">number of bytes in buffer</parameter>

</input>
<result>
	<p>The contents of the buffer should have been written to the 
	stream.</p>

	io_Length	-	The number of bytes actually written
	io_DosError	-	dos error code or 0 for success.
    <description>
    <li><item><code>io_Length</code></item>number of bytes read</li>
    <li><item><code>io_DosError</code></item>DOS error code or <code>0</code> for no error.</li>
    </description>
</result>

<seealso>
    <item><code>FSA_READ</code></item>
</seealso>
</autodoc>

</subsection>
<subsection title="FSA_SEEK">
<autodoc>
<name><code>FSA_SEEK</code> - Seek within a file</name>

<function>
	<p>This command shall change the position of the next read or write
	in the file. The command will also return the old position in the
	file.</p>

	<p>XXX: Error condition for seeking before the start, and after the
	     end of file.</p>

    	<p>This command uses the <code>io_Union.io_SEEK</code> member.</p>

</function>

<notes>
	A command with <code>io_Offset == 0</code>, and 
	<code>io_SeekMode == OFFSET_CURRENT</code> is a NOP in terms of
	seeking	and will simply return the current file position.
</notes>

<input>
	<parameter name="io_Unit">filehandle</parameter>
	<parameter name="io_Offset">offset</parameter>
	<parameter name="io_SeekMode">mode
	<description>
	<li><item><code>OFFSET_BEGINNING</code></item>offset is relative to the
					  beginning of the file</li>
	<li><item><code>OFFSET_CURRENT</code></item>offset is relative to the
					  current position </li>
	<li><item><code>OFFSET_END</code></item>offset is relative to the
					  end of the file</li>
	</description>
	</parameter>
</input>

<result>
    <description>
    <li><item><code>io_Offset</code></item>old position</li>
    <li><item><code>io_DosError</code></item>DOS error code or <code>0</code> for no error.</li>
    </description>
</result>
</autodoc>

</subsection>
<!--
<subsection title="FSA_SET_FILE_SIZE">
<autodoc>
<name><code>FSA_SET_FILE_SIZE</code> - Set the size of a file

</name>
<function>
	Change the size of a file.

	If the old file size is less than the new size, then the file
	is simply truncated. If the file is made larger, then the data
	contained in the new section is invalid.

    	This command uses the io_Union.io_SEEK member.

</function>
<input>
	<parameter name="io_Unit">filehandle</parameter>
	io_Offset	- offset
	io_SeekMode	- mode

		OFFSET_BEGINNING	- offset is relative to the
					  beginning of the file
		OFFSET_CURRENT		- offset is relative to the
					  current position 
		OFFSET_END		- offset is relative to the
					  end of the file

</input>
<result>
	The file will be the new size.

	io_DosError	- dos error code or 0 for success

<heading>NOTES</heading>
	Not all handlers will support this command.


</subsection>
<subsection title="FSA_WAIT_CHAR">
<autodoc>
<name>
    	FSA_WAIT_CHAR - wait for a character to arrive
    	
</name>
<function>
    	This command will wait for a character to be ready for reading.
    	You should only wait for a maximum of io_Timeout microseconds.
    	If io_Timeout is 0, then you should wait indefinately.

    	This command can be used on both plain files and interactive files.
    	For plain files it should return immediately, unless for some reason
    	there is no data available (a PIPE or a network file where there is
    	no data yet).

    	This command uses the io_Union.io_WAIT_CHAR member.

</function>
<input>
	<parameter name="io_Unit">Filehandle to wait on</parameter>
    	io_Timeout  	- number of microseconds to wait for input

</input>
<result>
    	io_Success  	- set to TRUE if a character arrived in time.
    	io_DosError 	- set to the DOS error code, or 0 for no error

<heading>SEE ALSO</heading>
    	FSA_IS_INTERACTIVE
    	
</subsection>
<subsection title="FSA_FILE_MODE">
<autodoc>
<name>
    	FSA_FILE_MODE - set the mode of a file
    	
</name>
<function>
    	Apply a new mode to the file. This command uses a mask to define which
    	of the modes should be changed. Supplying a mask of 0 will return the
    	current set of modes.

    	This command uses the io_Union.io_FILE_MODE member.

</function>
<input>
	<parameter name="io_Unit">Filehandle to change mode on</parameter>
    	io_FileMode 	- new modes to apply to the file
    	io_Mask     	- mask of modes which are to be changed.
    
</input>
<result>
    	The modes should be set to those described by the mask and mode flags.
    	
    	io_FileMode 	- the new set of filemodes
    	io_DosError 	- the DOS error code on failure, or 0 for success
    	
</subsection>
<subsection title="FSA_IS_INTERACTIVE">
<autodoc>
<name>
    	FSA_IS_INTERACTIVE - is this file a terminal
    	
</name>
<function>
    	Query the filesystem as to whether this file is a interactive terminal.
    	
    	This function uses the io_Union.io_IS_INTERACTIVE member.

</function>
<input>
	<parameter name="io_Unit">Filehandle to query</parameter>
 
</input>
<result>
    	io_IsInteractive - TRUE if the file is interactive, FALSE otherwise
    	io_DosError 	- dos error code, or 0 for success.

<heading>SEE ALSO</heading>
    	FSA_WAIT_CHAR

</subsection>
<subsection title="FSA_SAME_LOCK">
<autodoc>
<name>
    	FSA_SAME_LOCK - are two locks the same?
    	
</name>
<function>
    	This function will compare two locks, and return whether the refer
    	to the same object in the filesystem.
    	
    	This command uses the io_Union.io_SAME_LOCK member.

</function>
<input>
    	io_Lock[0]  	- lock 1
    	io_Lock[1]  	- lock 2
    	
</input>
<result>
    	io_Same     	- set to LOCK_DIFFERENT or LOCK_SAME depending upon
    	    	    	  the result of the comparison.
    	io_DosError 	- DOS error code, or 0 for success.

<heading>SEE ALSO</heading>
    	FSA_OPEN

</subsection>
<subsection title="FSA_EXAMINE">
<autodoc>
<name>
	FSA_EXAMINE - example a file or directory

</name>
<function>
	This command will obtain information about the current file or
	directory and return it in the ExAllData structure passed in.

	We do not support passing filesystems the FileInfoBlock structure
	as that has limits upon the size of paths. The AROS dos.library
	will handle the translation between the two structures.

	You need only return the information requested, which is determined
	by the value in io_Mode.

    	This command uses the io_Union.io_EXAMINE

</function>
<input>
	<parameter name="io_Unit">Handle of file or directory</parameter>
	io_ead		- struct ExAllData to be filled.
	io_Size 	- size of the buffer in bytes.
	io_Mode 	- type of information to obtain.

</input>
<result>
	io_DosError	- one of the DOS error codes, or 0 for success.

<heading>SEE ALSO</heading>
	FSA_EXAMINE_ALL

</subsection>
<subsection title="FSA_EXAMINE_ALL">
<autodoc>
<name>
	FSA_EXAMINE_ALL - Examine the contents of a directory

</name>
<function>
	Read the directory information of the current file or directory.
	If the handle is for a file, then you need only fill in the
	information for that file. You need only fill in the information
	requested by the caller.

	You should continue filling in information in the buffer until
    	you run out of space. The ed_Next fields of the ExAllData structure
	are used to link the entries together. The last entry should have
	ed_Next = NULL. Entries should be aligned to the size of the
	system pointer datatype.

	If io_DosError != 0, then the contents of the buffer is undefined.
	If you need space to store filenames, comments strings, etc these
	should be placed at the end of the buffer.

</function>
<input>
	<parameter name="io_Unit">Handle of file or directory</parameter>
	io_ead		- struct ExAllData[] buffer to be filled
	io_Size 	- size of the buffer in bytes
	io_Mode 	- type of information to get

</input>
<result>
	io_DosError	- dos error code or 0 for success.

<heading>SEE ALSO</heading>
	FSA_EXAMINE, FSA_EXAMINE_ALL_END

</subsection>
<subsection title="FSA_EXAMINE_ALL_END">
<autodoc>
<name>
    	FSA_EXAMINE_ALL_END - Finish examining a number of files.

</name>
<function>
    	Finish examining a number of objects in the filesystem. This is
    	used to reset the filesystems internal state if required.

    	This command does not use the io_Union field.

</function>
<input>
	<parameter name="io_Unit">Filehandle</parameter>

</input>
<result>
    	io_DosError 	- DOS error code, or 0 for success.
    	
<heading>SEE ALSO</heading>
    	FSA_EXAMINE, FSA_EXAMINE_ALL
    	
</subsection>
<subsection title="FSA_OPEN_FILE">
<autodoc>
<name>
	FSA_OPEN_FILE

</name>
<function>
	Open a handle onto a file, creating the file if necessary. This
	command only works on files, not directories.

	Th
</name>
<function>
	Open a handle onto a file, creating the file if necessary. This
	command one io_Filename field gives the name of the file, which is
	relative to the handle passed in <code>io_Unit</code>. If the <code>io_Unit</code> handle is NULL, then
	the file is relative to the root of the directory tree.

    	This command also allows you to change the protection bits of the
    	file.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory.</parameter>
	io_Filename	-	filename relative to <code>io_Unit</code>.
	io_FileMode	-	mode to open with:
		    FMF_LOCK	- lock exclusively
		    FMF_READ	- open for reading
    		    FMF_WRITE	- open for writing
    		    FMF_EXECUTE	- open to execute
		    FMF_CREATE	- create file if it doesn't exist
		    FMF_CLEAR	- delete file before opening
		    FMF_RAW	- open cooked console in raw mode (and vice
				  versa)
    	io_Protection	-   	The protection bits for the file.

</input>
<result>
	io_Unit		-	pointer to newly created handle.
	io_DosError	-	dos error code or 0 for success.

<heading>SEE ALSO</heading>
	FSA_OPEN, FSA_CLOSE

</subsection>
<subsection title="FSA_CREATE_DIR">
<autodoc>
<name>
	FSA_CREATE_DIR - Create a new directory

</name>
<function>
	This command tells the filesystem to create a new directory, 
	lock it, and return a handle to the lock. The directory 
	should be created with the modes given in io_Args[1].

	XXX: Is the lock read or write?

	The lock should be relative to the handle in <code>io_Unit</code>, or to
	the root directory if <code>io_Unit</code> == NULL.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory or <code>NULL</code>.</parameter>
	io_Filename	- relative name of directory to create
	io_Protection	- protection flags for the new directory

</input>
<result>
	The directory requested exists if it could be created.

	io_Unit		- handle to new directory
	io_DosError	- dos error code or 0 for sucess

<heading>SEE ALSO</heading>
	FSA_OPEN

</subsection>
<subsection title="FSA_CREATE_HARDLINK">
<autodoc>
<name>
    	FSA_CREATE_HARDLINK - Create a hard link to a file.

</name>
<function>
    	Create a hard link to a file. There is no difference between a hard
    	link and its original file. If the original file is deleted, the data
    	will still exist because of the link.

    	Hard links can not point across devices.
    	
    	This command uses the io_Union.io_CREATE_HARDLINK member.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory or <code>NULL</code>.</parameter>
    	io_Filename 	- filename of the hard link.
    	io_OldFile  	- file to make the hard link towards.

</input>
<result>
    	A hard link will have been created if possible.

    	io_DosError 	- DOS error code, or 0 for success.

<heading>SEE ALSO</heading>
    	FSA_CREATE_SOFTLINK
    	
</subsection>
<subsection title="FSA_CREATE_SOFTLINK">
<autodoc>
<name>
    	FSA_CREATE_SOFTLINK - Create a soft link to a file.

</name>
<function>
    	Create a soft link to a file. There is a difference between a soft
    	link and its original file. If the original file is deleted, the soft
    	link will no longer be valid (but it will not be deleted).

    	As soft links are stored as the filename of the link to file, they
    	can be used across devices. This means that the filename stored
    	MUST be an absolute filename, as the current directory will be
    	unknown at read time.
    	
    	This command uses the io_Union.io_CREATE_SOFTLINK member.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory or <code>NULL</code>.</parameter>
    	io_Filename 	- filename of the soft link to create.
    	io_Reference  	- filename to make the soft link point towards.

</input>
<result>
    	A soft link will have been created if possible.

    	io_DosError 	- DOS error code, or 0 for success.

<heading>SEE ALSO</heading>
    	FSA_CREATE_HARDLINK

</subsection>
<subsection title="FSA_RENAME">
<autodoc>
<name>
    	FSA_RENAME - Rename an object in the filesystem

</name>
<function>
    	Rename an object in the filesystem. This function may be called on
    	a file which doesn't exist. The filenames specified should be
    	considered relative to <code>io_Unit</code> which specifies the current directory
    	(or NULL for the root directory).

    	Renaming a directory is equivalent to moving the entire contents of
    	the directory.

    	This command uses the io_Union.io_RENAME member.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory or <code>NULL</code>.</parameter>
    	io_Filename 	- old filename
    	io_NewName  	- new filename    	

<heading>OUTPUT</heading>
    	io_DosError 	- DOS error code, or 0 for success.

</subsection>
<subsection title="FSA_READ_SOFTLINK">
<autodoc>
<name>
    	FSA_READ_SOFTLINK - Read the name of a softlinked file.

</name>
<function>
    	This command will read the name of the file referenced by file
    	<code>io_Unit</code>. The filename returned is an absolute filename.

    	This command uses the io_Union.io_READ_SOFTLINK member.

</function>
<input>
	<parameter name="io_Unit">Handle of file to resolve the softlink from.</parameter>
    	io_Buffer   	- buffer to fill with the pathname
    	io_Size     	- size of the buffer. Return ERROR_LINE_TOO_LONG if
    	    	    	  the buffer is not large enough.

</input>
<result>
    	The buffer io_Buffer will contain the absolute filename that this
    	link refers to.
    	
    	io_DosError 	- DOS error code, or 0 for success.

<heading>SEE ALSO</heading>
    	FSA_MAKE_SOFTLINK
    	
</subsection>
<subsection title="FSA_DELETE_OBJECT">
<autodoc>
<name>
	FSA_DELETE_OBJECT - Delete an object from the filesystem

</name>
<function>
	Delete a given file or directory. It is illegal to try and
	delete a directory which contains files - you should return
	ERROR_DIRECTORY_NOT_EMPTY if an attempt is made.

	Files with outstanding handles cannot be deleted.

	If the <code>io_Unit</code> handle is NULL, the file to delete is relative
	to the root of the filesystem.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory or <code>NULL</code>.</parameter>
	io_Filename	- relative filename

</input>
<result>
	io_DosError	- dos error code or 0

</subsection>
<subsection title="FSA_SET_COMMENT">
<autodoc>
<name>
	FSA_SET_COMMENT - Set the comment of an object

</name>
<function>
	Set a new comment for a file or directory. The maximum length for
	a comment has historically been 80 characters (including NULL
	termination).

</function>
<input>
	<parameter name="io_Unit">Handle of current directory.</parameter>
	io_Filename	- relative filename
	io_Comment	- pointer to a C string (STRPTR)

</input>
<result>
	The object will have a new comment.

	io_DosError	- dos error code or 0 for success

</subsection>
<subsection title="FSA_SET_PROTECT">
<autodoc>
<name>
	FSA_SET_PROTECT - Set protection bits for a file

</name>
<function>
	Set the protection bits on a file or directory. Note that there
	are four groups of protection bits.

	    Owner read, write, execute, delete
	    Group read, write, execute, delete
	    Other read, write, execute, delete
	    Pure, Script, Archived

	You should not that the owner bits are handled a bit strangely
	as they are active low (ie 0 means enabled/set).

	Note that if <code>io_Unit</code> is valid (ie non-NULL), and io_Args[0] is
	NULL then you should change the mode of the object described
	by the <code>io_Unit</code> handle.

</function>
<input>
	<parameter name="io_Unit">Handle of current directory.</parameter>
	io_Filename	- relative filename
	io_Protection	- new protection bits

</input>
<result>
	The object will have new protection bits.

	io_DosError	- dos error code or 0 for success.

</subsection>
<subsection title="FSA_SET_OWNER">
<autodoc>
<name>
	FSA_SET_OWNER - Set the owner of a file

</name>
<function>
	This command allows a user to set the ownership of files. The
	file should be changed to reflect the new owner of the directory.

	The owner and group fields in the arguments are interpreted as
	32-bit values, however in general, they will only be 16-bit 
	values. If the values are outside the 16-bit range, and you are
	unabled to handle the values then you can return an error.
	The ERROR_BAD_NUMBER appears to be the most appropriate error
	number.

	Special User ID's:
	    0	-	root/Supervisor
	    -1	-	No owner (0x0000FFFF or 0xFFFFFFFF)

	Special Group ID's:
	    0	-	wheel/Supergroup
	    -1	-	No group (0x0000FFFF or 0xFFFFFFFF)

	Typically AmigaOS filesystems have had little multiuser support,
	and it should be expected that few filesystems will actually
	support this command. For security reasons, only the superuser
	or the owner of a file should be allowed to change the ownership.


</function>
<input>
	<parameter name="io_Unit">Handle of current directory.</parameter>
	io_Filename	- relative filename
	io_UID		- new user ID
	io_GID		- new group ID

</input>
<result>
	The file will now be owned by a different user.

	io_DosError	- dos error code or 0 or success.

</subsection>
<subsection title="FSA_SET_DATE">
<autodoc>
<name>
	FSA_SET_DATE - Set the date of a file/directory

</name>
<function>
	Set the modification date of a file or directory. If the filesystem
	does not support the date, for example it is too old, then you
	should return ERROR_BAD_NUMBER. It should not be possible to set
	the creation date of an object (except by creating it).

</function>
<input>
	<parameter name="io_Unit">Handle of current directory.</parameter>
	io_Filename	- relative filename
    	io_Date     	- struct DateStamp describing new date.

</input>
<result>
	The modification date will have been changed.

	io_DosError	- dos error code or 0 for success.

</subsection>
<subsection title="FSA_IS_FILESYSTEM">
<autodoc>
<name>
    	FSA_IS_FILESYSTEM - Ask the filesystem handler if it is a filesystem

</name>
<function>
    	Query the filesystem as to whether it is a proper filesystem. An 
    	example of something that is not a filesystem is a device handler
    	like PAR:.
    	
    	This command uses the io_Union.io_IS_FILESYSTEM member.

</function>
<input>
    	None.

</input>
<result>
    	io_IsFilesystem - TRUE if this is a filesystem, FALSE otherwise.
    	io_DosError 	- DOS error code, or 0 for sucecss.

</subsection>
<subsection title="FSA_MORE_CACHE">
<autodoc>
<name>
    	FSA_MORE_CACHE - Add more cache buffers to the filesystem.

</name>
<function>
    	Add the number io_NumBuffers of cache buffers to the filesystem.
    	The size of the buffer should have been given during the initial
    	filesystem open.
    	
    	If the number of buffers is negative, then the result will be to
    	remove buffers from the device. You can not have less than 0 buffers.
    	
    	This command uses the io_Union.io_MORE_CACHE member.

</function>
<input>
    	io_NumBuffers	- The number of buffers to add/remove.

</input>
<result>
    	The number of buffers will have been altered if possible.
    	io_NumBuffers	- The new number of buffers in the filesystem. This
    	    	    	  should be returned, even on failure.
    	io_DosError 	- DOS error code, or 0 for success.

</subsection>
<subsection title="FSA_FORMAT">
<autodoc>
<name>
    	FSA_FORMAT - Initialise a filesystem

</name>
<function>
    	Initialise a device to be used by this filesystem. The device media  
    	should have already been initialised, and this command simply gets
    	the filesystem to write its own data.
    	
    	This command uses the io_Union.io_FORMAT member.

</function>
<input>
    	io_VolumeName	- the new name for the volume.
    	io_DosType  	- the new type of the volume. This is filesystem
    	    	    	  specific.

</input>
<result>
    	The filesystem will have been initialised, and is ready for mounting.
    	
    	io_DosError 	- DOS error code, or 0 for success.

</subsection>
<subsection title="FSA_MOUNT_MODE">
<autodoc>
<name>
    	FSA_MOUNT_MODE

</name>
<function>
    	Change or read the mount modes of the volume passed in <code>io_Unit</code>.
    	The mask is used to select which modes are to be changed.
    	
    	This command uses the io_Union.io_MOUNT_MODE member.

</function>
<input>
    	io_MountMode	- The new mount mode of the filesystem.
    	io_Mask     	- The mask of flags to change in the mount mode.
    	io_Password 	- The password which is required for MMF_LOCKED.
    	    	    	  It is a good idea not to store this password as
    	    	    	  plain text.

</input>
<result>
    	io_MountMode	- The new mount modes of the filesystem.
-->
</section>

</chapter>
