<chapter title="Coding conventions">

<section title="General style">

<p>This code is used by many people and therefore you should keep some things
in mind when you submit source code:</p>

<ul>
<li>Keep things simple</li>
<li>Keep the source clean</li>
<li>Always know what you are doing</li>
<li>Tell what you are doing</li>
<li>Remember that you write code once but that it is read many times
by many people</li>
</ul>

</section>
<section title="Comments">

<p>AROS uses some of the comments in the source to generate the documentation.
Therefore it's neccessary to keep a certain format so the tools can find
their information. Other comments are ignored but they should explain what
you thought when you wrote the code. If you really can't think of an
explanation, then don't write the code a second time like this:</p>

<code>
/* This adds 1 to t */
t ++;
</code>

<p>What we think of is this:</p>

<code>
/* Go on with next element */
t ++;
</code>

</section>
<section title="Function prototypes and headers">

<p>Every function in AROS must have a full ANSI C prototype. Prototypes should
be collected in in one header per file if it is needed by only a few files
(no need to recompile the whole project if you change a function which used
only once), in one header per directory if it's a commonly used function in
that directory or in one header per logical group (ie. one header for all
functions in a library).</p>

<p>The function header (ie. the comment before the function) must be of a
special format because the AutoDocs are generated from it. Here is an
example for it (from <filename>AROS/exec/addhead.c</filename>):</p>

<code>
/*****************************************************************************

    NAME */
#include <exec/lists.h>
#include <clib/exec_protos.h>

	AROS_LH2I(void, AddHead,

/*  SYNOPSIS */
	AROS_LHA(struct List *, list, A0),
	AROS_LHA(struct Node *, node, A1),

/*  LOCATION */
	struct ExecBase *, SysBase, 40, Exec)

/*  FUNCTION
	Insert Node node as the first node of the list.

    INPUTS
	list - The list to insert the node into
	node - This node is to be inserted

    RESULT
	None.

    NOTES

    EXAMPLE
	struct List * list;
	struct Node * pred;

	// Insert Node at top
	AddHead (list, node);

    BUGS

    SEE ALSO
	NewList(), AddTail(), Insert(), Remove(), RemHead(), RemTail(),
	Enqueue()

    INTERNALS

    HISTORY
	26-08-95    digulla created after EXEC-Routine
	26-10-95    digulla adjusted to new calling scheme

******************************************************************************/
{
</code>

<p>As you can see, comments are used to merge the function prototype and the
header into one.</p>

<description>
<li><item>NAME</item> This field contains all neccessary prototypes to use the function
from the user point of view and the name of the function in a <code>AROS_LH*()</code>
macro (Library Header). These macros are used to make the same code work on
different kind of hardwares. The name of the macro depends on the amount of
parameters and whether the function needs the library base. <code>AddHead()</code>
does not and therefore an "I" is appended to the macros name. If it need
the library base (like <code>AddTask()</code>), then the "I" is omitted.

<p>If the function is not part of a shared library and it's arguments must be
passed in certain registers (eg. callback hooks), you must use
<code>AROS_UFH*()</code> macros (User Function Header) instead of <code>AROS_LH*()</code>. Append
the number of arguments to this macro. Since it has never a base, the field
LOCATION must be omitted and it's not neccessary to append the "I" to the
macros name. An example for a callback hook <code>foo()</code> would be:</p>

<code>
AROS_UFH3(ULONG, foo,
    AROS_UFHA(struct Hook, hook,  A0),
    AROS_UFHA(APTR,        obj,   A2),
    AROS_UFHA(APTR,        param, A1)
)
</code>

<p>(note that the registers need not have a particular order).</p>

<p>If the function is not part of a shared library and it's arguments need not
be in specific registers, you need no <code>AROS_*H*()</code> macros:</p>

<code>
/*****************************************************************************

    NAME */
#include <header.h>

	int foo (

/*  SYNOPSIS */
	int a,
	int b)

/*  FUNCTION
	blahblahblah.
	...

*****************************************************************************/
</code>
</li>

<li><item>SYNOPSIS</item> This field contains all arguments of the function one by
one in <code>AROS_LHA()</code> macros (Library Header Argument). This macro makes sure
the respective argument is put in the right CPU register when the function
is called (if possible and neccessary). The first argument for the macro is
the type of the parameter followed by the name of the parameter and the
register the parameter is expected in. Valid names for registers are D0,
D1, D2 upto D7 and A0 upto A6.

<p>If the function is not part of a library but the arguments must be passed
to it in registers, then use <code>AROS_UFHA()</code> macros (User Function Header
Argument) which take the same parameters as the <code>AROS_LHA()</code> macros. Don't
forget the closing parenthese for the <code>AROS_UFC</code>.</p>

If the function is not part of a library and the arguments need not be
passed in registers, no macros are neccessary.
</li>

<li><item>LOCATION</item> This field is neccessary for shared libraries only. It
contains the last four parameters for the <code>AROS_LH*()</code> macro which are the
type of the library, the name of the variable, in which the function
expects the library base, the offset of the function in the jumptable (the
first vector has 1 and the first vector which may be used by a function is
5) and the name of the library.
</li>

<li><item>FUNCTION</item> This field contains a description of the function.
</li>

<li><item>INPUTS</item> This field contains a list of all parameters of the form
"name - description" or "name, name, name - description". The description
should tell what the parameter is and what values can be passed to it.
There is no point in explaining the parameter twice in FUNCTION and here.
If the function has no parameters, say "None." here.
</li>

<li><item>RESULT</item> What the function passes back. This includes return values
and values passed in arguments of the function. If the function may fail,
you should explain what it returns on failure and why it might fail.
</li>

<li><item>NOTES</item> Important things the user must know or take into account.
</li>

<li><item>EXAMPLE</item> This field should contain a small or fully featured
example.  A good way to present an example is to write some code which tests
the function, put it into <code>#ifdef TEST</code> somewhere in the file and
put a "See below." here. If you need comments in the code, you have two ways
for this. If you need only short one-line comments, use C++ style (|//
comment<code>). Everything from the </code>//| to the end of the line is
the comment.  If you need more comment, then you can end the comment after the
<code>EXAMPLE</code> and use <code>#ifdef EXAMPLE</code> to mask the example
out:

<code>
    EXAMPLE */
#ifdef EXAMPLE
	struct List * list;
	struct Node * pred;

	/* Insert Node at top of the list */
	AddHead (list, node);
#endif
</code>

Don't use <code>#ifdef EXAMPLE</code> if you have a fully featured example (ie. one
which can be compiled without errors).
</li>

<li><item>BUGS</item> This field contains a list of known bugs.
</li>

<li><item>SEE ALSO</item> This field contains a list of other functions and documents
which might be of interest. This includes function which you need to
initialize, create or destroy an object necessary for this function,
functions which do similar and opposite things on the main object.

For example, <code>SetAttrs()</code> should contain functions here which can create,
destroy and manipulate BOOPSI objects but not taglists.
</li>

<li><item>INTERNALS</item> This field should contain information for other developers
which are irrelevant to the user, for example an explanation of the
algorithm of the function or dependencies.
</li>

<li><item>HISTORY</item>Since we use CVS, this field is obsolete.
You can delete it, if you encounter it.
</li>

</description>

</section>
<section title="Formatting">

<p>Here is an example of how to format AROS code:</p>

<code>
{
    /* a */
    struct RastPort * rp;
    int               a;

    /* b */
    rp = NULL;
    a  = 1;

    /* c */
    if (a == 1)
	printf ("Init worked\n");

    /* d */
    if
    (
	!(rp = Get_a_pointer_to_the_RastPort
	    (
		some
		, long
		, arguments
	    )
	)
    ||
	a <= 0
    )
    {
	printf ("Something failed\n");
	return FAIL;
    }

    /* e */
    a = printf ("My RastPort is %p, a=%d\n"
	, rp
	, a
    );

    return OK;
}
</code>

<p>Looks ugly, eh ? :-) Ok, here are the rules:</p>

<ul>
<li>If several lines contain similar code, put similar things below each
other (see a and b);
</li>

<li>Put spaces between operands and operators
</li>

<li> Put braces <code>{}</code>, brackets <code>[]</code> and parenthese
<code>()</code> below each other (d) if
there is much code between. Brackets and parenthese may be in one line if
the code between is small (c)
</li>

<li>Indent by 4 Spaces. Two indent levels may be abbreviated by one tab.

<p>The reasons for this are: 1. While some editors can use an arbitrary
sizes for tabs, it's a bit complicated to tell another editor which
tab size was used by the one used to write the code. 2. Most code in
AROS was written this way and your code should look like the
rest. 3. You can print this code on any printer without special
tools to "fix" the tabs. 4. Most editors have smart tabs which do
exactly this. If your editor doesn't, write a bug report.</p>
</li>

<li>If you have a function with many arguments (d, e) you should put the
parenthese in lines of their own and each argument in one line (d) or put
the first argument behind the opening parenthese (e) and each following
argument in a line of its own with the comma in front. The closing
parenthese is in a line of its own and aligned with the beginning of the
expression (ie. the a and not the opening parenthese or the
<code>printf()</code>).
</li>

<li>use a single blank line to separate logical blocks. Large comments
should have a blank line before and after them, small comments should be
put before the code they explain with only one blank line before them.
</li>

</ul>

</section>
<section title="Writing ROM-able code">

<p>Code in AROS modules should be written in a way that makes it suitable
for embedding into a ROM, FlashRAM or other kinds read-only
memory. The following coding style rules are meant to make it
possible. Of course they apply to all Kickstart modules and to code
that may be made resident, shared or linked to other modules.</p>

<ul>
<li>
ROM modules must have no .data and .bss sections.
Basically, we need to get rid of all non-const global data.
The real Amiga Kickstart proves that it's both possible
and easy to achieve this.

If you encounter an external variable (static or not) that
is modified by the code, try to get rid of it or move it into
the base of the library/device (or in the device node of your
handler or in the userdata of your class).
</li>

<li>
The above applies to library bases as well. If you are writing
a library, put the bases of other libraries into your own library
base structure. Boopsi classes can store library bases in their
class private data.
</li>

<li>
Try to set the <code>static</code> and <code>const</code> attributes to all
your global data. You can also use the <code>CONST_STRPTR</code> and
<code>CONST_APTR</code> types defined in
<filename>&lt;exec/types.h&gt;</filename>. Using <code>static const</code>
allows the compiler to move data into the <shell>.text</shell> (AKA code)
segment.  If you need to pass these globals to another function, try to chenge
its prototype to use <code>const</code> too. Note that, as of OS 3.5, Olaf
Barthel has finally switched to using <code>const</code> in
<filename>&lt;clib/#?_protos.h&gt;</filename> headers.
</li>

<li>
<strong>NEVER EVER</strong> touch buffers passed in by the user as an "input"
parameter. The concept of input parameters is often implicit
in the function description. For instance, the filename passed
to <code>Open()</code> is clearly an input variable and
<code>Open()</code> must not
mess with it, even if it is going to fix it back later. Keep
in mind that the buffer might be in read-only memory or shared
among several instances of a resident or multithreaded program.
</li>

<li>
Try to avoid host-OS calls such as <code>malloc()</code> and
<code>free()</code> if you can do with <code>AllocMem()</code> and
<code>FreeMem()</code>. This is because
the pointer checking debug macros rely on finding the pointer
within the Exec memory blocks with <code>TypeOfMem()</code>.
</li>

</ul>

</section>
</chapter>
