\chapter{MetaMake}

\section{Introduction}

MetaMake is a version of make which allows to recursively build targets
in the various directories of a project or even another project.
It searches a directory tree for makefiles and all
makefiles it finds for "metatargets" and then tries to build all
metatargets. You can also specify a program which converts "source"
makefiles into makefiles before MetaMake will invoke make.

We use MetaMake to build AROS - The Amiga Replacement OS. AROS consists of
many different packages which depend on each other like this:

\begin{example}
#MM AROS : setup includes kernel workbench apps
\end{example}

This is a metatarget in a makefile (MetaMake looks for #MM as the first
thing in a line). It means that AROS depends on setup, includes, etc. as
you are used to from Make.

The big point is: MetaMake will consider *all makefiles at once* when it
checks a metatarget. So all metatargets "setup" in all makefiles will be
build when MetaMake tries to build AROS. MetaMake searches itself for the
makefiles, so to add a new package, just create a new makefile in that
directory and invoke MetaMake again.

This also allows to build the project from anywhere. You can invoke
MetaMake in a subdir or any other directory if you copy the config file to
$HOME.

MetaMake can also read a file with Make-style variable definitions. This
allows to build the project depending on some variable, for example:

\begin{example}
#MM kernel : kernel-$(ARCH)-$(CPU)
\end{example}

will build kernel-linux-i386 before kernel on Linux/i386 machines.

MetaMake will calculate \shell{$(TOP)} (the path to the top of the project)
and \shell{CURDIR} (the path to the current directory relative to
\shell{$(TOP)}) and pass them to make. Also \shell{$(TARGET)} will contain
the current target but this will not be passed to make automatically. If
you need the target in the makefile, you can use the \shell{maketool}
option to change this.

\section{Usage and Config Files}

\shell{Usage: mmake [<options>] [<metatargets>]}

To build mmake, just compile \filename{mmake.c}. It doesn't need any
other files.

mmake looks for a config file \filename{mmake.config} or
\filename{.mmake.config} in the current directory for a file in the
environment variable \shell{$MMAKE_CONFIG} or a file \filename{.mmake.config}
in the directory \shell{$HOME}.
This file can contain the following things:

\begin{description}
\item{#} This must be the first character in a line and begins a comment.
Comments are completely ignored my mmake (as are empty lines).

\item{[name]} This begins a config section for the project \shell{name}.
You can build targets for this project by saying \shell{name.target}.

\item{maketool} Specifies the name of the tool to build a target. The
default is \shell{make "TOP=$(TOP)" "CURDIR=$(CURDIR)"}

\item{top <dir>} Specifies the root directory for a project. You
will later find this config option in the variable \shell{$(TOP)}.
The default is the current directory.

\item{defaultmakefilename <filename>} Specifies the basename for
makefiles in your project. Basename means that mmake will consider
other files which have this stem and an extension, too. See the
items to generate makefiles for details. The default
is \filename{Makefile}

\item{defaulttarget <target>} The name of the default target which
mmake will try to make if you call it with the name of the
project alone. The default is \shell{all}.

\item{genmakefilescript <cmdline>} mmake will check for files
with the basename as specified in \shell{defaultmakefilename}
with the extension \shell{.src}. If such a file is found, the
following conditions are checked: Whether this file is newer
than the makefile, whether the makefile doesn't exist and
whether the file \shell{genmakefiledeps} is newer than the
makefile. If any of these is true, mmake will call this script
the the name of the source file as an extra option and the
stdout of this script will be redirected to \shell{defaultmakefilename}.
If this is missing, mmake will not try to regenerate makefiles.

\item{genmakefiledeps <path>} This is the name of a file which is
considered when mmake tries to decide whether a makefile must
be regenerated. Currently, only one such file can be specified.

\item{globalvarfile <path>} This is a file which contains more
variables in the normal make(1) syntax. mmake doesn't
know about any special things like line continuation, so
be careful not to use such variables later (but they
don't do any harm if they exist in the file. You should
just not use them anywhere in mmake).

\item{add <path>} Adds a nonstandard makefile to the list of
makefiles for this project. mmake will apply the standard
rules to it as if the \shell{defaultmakefilename} was
like this filename.

\item{ignoredir <path>} Will tell mmake to ignore directories
with this name. Try \shell{ignore CVS} if you use CVS to
manage your projects' sources.

Any option which is not recognised will be added to the list
of known variables (ie. \shell{foo bar} will create a
variable \shell{$(foo)} which is expanded to \shell{bar}).

\section{Example}

Here is an example:

\begin{example}
# This is a comment
# Options before the first [name] are defaults. Use them for global
# defaults
defaultoption value

# Special options for the project name. You can build targets for this
# project with "mmake name.target"
[AROS]
# The root dir of the project. This can be accessed as $(TOP) in every
# makefile or when you have to specify a path in mmake. The default is
# the current directory
top /home/digulla/AROS
# This is the default name for Makefiles. The default is "Makefile"
defaultmakefilename makefile
# If you just say "mmake AROS", then mmake will go for this target
defaulttarget AROS
# mmake allows to generate makefiles with a script. The makefile
# will be regenerated if it doesn't exist, if the source file is
# newer or if the file specified with genmakefiledeps is newer.
# The name of the source file is generated by concatenating
# defaultmakefilename and ".src"
genmakefilescript gawk -f $(TOP)/scripts/genmf.gawk --assign "TOP=$(TOP)"
# If this file is newer than the makefile, the script
# genmakefilescript will be executed.
genmakefiledeps $(TOP)/scripts/genmf.gawk
# mmake will read this file and every variable in this file will
# be available everywhere where you can use a variable.
globalvarfile $(TOP)/config/host.cfg

# Some makefiles must have a different name than
# defaultmakefilename. You can add them manually here.
#add compiler/include/makefile
#add makefile
\end{example}

A metatarget look like so: \shell{project.target}. Example:
\shell{AROS.setup}. If nothing is specified, mmake will make the default
target of the first project in the config file. If the project is specified
but no target, mmake will make the default target of this project.

