\chapter{Developing Software for AROS}

\section{Setting up}

To compile code for AROS, you only need the binary distribution and
a C compiler. If you use Linux, you should have everything neccessary
already, if you use Amiga, install the GeekGadgets development environment
(see \lref{GG}{GG}).

\section{Compiling}

To get known to the compiling process, without worrying about the AROS
API, dig up your helloworld.c somewhere, or else use this one:

\begin{code}
#include<stdio.h>
int main () {printf("Hello, World!\n"); return 0;}
\end{code}

\subsection{Compiling on Amiga}

If you run AROS on an Amiga machine, you can use your favorite Amiga compiler
to compile your program directly into Amiga binaries.

\subsection{Compiling on Linux}

On Linux, you compile your code to (specially linked) Linux binaries. This
means that you should keep in mind what libraries, headers and startup code
you must use.

First we compile the code to object files In the following examples, be sure
to replace $AROSDIR with your AROS directory:

\begin{example}
gcc -c helloworld.c -I$AROSDIR/bin/linux-i386/AROS/include
\end{example}

If all goes well we will have an object file named helloworld.o . Now we
must link it with the necessary Linux AROS libraries. The following little
command seems to suffice for a good compilation:

\begin{example}
gcc -nostartfiles -nostdlib -Xlinker -i $AROSDIR/bin/linux-i386/AROS/lib/startup.o helloworld.o -o helloworld -L$AROSDIR/bin/linux-i386/AROS/lib -larossupport -lamiga -larosc -larosm
\end{example}

Now if all goes well we will have an AROS executable. Copy it to somewhere
were AROS can find it, and try to run it from inside AROS. My experience is,
that if you receive an error "Object is of wrong type" you should review
your source code.

\subsection{Make and MetaMake}

If you would develop more serious code, you wouldn't want to rewrite the
above every time you have to compile it. The most common answer to this
problem is "make", a tool you should be known with. AROS uses its own tool
called MetaMake, that extends make functionality.

If you build AROS from the source code, it would be easy to make your own
programs compile together with it. There is an empty directory called
"local" in the source code, where you can insert your coding experiments.

\section{AROS extensions}

AROS makes a few extensions to the original AmigaOS. Some of them are
transparent and compatible, others are only compatible and some or not.

\subsection{Macros}

AROS defines a couple of macros in various header files. All macros
cast their parameters to the correct type, so you must provide a
valid input but can safe the casts (macros are meant to make life
more simple).

\begin{description}
\item{NEWLIST(list)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Initializes a list. You must not use any list before you have initialized
it.

\item{GetHead(list)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Returns a pointer to the first node of a list or |NULL| if the list
is empty.

\item{GetTail(list)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Returns a pointer to the last node of a list or |NULL| if the list
is empty.

\item{GetSucc(node)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Returns a pointer to the next node of a list or |NULL| if there is none.

\item{GetPred(list)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Returns a pointer to the previous node of a list or |NULL| if there is none.

\item{ForeachNode(list,node)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Iterates through a list. A block of code must follow this macro. The
block doesn't get executed if the list is empty. When the list terminates
|node| doesn't contain |NULL| but |node->ln_Succ| will be NULL. You
cannot use this macro if you want to delete the nodes in the list (ie.
you must not call |Remove()| inside the block of code following the
macro). Use |ForeachNodeSafe()| if you have to delete nodes.

\begin{code}
/* Iterate through a list with complete nodes and print their names */
t = 1;
ForeachNode(list,node)
{
    if (node->ln_Name)
    {
	printf ("Node %d: %s\n", t++, node->ln_Name);

	if (!strcmp (node->ln_Name, "end"))
	    break;
    }
}

if (node->ln_Succ)
    printf ("Not all nodes have been processed\n");
else
    printf ("The list doesn't contain a node with the name \"end\"\n");
\end{code}

\item{ForeachNodeSafe(list,node,tmpNode)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Iterates through a list. A block of code must follow this macro. The
block doesn't get executed if the list is empty. When the list terminates
|node| doesn't contain |NULL| but |node->ln_Succ| will be NULL. You
can use this macro with code that deletes nodes in the list.

\item{SetNodeName(node,name)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Sets a new name for a node. The name is not copied, the macro will just
make |ln_Name| point to |name|.
The macro casts |node| to |struct Node *|
so you better make sure that |node| is a full featured node.

\item{GetNodeName(node)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

Return the current name of a node.
The macro casts |node| to |struct Node *|
so you better make sure that |node| is a full featured node.

\item{ListLength(list,count)}
Compatible: Yes\nl
Location: \filename{exec/lists.h}

This puts the number of nodes in |list| into |count|.

\item{INTUITIONNAME}
Compatible: Yes\nl
Location: \filename{intuition/intuition.h}

Contains the name of the Intuition library. You should use this in
|OpenLibrary()|, for example, to avoid typos.

\end{description}

\subsection{Resource Tracking (RT)}

Everyone talks about RT but what's it anyway ? RT means three things:

\begin{enumeration}
\item The OS takes notes about allocated resources (eg. memory, windows,
libraries, devices, screens, etc).

\item The OS checks the usage of those resources (ie. Did you open
that window you want to render into ? Is it still open ? Is that a
window anyway ?)

\item The OS closes resources if they are no longer used (either because your
program crashed or because it exited without freeing them).

\end{enumeration}

The current implementation can do all three things but to enable it,
you must make some modifications to your code. The only disadvantage of
the current implementation is that the resources won't be freed if the
program crashes.

\begin{enumeration}
\item Add the following
lines to your code. It should be the first thing seen by the compiler:

\begin{code}
#define ENABLE_RT  1
\end{code}

If you replace the |1| by |0|, then RT will be silently disabled.

\item Add |#include <aros/rt.h>| after the last include from \filename{proto/}

\item Add |RT_Init();| as the first command in |main()|.

\item Call |RT_Exit()| before you terminate your program.

\item Recompile.

\end{enumeration}

The advantages are that you will get errors if you try to access
resources which you didn't allocate and that you will get a list
of resources which you didn't free at the end of your program.
All messages will contain the position in the code where the error
happened (if available) and the position in the code where the
resource was allocated (this is the reason why RT has to be compiled
in. It could be built into the OS, too, but it would be hard
to gather the information where an error occurred).

A good example about how to use RT and what it can do can be
found in \filename{AROS/workbench/demos/rtdemo.c}
(\link{Output of rtdemo}{rtdemo.log}).

The following resources are tracked:

\begin{itemize}
\item Memory in |AllocMem()|, |FreeMem()|, |AllocVec()| and |FreeVec()|

\item MsgPorts in |CreateMsgPort()|, |DeleteMsgPort()|, |CreatePort()|,
|DeletePort()| and |PutMsg()|

\item Files in |Open()|, |Close()|, |Read()| and |Write()|. |Read()| and
|Write()| also check their buffers.

\item Windows in |OpenWindow()|, |OpenWindowTags()|, |OpenWindowTagList()|,
|CloseWindow()|, |WindowToFront()|, |WindowToBack()|

\item Screens in |OpenScreen()|, |OpenScreenTags()|, |OpenScreenTagList()|,
|CloseScreen()|, |ScreenToFront()|, |ScreenToBack()|. |CloseScreen()| also
checks for open windows on the screen before closing.

\end{itemize}

