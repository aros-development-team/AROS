[name] - Draft v0.2

Index

1 ................ Preface
2 ................ Authors
3 ................ Introduction
4 ................ Description
4.1 .............. Interfaces
4.2 .............. Classes
4.3 .............. Objects
4.4 .............. Exceptions
5 ................ Implementation
5.1 .............. Interfaces
5.2 .............. Classes
5.3 .............. Objects
5.4 .............. VTables
5.5 .............. Methods invocation
5.6 .............. Casting
5.7 .............. Exceptions
5.7.1 ............ Exceptions and AROS

Appendices

A ................ TODO
B ................ Contributors
C ................ ChangeLog


1 - Preface

The purpouse of this document is to describe the ideas behind a new Object
Oriented programming framework, that is meant to be language independent, fast
and extendible.

At the moment not everything is defined and so this document is subject to heavy
changes in future. When the ideas and the implementation details will be enough
clear to be able to actually write something, this document will reflect such a
situation by turning version 1.0. Until then, everything stated here has to be
considered as highly questionable.




2 - Authors

This document is being written by Fabio Alemagna, and  his are the ideas inside
of it. Where necessary credits will be given to other people and references to
their work will be made. Contributors are welcome, and they'll be mentioned at
the end of this document.




3 - Introduction

I won't explain here what OO is and why is it useful, I'll instead assume that
the reader is aware of such things and he/she knows what are their implications.

This document is the answer to the need of AROS (http://www.aros.org/) for a new
OO system that would keep the functionalities of the current one and would
improve its speed and usability. The system here described is, of course, not
tied to AROS, though.

[name] is meant to be

1) Language independent

   [name] is not tied to any particular language. Programmers can write programs
   that use [name] in any language, even assembly. Preferring one language over
   another one will give, though, particular advantages and/or disadvantages.

   This document describes the C interface of [name] that will be probably the
   most used and is the only one that is currently supported.

2) Extendible

   Say a program P uses a class A. Later on the class A extends its interface.
   In such a situation the program P must NOT have to be recompiled, unlike it
   would happen in languages like C++.

   Moreover, a program must be able to use classes that it wasn't aware of at
   compile-time.

3) Fast

   Usually, characteristics like (1) and (2) imply a slow implementation. This
   document will explain how is it possible to keep (1) and (2) while being
   really fast, as fast as C++ can be, or maybe a little bit slower.




4 - Description

In this section I'll explain the fundamental characteristics of [name].


4.1 Interfaces

Usually OO systems are explained in terms of classes and objects, the latters
being an "instantiation" of the formers. This stands correct also here, but
addictional terms are defined and a stronger meaning is given to the normally
used ones.

You can, infact, imagine a class being divided in two parts: its "interface" and
its "implementation". The interface merely describes what the class CAN DO and
what are its attributes, whilst the implementation actually DOES those things,
in a way that is unknown to the class' user.

Well, in [name] interfaces are entities of their own. They are really separated
from classes. The latters, infact, are an "implementation" of given
interfaces.

Interfaces are not forced to have an implementation, that is there must not be
by force a 1:1 mapping between classes and interfaces.

Interfaces can, moreover, "extend" other interfaces, that is they can include
all the characteristics of the interfaces that they extend, plus adding some of
their own.


4.2 Classes

As said, classes are implementation of interfaces. Actually, a class might be
better defined as a couple consisting of an interface and its implementation,
but to stick with the common naming convention I'll use the term "class" to
indicate the implementation, otherwise I'd have to not use the term "class"
altogether.

A class can implement as many interfaces as it wishes, but it can only "extend"
ONE other class, no more than ONE. When a class "extends" another class it
automatically implements the interfaces that the extended class implements and
gets their implementation. A class can override the implementation of a specific
characteristic provided by the class being extended and is required to implement
all the characteristics that the class being extended doesn't implement.


4.3 Objects

Objects are, as in the usual naming convention, instances of classes. You can
imagine a class like being a "blueprint" and the object like being what comes
out of it.

Classes are actually objects themselves, and so are interfaces [this has to be
better checked, I still have some doubts about the chicken&egg problem...].

[add something else?]


4.4 Exceptions

One way of dealing with errors and unusual situations consists in checking for
the success of every operation being done. This is the way errors are dealt with
in C, for example, and although it's easy to implement, it's very bug prone and
boring to use, without taking in consideration that it often leads to ugly and
difficult to read code, full of nested if...then...else constructs.

Another way consists in using what are called "exceptions". The idea is that
"exceptional" situation, like errors, are dealt all together, in a piece of code
kept separated from the rest. This allows for a better readable source code and
also for a more powerful and less bug-prone error handling.

Exceptions are commonly used in C++, and are the only encouraged way of dealing
with errors in Java.

[name] uses exceptions as well, and with some preprocessor magics it's
possible using them in C almost like in Java or C++.

Exceptions can be hungry of CPU cycles, though, so they must not be misused, and
where necessary the good old if...then...else construct can and must be used
instead.




5 Implementation

In this section I'll explain how do I intend to implement the above
characteristics.


5.1 Interfaces

Interfaces are a collection of methods and attributes *names*, the interface
itself having a name. An interface can be queried to get the attributes or
methods ids that one wishes to use, by issuing a request on that interface
providing the name of desired attribute or method. A method or attribute ID is
basically an index into an array. The content of this array is analized in 5.4.

[explain how names are handled and stored into the interfaces]


5.2 Classes

As we know, classes are implementation of interfaces. Classes are required to
implement the methods that the interfaces describe and are required to implement
a way to get/change attributes.

Implementation wise, a class can implement only ONE interface. This interface
can, however, extend more than one other interface, so pratically the class DOES
implement more than one interface. This is so because every class is referenced
thru its interface, that is the methods and attributes names.

[hmm... not very well explained. Write more and explain better]


5.3 Objects

Objects are instances of classes, that is they can be considered like couples of
datas and the methods which work on these datas.

[add more stuff...]


5.4 VTables

The main goal of [name] is to allow for a FAST mathod invocation. In most of the
cases, with the system I'm gonna explain, this goal is achieved.

From 5.1 we know that a method ID is an index into an array. This array is what
in C++ is called "VTable", that is an array of pointer to method functions.
Thus a method ID unanbiguously identifies a method into a given array and, given
an ID, to invoke the method something like this is enough:

    (*vtable[methodid])(obj, args...)

IDs are assigned sequentially to the methods of a given interface. For example:

    interface I1
    {
        methodI1_1();
        methodI1_2();
        methodI1_3();
    };

methodI1_1 has ID 0, methodI1_2 has ID 1, methodI1_3 has ID 2.

Now say we have an interface that extends the interface I1:

    interface I2 extends I1
    {
        methodI2_1();
        methodI2_2();
        methodI3_3();
    }

In this case the methods IDs do not start at 0, but rather at 3, that is:

methodI2_1 has ID 3, methodI2_2 has ID 4, methodI2_3 has ID 5.

This way we can store the pointers to their implementation sequentially into one
single vtable:

    Method vtable[]=
    {
        methodI1_1;
        methodI1_2;
        methodI1_3;
        methodI2_1;
        methodI2_2;
        methodI3_3;
    };

It's then possible to use one single vtable thru both the interfaces I1 and
I2.

This is basically what happens with Classes and their interfaces, where there's
only one thread of inheritance, but what happens when one interface extends MORE
than one other interface?

For example:

    interface I2
    {
        methodI2_1();
        methodI2_2();
        methodI3_3();
    }

    interface I3 extends I1, I2
    {
        methodI3_1();
        methodI3_2();
        methodI3_3();
    }

How does the vtable for I3 look like? Here the rule applies that the method IDs
are assigned starting from the leftmost extended interface to the rightmost one,
and then the assignment continues with the extending interface itself.

Thus:

    Method vtable[]=
    {
        methodI1_1;
        methodI1_2;
        methodI1_3;
        methodI2_1;
        methodI2_2;
        methodI3_3;
        methodI3_1;
        methodI3_2;
        methodI3_3;
    };

But the multiple inheritance of interfaces is a characteristic that comes in
hand when we need to utilize only ONE of the multiple interfaces that a given
interface extends or that a given class implements, thus there must be a way of
getting only the methods of the interface I2 inside the interface I3, for
example. This is, infact, the argument of the section 5.6.


5.5 Methods invocation

Think of the interface I3. What happens to its method IDs if the interface
I2 grows? The method IDs simply adapt themselves to the new situation, thus they
are not fixed. We can generalize this by saying that

    5.5.a) an interface that extends another interface has not fixed IDs
           for its methods.

So, if these ids are not fixed, how can we get to know about their values?

In 5.1 we learnt that an interface is a collection of methods names. This means
that we have to query an interface for the methods we want to get the id of,
passing it their names.

Once we have the method ID we need a vtable, so how do we get it?

Classes hold informations about which interfaces they implement. They also
can give us the vtable we're asking for, given they implement the
related interface.

Once we have a vtable and a method ID we can invoke the method on a given
Object.

Thus, summarizing:

1) First we need the method ID of a method of a given interface
2) Then we need the interface's vtable
3) Now we can invoke the method on a given object

Once created, an interface doesn't change during all of its life, that is until
there's a class in the system that uses it, that is until there is an object
that uses that class. This pratically means that method IDs are actually FIXED
during the life cycle of a given program, although they are not fixed in
general, thus we can get at startup-time all the method ID's that the program is
gonna use and consequently not waste cpu cycles every time a method has to be
invoked. This can be somehow automated by mean of a special linker that
recognizes the IDs names and automatically writes the needed code to get their
values.

Another way might be that the method IDs are still gotten at runtime,
but only once, that is lazy binding. This might be achieved by building stub
functions that use some static variables to store the IDs in, but also by
writing some self modifying code.

All that might be avoided altogether in a system with dynamic linking.

One thing must be borne in mind: method IDs are NOT necessarily unique, that is
different methods in different interfaces can have equal method IDs. This might
lead to crashes and/or unexpected behaviours in case one method is invoked on an
object that belongs to a class that doesn't implement the interface to which the
method we are invoking belongs. How can we avoid that?

Solving this problem actually means being able to use this system at all,
because otherwise the system would be too fragile.

Well, the solution is quite simple, actually, and consists in giving the
compiler the job of checking types so that it's not possible invoking a method
on the wrong object.

Observe this type definition in C

    typedef struct Object
    {
        IPTR (**)() vtable;
        APTR        data;
    } Object;

This type describes a "reference" to an object of the class Object, that would
be the root class of the OO framework. Call it Root, if you wish.

Each interface would define such a type, perfectly equaly to the above one, with
the only difference that the name would be different, thus casting among
different types like thos would result in a compile time error. This is, infact,
where the compiler's job lies.

To invoke a method on an object first we need to instantiate an object. This can
be done with this code [not definitive]:

    Object obj = NewObject(Object, tags);

The above code would instantiate an object of the class "Object".

Then to invoke a method we use the macro

    DoMethod
    (
        Obj,       // The object to invoke the method on
        Interface, // The interface's name to which the Method belongs. It must
                   // be the same interface to wich Obj belongs
    	Method,    // The method's name
        Args...    // The method's arguments
    )


    #define DoMethod(Obj, Interface, Method, Args...) \
        (((Interface ## _ ## Method ## _type)((Interface)(Obj)).vtable[Interface ## _ ## Method ## _ ## id])(Obj, Args))

With a wise use of the preprocessor and of the type casting it's IMPOSSIBLE
invoking a method on the wrong object.

[needs further explanation].

If the compiler supplied a pseudo function like "nameoftype(type)" à la typeof()
it would be possible not passing the interface's name to the DoMethod() macro,
thus making more natural and readable the code. The macro could infact look like
this:

    #define DoMethod(Obj, Method, Args...) \
        (((nameoftype(typeof(Obj)) ## _ ## Method ## _type)(Obj)).vtable[nameoftype(typeof(Obj)) ## _ ## Method ## _ ## id])(Obj, Args))

So this is definitely something that must be looked into.

5.6 Casting

Say that I have this class hierarchy:

          Object
            ||
            ||
            \/
          Shape
            ||
            ||
            \/
  Circle, Square, Triangle

And I have these objects references:

    Circle   c;
    Square   s;
    Triangle t;

I want to be able to store them into an array, so that I can act on them looking
at them just as "Shapes". Thus I need an array of shapes:

    Shape    shapes[3];

The problem, here, is that I cannot just do something like

    5.6.a) shapes[0] = c; // wrong!

because this is not C++ and the C compiler doesn't know how to cast a Circle to
a Shape. This basically means that the casting cannot be implicit.

A macro StaticCast() will come in hand, in this case:

    #define StaticCast(Interface, Obj) ((Interface){Obj.vtable, Obj.data})

This macro accepts as input the interface to which the object has to be casted
and the object itself.

Thus, whilst 5.6.a is wrong, this is correct:

    5.6.b) shapes[0] = StaticCast(Shape, c);

The attentive reader will have noticed something important in the above macro:
there's NO checking to see whether the Object's class really implements the
requested interface!

That is, infact, an unsafe casting, that because of this is also very fast. It
must be used only when one really knows what he/she's doing, and it can always
be used to cast one class to one of its parents.

It can NEVER be used, instead, to cast from an interface to one of the
interfaces that it extends and that is not the leftmost one. This is because the
vtable, in that case, will not start at the same address as the old one, but
will instead be shifted by some places.

In all those cases that it's not possible using StaticCast(), then DynamicCast()
must be used [not definitive]:

    #define DynamicCast(Interface, Obj)((Interface){GetVTable(Obj, Interface ## _id), Obj.data})

GetVTable is a function/macro [still to be defined] that gets an object
reference and an interface ID and gives back the related vtable for the given
object. In case the interface is not implemented in the object's class then an
*exception* is arisen.

This is the safest way of casting, but it's also the slowest one, thus when
possible must be avoided.


5.7 Exceptions

As explained in 4.4 exceptions are widely used in [name]. This section describes
the C interface and the implementation of the exceptions in [name].

The code that wanted to handle exceptions in [name] would look this way:

5.7.a)

    TRY
    {
        /* Code that can generate exceptions */
        ...
    }
    CATCH(Exception1, name1)
    {
        /* Code that handles the exception */
        ...
    }
    CATCH(Exception2, name2)
    {
        /* Code that handles the exception */
        ...
    }
    ...
    CATCH(ExceptionN, nameN)
    {
        /* Code that handles the exception */
        ...
    }
    ENDCATCH

If you are familiar with the try...catch block of C++ and Java you surely get
what does it do.

The above code would be translated, with the help of the C preprocessor, in the
below code [Not definitive]:


5.7.b)

    {
        jmp_buf oldexceptbuf = currentexceptbuf;
        IPTR (**)() vtable;

        if (setjmp(&currentexceptbuf) == 0)
        {
            {
                /* code that can generate exceptions */
                ...
            }
        }
        else
        if ((vtable == GetVTableNoExcept(currexception, Exception1_id)))
        {
            Exception1 name1 = (Exception1)({vtable, currentexception.data});

            currentexceptbuf = oldexceptbuf;

            {
                /* Code that handles the exception */
                ...
            }
        }
        else
        if ((vtable == GetVTableNoExcept(currexception, Exception2_id)))
        {
            Exception2 name2 = (Exception2)({vtable, currentexception.data});

            currentexceptbuf = oldexceptbuf;

            {
                /* Code that handles the exception */
                ...
            }
        }
        ...
        else
        if ((vtable == GetVTableNoExcept(currexception, ExceptionN_id)))
        {
            ExceptionN nameN = (ExceptionN)({vtable, currentexception.data});

            currentexceptbuf = oldexceptbuf;

            {
                /* Code that handles the exception */
                ...
            }
        }
        else
        {
            /* Default code for the exception handling */
        }

        currentexceptbuf = oldexceptbuf;
    }

The macros look like this:

5.7.c)

    #define TRY                                  \
    {                                            \
        jmp_buf oldexceptbuf = currentexceptbuf; \
        IPTR (**)() vtable;                      \
                                                 \
        if (setjmp(&currentenv) == 0)            \
        {

currentexceptbuf is a per-task global variable that holds the status to which
the program has to go in case an exception is "thrown". This status is
saved and the current one is put in the variable so that the exceptions thrown
by the code inside the TRY block will be caught by the related CATCH blocks.

    #define CATCH(Interface, Obj)                                           \
        }                                                                   \
        else                                                                \
        if ((vtable == GetVTableNoExcept(currexception, Interface ## _id))) \
        {                                                                   \
            Interface Obj = (Interface)({vtable, currentexception.data});   \
                                                                            \
            currentexceptbuf = oldexceptbuf;

In case an exception is thrown, setjmp() will return a non-zero value and so the
CATCH block will be executed. The above code checks whether the exception is an
object of a class that implements a given interface. To do this check is used a
version of GetVTable(), that we saw in 5.5, that doesn't throw an exception in
case the object's class doesn't implement the interface. GetVTable() itself,
infact, makes use of GetVTableNoExcept() for its purpouses.

If the exception object's class doesn't implement the interface then the next
CATCH block, if present, will be executed, otherwise the previous status is
restored so that another exception can be thrown if necessary, and the code
inside the CATCH block is executed.

    #define ENDCATCH                                       \
        }                                                  \
        else                                               \
        {                                                  \
            /* Default code for the exception handling */  \
        }                                                  \
                                                           \
        currentexceptbuf = oldexceptbuf;
    }

If no exceptions are caught then the above code is executed, which deals with
the exception in a default way [ define which way ].

As we know, the exceptions can be "thrown". To do this another macro comes
in hand, that is

     THROW
     (
         ExceptionX,  // The interface's name implemented by the class of which
                      // the exception object has to be an instantation.
         tags...      // The tags and their values used by the class'
                      // constructor
     );

The exception's class MUST implement the "Exception" interface, either
directly or thru another class that it extends. This will be checked at runtime,
and in case this requirement is not meet an exception [put here the name of the
exception] will be thrown, of course not using the THROW() macro [this has to
be revised, perhaps].


This is how the macro is suposed to look like [it's just the first thought]:

    #define THROW(ExceptionX, tags...)                                            \
    {                                                                             \
        /* Dispose the old exception, if there's any */                           \
        if (currexception.data) DisposeObject(currexception);                     \
                                                                                  \
        if (HasInterface(ExceptionX ## _id, Exception ## _id))                    \
        {                                                                         \
	    /* Create a new one */                                                \
            currexception = StaticCast(Exception, NewObject(ExceptionX, ##tags)); \
                                                                                  \
	    /* Return to the previous saved state */                              \
            longjmp(&currentexceptbuf, 1);                                        \
        }                                                                         \
        else                                                                      \
        {                                                                         \
	    /* Create a new one */                                                \
            currexception = StaticCast(Exception, NewObject(ExceptionNotValid));  \
                                                                                  \
	    /* Return to the previous saved state */                              \
            longjmp(&currentexceptbuf, 1);                                        \
        }                                                                         \
    }                                                                             

[What if while throwing an exception we run out of memory? Does the
"OutOfMemory" exception have to be handled separately, perhaps?]

5.7.1 Exceptions and AROS

To implement exceptions there's the need of some per-task global variables. These
variables can be put, in AROS, within the ETask structure of the Task structure. This is
all that is needed, I think, to implement exceptions in AROS.




Appendices

A - TODO

1) Give a proper name, preferably an acronym, to this OO framework. It has to
   be something easy to remember and with a strong meaning. BOOPSI(tm) is a good
   example of such an acronym, but of course it's not appropriate to this
   context.

2) Replace all the [name] occurrencies in this text with the chosen name

3) Have a deeper look at the exceptions handling

4) Write anything that has not been written until now and that needs to :)




B - Contributors

Fabio Alemagna <falemagn@studenti.unina.it> - The ideator




C - ChangeLog

$Log$
Revision 1.8  2001/12/11 19:39:25  falemagn
Fixed some types and added a little section about how to implement exceptions in AROS

Revision 1.7  2001/12/11 18:55:25  falemagn
Corrected some typos

Revision 1.6  2001/12/11 18:50:54  falemagn
Added the sections regarding the exceptions handling. Please give me your comments...

