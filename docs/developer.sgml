<!DOCTYPE BOOK PUBLIC "-//Davenport//DTD DocBook V3.0//EN">

<!-- $Id$ -->

<!-- IDs are named the following way:
     glos-NAME for glossary entries
     part-NAME for <PART>
     chap-NAME for <CHAPTER>
     sect-NAME for <SECT1> through <SECT5>
     expl-NAME for explanations inside a <SECT?>, for example flag-lists or
               function descriptions
     TYPE-prog-NAME for explanations, how to implement a feature (eg
                    chap-prog_libraries on a tutorial, how to implement a
                    custom library)
     DIR-NAME-h for include-files (eg exec-memory-h)
     DIR-NAME-ENTITY for entities in include files (eg exec-libraries-library
                     for struct Library or exec-memory-memf for MEMF_ flags)
     LIB-library for ToC of library functions (eg exec-library)
     LIB-FUNCNAME for function references (eg exec-openlibrary for
                  OpenLibrary() of exec.library)
-->

<BOOK>
  <TITLE><PRODUCTNAME>The Amiga Research OS</PRODUCTNAME></TITLE>
  <TITLEABBREV><ACRONYM role="aros">AROS</ACRONYM></TITLEABBREV>
  <BOOKINFO>
    <BOOKBIBLIO>
      <TITLE><ACRONYM role="aros">AROS</ACRONYM> Programming Guide</TITLE>
      <TITLEABBREV><ACRONYM>APG</ACRONYM></TITLEABBREV>
      <SUBTITLE>Learn how to program <ACRONYM role="aros">AROS</ACRONYM></SUBTITLE>
      <AUTHORGROUP>
        <CORPAUTHOR>The AROS project</CORPAUTHOR>
        <AUTHOR lang="de"><FIRSTNAME>Sebastian</FIRSTNAME><SURNAME>Rittau</SURNAME></AUTHOR>
      </AUTHORGROUP>
      <COPYRIGHT><YEAR>1998</YEAR><HOLDER>AROS - The Amiga Research OS</HOLDER></COPYRIGHT>
      <ABSTRACT><SIMPARA>
        <ACRONYM role="aros">AROS</ACRONYM> - The <PRODUCTNAME>Amiga Research Operating
        System</PRODUCTNAME> tries to port the <ACRONYM>API</ACRONYM> of the
        Amiga Operating System to different hardware platform. This document
        provides an introduction to programming <ACRONYM role="aros">AROS</ACRONYM> by
        describing how <ACRONYM role="aros">AROS</ACRONYM> works and by describing its
        <ACRONYM>API</ACRONYM>.
      </SIMPARA></ABSTRACT>
      <RELEASEINFO>This is the very first version of this document. It is work-in-progress.</RELEASEINFO>
    </BOOKBIBLIO>
  </BOOKINFO>

  <TOC></TOC>

<!-- ================================================================ -->
<!-- ============================= Concepts ========================= -->
<!-- ================================================================ -->

  <PART id="part-concepts"><TITLE>Concepts</TITLE>

<!-- ============================== General ========================= -->

    <CHAPTER id="chap-general"><TITLE>Includes, Definitions and General Programming Issues</TITLE>
      <SECT1><TITLE>Include Files</TITLE>
        <PARA><ACRONYM role="aros">AROS</ACRONYM> comes with a variety of include files.
        As <ACRONYM role="aros">AROS</ACRONYM> is a pointer- and structure-rich operating
        system, these files are mainly used for defining these structures.
        </PARA>
      </SECT1>

      <SECT1><TITLE>Types</TITLE>
        <PARA>In <FILENAME class="headerfile">exec/types.h</FILENAME>
        the following short-cuts are typedef'd. They are used often in
        <ACRONYM role="aros">AROS</ACRONYM>, so you should nearly always include
        <FILENAME class="headerfile">exec/types.h</FILENAME>.
        <ITEMIZEDLIST spacing="compact">
          <LISTITEM><SIMPARA><TYPE>APTR</TYPE>: a generic pointer for multiple purposes</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>STRPTR</TYPE>: a pointer to a null-terminated string</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>UQUAD</TYPE>: unsigned 64bit variable</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>QUAD</TYPE>: signed 64bit variable</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>DOUBLE</TYPE>: 64bit <ACRONYM>IEEE</ACRONYM> floating point variable</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>ULONG</TYPE>: unsigned 32bit variable (longword)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>LONG</TYPE>: signed 32bit variable (longword)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>FLOAT</TYPE>: 32bit <ACRONYM>IEEE</ACRONYM> floating point variable</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>UWORD</TYPE>: unsigned 16bit variable (word)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>WORD</TYPE>: signed 16bit variable (word)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>UBYTE</TYPE>: unsigned 8bit variable (byte)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>BYTE</TYPE>: signed 8bit variable (byte)</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>BOOL</TYPE>: boolean variable, <SYMBOL>TRUE</SYMBOL> and <SYMBOL>FALSE</SYMBOL> are also defined in <FILENAME class="headerfile">exec/types.h</FILENAME></SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><TYPE>VOID</TYPE>: void</SIMPARA></LISTITEM>
        </ITEMIZEDLIST></PARA>

<!-- =================== -->

        <SECT2><TITLE><TYPE>IPTR</TYPE>s</TITLE>
          <PARA>There is another important typedef, <TYPE>IPTR</TYPE>.
          It is really important in <ACRONYM role="aros">AROS</ACRONYM>, as it the only
          way to declare a field that can contain both: an integer and a pointer.
          </PARA>
          <NOTE>
            <PARA>AmigaOS does not know this typedef. If you are porting a
            program from AmigaOS to <ACRONYM role="aros">AROS</ACRONYM>,
            you have to search your source for occurences of
            <TYPE>ULONG</TYPE>s that can also contain pointers, and change them
            into <TYPE>IPTR</TYPE>s. If you don't do this, your program will
            not work on systems, which have pointers with more than 32 bits
            (for example <PRODUCTNAME><ACRONYM>DEC</ACRONYM> Alpha</PRODUCTNAME>s
            that have 64bit pointers).</PARA>
          </NOTE>
        </SECT2>

<!-- ================= -->

        <SECT2><TITLE><TYPE>BPTR</TYPE>s</TITLE>
          <PARA>The so-called <TYPE>BPTR</TYPE>s were always a problem
          in AmigaOS and this problem was inherited by <ACRONYM role="aros">AROS</ACRONYM>.
          In binary-compatible <ACRONYM role="aros">AROS</ACRONYM> versions a
          <TYPE>BPTR</TYPE> is in fact the fourth of the real pointer.
          If, for example, a pointer points to address
          <LITERAL>$80000</LITERAL>, the <TYPE>BPTR</TYPE>, pointing to the
          same address would contain <LITERAL>$20000</LITERAL>.
          On systems without binary-compatibility, a <TYPE>BPTR</TYPE> is
          equal to an <TYPE>APTR</TYPE>.</PARA>
          <PARA>To convert between a normal pointer and a <TYPE>BPTR</TYPE>,
          use the macros
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;dos/bptr.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>APTR <FUNCTION>MKBADDR</FUNCTION></FUNCDEF>
              <PARAMDEF>BPTR <PARAMETER>bptr</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>BPTR <FUNCTION>BADDR</FUNCTION></FUNCDEF>
              <PARAMDEF>APTR <PARAMETER>ptr</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          </PARA>
          <PARA>There also exists something called <TYPE>BSTR</TYPE>, a special
          kind of string. We will not dicuss this here, though, because it is
          used only very rarely.</PARA>
          <SIDEBAR><TITLE>History</TITLE>
            <PARA>When the development of the Amiga started, it was designed
            as a pure module-based games-console. As such it didn't need any
            means of filesystem handling. The OS was created without it in
            mind. But Commodore, who bought the Amiga, wanted a full-fletched
            home-computer instead of another games-platform. So, a short time
            before the Amiga's initial presentation, a filesystem was needed.
            Instead of wasting time in developing a custom one, the filesystem
            of an operating systm called <ACRONYM>TRIPOS</ACRONYM> was ported
            to the Amiga. Unfortunately <ACRONYM>TRIPOS</ACRONYM> was written
            in <ACRONYM>BCPL</ACRONYM>, a programming language with a quite
            eccentric pointer handling. This pointer handling was inherited
            by the AmigaDOS and later by <ACRONYM role="aros">AROS</ACRONYM> (even though
            later versions of AmigaOS and also <ACRONYM role="aros">AROS</ACRONYM> are
            written in C).</PARA>
          </SIDEBAR>
        </SECT2>
      </SECT1>

<!-- ================ -->

      <SECT1><TITLE>Program Execution</TITLE>
        <PARA>All <ACRONYM role="aros">AROS</ACRONYM> programs must return a program
        execution status. This status expresses, if the program was executed
        successful, and if not, how serious the case of failure was. In
        <FILENAME class="headerfile">dos/dos.h</FILENAME> the following
        constants are defined, which represent the standard return states:
        <ITEMIZEDLIST spacing="compact">
          <LISTITEM><SIMPARA><SYMBOL>RETURN_OK</SYMBOL> is returned, if the
          program executed successfully.</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><SYMBOL>RETURN_WARN</SYMBOL> means that the
          program executed successfully, but there was something not quite
          right. This could be returned, if for example a temporal file could
          not be deleted after use.</SIMPARA>
          <SIMPARA><SYMBOL>RETURN_WARN</SYMBOL> is also returned to express a
          boolean state. In this case <SYMBOL>RETURN_WARN</SYMBOL> means
          true, while <SYMBOL>RETURN_OK</SYMBOL> means false.</SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><SYMBOL>RETURN_ERROR</SYMBOL> is returned on
          errors that caused the execution of the program to fail partly.
          </SIMPARA></LISTITEM>
          <LISTITEM><SIMPARA><SYMBOL>RETURN_FAIL</SYMBOL> is returned if the
          execution of the program failed completely.</SIMPARA></LISTITEM>
        </ITEMIZEDLIST></PARA>
      </SECT1>
    </CHAPTER>

<!-- ======================== Libraries and Taglists ====================== -->

    <CHAPTER id="chap-libraries"><TITLE>Libraries and Taglists</TITLE>
      <SECT1 id="sect-libraries"><TITLE>Introduction to Libraries</TITLE>
        <PARA><FIRSTTERM>Shared libraries</FIRSTTERM> are the magic that make
        <ACRONYM role="aros">AROS</ACRONYM> work. Every library is a collection of
        functions that fulfill a certain purpose. Normally functions with a
        similar purpose are contained in one library. For example all the
        basic memory handling functions are contained in
        <FILENAME role="library">exec.library</FILENAME>.</PARA>

        <PARA>Libraries are normally found in the
        <FILENAME class="directory">LIBS:</FILENAME> directory, but can also
        be stored at other places. Some important libraries are not stored as
        a separate file, but are contained in the kernel. Note that this the
        kernel libraries are different from installation to installation, so
        don't depend on a specific library being part of the kernel.</PARA>

        <PARA>Here is a list of some important libraries and their function.
        You don't have to remember all of these, as they will be discussed
        later in detail.</PARA>

        <ITEMIZEDLIST>
          <LISTITEM><PARA><FILENAME role="library"><LINK linkend="exec-library">exec.library</LINK></FILENAME>
          is the most important library. It is responsible for handling the
          most basic things like managing <LINK linkend="sect-tasks">tasks</LINK>
          (ie programs), <LINK linkend="sect-memory">memory</LINK>,
          <LINK linkend="sect-libraries">libraries</LINK> and many other
          things.</PARA></LISTITEM>

          <LISTITEM><PARA><FILENAME role="library"><LINK linkend="utility-library">utility.library</LINK></FILENAME>
          implements very important mechanisms for "talking" to libraries:
          <LINK linkend="sect-taglists">taglists</LINK> that will be dicussed later
          in this chapter and <LINK linkend="sect-hooks">hooks</LINK>. Apart from
          that, utility contains miscellaneous small utility functions.
          </PARA></LISTITEM>

          <LISTITEM><PARA><FILENAME role="library"><LINK linkend="dos-library">dos.library</LINK></FILENAME>
          is responsible for file-handling and some basic I/O functions.
          Without dos, <ACRONYM role="aros">AROS</ACRONYM> would not be able to access
          files.</PARA></LISTITEM>

          <LISTITEM><PARA><FILENAME role="library"><LINK linkend="intuition-library">intuition.library</LINK></FILENAME>
          handles <LINK linkend="part-gui">graphical user interfaces
          (<ACRONYM>GUI</ACRONYM>s)</LINK>. With intuition you can create
          <LINK linkend="chap-windows">windows</LINK> and
          <LINK linkend="chap-gadgets">gadgets</LINK> and handle them accordingly.
          There are other libraries, which work on top of intuition and
          provide more sophisticated and more specialized <ACRONYM>GUI</ACRONYM>
          functions. Examples are <FILENAME role="filename"><LINK linkend="gadtools-library">gadtools.library</LINK></FILENAME>,
          which implements some more complicated gadgets and
          <FILENAME role="library"><LINK linkend="asl-library">asl.library</LINK></FILENAME>,
          which provides file- and other <LINK linkend="chap-requesters">requesters</LINK>.
          </PARA></LISTITEM>

          <LISTITEM><PARA><FILENAME role="library"><LINK linkend="boopsi-library">boopsi.library</LINK></FILENAME>
          handles <LINK linkend="chap-boopsi"><ACRONYM role="aros">AROS</ACRONYM>' internal
          object oriented system (<ACRONYM>BOOPSI</ACRONYM>)</LINK>.</PARA></LISTITEM>
        </ITEMIZEDLIST>
      </SECT1>

<!-- ================ -->

      <SECT1><TITLE>Usage of Libraries</TITLE>
        <PARA>To use the functions of a library, you have to open the library
        first. The only library that doesn't have to be opened first is
        <FILENAME role="library">exec.library</FILENAME>. Exec is always open and your compiler
        knows how to access it. Your compiler may addtionally open some
        libraries for you, so you don't have to open them manually. Read your
        compiler's manual to learn about such features.</PARA>

        <PARA>To open a library you have to use a function of
        <FILENAME role="library">exec.library</FILENAME>:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>struct Library * <FUNCTION>OpenLibrary</FUNCTION></FUNCDEF>
            <PARAMDEF>STRPTR <PARAMETER>name</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>version</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS></PARA>

        <PARA><FUNCTION>OpenLibrary()</FUNCTION> takes two arguments:
        <ITEMIZEDLIST>
          <LISTITEM><PARA><PARAMETER>name</PARAMETER> points to the name of
          the library. Normally this is just the plain name, but this can
          also be a complete (absolute or relative) path to the library.</PARA>
          <NOTE><PARA>Paths do not work with kernel-based libraries
          (<ABBREV>ie</ABBREV> libraries that are included in the kernel).
          Use absolute path only, if you know exactly, what you are doing!
          </PARA></NOTE></LISTITEM>

          <LISTITEM><PARA><PARAMETER>version</PARAMETER> is the minimal
          version of the library to open. If the named library is found, but
          its version is lower than <PARAMETER>version</PARAMETER>, the
          library will not be opened, but an error will be returned. Versions
          are important, because libraries are supposed to be expandable. Some
          functions are only available from a certain version of a library on.
          For example the function <FUNCTION><LINK linkend="exec-allocvec">AllocVec()</LINK></FUNCTION>
          of <FILENAME role="library">exec.library</FILENAME> was introduced in version 36
          of the library. If you try to call this function with lower versions
          of <FILENAME role="library">exec.library</FILENAME> installed, unexpected things
          will happen (most likely the application will crash).</PARA></LISTITEM>
        </ITEMIZEDLIST></PARA>

        <PROCEDURE>
          <PARA>The following procedure is used to load the library to open:</PARA>
          <STEP>
            <PARA>First, the name of the library is searched for in the
            list of already loaded libraries (<GLOSSTERM><FIRSTTERM>resident
            list</FIRSTTERM></GLOSSTERM>). If this library
            was loaded into memory before (eg by a different program) and still
            is there, everything is fine and <FUNCTION>OpenLibrary()</FUNCTION>
            returns now.</PARA>
            <PARA>Libraries in the kernel are always on list of loaded libraries.</PARA>
            <NOTE><PARA>Comparisons in this list are case sensitive! Be sure
            to use the right case in <PARAMETER>name</PARAMETER>. Normally
            all characters in a library name are lower-case.</PARA></NOTE>
          </STEP>
          <STEP performance="optional">
            <PARA>If the library was not found in the resident list and
            a path was supplied with <PARAMETER>name</PARAMETER>, the given
            file is tried to be opened. If this fails,
            <FUNCTION>OpenLibrary()</FUNCTION> returns an error.
          </STEP>
          <STEP>
            <PARA>If only the plain library-name was given, the library is
            searched for in the <GLOSSTERM>current directory</GLOSSTERM>
            first. If it's not found there, it is searched for in the
            directory <FILENAME class="directory">LIBS:</FILENAME>.
          </STEP>
        </PROCEDURE>

        <PARA><FUNCTION>OpenLibrary()</FUNCTION> returns either a pointer to
        a structure, describing the library (<LINK linkend="exec-libraries-library">struct <STRUCTNAME>Library *</STRUCTNAME></LINK>
        defined in <FILENAME class="headerfile">exec/libraries.h</FILENAME>)
        or <SYMBOL>NULL</SYMBOL>, meaning that opening the library failed for
        some reason. The resulting pointer has to be stored for the compiler's
        use. Normally it is stored in a variable in the form:
        <LITERAL><REPLACEABLE>Libname</REPLACEABLE>Base</LITERAL>, eg
        <LITERAL>IntuitionBase</LITERAL> for the pointer to
        <FILENAME role="library">intuition.library</FILENAME>.</PARA>

        <PARA>After opening the library, you can use its functions by just
        calling them like any other function in your program. But to let your
        compiler know, what to do, you have to include the
        library-specific header-file. This is normally called
        <FILENAME class="headerfile">proto/<REPLACEABLE>libname</REPLACEABLE>.h</FILENAME> for
        C compilers.</PARA>

        <PARA>When you have finished using the library you have to close it
        again to free the resources used by it. This is performed with:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>void <FUNCTION>CloseLibrary</FUNCTION></FUNCDEF>
            <PARAMDEF>struct Library * <PARAMETER>libbase</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS></PARA>

        <PARA><FUNCTION>CloseLibrary()</FUNCTION> closes the library pointed
        to by <PARAMETER>libbase</PARAMETER>. This may also be
        <SYMBOL>NULL</SYMBOL>, in which case <FUNCTION>CloseLibrary()</FUNCTION>
        does nothing.</PARA>

        <PARA>We will demonstrate the use of libraries by creating a small
        graphical hello-world program. Instead of printing <COMPUTEROUTPUT>Hello World!</COMPUTEROUTPUT> to
        the console, we will display it in a requester. A function to display
        a requester is <FUNCTION><LINK linkend="intuition-easyrequestargsa">EasyRequestArgs()</LINK></FUNCTION>,
        being a function of <FILENAME role="library">intuition.library</FILENAME>.
        We will not discuss its usage here. For more information, see the
        section about <LINK linkend="chap-requesters">Requesters</LINK>.</PARA>

        <EXAMPLE><TITLE>Usage of libraries</TITLE>
          <PROGRAMLISTING>
#include &lt;proto/exec.h>          /* OpenLibrary() and CloseLibrary() */
#include &lt;exec/libraries.h>      /* struct Library */
#include &lt;dos/dos.h>             /* RETURN_OK and RETURN_FAIL */
#include &lt;proto/intuition.h>     /* EasyRequestArgs() */
#include &lt;intuition/intuition.h> /* struct EasyStruct */

/* This variable will store the pointer to intuition.library */
struct Library *IntuitionBase;

int main(int argc, char *argv[])
{
    /* Needed for EasyRequestArgs(). Just ignore. */
    struct EasyStruct es = {
      sizeof(struct EasyStruct), 0UL,
      "Requester", "Hello World!", "Ok"
    };

    /* First, we open intuition.library. We need version 36 or better,
       because EasyRequestArgs() was introduced in that version of
       intuition.library.
    */
    IntuitionBase = OpenLibrary("intuition.library", 36);

    /* We have to check, if intuition.library was successfully opened.
       If it was not, we must not call a function from it, so we return
       immediatly with an error.
    */
    if (!IntuitionBase)
        return RETURN_FAIL;

    /* After opening intuition.library, we can call EasyRequestArgs(). */
    EasyRequestArgs(NULL, &amp;es, NULL, NULL);

    /* At last, we have to close intuition.library again. */
    CloseLibrary(IntuitionBase);

    return RETURN_OK;
}
          </PROGRAMLISTING>
        </EXAMPLE>

        <PARA>Try to compile and run this program. It should present you a
        handsome hello-world requester.</PARA>
      </SECT1>

<!-- =============== -->

      <SECT1 id="sect-taglists"><TITLE>Giving Additional Arguments with Taglists</TITLE>
        <PARA>Every library function takes a fixed number of arguments. This
        poses quite a problem with complex functions that would need a lot of
        arguments. To avoid this problem, so-called taglists were introduced.
        In <FILENAME class="headerfile"><LINK linkend="utility-tagitem-h">utility/tagitem.h</LINK></FILENAME>
        we find a structure <STRUCTNAME>TagItem</STRUCTNAME>, which contains
        the members <STRUCTFIELD>ti_Tag</STRUCTFIELD> and
        <STRUCTFIELD>ti_Data</STRUCTFIELD>. A taglist contains of an array of
        this structure. The size of the list is not limited. The field
        <STRUCTFIELD>ti_Tag</STRUCTFIELD> is an identifier (often referred to
        as <FIRSTTERM>Tag</FIRSTTERM>) that declares what
        <STRUCTFIELD>ti_Data</STRUCTFIELD> contains.
        <STRUCTFIELD>ti_Data</STRUCTFIELD> is either an integer or a pointer.
        It is guaranteed to be at least of the size of a long-word or a
        pointer (whichever is bigger).</PARA>

        <PARA>In every description of a function that uses a tag-list, all
        possible tags are listed. Functions have to ignore unknown tags and
        use defaults for tags not provided, so taglists are a very flexible
        way of providing arguments to a function.</PARA>

        <PARA>There are some special tags that all functions understand
        (defined in <FILENAME class="headerfile"><LINK linkend="utility-tagitem-h">utility/tagitem.h</LINK></FILENAME>):</PARA>

        <ITEMIZEDLIST>
          <LISTITEM><PARA><SYMBOL>TAG_DONE</SYMBOL> and <SYMBOL>TAG_END</SYMBOL>
          define the end of a taglist. Every taglist must be terminated with
          one of it. <STRUCTFIELD>ti_Data</STRUCTFIELD> must be ignored by
          the called function, so it doesn't have to exist in memory.</PARA></LISTITEM>

          <LISTITEM><PARA><SYMBOL>TAG_IGNORE</SYMBOL> means that the contents
          of <STRUCTFIELD>ti_Data</STRUCTFIELD> is to be ignored. This tag is
          especially useful for conditional inclusion of tags.</PARA></LISTITEM>

          <LISTITEM><PARA><SYMBOL>TAG_MORE</SYMBOL>: By using this tag, you
          can link taglists together. <STRUCTFIELD>ti_Data</STRUCTFIELD>
          points to another taglist. Processing of the current taglist will
          be stopped and instead the new one will be processed. This tag also
          terminates the current taglist.</PARA></LISTITEM>

          <LISTITEM><PARA><SYMBOL>TAG_SKIP</SYMBOL> forces the parser to
          skip the next <STRUCTFIELD>ti_Data</STRUCTFIELD> tags. They will
          not be processed.</PARA></LISTITEM>
        </ITEMIZEDLIST>

        <PARA>You may always provide <SYMBOL>NULL</SYMBOL> instead of a pointer
        to a taglist. All functions must be able to handle
        <SYMBOL>NULL</SYMBOL> pointers. They are equal to taglists with
        <SYMBOL>TAG_DONE</SYMBOL> as first tag.</PARA>

        <PARA>A function that requires a taglist is:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/intuition.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>struct Window * <FUNCTION>OpenWindowTagList</FUNCTION></FUNCDEF>
            <PARAMDEF>struct NewWindow * <PARAMETER>newwin</PARAMETER></PARAMDEF>
            <PARAMDEF>struct TagList * <PARAMETER>taglist</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
        This function will be discussed in detail in the
        <LINK linkend="chap-windows">chapter about windows</LINK>. For
        now you only have to know that this function opens a new window.
        We set the argument <PARAMETER>newwin</PARAMETER> to
        <SYMBOL>NULL</SYMBOL>. The only tags looked at for now are:
        <INFORMALTABLE colsep="0" rowsep="0" frame="none">
          <TGROUP cols="3">
            <COLSPEC align="left">
            <COLSPEC align="left">
            <COLSPEC align="left">
            <THEAD><ROW><ENTRY>Tag</ENTRY><ENTRY>Description</ENTRY><ENTRY><STRUCTFIELD>ti_Data</STRUCTFIELD></ENTRY></ROW></THEAD>
            <TBODY>
              <ROW>
                <ENTRY><SYMBOL>WA_Width</SYMBOL></ENTRY>
                <ENTRY>width of window in pixel</ENTRY>
                <ENTRY><SYMBOL>UWORD</SYMBOL>
              </ROW>
              <ROW>
                <ENTRY><SYMBOL>WA_Height</SYMBOL></ENTRY>
                <ENTRY>height of window in pixel</ENTRY>
                <ENTRY><SYMBOL>UWORD</SYMBOL>
              </ROW>
              <ROW>
                <ENTRY><SYMBOL>WA_Title</SYMBOL></ENTRY>
                <ENTRY>string in window title</ENTRY>
                <ENTRY><SYMBOL>STRPTR</SYMBOL></ENTRY>
              </ROW>
            </TBODY>
          </TGROUP>
        </INFORMALTABLE></PARA>
        <PARA>Another function we need for our small example is:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/intuition.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>void <FUNCTION>CloseWindow</FUNCTION></FUNCDEF>
            <PARAMDEF>struct Window * <PARAMETER>win</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
        This function is used to close an opened window.</PARA>

        <PARA>Now let's have a look at another small hello-world-program.
        This opens window, which says "Hello World!" in the title-bar,
        for two seconds.</PARA>

        <EXAMPLE><TITLE>Usage of taglists</TITLE>
          <PROGRAMLISTING>
#include &lt;proto/exec.h>
#include &lt;exec/libraries.h>
#include &lt;proto/dos.h>
#include &lt;proto/intuition.h>
#include &lt;intuition/intuition.h>

struct Library * DOSBase;
struct Library * IntuitionBase;

int main(int argc, char *argv[])
{
    int error = RETURN_OK;

    /* We need this for Delay() later on. */
    DOSBase = OpenLibrary("dos.library", 36);
    if (DOSBase)
    {
        IntuitionBase = OpenLibrary("intuition.library", 36);
        if (IntuitionBase);
        {
            struct Window *win;
            /* We set up our tags. */
            struct TagItem tags[] = {
              { WA_Width, 100 },
              { WA_Height, 50 },
              { WA_Title, "Hello World!" },
              { TAG_DONE, 0UL }
            }

            win = OpenWindowTagList(NULL, tags);
            if (win)
            {
                /* Now wait for two seconds, so we can look at our nice
                   window.
                */
                Delay(100);

                /* We close our window again. */
                CloseWindow(win);
            }

            CloseLibrary(IntuitionBase);
        } else
            error = RETURN_FAIL;
        CloseLibrary(DOSBase);
    } else
        error = RETURN_FAIL;

    return error;
}
          </PROGRAMLISTING>
        </EXAMPLE>

        <PARA>Of course, this method of setting up the taglist is quite
        complicated. So for most functions that use taglists
        short-cuts are available. The link-library
        <FILENAME role="library">amiga.lib</FILENAME> provides these short-cuts for all
        internal <ACRONYM role="aros">AROS</ACRONYM> functions. These
        <FIRSTTERM>varargs</FIRSTTERM> versions can be used like this:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/alib.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF><FUNCTION><REPLACEABLE>MyFunc</REPLACEABLE></FUNCTION></FUNCDEF>
            <PARAMDEF><PARAMETER><REPLACEABLE>arg1</REPLACEABLE></PARAMETER></PARAMDEF>
            <PARAMDEF>...</PARAMDEF>
            <PARAMDEF><PARAMETER><REPLACEABLE>argn</REPLACEABLE></PARAMETER></PARAMDEF>
            <PARAMDEF><PARAMETER><REPLACEABLE>TAG1</REPLACEABLE></PARAMETER></PARAMDEF>
            <PARAMDEF><PARAMETER><REPLACEABLE>data1</REPLACEABLE></PARAMETER></PARAMDEF>
            <PARAMDEF>...</PARAMDEF>
            <PARAMDEF><PARAMETER>TAG_DONE</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS></PARA>

        <PARA>Our example above would look like this, using the varargs
        version of <FUNCTION>OpenWindowTagList()</FUNCTION>, called
        <FUNCTION>OpenWindowTags()</FUNCTION>:
        <EXAMPLE><TITLE>Usage of taglists, using varargs</TITLE>
          <PROGRAMLISTING>
[...]
    if (IntuitionBase);
    {
        struct Window *win;

        win = OpenWindowTags(NULL, WA_Width, 100,
                                   WA_Height, 20,
                                   WA_Title, "Hello World!",
                                   TAG_DONE);
        if (win)
        {
[...]
          </PROGRAMLISTING>
        </EXAMPLE>
        Much easier, isn't it?</PARA>
        <PARA>In the <LINK linkend="sect-prog-taglists">section about
        <ACRONYM>BOOPSI</ACRONYM></LINK>, processing of taglists will be
        discussed.</PARA>
      </SECT1>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-memory"><TITLE>Exec Lists and Memory Management</TITLE>
      <SECT1 id="sect-lists"><TITLE>Exec Lists</TITLE>
        <PARA><ACRONYM role="aros">AROS</ACRONYM> implements a system of
        <FIRSTTERM>linked lists</FIRSTTERM>, so-called <FIRSTTERM>exec lists</FIRSTTERM>.
        A linked-list consists of a number of <FIRSTTERM>nodes</FIRSTTERM>
        that point to each other. Two types of nodes are defined in
        <LINK linkend="exec-nodes-h"><FILENAME class="headerfile">exec/nodes.h</FILENAME></LINK>:
        <ITEMIZEDLIST>
          <LISTITEM><PARA>struct <STRUCTNAME>MinNode</STRUCTNAME> is the basic
          node. You don't need to know about its structure, since every
          possible action on them is handled by some library function.</PARA></LISTITEM>
          <LISTITEM><PARA>struct <STRUCTNAME>Node</STRUCTNAME> extends the
          simple struct <STRUCTNAME>MinNode</STRUCTNAME>. It provides some
          additional fields:
          <VARIABLELIST>
            <VARLISTENTRY>
              <TERM><STRUCTFIELD>ln_Name</STRUCTFIELD></TERM>
              <LISTITEM><PARA>Each <STRUCTNAME>Node</STRUCTNAME> contains a
              pointer to a string, describing that node.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><STRUCTFIELD>ln_Type</STRUCTFIELD></TERM>
              <LISTITEM><PARA><LINK linkend="exec-nodes-types">A list of
              types</LINK> is defined in <FILENAME class="headerfile"><LINK linkend="exec-nodes-h">exec/nodes.h</LINK></FILENAME>.
              </PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><STRUCTFIELD>ln_Pri</STRUCTFIELD></TERM>
              <LISTITEM><PARA>A priority, used for sorting the list.</PARA></LISTITEM>
            </VARLISTENTRY>
          </VARIABLELIST>
        </ITEMIZEDLIST></PARA>

        <PARA>Both structures can be embedded into other structures. For
        example <LINK linkend="exec-libraries-library">struct
        <STRUCTNAME>Library</STRUCTNAME></LINK> (defined in
        <LINK linkend="exec-libraries-library"><FILENAME class="headerfile">exec/libraries.h</FILENAME></LINK>)
        contains a struct <STRUCTNAME>Node</STRUCTNAME> at the beginning. This
        way all libraries can be contained in a list. The field
        <STRUCTFIELD>ln_Name</STRUCTFIELD> points to the name of the library,
        <STRUCTFIELD>ln_Type</STRUCTFIELD> is set to <SYMBOL>NT_LIBRARY</SYMBOL>
        to show that this node is a library and
        <STRUCTFIELD>ln_Pri</STRUCTFIELD> reflects the
        <EMPHASIS>importance</EMPHASIS> of a library.</PARA>

        <PARA>Of course, we need a list containers. These are defined in
        <LINK linkend="exec-lists-h"><FILENAME class="headerfile">exec/lists.h</FILENAME></LINK>.
        Like nodes, we have two different kind of lists:
        <ITEMIZEDLIST>
          <LISTITEM><PARA>struct <STRUCTNAME>MinList</STRUCTNAME> is the
          minimal list. You do not need to know about its members; look at
          it as a black-box.</PARA></LISTITEM>
          <LISTITEM><PARA>struct <STRUCTNAME>List</STRUCTNAME> contains an
          additional field <STRUCTFIELD>lh_Type</STRUCTFIELD>, which
          corresponds to <STRUCTFIELD>ln_Type</STRUCTFIELD> of
          struct <STRUCTNAME>Node</STRUCTNAME>.</PARA></LISTITEM>
        </ITEMIZEDLIST></PARA>

        <PARA><STRUCTNAME>MinList</STRUCTNAME>s take <STRUCTNAME>MinNode</STRUCTNAME>s
        as members, while <STRUCTNAME>List</STRUCTNAME>s use <STRUCTNAME>Node</STRUCTNAME>s.
        They are not interchangeable. While it's technically possible to use
        <STRUCTNAME>Node</STRUCTNAME>s in <STRUCTNAME>MinList</STRUCTNAME>s,
        you loose all their advantages.</PARA>

        <PARA>FIXME: Macros</PARA>

<!-- ================= -->

        <SECT2><TITLE>List Manipulating Functions</TITLE>
          <PARA><FILENAME role="library">exec.library</FILENAME> and the link-library
          <FILENAME role="library">amiga.lib</FILENAME> contain some functions for manipulating
          exec lists. Before a list can be used, it <EMPHASIS>must</EMPHASIS> be
          initialized, using
          the <FILENAME role="library">amiga.lib</FILENAME> function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/alib.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>NewList</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS></PARA>

          <PARA>Nodes can be added to lists with the <FILENAME role="library">exec.library</FILENAME>
          functions
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>AddHead</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
              <PARAMDEF>struct Node * <PARAMETER>node</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>AddTail</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
              <PARAMDEF>struct Node * <PARAMETER>node</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>Enqueue</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
              <PARAMDEF>struct Node * <PARAMETER>node</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>Insert</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
              <PARAMDEF>struct Node * <PARAMETER>node</PARAMETER></PARAMDEF>
              <PARAMDEF>struct Node * <PARAMETER>pred</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          With <FUNCTION>AddHead()</FUNCTION> and <FUNCTION>AddTail()</FUNCTION>
          <PARAMETER>node</PARAMETER> is inserted at the beginning or the end
          of <PARAMETER>list</PARAMETER> respectively. <FUNCTION>Enqueue()</FUNCTION>
          inserts <PARAMETER>node</PARAMETER> according to its
          <STRUCTFIELD>ln_Pri</STRUCTFIELD> field. A node can be inserted after
          another by using <FUNCTION>Insert()</FUNCTION>. A pointer to the
          node that is to predecess <PARAMETER>node</PARAMETER> must be provided
          as <PARAMETER>pred</PARAMETER>.</PARA>

          <PARA>Nodes can be removed using the <FILENAME role="library">exec.library</FILENAME>
          functions
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>Remove</FUNCTION></FUNCDEF>
              <PARAMDEF>struct Node * <PARAMETER>node</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>struct Node * <FUNCTION>RemHead</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
            <FUNCPROTOTYPE>
              <FUNCDEF>struct Node * <FUNCTION>RemTail</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          While <FUNCTION>RemHead()</FUNCTION> and <FUNCTION>RemTail()</FUNCTION>
          remove the first or last node of a <PARAMETER>list</PARAMETER>
          respectively and return a pointer to it, <FUNCTION>Remove()</FUNCTION>
          removes <PARAMETER>node</PARAMETER> from whatever list it is in.</PARA>

          <PARA>Of course, all list functions (except <FUNCTION>Enqueue())</FUNCTION>
          can process struct <STRUCTNAME>MinList</STRUCTNAME>s and
          struct <STRUCTNAME>MinNode</STRUCTNAME>s, too.</PARA>

          <PARA>A list can be searched for a named node, using
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>struct Node * <FUNCTION>FindName</FUNCTION></FUNCDEF>
              <PARAMDEF>struct List * <PARAMETER>list</PARAMETER></PARAMDEF>
              <PARAMDEF>STRPTR <PARAMETER>name</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          <PARAMETER>name</PARAMETER> is a pointer to a string that is to be
          compared with the <STRUCTFIELD>ln_Name</STRUCTFIELD> of the nodes
          in <PARAMETER>list</PARAMETER>. The comparison is case-sensitive!
          If <PARAMETER>name</PARAMETER> matches any <STRUCTFIELD>ln_Name</STRUCTFIELD>
          field, a pointer to the corresponding node is returned. If no field
          matches, <SYMBOL>NULL</SYMBOL> is returned.

          <NOTE><PARA>A list used with <FUNCTION>FindName()</FUNCTION> must not
          contain any struct <STRUCTNAME>MinList</STRUCTNAME> entries. If it
          does, memory could get corrupted!</PARA></NOTE>

          <PARA>In the following example, we create a list, add three nodes to
          it, search a named node and then remove it.</PARA>

          <EXAMPLE><TITLE>List example</TITLE>
            <PROGRAMLISTING>
#include &lt;proto/alib.h>
#include &lt;proto/exec.h>
#include &lt;exec/types.h>
#include &lt;exec/lists.h>
#include &lt;exec/nodes.h>
#include &lt;dos/dos.h>    /* For RETURN_OK */

struct List list;

/* Our nodes */
struct Node node1 =
{
    NULL, NULL,    /* No predecessor and successor, yet */
    NT_UNKNOWN, 0, /* Unknown type, priority ignored */
    "First node"   /* Name of the node */
};

struct Node node2 =
{
    NULL, NULL,
    NT_UNKNOWN, 0,
    "Second node"
};

struct Node node3 =
{
    NULL, NULL,
    NT_UNKNOWN, 0,
    "Third node"
};


int main(int argc, char *argv[])
{
    struct Node *node;

    /* Prepare the list for use. */
    NewList(&amp;list);

    /* Add the first two nodes at the end of the list. */
    AddTail(&amp;list, &amp;node1);
    AddTail(&amp;list, &amp;node2);

    /* Insert the third node after the first node. */
    Insert(&amp;list, &amp;node3, &amp;node1);

    /* Find the second node */
    node = FindName(&amp;list, "Second node");

    /* If the node was found (which is always the case in this example),
       remove it.
    */
    if (node)
        Remove(&amp;node);

    return RETURN_OK;
}
            </PROGRAMLISTING>
          </EXAMPLE>
        </SECT2>
      </SECT1>

<!-- =============== -->

      <SECT1 id="sect-memory"><TITLE>Memory Handling</TITLE>
        <PARA>You need memory for nearly everything in a program. Many things
        can be done by using the stack. But often you need larger chunks of
        memory or don't want to use the stack for some reason. In these cases
        you have to allocate memory by yourself.</PARA>
        <PARA><FILENAME role="library">exec.library</FILENAME> provides different methods for
        allocating memory. The two most important functions are
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>APTR <FUNCTION>AllocMem</FUNCTION></FUNCDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>flags</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
          <FUNCPROTOTYPE>
            <FUNCDEF>APTR <FUNCTION>AllocVec</FUNCTION></FUNCDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>flags</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
        Both functions return a pointer to a memory area of the requested
        <PARAMETER>size</PARAMETER> provided as argument. If not enough memory
        was available, <SYMBOL>NULL</SYMBOL> is returned, instead. You must check
        for this condition, before using the memory. If the memory was
        successfully allocated, you can do with it whatever you want to.</PARA>
        <PARA>You can provide additional <PARAMETER>flags</PARAMETER> to get a
        special kind of memory. The following flags are defined in
        <LINK linkend="exec-memory-h"><FILENAME class="headerfile">exec/memory.h</FILENAME></LINK>:
        <VARIABLELIST id="expl-memf">
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_CLEAR</SYMBOL></TERM>
            <LISTITEM><PARA>The allocated memory area is initialized with zeros.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_LOCAL</SYMBOL></TERM>
            <LISTITEM><PARA>Get memory that will not be flushed, if the computer
            is reset.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_CHIP</SYMBOL></TERM>
            <LISTITEM><PARA>Get memory that is accessible by graphics and
            sound chips. This type of memory is required for some functions.
            </PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_FAST</SYMBOL></TERM>
            <LISTITEM><PARA>Get memory that is not accessible by graphics and
            sound chips. <EMPHASIS>You should normally not set this
            flag! It is needed only for some very esoteric functions. Many
            systems don't have this kind of memory.</EMPHASIS></PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_PUBLIC</SYMBOL></TERM>
            <LISTITEM><PARA>This flag must be set, if the memory you allocate
            is to be accessible by other tasks. If you do not set it, the
            allocated memory is <EMPHASIS>private</EMPHASIS> to your task. This
            issue will be discussed in detail in the chapter about
            <LINK linkend="sect-intercomm">inter-task communication</LINK>.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_REVERSE</SYMBOL></TERM>
            <LISTITEM><PARA>If this flag is set, the order of the search for
            empty memory blocks is reversed. Blocks that are at the end of the
            list of empty memory will be found first.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM><SYMBOL>MEMF_NO_EXPUNGE</SYMBOL></TERM>
            <LISTITEM><PARA>Normally, if not enough free memory of the requested
            size is found, <ACRONYM role="aros">AROS</ACRONYM> tries to free
            unused memory, for example by flushing unused libraries out of the
            memory. If this flag is set, this behaviour is turned off.</PARA></LISTITEM>
          </VARLISTENTRY>
        </VARIABLELIST></PARA>

        <PARA>Memory allocated with these functions <EMPHASIS>must be freed</EMPHASIS>
        after use with one of the following functions. <EMPHASIS>Note well that
        you must not use memory that was already freed.</EMPHASIS></PARA>

        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>void <FUNCTION>FreeMem</FUNCTION></FUNCDEF>
            <PARAMDEF>APTR <PARAMETER>memory</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
          <FUNCPROTOTYPE>
            <FUNCDEF>void <FUNCTION>FreeVec</FUNCTION></FUNCDEF>
            <PARAMDEF>APTR <PARAMETER>memory</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>

        <PARA>Of course, <FUNCTION>FreeMem()</FUNCTION> must be used for memory
        allocated with <FUNCTION>AllocMem()</FUNCTION> and
        <FUNCTION>FreeVec()</FUNCTION> for memory allocated with
        <FUNCTION>AllocVec()</FUNCTION>. The synopsis for these two functions
        shows the difference between <FUNCTION>AllocMem()</FUNCTION> and
        <FUNCTION>AllocVec()</FUNCTION>: <FUNCTION>AllocVec()</FUNCTION>
        remembers the size of the chunk of memory, it allocated. So, if you
        use <FUNCTION>AllocVec()</FUNCTION>, you don't have to store the
        requested size, while you have to, if you use
        <FUNCTION>AllocMem()</FUNCTION>.

<!-- =============== -->

        <SECT2><TITLE>Allocating Multiple Regions of Memory at once</TITLE>
          <PARA>Sometimes you may want to make multiple memory allocations at
          once. The usual way to do this is calling <FUNCTION>AllocVec()</FUNCTION>
          with the size of all memory-blocks added and then making pointers
          relative to the returned pointer. But what do you do, if you need
          memory of different kinds, it with different <SYMBOL>MEMF_</SYMBOL>
          flags set? You could make multiple allocations or simply use the
          function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>struct MemList * <FUNCTION>AllocEntry</FUNCTION></FUNCDEF>
              <PARAMDEF>struct MemList * <PARAMETER>oldlist</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS></PARA>
          <PARA>As you will have noticed, <FUNCTION>AllocEntry</FUNCTION> uses
          a pointer to a <LINK linkend="exec-memory-memlist">struct <STRUCTNAME>MemList</STRUCTNAME></LINK>
          as only argument and as result. We find the definition of this
          structure in <LINK linkend="exec-memory-h"><FILENAME class="headerfile">exec/memory.h</FILENAME></LINK>:
          <PROGRAMLISTING>
struct MemEntry
{
    union
    {
        ULONG meu_Reqs;
        APTR  meu_Addr;
    } me_Un;
    ULONG me_Length;
};
 

struct MemList
{
    struct Node     ml_Node;
    UWORD           ml_NumEntries;
    struct MemEntry ml_ME[1];
};
          </PROGRAMLISTING>
          The array <STRUCTFIELD>ml_ME</STRUCTFIELD> of <STRUCTNAME>struct
          MemList</STRUCTNAME> has a variable number of elements. The number
          of its elements is set in <STRUCTFIELD>ml_NumEntries</STRUCTFIELD>.</PARA>
          <PARA>The struct <STRUCTNAME>MemEntry</STRUCTNAME> describes one
          memory-entry. Stored are its size (<STRUCTFIELD>me_Length</STRUCTFIELD>),
          its requirements (ie the <LINK linkend="expl-memf"><SYMBOL>MEMF_</SYMBOL>
          flags</LINK>, set in <STRUCTFIELD>me_Un.meu_Reqs</STRUCTFIELD>) and
          possibly a pointer to the memory-block (<STRUCTFIELD>me_Un.meu_Addr</STRUCTFIELD>).</PARA>
          <PARA>The struct <STRUCTNAME>MemList</STRUCTNAME>, you pass in as
          <PARAMETER>oldlist</PARAMETER>, must have set the field
          <STRUCTFIELD>ml_NumEntries</STRUCTFIELD> to the actual number of
          struct <STRUCTNAME>MemEntry</STRUCTNAME>s contained in
          <STRUCTFIELD>ml_ME</STRUCTFIELD>. The <STRUCTNAME>struct
          MemEntry</STRUCTNAME>s must have set the fields
          <STRUCTFIELD>me_Length</STRUCTFIELD> and
          <STRUCTFIELD>me_Un.meu_Reqs</STRUCTFIELD>. The other fields are
          ignored.</PARA>
          <PARA>The function returns a pointer to a copy of the
          struct <STRUCTNAME>MemEntry</STRUCTNAME>, passed in as
          <PARAMETER>oldlist</PARAMETER>, with all the relevant fields set
          (especially <STRUCTFIELD>me_Un.meu_Addr</STRUCTFIELD>). An error is
          indicated by setting the most significant bit of the pointer
          returned. So you always have to check it, before using the pointer
          returned.</PARA>
          <PARA>Memory allocated with <FUNCTION>AllocEntry()</FUNCTION> must
          be freed using <FUNCTION>FreeMem()</FUNCTION>.
        </SECT2>

<!-- ================ -->

        <SECT2><TITLE>Memory Pools</TITLE>
          <PARA><ACRONYM role="aros">AROS</ACRONYM> manages different
          so-called memory-pools. Each memory-pool contains a list of
          memory-areas. The most important memory-pool is the pool that
          contains all free memory in the system. But you also can create
          memory-pools yourself. This has some advantages:

          <ITEMIZEDLIST>
            <LISTITEM><PARA>Everytime, you allocate some memory, the memory
            in the system becomes more fragmented. This fragmentation causes
            the available memory chunks to become smaller. This way larger
            allocations will fail. To prevent this problem, memory-pools were
            introduced. Instead of allocating many small chunks of memory,
            the pool-management routines allocate large chunks and then
            return small chunks out of it, when memory-requests are made.</PARA></LISTITEM>

            <LISTITEM><PARA>Private memory-pools have the ability to keep
            track of all the allocations you made so that all memory in a
            pool can be freed with one simple function-call (but you can also
            free memory individually).<PARA></LISTITEM>
          </ITEMIZEDLIST></PARA>

          <PARA>Before a memory-pool can be used, it must be created. This is
          performed by the function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>APTR <FUNCTION>CreatePool</FUNCTION></FUNCDEF>
              <PARAMDEF>ULONG <PARAMETER>flags</PARAMETER></PARAMDEF>
              <PARAMDEF>ULONG <PARAMETER>puddleSize</PARAMETER></PARAMDEF>
              <PARAMDEF>ULONG <PARAMETER>threshSize</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          <PARAMETER>flags</PARAMETER> specifies the type of memory you want
          to get from the <FUNCTION>AllocPooled()</FUNCTION> function
          (<LINK linkend="expl-allocpooled">see below</LINK>). All
          <SYMBOL>MEMF_</SYMBOL> definitions as <LINK linkend="expl-memf">described
          above</LINK> are allowed here.</PARA>

          <PARA><PARAMETER>puddleSize</PARAMETER> is the size of the chunks
          of memory that are allocated by the pool functions. Usually a size
          about ten times bigger than the average memory-size, you need to
          allocate, is a good guess. But on the other hand the
          <PARAMETER>puddleSize</PARAMETER> should not be too large. Normally
          you should limit it to about <LITERAL>50kb</LITERAL>. Note well,
          though, that these are only suggestions and no real limitations.</PARA>

          <PARA>Finally, the <PARAMETER>threshSize</PARAMETER> specifies,
          how large the memory that is to be allocated is allowed to be so
          that no new chunk is allocated automatically. If, for example,
          the <PARAMETER>threshSize</PARAMETER> is set to 25kb and you want
          to allocate a piece of memory with the size of 30kb, the internal
          lists of chunks of that memory-pool is not searched, but the memory
          is allocated directly, instead. If the memory to be allocated
          was only 20kb, the chunk-list would have been searched for a piece
          of free memory of that size, first. Of course, the
          <PARAMETER>threshSize</PARAMETER> <EMPHASIS>must not</EMPHASIS> be
          larger than the <PARAMETER>puddleSize</PARAMETER> and should not
          be too small, either. Half the <PARAMETER>puddleSize</PARAMETER> is
          a good guess here.</PARA>

          <PARA><FUNCTION>CreatePool()</FUNCTION> returns a private pointer to
          a pool-structure that must be saved for further use.
          <SYMBOL>NULL</SYMBOL> is returned, if no memory for the
          pool-structure was available. You have to check for this condition.</PARA>

          <PARA>After use, all memory-pools must be destroyed by calling
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>DeletePool</FUNCTION></FUNCDEF>
              <PARAMDEF>APTR <PARAMETER>pool</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          This function deletes the <PARAMETER>pool</PARAMETER> passed in.
          Additionally all memory that was allocated in this pool is freed.
          This way, you don't need to remember every single piece of memory,
          you allocated in a pool. Just call <FUNCTION>DeletePool()</FUNCTION>
          at the end. Note that you should be careful not to use pooled memory
          after its pool was deleted!</PARA>

          <PARA id="expl-allocpooled">If you want to allocate memory out of a
          pool, you need to call
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void * <FUNCTION>AllocPooled</FUNCTION></FUNCDEF>
              <PARAMDEF>APTR <PARAMETER>pool</PARAMETER></PARAMDEF>
              <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          Besides the <PARAMETER>pool</PARAMETER> to allocate memory from,
          the <PARAMETER>size</PARAMETER> of the memory to allocate must be
          passed in. Returned is a pointer to a block of memory of the
          requested size or <SYMBOL>NULL</SYMBOL> to indicate that not
          enough memory was available.</PARA>

          <PARA>Memory allocated with <FUNCTION>AllocPooled()</FUNCTION> can
          be freed by either destroying the whole pool with
          <FUNCTION>DeletePool()</FUNCTION> or individually by calling
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>FreePooled</FUNCTION></FUNCDEF>
              <PARAMDEF>APTR <PARAMETER>pool</PARAMETER></PARAMDEF>
              <PARAMDEF>void * <PARAMETER>memory</PARAMETER></PARAMDEF>
              <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          This function frees exactly one piece of memory that was previously
          allocated with <FUNCTION>AllocPooled()</FUNCTION>. The pointer to
          the <PARAMETER>memory</PARAMETER> pointer, returned by
          <FUNCTION>AllocPooled()</FUNCTION>, its <PARAMETER>size</PARAMETER>
          and the pool, it is in, have to be supplied as arguments.

          <SIDEBAR><TITLE><FUNCTION>DeletePool()</FUNCTION> vs <FUNCTION>FreePooled()</FUNCTION></TITLE>
            <PARA>You may ask yourself: <QUOTE>If <FUNCTION>DeletePool()</FUNCTION>
            deletes all the memory of a pool, why should I ever use
            <FUNCTION>FreePooled()</FUNCTION>?</QUOTE> The answer is easy: to
            save memory. Normally it's good style to free memory as soon as
            you don't need it anymore. But sometimes it is easier just to
            free a memory-pool after a bunch of allocations. Nevertheless
            you should not use this feature, if you are not sure, when the
            memory-pool will be deleted. Imagine a program like this (do not
            try to compile it; it won't):</PARA>

            <PROGRAMLISTING>
#define &lt;exec/types.h>
#define &lt;exec/memory.h>
#define &lt;dos/dos.h>

int main(int argc, char *argv[])
{
    APTR pool;
    APTR mem;

    /* Create our memory pool and test, if it was successful. */
    pool = CreatePool(MEMF_ANY, 50*1024, 25*1024);
    if (pool)
    {

        /* Just a dummy function. Image that this function will open a window,
           with two buttons "Do Action" and "Quit".
        */
        open_our_window();

        for(;;)
        {
            /* Another dummy function that returns one of the definitions
               below.
            */
            switch(get_action())
            {
            /* This is returned, if the button "Do Action" was released. */
            case DOACTION:
                mem = AllocPooled(pool, 10*1024);
                if (mem)
                {
                    /* Another dummy function that uses our memory. */
                    silly_function(mem);
                }
                break;
            /* This is returned, if the button "Quit" was released. */
            case QUIT:
                return RETURN_OK;
            }
        }

        /* Close the window, we have opened above. */
        close_our_window();

        /* Delete our pool. */
        DeletePool(pool);
    }
}
            </PROGRAMLISTING>

            <PARA>Each time the button <GUIBUTTON>Do Action</GUIBUTTON> is
            released, some memory is allocated. This memory is freed at the
            end of the program, when <FUNCTION>DeletePool()</FUNCTION> is
            called. Of course, the longer the program is used, the more
            memory will be in use. That is why it would be much better to
            free the memory after use. This is done by replacing the
            part between <LITERAL>case DOACTION:</LITERAL> and
            <LITERAL>case QUIT:</LITERAL> by:
            <PROGRAMLISTING>
                mem = AllocPooled(pool, 10*1024);
                if (mem)
                {
                    silly_function(mem);
                    FreePooled(pool, mem, 10*1024);
                }
                break;
            </PROGRAMLISTING>
          </SIDEBAR>

          <SECT3><TITLE>Obsolete Memory Pool Functions</TITLE>
            <PARA>Memory-pools are managed with <LINK linkend="exec-memory-memheader">struct <STRUCTNAME>MemHeader</STRUCTNAME></LINK>s.
            If you have a pointer to such a structure, you may try to
            allocate some memory of its pool:
            <FUNCSYNOPSIS>
              <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
              <FUNCPROTOTYPE>
                <FUNCDEF>void * <FUNCTION>Allocate</FUNCTION></FUNCDEF>
                <PARAMDEF>struct MemHeader * <PARAMETER>mh</PARAMETER></PARAMDEF>
                <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
              </FUNCPROTOTYPE>
            </FUNCSYNOPSIS>
            Apart from the pointer to the struct <STRUCTNAME>MemHeader</STRUCTNAME>
            passed in as <PARAMETER>mh</PARAMETER>, you have to supply the
            <PARAMETER>size</PARAMETER> of the memory-block you want to
            allocate. This function returns either a pointer to the first
            memory-block found or <SYMBOL>NULL</SYMBOL> if no matching block
            was found.</PARA>

            <PARA>You must free every memory-block allocated with
            <FUNCTION>Allocate()</FUNCTION> with
            <FUNCSYNOPSIS>
              <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
              <FUNCPROTOTYPE>
                <FUNCDEF>void <FUNCTION>Deallocate</FUNCTION></FUNCDEF>
                <PARAMDEF>struct MemHeader * <PARAMETER>mh</PARAMETER></PARAMDEF>
                <PARAMDEF>APTR <PARAMETER>mem</PARAMETER></PARAMDEF>
                <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
              </FUNCPROTOTYPE>
            </FUNCSYNOPSIS>
            You have to pass the same <PARAMETER>mh</PARAMETER> and
            <PARAMETER>size</PARAMETER> to <FUNCTION>Deallocate()</FUNCTION>
            as you have passed to <FUNCTION>Allocate()</FUNCTION> and
            additionally the pointer returned by it.</PARA>

            <PARA><FILENAME role="library">intuition.library</FILENAME>
            provides another way to handle memory pools with the functions
            <LINK linkend="intuition-allocremember"><FUNCTION>AllocRemember()</FUNCTION></LINK>
            and <LINK linkend="intuition-freeremember"><FUNCTION>FreeRemember()</FUNCTION></LINK>.
            Note, though, that these are obsolete. You should use the normal
            pool-functions of <FILENAME role="library">exec.library</FILENAME>,
            instead.</PARA>
          </SECT3>
        </SECT2>

<!-- ================== -->

        <SECT2><TITLE>Allocating a specific memory address</TITLE>
          <PARA>Under very rare circumstances you may have to allocate
          memory at a specific memory address. This performed by using
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void * <FUNCTION>AllocAbs</FUNCTION></FUNCDEF>
              <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
              <PARAMDEF>APTR <PARAMETER>address</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          This function tries to allocate <PARAMETER>size</PARAMETER> bytes at
          <PARAMETER>address</PARAMETER>. If this is successful, a pointer
          to the requested address is returned. If some memory of the
          requested block is already allocated or is not available in the
          system, <SYMBOL>NULL</SYMBOL> is returned, instead.</PARA>

          <WARNING><SIMPARA>The beginning of the memory block requested will
          be used by exec to store its node-data (the exact size is calculated
          by (2*sizeof (void *)) ). Therefore, you <EMPHASIS>must not
          write</EMPHASIS> to the beginning of the memory-block! Because of
          these obstacles you should not use <FUNCTION>AllocAbs()</FUNCTION>,
          except if you really need it.</SIMPARA></WARNING>

          <PARA>Memory allocated with <FUNCTION>AllocAbs()</FUNCTION> must
          be freed, using <FUNCTION>FreeMem()</FUNCTION>.
        </SECT2>

        <SECT2><TITLE>Querying Memory Size and Available Memory</TITLE>
          <PARA>To get the size of available memory, use the function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>ULONG <FUNCTION>AvailMem</FUNCTION></FUNCDEF>
              <PARAMDEF>ULONG <PARAMETER>type</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS></PARA>

          <PARA><PARAMETER>type</PARAMETER> are some of the following flags (or'ed),
          as defined in <LINK linkend="exec-memory-h"><FILENAME class="headerfile">exec/memory.h</FILENAME></LINK>:
          <VARIABLELIST>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_ANY</SYMBOL></TERM>
              <LISTITEM><PARA>Return the size of all free memory in the system.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_CHIP</SYMBOL></TERM>
              <LISTITEM><PARA>Return the size of memory, which is accessible
              by graphics and sound chips.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_FAST</SYMBOL></TERM>
              <LISTITEM><PARA>Return the size of memory that is not accessible
              by graphics and sound chips.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_LARGEST</SYMBOL></TERM>
              <LISTITEM><PARA>Return only the largest block, instead of all
              memory of the type specified.</PARA></LISTITEM>
            </VARLISTENTRY>
          </VARIABLELIST>
          You may as well specify other <SYMBOL>MEMF_</SYMBOL> flags,
          they will be simply ignored.</PARA>

          <NOTE><PARA>Note well that the queried memory-size does not have to
          reflect the real size of memory available, as this may always
          change in a multitasking-system, even while <FUNCTION>AvailMem()</FUNCTION>
          is executed.</PARA></NOTE>

          <EXAMPLE><TITLE>Program to list memory available in the system</TITLE>
            <PROGRAMLISTING>
#include &lt;stdio.h>
#include &lt;exec/memory.h>

int main(int argc, char *argv[])
{
    printf("Total free memory: %h, largest block: %h\n",
      AvailMem(MEMF_ANY), AvailMem(MEMF_ANY|MEMF_LARGEST));
    printf("Free chip memory:  %h, largest block: %h\n",
      AvailMem(MEMF_CHIP), AvailMem(MEMF_CHIP|MEMF_LARGEST));
    printf("Free fast memory:  %h, largest block: %h\n",
      AvailMem(MEMF_FAST), AvailMem(MEMF_FAST|MEMF_LARGEST));
}
            </PROGRAMLISTING>
          </EXAMPLE>
        </SECT2>

<!-- ==================== -->

        <SECT2><TITLE>Adding Memory to the System</TITLE>
          <PARA>This chapter is only of concern to you, if you want to write a
          hardware-driver for a piece of hardware, which adds memory to the
          system.</PARA>

          <PARA>
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>AddMemList</FUNCTION></FUNCDEF>
              <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
              <PARAMDEF>ULONG <PARAMETER>type</PARAMETER></PARAMDEF>
              <PARAMDEF>LONG <PARAMETER>priority</PARAMETER></PARAMDEF>
              <PARAMDEF>APTR <PARAMETER>address</PARAMETER></PARAMDEF>
              <PARAMDEF>STRPTR <PARAMETER>name</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          adds memory to the list of free memory in the system. You have
          supply the <PARAMETER>address</PARAMETER> and the
          <PARAMETER>size</PARAMETER> of the memory to add.
          <PARAMETER>type</PARAMETER> has to be set to at least one of the
          <LINK linkend="exec-memory-memf"><SYMBOL>MEMF_</SYMBOL></LINK> flags,
          which are defined in <LINK linkend="exec-memory-h"><FILENAME class="headerfile">exec/memory.h</FILENAME></LINK>:
          <VARIABLELIST>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_FAST</SYMBOL></TERM>
              <LISTITEM><PARA>Your memory must not be accessed by graphics or
              sound chips.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>MEMF_CHIP</SYMBOL></TERM>
              <LISTITEM><PARA>Your memory is reachable by graphics and sound
              chips.</PARA></LISTITEM>
            </VARLISTENTRY>
          </VARIABLELIST></PARA>

          <PARA>You can provide a <PARAMETER>priority</PARAMETER>, with which
          your memory will be added to the memory list. The general rule is:
          The quicker your memory, the higher the priority should be. If you
          don't know, what to supply here, supply <LITERAL>0</LITERAL>.
          Finally, you can provide a <PARAMETER>name</PARAMETER>, with which
          your memory can be identified by the system and its users. You may
          provide <SYMBOL>NULL</SYMBOL> instead of a name, but giving your
          memory a name is recommended.</PARA>

          <PARA>Once your memory was added to the list of free memory, it
          can't be removed anymore.</PARA>
        </SECT2>

<!-- ================== -->

        <SECT2><TITLE>Low Memory Situations</TITLE>
          <PARA>FIXME: AddMemHandler()/RemMemHandler()</PARA>
        </SECT2>
      </SECT1>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-files"><TITLE>Files and Directories</TITLE>
      <SECT1><TITLE>Paths</TITLE>
        <SIMPARA>FIXME: relative and absolute paths</SIMPARA>
      </SECT1>

<!-- ===================== -->

      <SECT1><TITLE>Files</TITLE>
        <SIMPARA>FIXME</SIMPARA>

<!-- ==================== -->

        <SECT2><TITLE>Reading Files</TITLE>
          <SIMPARA>FIXME</SIMPARA>
        </SECT2>

<!-- ===================== -->

        <SECT2><TITLE>Writing and Creating Files</TITLE>
          <SIMPARA>FIXME</SIMPARA>
        </SECT2>
      </SECT1>

<!-- ===================== -->

      <SECT1><TITLE>Directories</TITLE>
        <SIMPARA>FIXME</SIMPARA>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Links</TITLE>
        <PARA>Links are a method to apply multiple filenames to the same
        physical file or directory. This way the file can be stored in
        multiple directories with different filenames. There are two different
        types of links: hardlinks and softlinks. A softlink is just a
        reference to another file by its name. This name may be stated as
        relative or absolute path. If a softlink is accessed,
        <ACRONYM role="aros">AROS</ACRONYM> tries to resolve the name of the file the
        link points to and redirects all actions to that file. Of course,
        the file pointed to does not have to exist. It may have been deleted
        after the link was created.</PARA>
        <PARA>Hardlinks are another instance of the same file. They don't just
        reference the file by its name, they <EMPHASIS>are</EMPHASIS> the
        file. Normally, a hardlink can't be distinguished from the orginal
        filename; effectively the file has been given a second name. Due to
        this, hardlinks can not be created over different volumes; they must
        be at the same volume.</PARA>
        <NOTE><PARA>Not all filesystems support both types of links or any
        links at all.</PARA></NOTE>

<!-- ================== -->

        <SECT2><TITLE>Creating Links</TITLE>
          <SIMPARA>FIXME</SIMPARA>
        </SECT2>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Low Level File Access (Filehandlers)</TITLE>
        <SIMPARA>FIXME</SIMPARA>
      </SECT1>
    </CHAPTER>

<!-- =================== -->

    <CHAPTER id="chap-tasks"><TITLE>Tasks, Processes and the Shell</TITLE>
      <SECT1 id="sect-tasks"><TITLE>Tasks</TITLE>
        <PARA><ACRONYM role="aros">AROS</ACRONYM> is a multitasking operating
        system. This essentially means that multiple programs may be run at
        the same time. Every program running is called a task. But there are
        also tasks that are not user-programs. There are, for example, tasks
        handling the file-system and tasks watching the input devices. Every
        task gets a certain amount of time, in which it is running. After this
        time it's the next task's turn; the system <FIRSTTERM>reschedules</FIRSTTERM>
        the tasks.</PARA>

        <PARA>Plain tasks are very limited in their capabilities. Plain tasks
        must not call a function of <FILENAME role="library">dos.library</FILENAME>
        or a function that could call a function of <FILENAME role="library">dos.library</FILENAME>
        (this includes <FUNCTION>OpenLibrary()</FUNCTION> for most cases!).
        <LINK linkend="sect-processes"><FIRSTTERM>Processes</FIRSTTERM></LINK>
        don't have this limitation.</PARA>

<!-- =============== -->

        <SECT2><TITLE>The Task Structure</TITLE>
          <PARA>A task is described by a struct <STRUCTNAME>Task</STRUCTNAME>
          as defined in <LINK linkend="exec-tasks-task"><FILENAME class="headerfile">exec/tasks.h</FILENAME></LINK>.
          This structure contains information about the task like the
          its <LINK linkend="sect-stack">stack</LINK>, its
          <LINK linkend="sect-signals">signals</LINK> and some management
          data. To get the address of a task strucure, use
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>struct Task * <FUNCTION>FindTask</FUNCTION></FUNCDEF>
              <PARAMDEF>STRPTR <PARAMETER>name</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          <PARAMETER>name</PARAMETER> is a pointer to the name of the task to
          find. <EMPHASIS>Note that this name is case-sensitive!</EMPHASIS>
          If the named task is not found, <SYMBOL>NULL</SYMBOL> is returned,
          otherwise a pointer to a struct <STRUCTNAME>Task</STRUCTNAME>.</PARA>

          <PARA>To get a pointer to the current task, supply
          <SYMBOL>NULL</SYMBOL> as <PARAMETER>name</PARAMETER>. This can never
          fail.</PARA>

          <PARA>The task structure contains a field called
          <STRUCTFIELD>tc_UserData</STRUCTFIELD>. You can use it for your own
          purposes. It is ignored by <ACRONYM role="aros">AROS</ACRONYM>.</PARA>
        </SECT2>

<!-- ================== -->

        <SECT2><TITLE>States</TITLE>
          <PARA>A task must be in one of following states (as set in the field
          <STRUCTFIELD>tc_State</STRUCTFIELD> of the task structure):
          <VARIABLELIST>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_INVALID</SYMBOL></TERM>
              <LISTITEM><PARA>This state should never be set!</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_ADDED</SYMBOL></TERM>
              <LISTITEM><PARA>FIXME</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_RUN</SYMBOL></TERM>
              <LISTITEM><PARA>The task is currently running. On single
              processor architectures only one task can be in that state.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_READY</SYMBOL></TERM>
              <LISTITEM><PARA>The task waits for its execution.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_WAIT</SYMBOL></TERM>
              <LISTITEM><PARA>The task waits for some <LINK linkend="sect-signals">signal</LINK>
              to get activated. As long as this does not happen, the program
              doesn't become active; it is ignored on rescheduling. Most
              interactive programs are in this state most of the time, as
              they wait for user input.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_EXCEPT</SYMBOL></TERM>
              <LISTITEM><PARA>The task is in an exception.</PARA></LISTITEM>
            </VARLISTENTRY>
            <VARLISTENTRY>
              <TERM><SYMBOL>TS_REMOVED</SYMBOL></TERM>
              <LISTITEM><PARA>FIXME</PARA></LISTITEM>
            </VARLISTENTRY>
          </VARIABLELIST></PARA>

          <NOTE><PARA>Do not set these states yourself, unless you know
          exactly what you are doing!</PARA></NOTE>
        </SECT2>

<!-- =============== -->

        <SECT2><TITLE>Priorities</TITLE>
          <PARA>The field <STRUCTFIELD>tc_Node.ln_Pri</STRUCTFIELD> of the
          struct <STRUCTNAME>Node</STRUCTNAME> embedded in the task structure
          (see <LINK linkend="exec-nodes-node"><FILENAME class="headerfile">exec/nodes.h</FILENAME></LINK>
          and the <LINK linkend="sect-lists">section about exec lists</LINK>)
          specifies the priority of the task. Possible priorities reach from
          <LITERAL>-128</LITERAL> to <LITERAL>127</LITERAL>. The higher the
          priority the more processor time the task gets from the system. To
          set a task's priority use the function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>BYTE <FUNCTION>SetTaskPri</FUNCTION></FUNCDEF>
              <PARAMDEF>struct Task * <PARAMETER>task</PARAMETER></PARAMDEF>
              <PARAMDEF>BYTE <PARAMETER>newpri</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          The old priority is returned.</PARA>
        </SECT2>

<!-- =============== -->

        <SECT2><TITLE id="sect-stack">Stack</TITLE>
          <PARA>Every task has a stack. A stack is a piece of memory, in
          which a tasks stores its temorary data. Compilers, for example,
          use the stack to store variables, you use in your programs. On
          many architectures, the stack is also used to supply library
          functions with parameters.</PARA>

          <PARA>The size of the stack is limited. Therefore only a certain
          amount of data can be stored in the stack. The stack-size of a
          task is chosen by its caller and must be at least 4096 bytes. Tasks
          should generally not assume that their stack-size is bigger. So,
          if a task needs more stack, the stack can be exchanged by using the
          function
          <FUNCSYNOPSIS>
            <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
            <FUNCPROTOTYPE>
              <FUNCDEF>void <FUNCTION>StackSwap</FUNCTION></FUNCDEF>
              <PARAMDEF>struct StackSwapStruct * <PARAMETER>sss</PARAMETER></PARAMDEF>
            </FUNCPROTOTYPE>
          </FUNCSYNOPSIS>
          The only argument, <PARAMETER>sss</PARAMETER>, is a pointer to a
          struct <STRUCTNAME>StackSwapStruct</STRUCTNAME> as defined in
          <LINK linkend="exec-tasks-stackswapstruct"><FILENAME class="headerfile">exec/tasks.h</FILENAME></LINK>.</PARA>

          <PARA>struct <STRUCTNAME>StackSwapStack</STRUCTNAME> must contain a
          pointer to the beginning of the new stack (<STRUCTFIELD>strk_Lower</STRUCTFIELD>),
          to the end of the new stack (<STRUCTFIELD>stk_Upper</STRUCTFIELD>)
          and a new stack-pointer (<STRUCTFIELD>stk_Pointer</STRUCTFIELD>).
          This stack-pointer is normally set either to the same address as
          <STRUCTFIELD>stk_Lower</STRUCTFIELD> or to the same address as
          <STRUCTFIELD>stk_Upper</STRUCTFIELD>, depending on the kind of
          <ACRONYM>CPU</ACRONYM> used.</PARA>

          <PARA>When calling <FUNCTION>StackSwap()</FUNCTION>, the
          <STRUCTNAME>StackSwapStruct</STRUCTNAME> structure supplied as
          <PARAMETER>sss</PARAMETER> will be filled with information
          about the current stack.</PARA>

          <PARA>After finishing using the new stack, the old stack must be
          restored by calling <FUNCTION>StackSwap()</FUNCTION> a second time
          with the same <STRUCTNAME>StackSwapStruct</STRUCTNAME>.</PARA>

          <NOTE><PARA>Normally, only compilers need this function. Handle
          it with great care as different architectures use the stack in
          different ways!</PARA></NOTE>
        </SECT2>
      </SECT1>

<!-- ===================== -->

      <SECT1 id="sect-processes"><TITLE>Processes</TITLE>
        <PARA>A process is an expanded <LINK linkend="sect-tasks">task</LINK>.
        Opposed to a task, it can use functions of <LINK linkend="dos-library"><FILENAME role="library">dos.library</FILENAME></LINK>,
        because a process structure contains some special fields, concerning
        files and directories. But of course, all functions that can be
        used on tasks can also be used on processes.</PARA>

<!-- ==================== -->

        <SECT2><TITLE>The Process Structure</TITLE>
          <PARA>A process is described by a struct <STRUCTNAME>Process</STRUCTNAME>
          as defined in <LINK linkend="dos-dosextens-process"><FILENAME class="headerfile">dos/dosextens.h</FILENAME></LINK>.
          The first field in struct <STRUCTNAME>Process</STRUCTNAME> is an
          embedded <LINK linkend="exec-tasks-task">struct <STRUCTNAME>Task</STRUCTNAME></LINK>.
          The extra fields include information about the file-system, the
          console, the process is connected to, and miscellaneous other stuff.</PARA>

<!-- =================== -->

          <SECT3><TITLE id="sect-curdir">The Current Directory</TITLE>
            <PARA>FIXME</PARA>
          </SECT3>

<!-- ==================== -->

          <SECT3 id="sect-stdfh"><TITLE>Standard File Handles</TITLE>
            <PARA>FIXME</PARA>
          </SECT3>

<!-- =================== -->

          <SECT3><TITLE>Console Related Information</TITLE>
            <PARA>FIXME</PARA>
          </SECT3>
        </SECT2>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Creating own Tasks and Processes</TITLE>
        <PARA>There are mainly two methods of creating tasks and processes: you
        can either call an external program (ie open an executable file and
        run the program contained in it) or you can execute a piece of code,
        already in memory.</PARA>

<!-- ================= -->

        <SECT2><TITLE>Starting External Programs</TITLE>
          <PARA>External programs are always processes.</PARA>
          <PARA>FIXME</PARA>
        </SECT2>

<!-- =================== -->

        <SECT2><TITLE>Creating Tasks by Hand</TITLE>
          <PARA>FIXME</PARA>
        </SECT2>

<!-- ==================== -->

        <SECT2><TITLE>Creating Processes by Hand</TITLE>
          <PARA>FIXME</PARA>
        </SECT2>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Local and Global Variables</TITLE>
        <PARA>FIXME</PARA>
      </SECT1>

<!-- =================== -->

      <SECT1><TITLE>Expanded Error Diagnostics</TITLE>
        <PARA>Most functions of <LINK linkend="dos-library"><FILENAME role="library">dos.library</FILENAME></LINK>
        set the secondary error-code of the process structure on error. This
        way the caller can determine, why a certain system-call failed.
        Imagine, the function <FUNCTION>Open()</FUNCTION>, which opens a
        named file, fails. There can be multiple reasons for this: maybe the
        file named doesn't exist, maybe it is read protected. To find this
        out, you can query the secondary error-code set by the last function by
        using
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/dos.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>LONG <FUNCTION>IoErr</FUNCTION></FUNCDEF>
            <VOID>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS></PARA>

        <PARA>Dos-functions return one of the <SYMBOL>ERROR_</SYMBOL>
        definitions from <LINK linkend="dos-dos-error"><FILENAME class="headerfile">dos/dos.h</FILENAME></LINK>.
        Applications can, of course, process these error-codes by hand (which
        is useful in many cases), but often we just want to inform the user
        what went wrong. (Applications normally need not care, if a file
        could not be opened, because it did not exist or because it was read
        protected.) To output human-readable error messages,
        <FILENAME role="library">dos.library</FILENAME> provides two
        functions:
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/dos.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>LONG <FUNCTION>Fault</FUNCTION></FUNCDEF>
            <PARAMDEF>LONG <PARAMETER>code</PARAMETER></PARAMDEF>
            <PARAMDEF>STRPTR <PARAMETER>header</PARAMETER></PARAMDEF>
            <PARAMDEF>STRPTR <PARAMETER>buffer</PARAMETER></PARAMDEF>
            <PARAMDEF>LONG <PARAMETER>length</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
          <FUNCPROTOTYPE>
            <FUNCDEF>BOOL <FUNCTION>PrintFault</FUNCTION></FUNCDEF>
            <PARAMDEF>LONG <PARAMETER>code</PARAMETER></PARAMDEF>
            <PARAMDEF>STRPTR <PARAMETER>header</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS></PARA>

        <PARA>While <FUNCTION>PrintFault()</FUNCTION> simply prints an error
        message to the <GLOSSTERM linkend="glos-stdfh">standard output</GLOSSTERM>,
        <FUNCTION>Fault()</FUNCTION> fills a supplied buffer
        with the message. Both functions take a <PARAMETER>code</PARAMETER>
        argument. This is the code to be converted into a string. You can also
        supply a <PARAMETER>header</PARAMETER> string, which will prefix the
        error message. <PARAMETER>header</PARAMETER> may be NULL, in which
        case nothing is prefixed.</PARA>

        <PARA><FUNCTION>Fault()</FUNCTION> also required a pointer to a
        <PARAMETER>buffer</PARAMETER>, which is to be filled with the converted
        string. The <PARAMETER>length</PARAMETER> of this buffer (in bytes)
        is to be passed in as last argument. The total number of characters
        put into the buffer is returned. You are on the safe side, if your
        buffer has a size for 83 character plus the size of the header.</PARA>

        <PARA>Examples for the use of these functions can be found in later
        chapters, especially in the chapter about <LINK linkend="chap-files">Files
        and Directories</LINK>.</PARA>

        <PARA>Secondary error-codes of a program are handed back to the
        caller. If this is a shell, the secondary error-code will be put
        into the field <STRUCTFIELD>cli_Result2</STRUCTFIELD> of the shell
        structure (struct <STRUCTNAME>CommandLineInterface</STRUCTNAME> as
        defined in <LINK linkend="dos-dosextens-commandlineinterface"><FILENAME class="headerfile">dos/dosextens.h</FILENAME></LINK>
        and <LINK linkend="sect-shell">discussed later</LINK>).</PARA>

        <PARA>You can also set the secondary error-code yourself. This way,
        you can either to pass it back to another function in your program or
        to your caller. To set the secondary error, use
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/dos.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>LONG <FUNCTION>SetIoErr</FUNCTION></FUNCDEF>
            <PARAMDEF>LONG <PARAMETER>code</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
        <PARAMETER>code</PARAMETER> is the new secondary error-code and
        the old secondary error-code is returned.</PARA>

        <PARA><FUNCTION>SetIoErr()</FUNCTION> will be used in the
        <LINK linkend="chap-boopsi">chapter about object orientation</LINK>.</PARA>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Parsing Arguments</TITLE>
        <PARA>FIXME: ReadArgs()</PARA>
      </SECT1>

<!-- ================ -->

      <SECT1><TITLE id="sect-intercomm">Inter-Process and -Task Communication</TITLE>
        <PARA>FIXME</PARA>

<!-- ================= -->

        <SECT2 id="sect-signals"><TITLE>Signals</TITLE>
          <PARA>FIXME</PARA>
        </SECT2>

<!-- =================== -->

        <SECT2><TITLE>Ports</TITLE>
          <PARA>FIXME</PARA>
        </SECT2>
      </SECT1>

<!-- ================== -->

      <SECT1><TITLE>Multitasking Issues</TITLE>
        <SECT2><TITLE><FUNCTION>Forbid()</FUNCTION>/<FUNCTION>Permit()</FUNCTION></TITLE>
          <PARA>FIXME</PARA>
        </SECT2>

<!-- ================= -->

        <SECT2><TITLE>Semaphores</TITLE>
          <PARA>FIXME</PARA>
        </SECT2>
      </SECT1>

<!-- ================= -->

      <SECT1 id="sect-shell"><TITLE>Shell</TITLE>
        <PARA>FIXME</PARA>
      </SECT1>
    </CHAPTER>

<!-- ================================================================ -->

    <CHAPTER id="chap-boopsi"><TITLE><ACRONYM role="aros">AROS</ACRONYM>' Object Oriented System (<ACRONYM>BOOPSI</ACRONYM>), Hooks and Processing of Taglists</TITLE>
      <PARA>FIXME</PARA>
      <SECT1 id="sect-proc-taglists"><TITLE>Processing Taglists</TITLE>
        <PARA>The following chapter describes, how to implement functions that
        process taglists. It is written in reference to BOOPSI classes, but
        the usage is the same for other uses of taglists (eg in custom
        libraries).</PARA>
        <SIMPARA>FIXME</SIMPARA>
      </SECT1>

<!-- =================== -->

      <SECT1 id="sect-hooks"><TITLE>Hooks</TITLE>
        <SIMPARA>FIXME</SIMPARA>
      </SECT1>

<!-- ================== -->

      <SECT1 id="sect-prog-taglists"><TITLE>Implementing Taglists</TITLE>
        <SIMPARA>FIXME</SIMPARA>
      </SECT1>
    </CHAPTER>

<!-- ================================================================== -->

    <CHAPTER id="chap-datatypes"><TITLE>Datatypes</TITLE>
        <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- ================================================================== -->

    <CHAPTER id="chap-hidds"><TITLE>Devices and Hardware Independent Device Drivers (<ACRONYM>HIDD</ACRONYM>s)</TITLE>
        <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- ================================================================= -->

    <CHAPTER id="chap-filesys"><TITLE>Filesystem-Handlers</TITLE>
        <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-interrupts"><TITLE>Interrupts</TITLE>
        <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>
  </PART>

<!-- ====================================================================== -->
<!-- ======================= Graphical User Interfaces ==================== -->
<!-- ====================================================================== -->

  <PART id="part-gui"><TITLE>Graphical User Interfaces (<ACRONYM>GUI</ACRONYM>s)</TITLE>
    <TITLEABBREV><ACRONYM>GUI</ACRONYM>s</TITLEABBREV>
    <CHAPTER id="chap-windows"><TITLE>Windows</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-requesters"><TITLE>Requesters</TITLE>
      <PARA>Requesters are a special kind of <LINK linkend="chap-windows">windows</LINK>.
      They either confront the user with some information or request some
      information. Requesters always interrupt the user's normal workflow,
      so they should only be used either to inform him of some important
      event or to request an information, without which the application
      can't continue to work. This kind of requester is called
      <FIRSTTERM>modal requester</FIRSTTERM></PARA>

      <PARA>Examples of informational requesters are requesters that report
      errors (like failing to open a file) or about requesters, which show
      information about the program, when requested by the user.</PARA>

      <PARA>Like the name indicates, requesters can also request information
      from the user, like a file name (using file-requesters), his name or a
      simple yes/no decision ("Really quit application?").</PARA>

      <PARA>Requesters should only pop-up, if an application can't go on
      without knowing that the user learned about a certain fact or without
      getting a certain kind of information. Therefore, most requesters will
      block the application. That means that they will not listen to any
      input, except that in the requester. An exception are requesters that
      are explicitly requested by the user, like most file-requesters or
      about-requesters. Normally, these should not block the application.</PARA>

<!-- ================== -->

      <SECT1><TITLE id="sect-easyrequest">Easy Requesters</TITLE>
        <PARA>The so-called <FIRSTTERM>easy requesters</FIRSTTERM> are
        simple requesters. They can be used to either provide an information
        or to ask for a choice. The number of choices is limited to 256,
        but it is generally a bad idea to have more than about five different
        choices. You also have to take into account that the width of the
        <GLOSSTERM>screen</GLOSSTERM> is limited.</PARA>

        <PARA>FIXME: EasyRequestArgs(), BuildEasyRequest()</PARA>
      </SECT1>

<!-- ================ -->

      <SECT1><TITLE>Complex Requesters</TITLE>
        <PARA>FIXME</PARA>
      </SECT1>

<!-- ================ -->

      <SECT1><TITLE>Asl Requesters (Font-, File- and Screenmode-)</TITLE>
        <PARA>FIXME</PARA>
      </SECT1>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-screens"><TITLE>Screens</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-gadgets"><TITLE>Gadgets</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-painting"><TITLE>Painting and Drawing</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-images"><TITLE>Images</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- ==================================================================== -->

    <CHAPTER id="chap-hardgfx"><TITLE>Direct Hardware Access</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>
  </PART>

<!-- ==================================================================== -->
<!-- ============================== Programming ========================= -->
<!-- ==================================================================== -->

  <PART id="part-programming"><TITLE>Programming of Libraries, Datatypes, <ACRONYM>HIDD</ACRONYM>s, etc</TITLE>
    <CHAPTER id="chap-prog-libraries"><TITLE>Libraries</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- =================================================================== -->

    <CHAPTER id="chap-prog-datatypes"><TITLE>Datatypes</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- ================================================================== -->

    <CHAPTER id="chap-prog-hidds"><TITLE><ACRONYM>HIDD</ACRONYM>s and Devices</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>

<!-- ================================================================== -->

    <CHAPTER id="chap-prog-filesys"><TITLE>Filesystem-Handlers</TITLE>
      <SIMPARA>FIXME</SIMPARA>
    </CHAPTER>
  </PART>

<!-- =================================================================== -->
<!-- ============================= Libraries =========================== -->
<!-- =================================================================== -->

  <APPENDIX id="part-liblist"><TITLE>Library Overview</TITLE>

<!-- ============================= asl.library ========================= -->

    <REFENTRY id="asl-library">
      <REFNAMEDIV>
        <REFNAME>asl.library</REFNAME>
        <REFPURPOSE>complex requester handling</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ============================ boopsi.library ======================= -->

    <REFENTRY id="boopsi-library">
      <REFNAMEDIV>
        <REFNAME>boopsi.library</REFNAME>
        <REFPURPOSE>BOOPSI handling</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ============================== dos.library ========================= -->

    <REFENTRY id="dos-library">
      <REFNAMEDIV>
        <REFNAME>dos.library</REFNAME>
        <REFPURPOSE>file, process, I/O handling</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== gadtools.library ======================= -->

    <REFENTRY id="gadtools-library">
      <REFNAMEDIV>
        <REFNAME>gadtools.library</REFNAME>
        <REFPURPOSE>provides some more complex gadgets</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ============================= exec.library ========================= -->

    <REFENTRY id="exec-library">
      <REFNAMEDIV>
        <REFNAME>exec.library</REFNAME>
        <REFPURPOSE>basic task, memory and system handling</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== intuition.library ====================== -->

    <REFENTRY id="intuition-library">
      <REFNAMEDIV>
        <REFNAME>intuition.library</REFNAME>
        <REFPURPOSE>basic graphical user interface stuff</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== utility.library ========================= -->

    <REFENTRY id="utility-library">
      <REFNAMEDIV>
        <REFNAME>utility.library</REFNAME>
        <REFPURPOSE>taglists, hooks and various utility functions</REFPURPOSE>
      </REFNAMEDIV>

      <REFSECT1><TITLE>Description</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>
  </APPENDIX>

<!-- =================================================================== -->
<!-- ========================= Library Functions ======================= -->
<!-- =================================================================== -->

  <APPENDIX id="part-functions"><TITLE>Function Overview</TITLE>

<!-- =========================== AllocRemember() ======================= -->

    <REFENTRY id="intuition-allocremember">
      <REFMETA>
        <REFENTRYTITLE><FUNCTION>AllocRemember</FUNCTION></REFENTRYTITLE>
        <REFMISCINFO>intuition.library</REFMISCINFO>
      </REFMETA>
      <REFNAMEDIV>
        <REFNAME><FUNCTION>AllocRemember()</FUNCTION></REFNAME>
        <REFPURPOSE>allocate memory and remember it</REFPURPOSE>
      </REFNAMEDIV>

      <REFSYNOPSISDIV>
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/intuition.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>APTR <FUNCTION>AllocRemember</FUNCTION></FUNCDEF>
            <PARAMDEF>struct Remember ** <PARAMETER>key</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>flags</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
      </REFSYNOPSISDIV>

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ============================== AllocVec() ========================= -->

    <REFENTRY id="exec-allocvec">
      <REFMETA>
        <REFENTRYTITLE><FUNCTION>AllocVec</FUNCTION></REFENTRYTITLE>
        <REFMISCINFO>exec.library</REFMISCINFO>
      </REFMETA>
      <REFNAMEDIV>
        <REFNAME><FUNCTION>AllocVec()</FUNCTION></REFNAME>
        <REFPURPOSE>allocate memory and remember its size</REFPURPOSE>
      </REFNAMEDIV>

      <REFSYNOPSISDIV>
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/exec.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>APTR <FUNCTION>AllocVec</FUNCTION></FUNCDEF>
            <PARAMDEF>ULONG <PARAMETER>size</PARAMETER></PARAMDEF>
            <PARAMDEF>ULONG <PARAMETER>flags</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
      </REFSYNOPSISDIV>

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== FreeRemember() ======================== -->

    <REFENTRY id="intuition-freeremember">
      <REFMETA>
        <REFENTRYTITLE><FUNCTION>FreeRemember</FUNCTION></REFENTRYTITLE>
        <REFMISCINFO>intuition.library</REFMISCINFO>
      </REFMETA>
      <REFNAMEDIV>
        <REFNAME><FUNCTION>FreeRemember()</FUNCTION></REFNAME>
        <REFPURPOSE>free remembered memory</REFPURPOSE>
      </REFNAMEDIV>

      <REFSYNOPSISDIV>
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/intuition.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>void <FUNCTION>FreeRemember</FUNCTION></FUNCDEF>
            <PARAMDEF>struct Remember ** <PARAMETER>key</PARAMETER></PARAMDEF>
            <PARAMDEF>LONG <PARAMETER>reallyForget</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
      </REFSYNOPSISDIV>

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ========================= EasyRequestArgsA() ====================== -->

    <REFENTRY id="intuition-easyrequestargsa">
      <REFMETA>
        <REFENTRYTITLE><FUNCTION>EasyRequestArgsA</FUNCTION></REFENTRYTITLE>
        <REFMISCINFO>intuition.library</REFMISCINFO>
      </REFMETA>
      <REFNAMEDIV>
        <REFNAME><FUNCTION>EasyRequestArgsA()</FUNCTION></REFNAME>
        <REFPURPOSE>open a simple requester</REFPURPOSE>
      </REFNAMEDIV>

      <REFSYNOPSISDIV>
        <FUNCSYNOPSIS>
          <FUNCSYNOPSISINFO>#include &lt;proto/intuition.h></FUNCSYNOPSISINFO>
          <FUNCPROTOTYPE>
            <FUNCDEF>LONG <FUNCTION>EasyRequestArgsA</FUNCTION></FUNCDEF>
            <PARAMDEF>struct Window * <PARAMETER>window</PARAMETER></PARAMDEF>
            <PARAMDEF>struct EasyStruct * <PARAMETER>easyStruct</PARAMETER></PARAMDEF>
            <PARAMDEF>struct Window * <PARAMETER>IDCMP_ptr</PARAMETER></PARAMDEF>
            <PARAMDEF>struct Window * <PARAMETER>argList</PARAMETER></PARAMDEF>
          </FUNCPROTOTYPE>
        </FUNCSYNOPSIS>
      </REFSYNOPSISDIV>

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>
  </APPENDIX>

<!-- =================================================================== -->
<!-- ============================ Header Files ========================= -->
<!-- =================================================================== -->

  <APPENDIX id="part-headers"><TITLE>Header File Overview</TITLE>

<!-- ============================== dos/dos.h =========================== -->

    <REFENTRY id="dos-dos-h" role="header">
      <REFNAMEDIV>
        <REFNAME>dos/dos.h</REFNAME>
        <REFPURPOSE>basic features of dos.library</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 id="dos-dos-error" role="defines"><TITLE><STRUCTNAME>DOS Error Codes</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ========================== dos/dosextens.h ======================== -->

    <REFENTRY id="dos-dosextens-h" role="header">
      <REFNAMEDIV>
        <REFNAME>dos/dosextens.h</REFNAME>
        <REFPURPOSE>extended features of dos.library</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 id="dos-dosextens-commandlineinterface" role="struct"><TITLE>struct <STRUCTNAME>CommandLineInterface</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="dos-dosextens-process" role="struct"><TITLE>struct <STRUCTNAME>Process</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ========================= exec/libraries.h ======================== -->

    <REFENTRY id="exec-libraries-h" role="header">
      <REFNAMEDIV>
        <REFNAME>exec/libraries.h</REFNAME>
        <REFPURPOSE>library handling</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 id="exec-libraries-library" role="struct"><TITLE>struct <STRUCTNAME>Library</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ============================ exec/lists.h ========================= -->

    <REFENTRY id="exec-lists-h" role="header">
      <REFNAMEDIV>
        <REFNAME>exec/lists.h</REFNAME>
        <REFPURPOSE>exec list handling</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 role="includes"><TITLE>Includes</TITLE>
        <ITEMIZEDLIST>
          <LISTITEM><PARA><LINK linkend="exec-nodes-h"><FILENAME class="headerfile">exec/nodes.h</FILENAME></LINK></PARA></LISTITEM>
        </ITEMIZEDLIST>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="exec-lists-list" role="struct"><TITLE>struct <STRUCTNAME>List</STRUCTNAME></TITLE>
        <PARA>A standard exec list structure. This is used for all kinds of
        doubly linked lists. Members of this list are of type
        <LINK linkend="exec-nodes-node">struct <STRUCTNAME>Node</STRUCTNAME></LINK>.</PARA>

        <PARA>This structure can be embedded into other structures.</PARA>

        <VARIABLELIST role="fieldlist"><TITLE>Fields</TITLE>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>Node</STRUCTNAME> * <STRUCTFIELD>lh_Head</STRUCTFIELD></TERM>
            <LISTITEM><PARA>Pointer to the first item in the list. If the list is
            empty, this points to the <STRUCTFIELD>lh_Tail</STRUCTFIELD> field
            of the list.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>Node</STRUCTNAME> * <STRUCTFIELD>lh_Tail</STRUCTFIELD></TERM>
            <LISTITEM><PARA>Pointer to the last item in the list. If the list
            is empty, this is <SYMBOL>NULL</SYMBOL>.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>Node</STRUCTNAME> * <STRUCTFIELD>lh_TailPred</STRUCTFIELD></TERM>
            <LISTITEM><PARA>This is a fake entry that also points to the last
            entry in the list. If the list is empty, it points to the list
            itself, instead.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>UBYTE <STRUCTFIELD>lh_Type</STRUCTFIELD></TERM>
            <LISTITEM><PARA>This field specifies the type the nodes in the
            list. It corresponds to the <STRUCTFIELD>ln_Type</STRUCTFIELD>
            field of the <LINK linkend="exec-nodes-node"><STRUCTNAME>Node</STRUCTNAME></LINK>
            structure. See <FILENAME class="headerfile">exec/nodes.h</FILENAME>
            for a <LINK linkend="exec-nodes-types">list of possible types</LINK>.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>UBYTE <STRUCTFIELD>l_Pad</STRUCTFIELD></TERM>
            <LISTITEM><PARA>Unused field for word-padding.</PARA></LISTITEM>
          </VARLISTENTRY>
        </VARIABLELIST>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="exec-lists-minlist" role="struct"><TITLE>struct <STRUCTNAME>MinList</STRUCTNAME></TITLE>
        <PARA>A minimal exec list structure. This is exactly the same as a
        <LINK linkend="exec-lists-list"><STRUCTNAME>List</STRUCTNAME></LINK>
        structure, except that the <STRUCTFIELD>lh_Type</STRUCTFIELD> field
        is missing. Members of a <STRUCTNAME>MinList</STRUCTNAME> are of type
        <LINK linkend="exec-nodes-minnode">struct <STRUCTNAME>MinNode</STRUCTNAME></LINK>.
        <STRUCTNAME>Node</STRUCTNAME>s may be used, but you loose all their
        advantages.</PARA>

        <PARA>This structure can be embedded into other structures.</PARA>

        <VARIABLELIST role="fieldlist"><TITLE>Fields</TITLE>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>MinNode</STRUCTNAME> * <STRUCTFIELD>mlh_Head</STRUCTFIELD></TERM>
            <LISTITEM><PARA>Pointer to the first item in the list. If the list is
            empty, this points to the <STRUCTFIELD>mlh_Tail</STRUCTFIELD> field
            of the list.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>MinNode</STRUCTNAME> * <STRUCTFIELD>mlh_Tail</STRUCTFIELD></TERM>
            <LISTITEM><PARA>Pointer to the last item in the list. If the list
            is empty, this is <SYMBOL>NULL</SYMBOL>.</PARA></LISTITEM>
          </VARLISTENTRY>
          <VARLISTENTRY>
            <TERM>struct <STRUCTNAME>MinNode</STRUCTNAME> * <STRUCTFIELD>mlh_TailPred</STRUCTFIELD></TERM>
            <LISTITEM><PARA>This is a fake entry that also points to the last
            entry in the list. If the list is empty, it points to the list
            itself, instead.</LISTITEM>
          </VARLISTENTRY>
        </VARIABLELIST>
      </REFSECT1>

<!-- =================== -->

      <REFSECT1 id="exec-lists-macros"><TITLE>Macros</TITLE>
        <PARA>The following are included to ease the use of exec lists.</PARA>

        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== exec/memory.h ========================= -->

    <REFENTRY id="exec-memory-h" role="header">
      <REFNAMEDIV>
        <REFNAME>exec/memory.h</REFNAME>
        <REFPURPOSE>memory management</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================ -->

      <REFSECT1 id="exec-memory-memheader" role="struct"><TITLE>struct <STRUCTNAME>MemHeader</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================ -->

      <REFSECT1 id="exec-memory-memlist" role="header"><TITLE>struct <STRUCTNAME>MemList</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================ -->

      <REFSECT1 id="exec-memory-memf" role="defines"><TITLE>Memory Flags</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- =============== -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== exec/nodes.h ========================== -->

    <REFENTRY id="exec-nodes-h" role="header">
      <REFNAMEDIV>
        <REFNAME>exec/nodes.h</REFNAME>
        <REFPURPOSE>list-node handling</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 id="exec-nodes-node" role="struct"><TITLE>struct <STRUCTNAME>Node</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="exec-nodes-minnode" role="struct"><TITLE>struct <STRUCTNAME>MinNode</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="exec-nodes-types" role="defines"><TITLE>Node Types</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- =========================== exec/tasks.h ========================== -->

    <REFENTRY id="exec-tasks-h" role="header">
      <REFNAMEDIV>
        <REFNAME>exec/tasks.h</REFNAME>
        <REFPURPOSE>task handling</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1 id="exec-tasks-stackswapstruct" role="struct"><TITLE>struct <STRUCTNAME>StackSwapStruct</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1 id="exec-tasks-task" role="struct"><TITLE>struct <STRUCTNAME>Task</STRUCTNAME></TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>

<!-- ========================= utility/tagitem.h ======================= -->

    <REFENTRY id="utility-tagitem-h" role="header">
      <REFNAMEDIV>
        <REFNAME>utility/tagitem.h</REFNAME>
        <REFPURPOSE>taglist handling</REFPURPOSE>
      </REFNAMEDIV>

<!-- ================= -->

      <REFSECT1><TITLE>FIXME</TITLE>
        <PARA>FIXME</PARA>
      </REFSECT1>
    </REFENTRY>
  </APPENDIX>

<!-- =================================================================== -->
<!-- ============================== Glossary =========================== -->
<!-- =================================================================== -->

  <GLOSSARY>
    <GLOSSENTRY>
      <GLOSSTERM id="glos-abspath">Absolute Path</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Relative Path</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-cd">Current Directory</GLOSSTERM>
      <ACRONYM>CD</ACRONYM>
      <GLOSSDEF>
        <PARA>The directory, which all file-system actions are relative to,
        as long as no <GLOSSTERM baseform="absolute path">absolute paths</GLOSSTERM>
        are used. Every <GLOSSTERM>process</GLOSSTERM> structure stores its
        current directory in the field <STRUCTFIELD>pr_CurrentDir</STRUCTFIELD>.</PARA>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-process">Process</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Task</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-relpath">Relative Path</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Absolute Path</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-resident-list">Resident List</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-screen">Screen</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Window</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM>Standard Error</GLOSSTERM>
      <ABBREV>stderr</ABBREV>
      <GLOSSSEE>Standard Filehandles</GLOSSSEE>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-stdfh">Standard Filehandles</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM>Standard Input</GLOSSTERM>
      <ABBREV>stdin</ABBREV>
      <GLOSSSEE>Standard Filehandles</GLOSSSEE>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM>Standard Output</GLOSSTERM>
      <ABBREV>stdout</ABBREV>
      <GLOSSSEE>Standard Filehandles</GLOSSSEE>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-task">Task</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Process</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>

    <GLOSSENTRY>
      <GLOSSTERM id="glos-window">Window</GLOSSTERM>
      <GLOSSDEF>
        <PARA>FIXME</PARA>
        <GLOSSSEEALSO>Screen</GLOSSSEEALSO>
      </GLOSSDEF>
    </GLOSSENTRY>
  </GLOSSARY>
</BOOK>
