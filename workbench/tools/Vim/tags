!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!rm	testdir/amiga.vim	/^cmap !rm !Delete all$/;"	m
$VAR	testdir/test49.vim	/^	let $VAR = "let(" . THROW("var") . ")"$/;"	v
$VAR	testdir/test49.vim	/^	let $VAR = "old_value"$/;"	v
/tmp	testdir/amiga.vim	/^map! \/tmp t:$/;"	m
AARGLIST	structs.h	563;"	d
ABBREV	vim.h	528;"	d
ABBR_OFF	keymap.h	43;"	d
ACTION_EXPAND	vim.h	666;"	d
ACTION_GOTO	vim.h	662;"	d
ACTION_SHOW	vim.h	661;"	d
ACTION_SHOW_ALL	vim.h	664;"	d
ACTION_SPLIT	vim.h	663;"	d
ADDPATH	testdir/test49.vim	/^    function ADDPATH(p)$/;"	f
ADD_NL	regexp.c	159;"	d	file:
ADVANCE_P	regexp.c	4289;"	d	file:
ADVANCE_P	regexp.c	4291;"	d	file:
ADVANCE_REGINPUT	regexp.c	3161;"	d	file:
ADVANCE_REGINPUT	regexp.c	3189;"	d	file:
ALEF	farsi.h	110;"	d
ALEF_	farsi.h	29;"	d
ALEF_A	farsi.h	109;"	d
ALEF_D_H	farsi.h	168;"	d
ALEF_U_H	farsi.h	166;"	d
ALEF_U_H_	farsi.h	28;"	d
ALIGN_LONG	structs.h	271;"	d
ALIGN_MASK	structs.h	277;"	d
ALIGN_SIZE	structs.h	272;"	d
ALIGN_SIZE	structs.h	274;"	d
ALIST	structs.h	556;"	d
ALIST	structs.h	558;"	d
ALL_BUILTIN_TCAPS	feature.h	512;"	d
ALPHA	regexp.c	185;"	d	file:
ALT_INPUT_LOCK_OFF	vim.h	1644;"	d
ALT_INPUT_LOCK_ON	vim.h	1645;"	d
ALT_X_INPUT	feature.h	1176;"	d
ALWAYS_USE_GUI	gui.h	77;"	d
AL_ADD	ex_cmds2.c	1050;"	d	file:
AL_DEL	ex_cmds2.c	1051;"	d	file:
AL_SET	ex_cmds2.c	1049;"	d	file:
ANCHOR_BUF_SIZE	os_amiga.c	1394;"	d	file:
ANCHOR_SIZE	os_amiga.c	1395;"	d	file:
ANSIOFF	Make_agui.mak	/^ANSIOFF = *e[0m$/;"	m
ANY	regexp.c	161;"	d	file:
ANYBUT	regexp.c	163;"	d	file:
ANYOF	regexp.c	162;"	d	file:
APPENDBIN	vim.h	1180;"	d
APPENDBIN	vim.h	1184;"	d
ARABIC_CHAR	arabic.h	258;"	d
ARG	testdir/test49.vim	/^function! ARG(x, n)$/;"	f
ARGCOUNT	structs.h	565;"	d
ARGLIST	structs.h	561;"	d
ARGOPT	ex_cmds.h	52;"	d
ARGTYPE_EDIT	main.c	2789;"	d	file:
ARGTYPE_EDIT_WAIT	main.c	2790;"	d	file:
ARGTYPE_OTHER	main.c	2788;"	d	file:
ARGTYPE_SEND	main.c	2791;"	d	file:
ASCII_ISALNUM	macros.h	102;"	d
ASCII_ISALNUM	macros.h	107;"	d
ASCII_ISALPHA	macros.h	101;"	d
ASCII_ISALPHA	macros.h	106;"	d
ASCII_ISLOWER	macros.h	103;"	d
ASCII_ISLOWER	macros.h	108;"	d
ASCII_ISUPPER	macros.h	104;"	d
ASCII_ISUPPER	macros.h	109;"	d
ASKMORE	vim.h	526;"	d
ASSERT	nbdebug.h	17;"	d
ASSERT	nbdebug.h	57;"	d
ATTR_OFF	syntax.c	101;"	d	file:
AT_CURSOR	farsi.h	178;"	d
AUGROUP_ALL	fileio.c	6747;"	d	file:
AUGROUP_DEFAULT	fileio.c	6745;"	d	file:
AUGROUP_ERROR	fileio.c	6746;"	d	file:
AUGROUP_NAME	fileio.c	6740;"	d	file:
AYN	farsi.h	131;"	d
AYN_	farsi.h	44;"	d
A_firstc_laa	arabic.c	/^A_firstc_laa(c, c1)$/;"	f	file:
A_is_a	arabic.c	/^A_is_a(cur_c)$/;"	f	file:
A_is_f	arabic.c	/^A_is_f(cur_c)$/;"	f	file:
A_is_formb	arabic.c	/^A_is_formb(c)$/;"	f	file:
A_is_harakat	arabic.c	/^A_is_harakat(c)$/;"	f	file:
A_is_iso	arabic.c	/^A_is_iso(c)$/;"	f	file:
A_is_ok	arabic.c	/^A_is_ok(c)$/;"	f	file:
A_is_s	arabic.c	/^A_is_s(cur_c)$/;"	f	file:
A_is_special	arabic.c	/^A_is_special(c)$/;"	f	file:
A_is_valid	arabic.c	/^A_is_valid(c)$/;"	f	file:
AmigaError	gui_amiga.c	/^AmigaError(const char *string)$/;"	f	file:
AppendCharToRedobuff	getchar.c	/^AppendCharToRedobuff(c)$/;"	f
AppendNumberToRedobuff	getchar.c	/^AppendNumberToRedobuff(n)$/;"	f
AppendToRedobuff	getchar.c	/^AppendToRedobuff(s)$/;"	f
AppendToRedobuffLit	getchar.c	/^AppendToRedobuffLit(s)$/;"	f
ArpBase	os_amiga.c	/^struct ArpBase		*ArpBase = NULL;$/;"	v	typeref:struct:ArpBase
AutoCmd	fileio.c	/^typedef struct AutoCmd$/;"	s	file:
AutoCmd	fileio.c	/^} AutoCmd;$/;"	t	typeref:struct:AutoCmd	file:
AutoPat	fileio.c	/^typedef struct AutoPat$/;"	s	file:
AutoPat	fileio.c	/^} AutoPat;$/;"	t	typeref:struct:AutoPat	file:
AutoPatCmd	fileio.c	/^typedef struct AutoPatCmd$/;"	s	file:
AutoPatCmd	fileio.c	/^} AutoPatCmd;$/;"	t	typeref:struct:AutoPatCmd	file:
B	testdir/test49.vim	/^    function! B(jump)$/;"	f
B0_FNAME_SIZE	memline.c	128;"	d	file:
B0_HNAME_SIZE	memline.c	130;"	d	file:
B0_MAGIC_CHAR	memline.c	139;"	d	file:
B0_MAGIC_INT	memline.c	137;"	d	file:
B0_MAGIC_LONG	memline.c	136;"	d	file:
B0_MAGIC_SHORT	memline.c	138;"	d	file:
B0_UNAME_SIZE	memline.c	129;"	d	file:
BACK	regexp.c	136;"	d	file:
BACKREF	regexp.c	199;"	d	file:
BACKSPACE_CHAR	edit.c	115;"	d	file:
BACKSPACE_LINE	edit.c	118;"	d	file:
BACKSPACE_WORD	edit.c	116;"	d	file:
BACKSPACE_WORD_NOT_SPACE	edit.c	117;"	d	file:
BACKWARD	vim.h	535;"	d
BACKWARD_FILE	vim.h	537;"	d
BANG	ex_cmds.h	34;"	d
BASENAMELEN	os_amiga.h	40;"	d
BBOLD	Make_agui.mak	/^BBOLD = *e[1m$/;"	m
BC	term.c	/^char *UP, *BC, PC;$/;"	v
BC	termlib.c	/^char	*UP = 0, *BC = 0;     \/* Pointers to UP and BC strings from database *\/$/;"	v
BCOL1	Make_agui.mak	/^BCOL1 = *e[41m$/;"	m
BCOL2	Make_agui.mak	/^BCOL2 = *e[42m$/;"	m
BCOL3	Make_agui.mak	/^BCOL3 = *e[43m$/;"	m
BCOL4	Make_agui.mak	/^BCOL4 = *e[44m$/;"	m
BCO_ALWAYS	vim.h	833;"	d
BCO_ENTER	vim.h	832;"	d
BCO_NOHELP	vim.h	834;"	d
BE	farsi.h	112;"	d
BEHIND	regexp.c	145;"	d	file:
BELL	ascii.h	109;"	d
BELL	ascii.h	25;"	d
BF_CHECK_RO	vim.h	548;"	d
BF_NEVERLOADED	vim.h	551;"	d
BF_NEW	vim.h	556;"	d
BF_NEW_W	vim.h	557;"	d
BF_NOTEDITED	vim.h	553;"	d
BF_READERR	vim.h	558;"	d
BF_RECOVERED	vim.h	547;"	d
BF_WRITE_MASK	vim.h	561;"	d
BHPOS	regexp.c	155;"	d	file:
BH_DIRTY	structs.h	338;"	d
BH_LOCKED	structs.h	339;"	d
BIN_ASSIGN	xxd/xxd.c	153;"	d	file:
BIN_ASSIGN	xxd/xxd.c	164;"	d	file:
BIN_ASSIGN	xxd/xxd.c	171;"	d	file:
BIN_CREAT	xxd/xxd.c	152;"	d	file:
BIN_CREAT	xxd/xxd.c	163;"	d	file:
BIN_CREAT	xxd/xxd.c	170;"	d	file:
BIN_READ	xxd/xxd.c	150;"	d	file:
BIN_READ	xxd/xxd.c	161;"	d	file:
BIN_READ	xxd/xxd.c	168;"	d	file:
BIN_WRITE	xxd/xxd.c	151;"	d	file:
BIN_WRITE	xxd/xxd.c	162;"	d	file:
BIN_WRITE	xxd/xxd.c	169;"	d	file:
BKC_AUTO	option.h	309;"	d
BKC_BREAKHARDLINK	option.h	312;"	d
BKC_BREAKSYMLINK	option.h	311;"	d
BKC_NO	option.h	310;"	d
BKC_YES	option.h	308;"	d
BLN_CURBUF	vim.h	714;"	d
BLN_DUMMY	vim.h	716;"	d
BLN_LISTED	vim.h	715;"	d
BLOCK0_ID0	memline.c	68;"	d	file:
BLOCK0_ID1	memline.c	69;"	d	file:
BL_FIX	vim.h	823;"	d
BL_SOL	vim.h	822;"	d
BL_WHITE	vim.h	821;"	d
BOL	regexp.c	132;"	d	file:
BOOL	gui_amiga.c	52;"	d	file:
BOW	regexp.c	150;"	d	file:
BRACE_AT_END	misc1.c	5502;"	d	file:
BRACE_AT_START	misc1.c	5501;"	d	file:
BRACE_COMPLEX	regexp.c	208;"	d	file:
BRACE_IN_COL0	misc1.c	5500;"	d	file:
BRACE_LIMITS	regexp.c	152;"	d	file:
BRACE_SIMPLE	regexp.c	148;"	d	file:
BRANCH	regexp.c	134;"	d	file:
BREAKCHECK_SKIP	misc1.c	7637;"	d	file:
BREAKCHECK_SKIP	misc1.c	7639;"	d	file:
BREAKP	ex_cmds2.c	358;"	d	file:
BROWSE_CURRBUF	feature.h	713;"	d
BROWSE_FILTER_ALL_FILES	vim.h	1617;"	d
BROWSE_FILTER_ALL_FILES	vim.h	1623;"	d
BROWSE_FILTER_DEFAULT	vim.h	1618;"	d
BROWSE_FILTER_DEFAULT	vim.h	1624;"	d
BROWSE_FILTER_MACROS	vim.h	1615;"	d
BROWSE_FILTER_MACROS	vim.h	1621;"	d
BS	ascii.h	110;"	d
BS	ascii.h	26;"	d
BS_EOL	option.h	276;"	d
BS_INDENT	option.h	275;"	d
BS_START	option.h	277;"	d
BT_EXTRA_KEYS	term.c	75;"	d	file:
BUF2SIZE	os_amiga.c	300;"	d	file:
BUFNAME	ex_cmds.h	50;"	d
BUFSIZE	fileio.c	36;"	d	file:
BUFUNL	ex_cmds.h	51;"	d
BVAR_ENTRY	eval.c	73;"	d	file:
B_IMODE_IM	structs.h	1058;"	d
B_IMODE_LAST	structs.h	1056;"	d
B_IMODE_LAST	structs.h	1059;"	d
B_IMODE_LMAP	structs.h	1054;"	d
B_IMODE_NONE	structs.h	1053;"	d
B_IMODE_USE_INSERT	structs.h	1052;"	d
BalloonEval	gui_beval.h	/^} BalloonEval;$/;"	t	typeref:struct:BalloonEvalStruct
BalloonEval	proto.h	178;"	d
BalloonEvalStruct	gui_beval.h	/^typedef struct BalloonEvalStruct$/;"	s
Bar	testdir/test49.vim	/^function! Bar()$/;"	f
BeState	gui_beval.h	/^} BeState;$/;"	t	typeref:enum:__anon2
C	testdir/test49.vim	/^    function! C(jump)$/;"	f
C	testdir/test49.vim	/^function! C()$/;"	f
CALL	testdir/test49.vim	/^    com! -nargs=1 CALL$/;"	c
CAR	ascii.h	115;"	d
CAR	ascii.h	31;"	d
CASE_INSENSITIVE_FILENAME	os_amiga.h	13;"	d
CA_COMMAND_BUSY	structs.h	1661;"	d
CA_NO_ADJ_OP_END	structs.h	1662;"	d
CBUFLEN	misc1.c	2854;"	d	file:
CC	Make_agui.mak	/^CC = sc$/;"	m
CC	Make_aros.mak	/^CC     = i386-linux-aros-gcc$/;"	m
CC	Make_dice.mak	/^CC = dcc$/;"	m
CC	Make_manx.mak	/^CC = cc$/;"	m
CC	Make_morph.mak	/^CC =		gcc$/;"	m
CC	Make_sas.mak	/^CC	= sc$/;"	m
CCNOSYM	Make_manx.mak	/^CCNOSYM = $(CC) $(CFLAGS) -o$/;"	m
CCSYM	Make_manx.mak	/^CCSYM = $(CC) $(CFLAGS) -hi$(SYMS) -o$/;"	m
CFLAGS	Make_agui.mak	/^CFLAGS = NOLINK $(DBG)  CPU=$(CPU) NOSTACKCHECK$/;"	m
CFLAGS	Make_aros.mak	/^CFLAGS = -pipe -O2 -Wall -Iproto \\$/;"	m
CFLAGS	Make_dice.mak	/^CFLAGS = -c -DAMIGA -Iproto $(DEFINES)$/;"	m
CFLAGS	Make_manx.mak	/^CFLAGS = $(OPTIONS) -wapruq -ps -qf -Iproto $(DEFINES) -DAMIGA$/;"	m
CFLAGS	Make_morph.mak	/^CFLAGS =	-c						\\$/;"	m
CFLAGS	Make_sas.mak	/^CFLAGS  = NOLINK $(DBG) CPU=$(CPU) NOSTACKCHECK DEF=AMIGA CODE=FAR idir=proto ignore=317$/;"	m
CFLAGS	xxd/Make_amiga.mak	/^CFLAGS = $(OPTIONS) -wapruq -ps -qf -DAMIGA -Dconst=$/;"	m
CFLAGS2	Make_agui.mak	/^CFLAGS2 = $(OPTIMIZE) $(ERROR) GSTIMMEDIATE GST=$(GST)$/;"	m
CFLAGS2	Make_sas.mak	/^CFLAGS2 = $(OPTIMIZE) $(ERROR) GSTIMMEDIATE GST=$(GST)$/;"	m
CFLAGS3	Make_agui.mak	/^CFLAGS3 =NOSINT SCODE SDATA STRINGMERGE MEMSIZE=$(MEMSIZE)$/;"	m
CFLAGS3	Make_sas.mak	/^CFLAGS3 = $(COPTS) STRINGMERGE MEMSIZE=$(MEMSIZE)$/;"	m
CFLAGS4	Make_agui.mak	/^CFLAGS4 = $(DEFINES) DATAMEMORY=$(MEMORYTYPE)$/;"	m
CFLAGS4	Make_sas.mak	/^CFLAGS4 = $(DEFINES) DATAMEMORY=$(MEMORYTYPE)$/;"	m
CHARSIZE	macros.h	121;"	d
CHAR_CELLS	screen.c	4301;"	d	file:
CHAR_CLASS	ui.c	1279;"	d	file:
CHE	farsi.h	117;"	d
CHECK	memline.c	12;"	d	file:
CHECK	testdir/test49.vim	/^    function! CHECK(n, ...)$/;"	f
CHECK	testdir/test49.vim	/^function! CHECK(n, exception, throwname, throwline)$/;"	f
CHECK_CMDWIN	window.c	109;"	d	file:
CHECK_DOUBLE_CLICK	vim.h	1437;"	d
CHECK_INODE	vim.h	222;"	d
CHECK_KEYS_TIME	edit.c	34;"	d	file:
CHECK_PATH	vim.h	659;"	d
CLASS_ALNUM	regexp.c	417;"	d	file:
CLASS_ALPHA	regexp.c	419;"	d	file:
CLASS_BACKSPACE	regexp.c	445;"	d	file:
CLASS_BLANK	regexp.c	421;"	d	file:
CLASS_CNTRL	regexp.c	423;"	d	file:
CLASS_DIGIT	regexp.c	425;"	d	file:
CLASS_ESCAPE	regexp.c	447;"	d	file:
CLASS_GRAPH	regexp.c	427;"	d	file:
CLASS_LOWER	regexp.c	429;"	d	file:
CLASS_NONE	regexp.c	449;"	d	file:
CLASS_PRINT	regexp.c	431;"	d	file:
CLASS_PUNCT	regexp.c	433;"	d	file:
CLASS_RETURN	regexp.c	443;"	d	file:
CLASS_SPACE	regexp.c	435;"	d	file:
CLASS_TAB	regexp.c	441;"	d	file:
CLASS_UPPER	regexp.c	437;"	d	file:
CLASS_XDIGIT	regexp.c	439;"	d	file:
CLEAR	vim.h	446;"	d
CLIP_CLEAR	ui.c	554;"	d	file:
CLIP_SET	ui.c	555;"	d	file:
CLIP_TOGGLE	ui.c	556;"	d	file:
CLUSTER_ADD	syntax.c	221;"	d	file:
CLUSTER_REPLACE	syntax.c	220;"	d	file:
CLUSTER_SUBTRACT	syntax.c	222;"	d	file:
CMDBUFFSIZE	vim.h	1152;"	d
CMDLINE	vim.h	510;"	d
CMDWIN	ex_cmds.h	54;"	d
CMD_CONT	ex_cmds2.c	56;"	d	file:
CMD_FINISH	ex_cmds2.c	59;"	d	file:
CMD_INTERRUPT	ex_cmds2.c	61;"	d	file:
CMD_NEXT	ex_cmds2.c	57;"	d	file:
CMD_QUIT	ex_cmds2.c	60;"	d	file:
CMD_STEP	ex_cmds2.c	58;"	d	file:
CMP_INTERNAL	option.h	339;"	d
CMP_KEEPASCII	option.h	340;"	d
COLS	xxd/xxd.c	205;"	d	file:
COL_RULER	option.c	7704;"	d	file:
COM_ALL	option.h	231;"	d
COM_AUTO_END	option.h	226;"	d
COM_BLANK	option.h	222;"	d
COM_END	option.h	225;"	d
COM_FIRST	option.h	227;"	d
COM_LEFT	option.h	228;"	d
COM_MAX_LEN	option.h	232;"	d
COM_MIDDLE	option.h	224;"	d
COM_NEST	option.h	221;"	d
COM_NOBACK	option.h	230;"	d
COM_RIGHT	option.h	229;"	d
COM_START	option.h	223;"	d
CONFIRM	vim.h	531;"	d
CONT	testdir/test49.vim	/^    function! CONT(n)$/;"	f
CONTEXT_UNKNOWN	vim.h	566;"	d
CONT_ADDING	globals.h	109;"	d
CONT_INTRPT	globals.h	110;"	d
CONT_LOCAL	globals.h	117;"	d
CONT_N_ADDS	globals.h	112;"	d
CONT_SOL	globals.h	115;"	d
CONT_S_IPOS	globals.h	113;"	d
CONV_CODEPAGE	structs.h	855;"	d
CONV_ICONV	structs.h	853;"	d
CONV_LATIN1_MAC	structs.h	859;"	d
CONV_MAC_LATIN1	structs.h	858;"	d
CONV_MAC_UTF8	structs.h	860;"	d
CONV_NONE	structs.h	850;"	d
CONV_RESTLEN	fileio.c	98;"	d	file:
CONV_TO_LATIN1	structs.h	852;"	d
CONV_TO_UTF8	structs.h	851;"	d
CONV_UTF8_MAC	structs.h	861;"	d
COPTS	Make_sas.mak	/^COPTS	= SINT SCODE SDATA$/;"	m
COUNT	ex_cmds.h	44;"	d
CPO_ALL	option.h	161;"	d
CPO_ALTREAD	option.h	118;"	d
CPO_ALTWRITE	option.h	119;"	d
CPO_BACKSPACE	option.h	150;"	d
CPO_BAR	option.h	120;"	d
CPO_BSLASH	option.h	121;"	d
CPO_BUFOPT	option.h	146;"	d
CPO_BUFOPTGLOB	option.h	147;"	d
CPO_CONCAT	option.h	123;"	d
CPO_CW	option.h	151;"	d
CPO_DEFAULT	option.h	160;"	d
CPO_DIGRAPH	option.h	125;"	d
CPO_DOLLAR	option.h	155;"	d
CPO_DOTTAG	option.h	124;"	d
CPO_EMPTYREGION	option.h	127;"	d
CPO_ENDOFSENT	option.h	133;"	d
CPO_ESC	option.h	153;"	d
CPO_EXECBUF	option.h	126;"	d
CPO_FILTER	option.h	156;"	d
CPO_FNAMER	option.h	128;"	d
CPO_FNAMEW	option.h	129;"	d
CPO_FWRITE	option.h	152;"	d
CPO_GOTO1	option.h	130;"	d
CPO_INTMOD	option.h	131;"	d
CPO_JOINSP	option.h	132;"	d
CPO_KEYCODE	option.h	134;"	d
CPO_KOFFSET	option.h	135;"	d
CPO_LINEOFF	option.h	141;"	d
CPO_LISP	option.h	143;"	d
CPO_LISTWM	option.h	137;"	d
CPO_LITERAL	option.h	136;"	d
CPO_MATCH	option.h	157;"	d
CPO_MATCHBSL	option.h	139;"	d
CPO_NUMCOL	option.h	140;"	d
CPO_OVERNEW	option.h	142;"	d
CPO_REDO	option.h	144;"	d
CPO_REMMARK	option.h	145;"	d
CPO_SEARCH	option.h	122;"	d
CPO_SHOWMATCH	option.h	138;"	d
CPO_SPECI	option.h	159;"	d
CPO_STAR	option.h	158;"	d
CPO_TAGPAT	option.h	148;"	d
CPO_UNDO	option.h	149;"	d
CPO_YANK	option.h	154;"	d
CPU	Make_agui.mak	/^CPU=68060$/;"	m
CPU	Make_sas.mak	/^CPU=68000$/;"	m
CP_UTF8	mbyte.c	343;"	d	file:
CRC32	misc2.c	3168;"	d	file:
CREATE_DUMMY_FILE	memline.c	3389;"	d	file:
CRV_GET	term.c	112;"	d	file:
CRV_GOT	term.c	114;"	d	file:
CRV_SENT	term.c	113;"	d	file:
CRYPT_MAGIC	fileio.c	40;"	d	file:
CRYPT_MAGIC_LEN	fileio.c	41;"	d	file:
CSF_ACTIVE	structs.h	609;"	d
CSF_CAUGHT	structs.h	615;"	d
CSF_ELSE	structs.h	610;"	d
CSF_FINALLY	structs.h	613;"	d
CSF_SILENT	structs.h	616;"	d
CSF_THROWN	structs.h	614;"	d
CSF_TRUE	structs.h	608;"	d
CSF_TRY	structs.h	612;"	d
CSF_WHILE	structs.h	611;"	d
CSI	ascii.h	122;"	d
CSI	ascii.h	37;"	d
CSI_STR	ascii.h	123;"	d
CSI_STR	ascii.h	38;"	d
CSQF_CMDS	option.h	369;"	d
CSQF_FLAGS	option.h	370;"	d
CSTACK_LEN	structs.h	585;"	d
CSTP_BREAK	structs.h	628;"	d
CSTP_CONTINUE	structs.h	629;"	d
CSTP_ERROR	structs.h	625;"	d
CSTP_FINISH	structs.h	631;"	d
CSTP_INTERRUPT	structs.h	626;"	d
CSTP_NONE	structs.h	624;"	d
CSTP_RETURN	structs.h	630;"	d
CSTP_THROW	structs.h	627;"	d
CTERM_ATTR_ENTRY	syntax.c	7338;"	d	file:
CTRL_F_STR	ascii.h	129;"	d
CTRL_F_STR	ascii.h	47;"	d
CTRL_H_STR	ascii.h	130;"	d
CTRL_H_STR	ascii.h	48;"	d
CTRL_V_STR	ascii.h	131;"	d
CTRL_V_STR	ascii.h	49;"	d
CTRL_W_STR	ascii.h	132;"	d
CTRL_W_STR	ascii.h	50;"	d
CTRL_X_CMDLINE	edit.c	32;"	d	file:
CTRL_X_DICTIONARY	edit.c	30;"	d	file:
CTRL_X_FILES	edit.c	25;"	d	file:
CTRL_X_FINISHED	edit.c	29;"	d	file:
CTRL_X_MSG	edit.c	36;"	d	file:
CTRL_X_NOT_DEFINED_YET	edit.c	22;"	d	file:
CTRL_X_PATH_DEFINES	edit.c	28;"	d	file:
CTRL_X_PATH_PATTERNS	edit.c	27;"	d	file:
CTRL_X_SCROLL	edit.c	23;"	d	file:
CTRL_X_TAGS	edit.c	26;"	d	file:
CTRL_X_THESAURUS	edit.c	31;"	d	file:
CTRL_X_WANT_IDENT	edit.c	20;"	d	file:
CTRL_X_WHOLE_LINE	edit.c	24;"	d	file:
CT_CELL_MASK	vim.h	872;"	d
CT_FNAME_CHAR	vim.h	875;"	d
CT_ID_CHAR	vim.h	874;"	d
CT_PRINT_CHAR	vim.h	873;"	d
CURSOR	regexp.c	217;"	d	file:
CURSOR_BAR_RIGHT	macros.h	244;"	d
CURSOR_MOVED	vim.h	1424;"	d
CURSOR_SHAPE	feature.h	1069;"	d
CUR_STATE	syntax.c	334;"	d	file:
CV	proto.h	237;"	d
CYGWIN	xxd/xxd.c	147;"	d	file:
CharOrd	ascii.h	100;"	d
CharOrd	ascii.h	19;"	d
CharOrdLow	ascii.h	20;"	d
CharOrdLow	ascii.h	98;"	d
CharOrdUp	ascii.h	21;"	d
CharOrdUp	ascii.h	99;"	d
CharOrd__	ascii.h	97;"	d
CheckConfiguration	testdir/test49.vim	/^    function! CheckConfiguration(type)	    " type is "error" or "interrupt"$/;"	f
CheckThrow	testdir/test49.vim	/^    function! CheckThrow(Type)$/;"	f
Chk_Abort	os_amiga.c	/^Chk_Abort(void)$/;"	f
Chk_Abort	os_amiga.c	1364;"	d	file:
CmdException	testdir/test49.vim	/^command! CmdException  let g:exception  = v:exception$/;"	c
CmdThrowpoint	testdir/test49.vim	/^command! CmdThrowpoint let g:throwpoint = v:throwpoint$/;"	c
Columns	globals.h	/^EXTERN long	Columns INIT(= 80);	\/* nr of columns in the screen *\/$/;"	v
Completion	edit.c	/^struct Completion$/;"	s	file:
CtrlChar	ascii.h	170;"	d
Ctrl_A	ascii.h	135;"	d
Ctrl_A	ascii.h	53;"	d
Ctrl_AT	ascii.h	134;"	d
Ctrl_AT	ascii.h	52;"	d
Ctrl_B	ascii.h	136;"	d
Ctrl_B	ascii.h	54;"	d
Ctrl_BSL	ascii.h	163;"	d
Ctrl_BSL	ascii.h	80;"	d
Ctrl_C	ascii.h	137;"	d
Ctrl_C	ascii.h	55;"	d
Ctrl_D	ascii.h	138;"	d
Ctrl_D	ascii.h	56;"	d
Ctrl_E	ascii.h	139;"	d
Ctrl_E	ascii.h	57;"	d
Ctrl_F	ascii.h	140;"	d
Ctrl_F	ascii.h	58;"	d
Ctrl_G	ascii.h	141;"	d
Ctrl_G	ascii.h	59;"	d
Ctrl_H	ascii.h	142;"	d
Ctrl_H	ascii.h	60;"	d
Ctrl_HAT	ascii.h	164;"	d
Ctrl_HAT	ascii.h	82;"	d
Ctrl_I	ascii.h	143;"	d
Ctrl_I	ascii.h	61;"	d
Ctrl_J	ascii.h	144;"	d
Ctrl_J	ascii.h	62;"	d
Ctrl_K	ascii.h	145;"	d
Ctrl_K	ascii.h	63;"	d
Ctrl_L	ascii.h	146;"	d
Ctrl_L	ascii.h	64;"	d
Ctrl_LSB	ascii.h	161;"	d
Ctrl_LSB	ascii.h	79;"	d
Ctrl_M	ascii.h	147;"	d
Ctrl_M	ascii.h	65;"	d
Ctrl_N	ascii.h	148;"	d
Ctrl_N	ascii.h	66;"	d
Ctrl_O	ascii.h	149;"	d
Ctrl_O	ascii.h	67;"	d
Ctrl_P	ascii.h	150;"	d
Ctrl_P	ascii.h	68;"	d
Ctrl_Q	ascii.h	151;"	d
Ctrl_Q	ascii.h	69;"	d
Ctrl_R	ascii.h	152;"	d
Ctrl_R	ascii.h	70;"	d
Ctrl_RSB	ascii.h	162;"	d
Ctrl_RSB	ascii.h	81;"	d
Ctrl_S	ascii.h	153;"	d
Ctrl_S	ascii.h	71;"	d
Ctrl_T	ascii.h	154;"	d
Ctrl_T	ascii.h	72;"	d
Ctrl_U	ascii.h	155;"	d
Ctrl_U	ascii.h	73;"	d
Ctrl_V	ascii.h	156;"	d
Ctrl_V	ascii.h	74;"	d
Ctrl_W	ascii.h	157;"	d
Ctrl_W	ascii.h	75;"	d
Ctrl_X	ascii.h	158;"	d
Ctrl_X	ascii.h	76;"	d
Ctrl_Y	ascii.h	159;"	d
Ctrl_Y	ascii.h	77;"	d
Ctrl_Z	ascii.h	160;"	d
Ctrl_Z	ascii.h	78;"	d
Ctrl__	ascii.h	165;"	d
Ctrl__	ascii.h	83;"	d
Ctrl_chr	ascii.h	167;"	d
Ctrl_chr	ascii.h	44;"	d
CursorOff	gui_amiga.c	/^	CursorOff,$/;"	e	enum:__anon26::__anon27	file:
CursorOn	gui_amiga.c	/^	CursorOn,$/;"	e	enum:__anon26::__anon27	file:
CursorWait	gui_amiga.c	/^	CursorWait$/;"	e	enum:__anon26::__anon27	file:
D	gui.h	12;"	d
D	gui_amiga.c	126;"	d	file:
D	gui_amiga.c	131;"	d	file:
DAL	farsi.h	120;"	d
DATA_BL	memline.c	/^typedef struct data_block	DATA_BL;    \/* contents of a data block *\/$/;"	t	typeref:struct:data_block	file:
DATA_ID	memline.c	66;"	d	file:
DBCS_2BYTE	globals.h	667;"	d
DBCS_CHS	globals.h	663;"	d
DBCS_CHSU	globals.h	664;"	d
DBCS_CHT	globals.h	665;"	d
DBCS_CHTU	globals.h	666;"	d
DBCS_DEBUG	globals.h	668;"	d
DBCS_JPN	globals.h	659;"	d
DBCS_JPNU	globals.h	660;"	d
DBCS_KOR	globals.h	661;"	d
DBCS_KORU	globals.h	662;"	d
DBG	Make_agui.mak	/^DBG = NODEBUG$/;"	m
DBG	Make_sas.mak	/^DBG = NODEBUG$/;"	m
DBG_FILE	ex_cmds2.c	362;"	d	file:
DBG_FUNC	ex_cmds2.c	361;"	d	file:
DB_COUNT	diff.c	18;"	d	file:
DB_Filled	gui_amiga.c	/^    DB_Filled,$/;"	e	enum:DrawBoxMode	file:
DB_INDEX_MASK	memline.c	123;"	d	file:
DB_MARKED	memline.c	122;"	d	file:
DB_NotFilled	gui_amiga.c	/^    DB_NotFilled$/;"	e	enum:DrawBoxMode	file:
DCS	ascii.h	124;"	d
DCS	ascii.h	39;"	d
DEBUG	regexp.c	43;"	d	file:
DEBUG	vim.h	1770;"	d
DEFAULT_TERM	term.c	1391;"	d	file:
DEFAULT_TERM	term.c	1395;"	d	file:
DEFAULT_TERM	term.c	1399;"	d	file:
DEFAULT_TERM	term.c	1403;"	d	file:
DEFAULT_TERM	term.c	1407;"	d	file:
DEFAULT_TERM	term.c	1411;"	d	file:
DEFAULT_TERM	term.c	1415;"	d	file:
DEFAULT_TERM	term.c	1419;"	d	file:
DEFAULT_TERM	term.c	1423;"	d	file:
DEFAULT_TERM	term.c	1424;"	d	file:
DEFAULT_TERM	term.c	1428;"	d	file:
DEFINES	Make_agui.mak	/^DEFINES = DEF=NO_ARP DEF=AMIGA DEF=NEWSASC DEF=FEAT_GUI_AMIGA \\$/;"	m
DEFINES	Make_dice.mak	/^DEFINES = -DHAVE_TGETENT -DUP_BC_PC_EXTERN -DOSPEED_EXTERN$/;"	m
DEFINES	Make_manx.mak	/^DEFINES =$/;"	m
DEFINES	Make_sas.mak	/^DEFINES = DEF=NO_ARP DEF=NEWSASC DEF="SASC=658"$/;"	m
DEL	Make_manx.mak	/^DEL = $(SHELL) -c rm -f$/;"	m
DEL	Make_sas.mak	/^DEL	= $(SHELL) -c rm -f$/;"	m
DEL	ascii.h	119;"	d
DEL	ascii.h	35;"	d
DELETION_REGISTER	ops.c	29;"	d	file:
DEL_STR	ascii.h	120;"	d
DEL_STR	ascii.h	36;"	d
DEP	Make_agui.mak	/^DEP = $(GST)$/;"	m
DFLALL	ex_cmds.h	38;"	d
DFLT_BDIR	os_amiga.h	176;"	d
DFLT_DIR	os_amiga.h	180;"	d
DFLT_EFM	option.h	24;"	d
DFLT_EFM	option.h	27;"	d
DFLT_EFM	option.h	30;"	d
DFLT_EFM	option.h	33;"	d
DFLT_EFM	option.h	36;"	d
DFLT_EFM	option.h	39;"	d
DFLT_EFM	option.h	41;"	d
DFLT_ERRORFILE	os_amiga.h	37;"	d
DFLT_FF	option.h	57;"	d
DFLT_FF	option.h	63;"	d
DFLT_FF	option.h	68;"	d
DFLT_FFS_VI	option.h	59;"	d
DFLT_FFS_VI	option.h	65;"	d
DFLT_FFS_VI	option.h	71;"	d
DFLT_FFS_VI	option.h	74;"	d
DFLT_FFS_VIM	option.h	58;"	d
DFLT_FFS_VIM	option.h	64;"	d
DFLT_FFS_VIM	option.h	69;"	d
DFLT_FO_VI	option.h	113;"	d
DFLT_FO_VIM	option.h	114;"	d
DFLT_GREPFORMAT	option.h	49;"	d
DFLT_HELPFILE	os_amiga.h	103;"	d
DFLT_MAXMEM	os_amiga.h	188;"	d
DFLT_MAXMEMTOT	os_amiga.h	191;"	d
DFLT_RUNTIMEPATH	os_amiga.h	38;"	d
DFLT_TEXTAUTO	option.h	60;"	d
DFLT_TEXTAUTO	option.h	66;"	d
DFLT_TEXTAUTO	option.h	72;"	d
DFLT_TEXTAUTO	option.h	75;"	d
DFLT_VDIR	os_amiga.h	184;"	d
DICT_EXACT	edit.c	2107;"	d	file:
DICT_FIRST	edit.c	2106;"	d	file:
DID_FOLD	screen.c	773;"	d	file:
DID_LINE	screen.c	772;"	d	file:
DID_NONE	screen.c	771;"	d	file:
DIFF_FILLER	diff.c	51;"	d	file:
DIFF_ICASE	diff.c	52;"	d	file:
DIFF_IWHITE	diff.c	53;"	d	file:
DIGIT	regexp.c	175;"	d	file:
DLG_BUTTON_SEP	vim.h	950;"	d
DLG_HOTKEY_CHAR	vim.h	951;"	d
DOBUF_CURRENT	vim.h	769;"	d
DOBUF_DEL	vim.h	765;"	d
DOBUF_FIRST	vim.h	770;"	d
DOBUF_GOTO	vim.h	762;"	d
DOBUF_LAST	vim.h	771;"	d
DOBUF_MOD	vim.h	772;"	d
DOBUF_SPLIT	vim.h	763;"	d
DOBUF_UNLOAD	vim.h	764;"	d
DOBUF_WIPE	vim.h	766;"	d
DOCMD_EXCRESET	vim.h	817;"	d
DOCMD_KEEPLINE	vim.h	818;"	d
DOCMD_KEYTYPED	vim.h	816;"	d
DOCMD_NOWAIT	vim.h	814;"	d
DOCMD_REPEAT	vim.h	815;"	d
DOCMD_VERBOSE	vim.h	813;"	d
DONE_ACTION	fold.c	89;"	d	file:
DONE_FOLD	fold.c	90;"	d	file:
DONE_NOTHING	fold.c	88;"	d	file:
DOS32	vim.h	120;"	d
DOS_LIBRARY	os_amiga.c	242;"	d	file:
DOS_MOUSE	feature.h	977;"	d
DO_DECLARE_EXCMD	ex_docmd.c	424;"	d	file:
DO_INIT	vim.h	1566;"	d
DRAW_BOLD	gui.h	153;"	d
DRAW_CURSOR	gui.h	158;"	d
DRAW_ITALIC	gui.h	156;"	d
DRAW_TRANSP	gui.h	152;"	d
DRAW_UNDERL	gui.h	154;"	d
DT_CSCOPE	vim.h	889;"	d
DT_FIRST	vim.h	884;"	d
DT_HELP	vim.h	887;"	d
DT_JUMP	vim.h	888;"	d
DT_LAST	vim.h	885;"	d
DT_NEXT	vim.h	882;"	d
DT_POP	vim.h	881;"	d
DT_PREV	vim.h	883;"	d
DT_SELECT	vim.h	886;"	d
DT_TAG	vim.h	880;"	d
DUM_LEN	getchar.c	2704;"	d	file:
DYNAMIC_ICONV_DLL	mbyte.c	3078;"	d	file:
DYNAMIC_ICONV_DLL_ALT	mbyte.c	3079;"	d	file:
DYNAMIC_MSVCRT_DLL	mbyte.c	3082;"	d	file:
DY_LASTLINE	option.h	400;"	d
DY_UHEX	option.h	401;"	d
Delete_autocommands	testdir/test49.vim	/^function! Delete_autocommands(...)$/;"	f
Display	proto.h	24;"	d
DrawBoxMode	gui_amiga.c	/^enum DrawBoxMode$/;"	g	file:
E	testdir/test49.vim	/^    function! E()$/;"	f
E	testdir/test49.vim	/^    function! E(jump)$/;"	f
E2BIG	structs.h	782;"	d
EBCDIC_CHAR_ADD	ascii.h	103;"	d
EBCDIC_CHAR_ADD_	ascii.h	102;"	d
ECMD_ADDBUF	vim.h	805;"	d
ECMD_FORCEIT	vim.h	804;"	d
ECMD_HIDE	vim.h	800;"	d
ECMD_LAST	vim.h	809;"	d
ECMD_LASTL	vim.h	808;"	d
ECMD_OLDBUF	vim.h	803;"	d
ECMD_ONE	vim.h	810;"	d
ECMD_SET_HELP	vim.h	801;"	d
ECONNREFUSED	netbeans.c	34;"	d	file:
EDITCMD	ex_cmds.h	49;"	d
EDIT_FILE	main.c	129;"	d	file:
EDIT_NONE	main.c	128;"	d	file:
EDIT_QF	main.c	132;"	d	file:
EDIT_STDIN	main.c	130;"	d	file:
EDIT_TAG	main.c	131;"	d	file:
EFAULT	structs.h	784;"	d
EILSEQ	structs.h	776;"	d
EILSEQ	structs.h	785;"	d
EILSEQ	vim.h	1684;"	d
EINTR	netbeans.c	36;"	d	file:
EINTR	netbeans.c	38;"	d	file:
EINVAL	structs.h	781;"	d
EMSG	vim.h	1251;"	d
EMSG2	vim.h	1252;"	d
EMSG3	vim.h	1253;"	d
EMSGN	vim.h	1254;"	d
EMSG_M_RET_NULL	regexp.c	317;"	d	file:
EMSG_ONE_RET_NULL	regexp.c	319;"	d	file:
EMSG_RET_FAIL	regexp.c	318;"	d	file:
EMSG_RET_NULL	regexp.c	316;"	d	file:
ENC_2BYTE	vim.h	1673;"	d
ENC_2WORD	vim.h	1675;"	d
ENC_4BYTE	vim.h	1674;"	d
ENC_8BIT	vim.h	1666;"	d
ENC_DBCS	vim.h	1667;"	d
ENC_DFLT	option.h	86;"	d
ENC_ENDIAN_B	vim.h	1670;"	d
ENC_ENDIAN_L	vim.h	1671;"	d
ENC_LATIN1	vim.h	1677;"	d
ENC_MACROMAN	vim.h	1678;"	d
ENC_UCSBOM	option.h	83;"	d
ENC_UNICODE	vim.h	1668;"	d
END	regexp.c	131;"	d	file:
ENOENT	structs.h	783;"	d
EOL	regexp.c	133;"	d	file:
EOL_DOS	option.h	92;"	d
EOL_MAC	option.h	93;"	d
EOL_UNIX	option.h	91;"	d
EOL_UNKNOWN	option.h	90;"	d
EOW	regexp.c	151;"	d	file:
ERR	testdir/test49.vim	/^    function! ERR(n)$/;"	f
ERROR	Make_agui.mak	/^ERROR = ERRORREXX ERRORCONSOLE ERRORSOURCE ERRORHIGHLIGHT$/;"	m
ERROR	Make_sas.mak	/^ERROR = ERRORCONSOLE ERRORSOURCE ERRORHIGHLIGHT$/;"	m
ERROR_NONE	eval.c	3093;"	d	file:
ERROR_OTHER	eval.c	3094;"	d	file:
ERROR_SCRIPT	eval.c	3092;"	d	file:
ERROR_TOOFEW	eval.c	3091;"	d	file:
ERROR_TOOMANY	eval.c	3090;"	d	file:
ERROR_UNKNOWN	eval.c	3088;"	d	file:
ERROR_UNKNOWN	eval.c	3089;"	d	file:
ERRabort	testdir/test49.vim	/^    function! ERRabort(n) abort$/;"	f
ESC	ascii.h	116;"	d
ESC	ascii.h	32;"	d
ESCAPE_CHARS	ex_docmd.c	3920;"	d	file:
ESC_CHG_TO_ENG_MODE	feature.h	625;"	d
ESC_STR	ascii.h	117;"	d
ESC_STR	ascii.h	33;"	d
ESC_STR_nc	ascii.h	118;"	d
ESC_STR_nc	ascii.h	34;"	d
ET_ERROR	structs.h	665;"	d
ET_INTERRUPT	structs.h	666;"	d
ET_USER	structs.h	664;"	d
EVAL_OFFSET_X	gui_beval.h	71;"	d
EVAL_OFFSET_Y	gui_beval.h	72;"	d
EVENT_BUFADD	vim.h	/^    EVENT_BUFADD = 0,		\/* after adding a buffer to the buffer list *\/$/;"	e	enum:auto_event
EVENT_BUFDELETE	vim.h	/^    EVENT_BUFDELETE,		\/* deleting a buffer from the buffer list *\/$/;"	e	enum:auto_event
EVENT_BUFENTER	vim.h	/^    EVENT_BUFENTER,		\/* after entering a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFFILEPOST	vim.h	/^    EVENT_BUFFILEPOST,		\/* after renaming a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFFILEPRE	vim.h	/^    EVENT_BUFFILEPRE,		\/* before renaming a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFHIDDEN	vim.h	/^    EVENT_BUFHIDDEN,		\/* just after buffer becomes hidden *\/$/;"	e	enum:auto_event
EVENT_BUFLEAVE	vim.h	/^    EVENT_BUFLEAVE,		\/* before leaving a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFNEW	vim.h	/^    EVENT_BUFNEW,		\/* after creating any buffer *\/$/;"	e	enum:auto_event
EVENT_BUFNEWFILE	vim.h	/^    EVENT_BUFNEWFILE,		\/* when creating a buffer for a new file *\/$/;"	e	enum:auto_event
EVENT_BUFREADCMD	vim.h	/^    EVENT_BUFREADCMD,		\/* read buffer using command *\/$/;"	e	enum:auto_event
EVENT_BUFREADPOST	vim.h	/^    EVENT_BUFREADPOST,		\/* after reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFREADPRE	vim.h	/^    EVENT_BUFREADPRE,		\/* before reading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFUNLOAD	vim.h	/^    EVENT_BUFUNLOAD,		\/* just before unloading a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWINENTER	vim.h	/^    EVENT_BUFWINENTER,		\/* after showing a buffer in a window *\/$/;"	e	enum:auto_event
EVENT_BUFWINLEAVE	vim.h	/^    EVENT_BUFWINLEAVE,		\/* just after buffer removed from window *\/$/;"	e	enum:auto_event
EVENT_BUFWIPEOUT	vim.h	/^    EVENT_BUFWIPEOUT,		\/* just before really deleting a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITECMD	vim.h	/^    EVENT_BUFWRITECMD,		\/* write buffer using command *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPOST	vim.h	/^    EVENT_BUFWRITEPOST,		\/* after writing a buffer *\/$/;"	e	enum:auto_event
EVENT_BUFWRITEPRE	vim.h	/^    EVENT_BUFWRITEPRE,		\/* before writing a buffer *\/$/;"	e	enum:auto_event
EVENT_CMDWINENTER	vim.h	/^    EVENT_CMDWINENTER,		\/* after entering the cmdline window *\/$/;"	e	enum:auto_event
EVENT_CMDWINLEAVE	vim.h	/^    EVENT_CMDWINLEAVE,		\/* before leaving the cmdline window *\/$/;"	e	enum:auto_event
EVENT_CURSORHOLD	vim.h	/^    EVENT_CURSORHOLD,		\/* cursor in same position for a while *\/$/;"	e	enum:auto_event
EVENT_ENCODINGCHANGED	vim.h	/^    EVENT_ENCODINGCHANGED,	\/* after changing the 'encoding' option *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDCMD	vim.h	/^    EVENT_FILEAPPENDCMD,	\/* appende to a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPOST	vim.h	/^    EVENT_FILEAPPENDPOST,	\/* after appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILEAPPENDPRE	vim.h	/^    EVENT_FILEAPPENDPRE,	\/* before appending to a file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDRO	vim.h	/^    EVENT_FILECHANGEDRO,	\/* before first change to read-only file *\/$/;"	e	enum:auto_event
EVENT_FILECHANGEDSHELL	vim.h	/^    EVENT_FILECHANGEDSHELL,	\/* after shell command that changed file *\/$/;"	e	enum:auto_event
EVENT_FILEREADCMD	vim.h	/^    EVENT_FILEREADCMD,		\/* read from a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEREADPOST	vim.h	/^    EVENT_FILEREADPOST,		\/* after reading a file *\/$/;"	e	enum:auto_event
EVENT_FILEREADPRE	vim.h	/^    EVENT_FILEREADPRE,		\/* before reading a file *\/$/;"	e	enum:auto_event
EVENT_FILETYPE	vim.h	/^    EVENT_FILETYPE,		\/* new file type detected (user defined) *\/$/;"	e	enum:auto_event
EVENT_FILEWRITECMD	vim.h	/^    EVENT_FILEWRITECMD,		\/* write to a file using command *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPOST	vim.h	/^    EVENT_FILEWRITEPOST,	\/* after writing a file *\/$/;"	e	enum:auto_event
EVENT_FILEWRITEPRE	vim.h	/^    EVENT_FILEWRITEPRE,		\/* before writing a file *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPOST	vim.h	/^    EVENT_FILTERREADPOST,	\/* after reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERREADPRE	vim.h	/^    EVENT_FILTERREADPRE,	\/* before reading from a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPOST	vim.h	/^    EVENT_FILTERWRITEPOST,	\/* after writing to a filter *\/$/;"	e	enum:auto_event
EVENT_FILTERWRITEPRE	vim.h	/^    EVENT_FILTERWRITEPRE,	\/* before writing to a filter *\/$/;"	e	enum:auto_event
EVENT_FOCUSGAINED	vim.h	/^    EVENT_FOCUSGAINED,		\/* got the focus *\/$/;"	e	enum:auto_event
EVENT_FOCUSLOST	vim.h	/^    EVENT_FOCUSLOST,		\/* lost the focus to another app *\/$/;"	e	enum:auto_event
EVENT_FUNCUNDEFINED	vim.h	/^    EVENT_FUNCUNDEFINED,	\/* if calling a function which doesn't exist *\/$/;"	e	enum:auto_event
EVENT_GUIENTER	vim.h	/^    EVENT_GUIENTER,		\/* after starting the GUI *\/$/;"	e	enum:auto_event
EVENT_REMOTEREPLY	vim.h	/^    EVENT_REMOTEREPLY,		\/* upon string reception from a remote vim *\/$/;"	e	enum:auto_event
EVENT_STDINREADPOST	vim.h	/^    EVENT_STDINREADPOST,	\/* after reading from stdin *\/$/;"	e	enum:auto_event
EVENT_STDINREADPRE	vim.h	/^    EVENT_STDINREADPRE,		\/* before reading from stdin *\/$/;"	e	enum:auto_event
EVENT_SYNTAX	vim.h	/^    EVENT_SYNTAX,		\/* syntax selected *\/$/;"	e	enum:auto_event
EVENT_T	vim.h	/^typedef enum auto_event EVENT_T;$/;"	t	typeref:enum:auto_event
EVENT_TERMCHANGED	vim.h	/^    EVENT_TERMCHANGED,		\/* after changing 'term' *\/$/;"	e	enum:auto_event
EVENT_TERMRESPONSE	vim.h	/^    EVENT_TERMRESPONSE,		\/* after setting "v:termresponse" *\/$/;"	e	enum:auto_event
EVENT_USER	vim.h	/^    EVENT_USER,			\/* user defined autocommand *\/$/;"	e	enum:auto_event
EVENT_VIMENTER	vim.h	/^    EVENT_VIMENTER,		\/* after starting Vim *\/$/;"	e	enum:auto_event
EVENT_VIMLEAVE	vim.h	/^    EVENT_VIMLEAVE,		\/* before exiting Vim *\/$/;"	e	enum:auto_event
EVENT_VIMLEAVEPRE	vim.h	/^    EVENT_VIMLEAVEPRE,		\/* before exiting Vim and writing .viminfo *\/$/;"	e	enum:auto_event
EVENT_WINENTER	vim.h	/^    EVENT_WINENTER,		\/* after entering a window *\/$/;"	e	enum:auto_event
EVENT_WINLEAVE	vim.h	/^    EVENT_WINLEAVE,		\/* before leaving a window *\/$/;"	e	enum:auto_event
EVIM_FILE	os_amiga.h	144;"	d
EW_ADDSLASH	vim.h	627;"	d
EW_DIR	vim.h	624;"	d
EW_FILE	vim.h	625;"	d
EW_KEEPALL	vim.h	628;"	d
EW_NOTFOUND	vim.h	626;"	d
EW_SILENT	vim.h	629;"	d
EX	ex_cmds.h	73;"	d
EX	ex_cmds.h	76;"	d
EXACTLY	regexp.c	137;"	d	file:
EXEC	testdir/test49.vim	/^function! EXEC(cmd)$/;"	f
EXMODE_NORMAL	vim.h	602;"	d
EXMODE_VIM	vim.h	603;"	d
EXPAND_AUGROUP	vim.h	583;"	d
EXPAND_BOOL_SETTINGS	vim.h	574;"	d
EXPAND_BUFFERS	vim.h	578;"	d
EXPAND_COLORS	vim.h	597;"	d
EXPAND_COMMANDS	vim.h	570;"	d
EXPAND_COMPILER	vim.h	598;"	d
EXPAND_DIRECTORIES	vim.h	572;"	d
EXPAND_ENV_VARS	vim.h	595;"	d
EXPAND_EVENTS	vim.h	579;"	d
EXPAND_EXPRESSION	vim.h	589;"	d
EXPAND_FILES	vim.h	571;"	d
EXPAND_FUNCTIONS	vim.h	587;"	d
EXPAND_HELP	vim.h	577;"	d
EXPAND_HIGHLIGHT	vim.h	582;"	d
EXPAND_LANGUAGE	vim.h	596;"	d
EXPAND_MAPPINGS	vim.h	585;"	d
EXPAND_MENUNAMES	vim.h	590;"	d
EXPAND_MENUS	vim.h	580;"	d
EXPAND_NOTHING	vim.h	569;"	d
EXPAND_OK	vim.h	568;"	d
EXPAND_OLD_SETTING	vim.h	576;"	d
EXPAND_SETTINGS	vim.h	573;"	d
EXPAND_SYNTAX	vim.h	581;"	d
EXPAND_TAGS	vim.h	575;"	d
EXPAND_TAGS_LISTFILES	vim.h	586;"	d
EXPAND_UNSUCCESSFUL	vim.h	567;"	d
EXPAND_USER_CMD_FLAGS	vim.h	592;"	d
EXPAND_USER_COMMANDS	vim.h	591;"	d
EXPAND_USER_COMPLETE	vim.h	594;"	d
EXPAND_USER_DEFINED	vim.h	599;"	d
EXPAND_USER_FUNC	vim.h	588;"	d
EXPAND_USER_NARGS	vim.h	593;"	d
EXPAND_USER_VARS	vim.h	584;"	d
EXPR	testdir/test49.vim	/^function! EXPR(x, n)$/;"	f
EXP_CASE	syntax.c	/^    EXP_CASE	    \/* expand ":syn case" arguments *\/$/;"	e	enum:__anon7	file:
EXP_SUBCMD	syntax.c	/^    EXP_SUBCMD,	    \/* expand ":syn" sub-commands *\/$/;"	e	enum:__anon7	file:
EXRC_FILE	os_amiga.h	164;"	d
EXTERN	main.c	14;"	d	file:
EXTERN	option.h	14;"	d
EXTERN	vim.h	1561;"	d
EXTERNCMD	vim.h	529;"	d
EXTRA	ex_cmds.h	35;"	d
EXTRASIZE	misc2.c	5391;"	d	file:
EXTRA_MARKS	mark.c	27;"	d	file:
Error	testdir/test49.vim	/^    function! Error()$/;"	f
EventHandler	gui_amiga.c	/^EventHandler(void)$/;"	f	file:
ExecAsScript	testdir/test49.vim	/^com! -nargs=1 -bar ExecAsScript call ExecAsScript(<f-args>)$/;"	c
ExecAsScript	testdir/test49.vim	/^function! ExecAsScript(funcname)$/;"	f
Exec_reg	globals.h	/^EXTERN int	Exec_reg INIT(= FALSE);	\/* TRUE when executing a register *\/$/;"	v
ExpandBufnames	buffer.c	/^ExpandBufnames(pat, num_file, file, options)$/;"	f
ExpandCleanup	ex_getln.c	/^ExpandCleanup(xp)$/;"	f
ExpandEscape	ex_getln.c	/^ExpandEscape(xp, str, numfiles, files, options)$/;"	f
ExpandFromContext	ex_getln.c	/^ExpandFromContext(xp, pat, num_file, file, options)$/;"	f	file:
ExpandGeneric	ex_getln.c	/^ExpandGeneric(xp, regmatch, num_file, file, func)$/;"	f
ExpandInit	ex_getln.c	/^ExpandInit(xp)$/;"	f
ExpandMappings	getchar.c	/^ExpandMappings(regmatch, num_file, file)$/;"	f
ExpandOldSetting	option.c	/^ExpandOldSetting(num_file, file)$/;"	f
ExpandOne	ex_getln.c	/^ExpandOne(xp, str, orig, options, mode)$/;"	f
ExpandRTDir	ex_getln.c	/^ExpandRTDir(pat, num_file, file, dirname)$/;"	f	file:
ExpandSettings	option.c	/^ExpandSettings(xp, regmatch, num_file, file)$/;"	f
ExpandUserDefined	ex_getln.c	/^ExpandUserDefined(xp, regmatch, num_file, file)$/;"	f	file:
ExtEdProtocolVersion	netbeans.c	/^static char *ExtEdProtocolVersion = "2.2";$/;"	v	file:
ExtraVim	testdir/test49.vim	/^    aug ExtraVim$/;"	a
ExtraVim	testdir/test49.vim	/^function! ExtraVim(...)$/;"	f
ExtraVimBase	testdir/test49.vim	/^let ExtraVimBase = expand("<sfile>")$/;"	v
ExtraVimCount	testdir/test49.vim	/^let ExtraVimCount = 0$/;"	v
ExtraVimTestEnv	testdir/test49.vim	/^let ExtraVimTestEnv = ""$/;"	v
ExtraVimThrowpoint	testdir/test49.vim	/^function! ExtraVimThrowpoint()$/;"	f
F	testdir/test49.vim	/^		    function F{ERR(t) + CONT(t)}$/;"	f
F	testdir/test49.vim	/^		    function F{ERR(t) + CONT(t)}()$/;"	f
F	testdir/test49.vim	/^		    function F{INT(t) + CONT(t)}$/;"	f
F	testdir/test49.vim	/^		    function F{THR(t) + CONT(t)}$/;"	f
F	testdir/test49.vim	/^		    function F{novar + CONT(t)}$/;"	f
F	testdir/test49.vim	/^		    function F{novar + CONT(t)}()$/;"	f
F	testdir/test49.vim	/^	function! F{EXPR("function-def", 2)}()$/;"	f
F	testdir/test49.vim	/^	function! F{EXPR("function-def-ok", 1)}()$/;"	f
F	testdir/test49.vim	/^	function! F{i}(i, arg)$/;"	f
F	testdir/test49.vim	/^    function F()$/;"	f
F	testdir/test49.vim	/^    function F{ERR(33) + CONT(33)}$/;"	f
F	testdir/test49.vim	/^    function F{ERRabort(42) + CONT(42)}$/;"	f
F	testdir/test49.vim	/^    function! F() abort$/;"	f
F	testdir/test49.vim	/^    function! F()$/;"	f
F	testdir/test49.vim	/^    function! F(jump)	" not executed as function, transformed to a script$/;"	f
F	testdir/test49.vim	/^    function! F(n)$/;"	f
F	testdir/test49.vim	/^    function! F(reason, n) abort$/;"	f
F	testdir/test49.vim	/^function! F() abort$/;"	f
F	testdir/test49.vim	/^function! F()$/;"	f
F	testdir/test49.vim	/^function! F(arg, line)$/;"	f
F	testdir/test49.vim	/^function! F(n)$/;"	f
F	testdir/test49.vim	/^function! F(x, n)$/;"	f
F	testdir/test49.vim	/^function! F(x, y, n)$/;"	f
F	testdir/test49.vim	/^function! F{1 + ERR() + OK()}(arg)$/;"	f
F0	testdir/test49.vim	/^	function F0$/;"	f
F0	testdir/test49.vim	/^	function! F0()$/;"	f
F0	testdir/test49.vim	/^function! F0()$/;"	f
F1	testdir/test49.vim	/^	    function! F1(arg)$/;"	f
F1	testdir/test49.vim	/^function! F1(arg)$/;"	f
F1	testdir/test49.vim	/^function! F1(arg1)$/;"	f
F2	testdir/test49.vim	/^function! F2(arg1, arg2)$/;"	f
FAIL	vim.h	544;"	d
FALSE	os_amiga.c	27;"	d	file:
FALSE	os_amiga.c	56;"	d	file:
FALSE	os_amiga.c	57;"	d	file:
FALSE	vim.h	1091;"	d
FARSI_0	farsi.h	91;"	d
FARSI_1	farsi.h	92;"	d
FARSI_2	farsi.h	93;"	d
FARSI_3	farsi.h	94;"	d
FARSI_4	farsi.h	95;"	d
FARSI_5	farsi.h	96;"	d
FARSI_6	farsi.h	97;"	d
FARSI_7	farsi.h	98;"	d
FARSI_8	farsi.h	99;"	d
FARSI_9	farsi.h	100;"	d
FCOL1	Make_agui.mak	/^FCOL1 = *e[31m$/;"	m
FCOL2	Make_agui.mak	/^FCOL2 = *e[32m$/;"	m
FCOL3	Make_agui.mak	/^FCOL3 = *e[33m$/;"	m
FCOL4	Make_agui.mak	/^FCOL4 = *e[34m$/;"	m
FC_ABORT	eval.c	98;"	d	file:
FC_RANGE	eval.c	99;"	d	file:
FDC_OFF	screen.c	1894;"	d	file:
FDO_ALL	option.h	434;"	d
FDO_BLOCK	option.h	435;"	d
FDO_HOR	option.h	436;"	d
FDO_INSERT	option.h	442;"	d
FDO_JUMP	option.h	444;"	d
FDO_MARK	option.h	437;"	d
FDO_PERCENT	option.h	438;"	d
FDO_QUICKFIX	option.h	439;"	d
FDO_SEARCH	option.h	440;"	d
FDO_TAG	option.h	441;"	d
FDO_UNDO	option.h	443;"	d
FD_CLOSED	fold.c	40;"	d	file:
FD_LEVEL	fold.c	41;"	d	file:
FD_OPEN	fold.c	39;"	d	file:
FE	farsi.h	133;"	d
FEAT_ARABIC	feature.h	323;"	d
FEAT_ARP	feature.h	1076;"	d
FEAT_AUTOCMD	feature.h	412;"	d
FEAT_BEVAL	feature.h	1149;"	d
FEAT_BEVAL_TIP	feature.h	1157;"	d
FEAT_BIG	feature.h	64;"	d
FEAT_BIG	feature.h	78;"	d
FEAT_BROWSE	feature.h	710;"	d
FEAT_BYTEOFF	feature.h	443;"	d
FEAT_CINDENT	feature.h	530;"	d
FEAT_CLIENTSERVER	feature.h	1038;"	d
FEAT_CLIPBOARD	feature.h	1005;"	d
FEAT_CLIPBOARD	feature.h	1017;"	d
FEAT_CLIPBOARD	feature.h	222;"	d
FEAT_CLIPBOARD	vim.h	121;"	d
FEAT_CMDHIST	feature.h	126;"	d
FEAT_CMDL_COMPL	feature.h	197;"	d
FEAT_CMDL_INFO	feature.h	244;"	d
FEAT_CMDL_INFO	feature.h	438;"	d
FEAT_CMDWIN	feature.h	138;"	d
FEAT_COMMENTS	feature.h	541;"	d
FEAT_CON_DIALOG	feature.h	728;"	d
FEAT_CRYPT	feature.h	548;"	d
FEAT_CSCOPE	feature.h	370;"	d
FEAT_CW_EDITOR	feature.h	748;"	d
FEAT_DIFF	feature.h	420;"	d
FEAT_DIGRAPHS	feature.h	156;"	d
FEAT_DND	feature.h	1025;"	d
FEAT_EMACS_TAGS	feature.h	336;"	d
FEAT_EVAL	feature.h	378;"	d
FEAT_EX_EXTRA	feature.h	258;"	d
FEAT_FIND_ID	feature.h	287;"	d
FEAT_FKMAP	feature.h	310;"	d
FEAT_FOLDING	feature.h	145;"	d
FEAT_FOOTER	feature.h	1182;"	d
FEAT_GETTEXT	feature.h	569;"	d
FEAT_GETTEXT	vim.h	395;"	d
FEAT_GUI	vim.h	93;"	d
FEAT_GUI_DIALOG	feature.h	729;"	d
FEAT_GUI_DIALOG	feature.h	737;"	d
FEAT_GUI_MAC	vim.h	79;"	d
FEAT_GUI_MSWIN	vim.h	98;"	d
FEAT_GUI_TEXTDIALOG	feature.h	743;"	d
FEAT_GUI_X11	gui.h	19;"	d
FEAT_GUI_X11	gui.h	24;"	d
FEAT_INS_EXPAND	feature.h	189;"	d
FEAT_JUMPLIST	feature.h	133;"	d
FEAT_KEYMAP	feature.h	174;"	d
FEAT_LANGMAP	feature.h	166;"	d
FEAT_LIBCALL	feature.h	661;"	d
FEAT_LINEBREAK	feature.h	251;"	d
FEAT_LISP	feature.h	526;"	d
FEAT_LISTCMDS	feature.h	109;"	d
FEAT_LOCALMAP	feature.h	181;"	d
FEAT_MAGIC_BRACES	eval.c	419;"	d	file:
FEAT_MBYTE	feature.h	582;"	d
FEAT_MBYTE	feature.h	595;"	d
FEAT_MBYTE_IME	vim.h	378;"	d
FEAT_MENU	feature.h	1167;"	d
FEAT_MENU	feature.h	675;"	d
FEAT_MENU	feature.h	700;"	d
FEAT_MODIFY_FNAME	feature.h	405;"	d
FEAT_MOUSE	feature.h	995;"	d
FEAT_MOUSESHAPE	feature.h	1062;"	d
FEAT_MOUSE_DEC	feature.h	974;"	d
FEAT_MOUSE_GPM	feature.h	985;"	d
FEAT_MOUSE_NET	feature.h	971;"	d
FEAT_MOUSE_PTERM	feature.h	980;"	d
FEAT_MOUSE_TTY	feature.h	992;"	d
FEAT_MOUSE_XTERM	feature.h	968;"	d
FEAT_MULTI_LANG	feature.h	565;"	d
FEAT_NETBEANS_INTG	feature.h	1120;"	d
FEAT_NORMAL	feature.h	69;"	d
FEAT_NORMAL	feature.h	81;"	d
FEAT_PATH_EXTRA	feature.h	295;"	d
FEAT_POSTSCRIPT	feature.h	398;"	d
FEAT_PRECOMMANDS	main.c	53;"	d	file:
FEAT_PRINTER	feature.h	394;"	d
FEAT_QUICKFIX	feature.h	272;"	d
FEAT_RIGHTLEFT	feature.h	302;"	d
FEAT_RIGHTLEFT	feature.h	314;"	d
FEAT_RIGHTLEFT	feature.h	327;"	d
FEAT_SCROLLBIND	feature.h	668;"	d
FEAT_SEARCHPATH	feature.h	279;"	d
FEAT_SEARCH_EXTRA	feature.h	265;"	d
FEAT_SESSION	feature.h	556;"	d
FEAT_SIGNS	feature.h	1129;"	d
FEAT_SIGN_ICONS	feature.h	1134;"	d
FEAT_SMALL	feature.h	67;"	d
FEAT_SMALL	feature.h	84;"	d
FEAT_SMARTINDENT	feature.h	534;"	d
FEAT_STL_OPT	feature.h	436;"	d
FEAT_SUN_WORKSHOP	feature.h	1110;"	d
FEAT_SYN_HL	feature.h	487;"	d
FEAT_TAG_BINS	feature.h	349;"	d
FEAT_TAG_OLDSTATIC	feature.h	357;"	d
FEAT_TEAROFF	feature.h	677;"	d
FEAT_TERMRESPONSE	feature.h	1047;"	d
FEAT_TEXTOBJ	feature.h	208;"	d
FEAT_TINY	feature.h	87;"	d
FEAT_TITLE	feature.h	432;"	d
FEAT_TOOLBAR	feature.h	697;"	d
FEAT_USR_CMDS	feature.h	385;"	d
FEAT_VERTSPLIT	feature.h	116;"	d
FEAT_VIMINFO	feature.h	477;"	d
FEAT_VIRTUALEDIT	feature.h	230;"	d
FEAT_VISUAL	feature.h	1007;"	d
FEAT_VISUAL	feature.h	216;"	d
FEAT_VISUALEXTRA	feature.h	218;"	d
FEAT_VREPLACE	feature.h	237;"	d
FEAT_WAK	option.h	776;"	d
FEAT_WILDIGN	feature.h	451;"	d
FEAT_WILDMENU	feature.h	458;"	d
FEAT_WINDOWS	feature.h	100;"	d
FEAT_WINDOWS	feature.h	119;"	d
FEAT_WRITEBACKUP	feature.h	768;"	d
FEAT_X11	vim.h	158;"	d
FEAT_XCLIPBOARD	feature.h	1015;"	d
FEAT_XFONTSET	feature.h	1152;"	d
FEAT_XFONTSET	feature.h	629;"	d
FEAT_XFONTSET	feature.h	646;"	d
FF	ascii.h	114;"	d
FF	ascii.h	30;"	d
FF	vim.h	1752;"	d
FF_DOS	option.h	52;"	d
FF_MAC	option.h	53;"	d
FF_MAX_STAR_STAR_EXPAND	misc2.c	3417;"	d	file:
FF_UNIX	option.h	54;"	d
FGETS_SIZE	fileio.c	5607;"	d	file:
FILE1	ex_cmds.h	58;"	d
FILES	ex_cmds.h	56;"	d
FILETYPE_FILE	os_amiga.h	106;"	d
FILE_SEP	xxd/xxd.c	166;"	d	file:
FILL_X	gui.h	114;"	d
FILL_X	gui.h	120;"	d
FILL_Y	gui.h	115;"	d
FILL_Y	gui.h	124;"	d
FIND_ANY	vim.h	657;"	d
FIND_DEFINE	vim.h	658;"	d
FIND_EVAL	vim.h	698;"	d
FIND_IDENT	vim.h	696;"	d
FIND_STRING	vim.h	697;"	d
FIO_ALL	fileio.c	93;"	d	file:
FIO_CODEPAGE	fileio.c	82;"	d	file:
FIO_ENCRYPTED	fileio.c	90;"	d	file:
FIO_ENDIAN_L	fileio.c	89;"	d	file:
FIO_GET_CP	fileio.c	84;"	d	file:
FIO_LATIN1	fileio.c	76;"	d	file:
FIO_MACROMAN	fileio.c	87;"	d	file:
FIO_NOCONVERT	fileio.c	91;"	d	file:
FIO_PUT_CP	fileio.c	83;"	d	file:
FIO_UCS2	fileio.c	78;"	d	file:
FIO_UCS4	fileio.c	79;"	d	file:
FIO_UCSBOM	fileio.c	92;"	d	file:
FIO_UTF16	fileio.c	80;"	d	file:
FIO_UTF8	fileio.c	77;"	d	file:
FIRST_KEYPAD	keymap.h	403;"	d
FIRST_NL	regexp.c	160;"	d	file:
FLEN_FIXED	eval.c	3100;"	d	file:
FMT_PATTERNS	quickfix.c	62;"	d	file:
FM_BACKWARD	vim.h	756;"	d
FM_BLOCKSTOP	vim.h	758;"	d
FM_FORWARD	vim.h	757;"	d
FM_SKIPCOMM	vim.h	759;"	d
FNAME	regexp.c	169;"	d	file:
FNAME_EXP	vim.h	702;"	d
FNAME_HYP	vim.h	703;"	d
FNAME_ILLEGAL	os_amiga.h	58;"	d
FNAME_INCL	vim.h	704;"	d
FNAME_MESS	vim.h	701;"	d
FNAME_REL	vim.h	705;"	d
FONTLEN	gui.c	631;"	d	file:
FONTSET_ALWAYS	gui.h	97;"	d
FORCE_BIN	ex_cmds.h	958;"	d
FORCE_NOBIN	ex_cmds.h	959;"	d
FORWARD	vim.h	534;"	d
FORWARD_FILE	vim.h	536;"	d
FOR_ALL_WINDOWS	globals.h	463;"	d
FOR_ALL_WINDOWS	globals.h	468;"	d
FO_ALL	option.h	115;"	d
FO_AUTO	option.h	111;"	d
FO_INS_BLANK	option.h	105;"	d
FO_INS_LONG	option.h	104;"	d
FO_INS_VI	option.h	103;"	d
FO_MBYTE_BREAK	option.h	106;"	d
FO_MBYTE_JOIN	option.h	107;"	d
FO_MBYTE_JOIN2	option.h	108;"	d
FO_ONE_LETTER	option.h	109;"	d
FO_OPEN_COMS	option.h	99;"	d
FO_Q_COMS	option.h	100;"	d
FO_Q_NUMBER	option.h	101;"	d
FO_Q_SECOND	option.h	102;"	d
FO_RET_COMS	option.h	98;"	d
FO_WHITE_PAR	option.h	110;"	d
FO_WRAP	option.h	96;"	d
FO_WRAP_COMS	option.h	97;"	d
FPC_DIFF	vim.h	794;"	d
FPC_DIFFX	vim.h	796;"	d
FPC_NOTX	vim.h	795;"	d
FPC_SAME	vim.h	793;"	d
FPC_SAMEX	vim.h	797;"	d
FRACTION_MULT	window.c	4142;"	d	file:
FRD_FINDNEXT	gui.h	516;"	d
FRD_MATCH_CASE	gui.h	524;"	d
FRD_REPLACE	gui.h	518;"	d
FRD_REPLACEALL	gui.h	519;"	d
FRD_R_FINDNEXT	gui.h	517;"	d
FRD_TYPE_MASK	gui.h	521;"	d
FRD_UNDO	gui.h	520;"	d
FRD_WHOLE_WORD	gui.h	523;"	d
FREE_FNAME	edit.c	73;"	d	file:
FR_COL	structs.h	1333;"	d
FR_LEAF	structs.h	1331;"	d
FR_ROW	structs.h	1332;"	d
FTOFF_FILE	os_amiga.h	115;"	d
FTPLUGIN_FILE	os_amiga.h	109;"	d
FTPLUGOF_FILE	os_amiga.h	118;"	d
FUNCARG	eval.c	107;"	d	file:
FUNCLINE	eval.c	108;"	d	file:
F_BCOMMA	farsi.h	86;"	d
F_BLANK	farsi.h	74;"	d
F_BSIZE	memfile.c	50;"	d	file:
F_BSIZE	memfile.c	56;"	d	file:
F_BSLASH	farsi.h	156;"	d
F_COMMA	farsi.h	81;"	d
F_CURRENCY	farsi.h	78;"	d
F_DCOLON	farsi.h	102;"	d
F_DIVIDE	farsi.h	88;"	d
F_EQUALS	farsi.h	105;"	d
F_EXCL	farsi.h	77;"	d
F_GREATER	farsi.h	104;"	d
F_HE	farsi.h	141;"	d
F_LBRACE	farsi.h	149;"	d
F_LBRACK	farsi.h	147;"	d
F_LESS	farsi.h	106;"	d
F_LPARENT	farsi.h	82;"	d
F_LQUOT	farsi.h	151;"	d
F_MINUS	farsi.h	87;"	d
F_MUL	farsi.h	84;"	d
F_PCN	farsi.h	76;"	d
F_PERCENT	farsi.h	79;"	d
F_PERIOD	farsi.h	80;"	d
F_PIPE	farsi.h	155;"	d
F_PLUS	farsi.h	85;"	d
F_PSP	farsi.h	75;"	d
F_QUESTION	farsi.h	107;"	d
F_RBRACE	farsi.h	150;"	d
F_RBRACK	farsi.h	148;"	d
F_RPARENT	farsi.h	83;"	d
F_RQUOT	farsi.h	152;"	d
F_SEMICOLON	farsi.h	103;"	d
F_SLASH	farsi.h	89;"	d
F_STAR	farsi.h	153;"	d
F_UNDERLINE	farsi.h	154;"	d
F_is_TyB_TyC_TyD	farsi.c	/^F_is_TyB_TyC_TyD(src, offset)$/;"	f	file:
F_is_TyC_TyD	farsi.c	/^F_is_TyC_TyD(c)$/;"	f	file:
F_is_TyE	farsi.c	/^F_is_TyE(c)$/;"	f	file:
F_isalpha	farsi.c	/^F_isalpha(c)$/;"	f
F_ischar	farsi.c	/^F_ischar(c)$/;"	f
F_isdigit	farsi.c	/^F_isdigit(c)$/;"	f
F_isterm	farsi.c	/^F_isterm(c)$/;"	f	file:
Foo	testdir/test49.vim	/^function! Foo()$/;"	f
FreeWild	misc1.c	/^FreeWild(count, files)$/;"	f
FullName_save	misc1.c	/^FullName_save(fname, force)$/;"	f
FuncException	testdir/test49.vim	/^function! FuncException()$/;"	f
FuncThrowpoint	testdir/test49.vim	/^function! FuncThrowpoint()$/;"	f
G	testdir/test49.vim	/^	    function! G{1 + ERR() + OK()}(arg)$/;"	f
G	testdir/test49.vim	/^    function! G() abort$/;"	f
G	testdir/test49.vim	/^    function! G()$/;"	f
G	testdir/test49.vim	/^    function! G(reason, n)$/;"	f
G	testdir/test49.vim	/^function! G()		" no abort attribute$/;"	f
G	testdir/test49.vim	/^function! G() abort$/;"	f
G	testdir/test49.vim	/^function! G()$/;"	f
G	testdir/test49.vim	/^function! G(arg, line)$/;"	f
G	testdir/test49.vim	/^function! G(x, y, n)$/;"	f
GAF	farsi.h	136;"	d
GAP	option.c	7241;"	d	file:
GAP	term.c	4997;"	d	file:
GARGCOUNT	structs.h	564;"	d
GARGLIST	structs.h	560;"	d
GA_CHAR	charset.c	408;"	d	file:
GA_EMPTY	structs.h	64;"	d
GA_PTR	charset.c	409;"	d	file:
GETF_ALT	vim.h	710;"	d
GETF_SETMARK	vim.h	709;"	d
GETF_SWITCH	vim.h	711;"	d
GET_CHARTAB	charset.c	28;"	d	file:
GHAF	farsi.h	134;"	d
GHAYN	farsi.h	132;"	d
GHAYN_	farsi.h	47;"	d
GLOBAL_WO	structs.h	1528;"	d
GOTO_COST	screen.c	6897;"	d	file:
GO_ALL	option.h	218;"	d
GO_ASEL	option.h	199;"	d
GO_ASELML	option.h	200;"	d
GO_BOT	option.h	201;"	d
GO_CONDIALOG	option.h	202;"	d
GO_FOOTER	option.h	216;"	d
GO_FORG	option.h	203;"	d
GO_GREY	option.h	204;"	d
GO_HORSCROLL	option.h	205;"	d
GO_ICON	option.h	206;"	d
GO_LEFT	option.h	207;"	d
GO_MENUS	option.h	209;"	d
GO_NOSYSMENU	option.h	210;"	d
GO_POINTER	option.h	211;"	d
GO_RIGHT	option.h	212;"	d
GO_TEAROFF	option.h	214;"	d
GO_TOOLBAR	option.h	215;"	d
GO_VERTICAL	option.h	217;"	d
GO_VLEFT	option.h	208;"	d
GO_VRIGHT	option.h	213;"	d
GSList	mbyte.c	4008;"	d	file:
GST	Make_agui.mak	/^GST=vim.gst$/;"	m
GST	Make_sas.mak	/^GST	= vim.gst$/;"	m
GUARDED	netbeans.c	60;"	d	file:
GUARDEDOFFSET	netbeans.c	61;"	d	file:
GUI_ATTR_ENTRY	syntax.c	7343;"	d	file:
GUI_BEVAL_H	gui_beval.h	11;"	d
GUI_MON_INVERT	gui.h	146;"	d
GUI_MON_IS_CURSOR	gui.h	147;"	d
GUI_MON_NOCLEAR	gui.h	149;"	d
GUI_MON_TRS_CURSOR	gui.h	148;"	d
GUI_MON_WRAP_CURSOR	gui.h	145;"	d
GVIM	Make_morph.mak	/^GVIM =$/;"	m
GVIMRC_FILE	os_amiga.h	172;"	d
GVIMSRC	Make_morph.mak	/^GVIMSRC =$/;"	m
Gadget2SInfo	gui_amiga.c	/^static struct PropInfo Gadget2SInfo = { AUTOKNOB+PROPBORDERLESS+FREEVERT+PROPNEWLOOK, 0, 0, MAXBODY, MAXBODY, };$/;"	v	typeref:struct:PropInfo	file:
GdkEvent	mbyte.c	/^   typedef int GdkEvent;$/;"	t	file:
GdkEvent	proto.h	28;"	d
GdkEventKey	mbyte.c	/^   typedef int GdkEventKey;$/;"	t	file:
GdkEventKey	proto.h	29;"	d
GdkIC	mbyte.c	/^typedef int GdkIC;$/;"	t	file:
GdkIC	mbyte.c	4012;"	d	file:
Gui	gui.h	/^typedef struct Gui$/;"	s
GuiFont	gui.h	/^  typedef GdkFont	*GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef PangoFontDescription	*GuiFont;       \/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef XFontStruct	*GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFont	gui.h	/^  typedef char		*GuiFont;$/;"	t
GuiFont	gui.h	/^  typedef long_u	GuiFont;	\/* handle for a GUI font *\/$/;"	t
GuiFontset	gui.h	/^  typedef GdkFont	*GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef PangoFontDescription  *GuiFontset;    \/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef XFontSet	GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiFontset	gui.h	/^  typedef char		*GuiFontset;$/;"	t
GuiFontset	gui.h	/^  typedef long_u	GuiFontset;	\/* handle for a GUI fontset *\/$/;"	t
GuiScrollbar	gui.h	/^typedef struct GuiScrollbar$/;"	s
H	testdir/test49.vim	/^function H()$/;"	f
H	testdir/test49.vim	/^function! H() abort$/;"	f
H	testdir/test49.vim	/^function! H()$/;"	f
HAMZE	farsi.h	111;"	d
HANGUL_DEFAULT_KEYBOARD	feature.h	624;"	d
HASLOOKBH	regexp.c	358;"	d	file:
HASNL	regexp.c	357;"	d	file:
HASWIDTH	regexp.c	354;"	d	file:
HAS_BW_FLAGS	fileio.c	75;"	d	file:
HAS_HOTKEY_LEN	message.c	2813;"	d	file:
HAVE_AVAIL_MEM	os_amiga.h	17;"	d
HAVE_BUFLIST_MATCH	buffer.c	33;"	d	file:
HAVE_DATE_TIME	os_amiga.h	34;"	d
HAVE_DROP_FILE	gui.h	89;"	d
HAVE_FCHDIR	vim.h	48;"	d
HAVE_FCNTL_H	os_amiga.h	25;"	d
HAVE_ISSYMLINK	vim.h	1704;"	d
HAVE_MEMSET	os_amiga.h	31;"	d
HAVE_PATHDEF	vim.h	32;"	d
HAVE_QSORT	os_amiga.h	32;"	d
HAVE_SANDBOX	globals.h	526;"	d
HAVE_SETENV	os_amiga.h	30;"	d
HAVE_SETENV	vim.h	247;"	d
HAVE_STAT_H	os_amiga.h	21;"	d
HAVE_STDLIB_H	os_amiga.h	23;"	d
HAVE_STRCSPN	os_amiga.h	26;"	d
HAVE_STRFTIME	os_amiga.h	29;"	d
HAVE_STRICMP	os_amiga.h	27;"	d
HAVE_STRING_H	os_amiga.h	24;"	d
HAVE_STRNICMP	os_amiga.h	28;"	d
HAVE_XPM	feature.h	684;"	d
HEAD	regexp.c	183;"	d	file:
HEADER_SIZE	memline.c	126;"	d	file:
HEX	regexp.c	177;"	d	file:
HEX_BITS	xxd/xxd.c	214;"	d	file:
HEX_CINCLUDE	xxd/xxd.c	213;"	d	file:
HEX_NORMAL	xxd/xxd.c	211;"	d	file:
HEX_POSTSCRIPT	xxd/xxd.c	212;"	d	file:
HE_J	farsi.h	118;"	d
HIGHL_COST	screen.c	6898;"	d	file:
HINSTANCE	mbyte.c	3072;"	d	file:
HINT_DEL_CHAR	vim.h	452;"	d
HINT_INS_CHAR	vim.h	453;"	d
HINT_NONE	vim.h	451;"	d
HIST_CMD	vim.h	862;"	d
HIST_COUNT	vim.h	867;"	d
HIST_DEBUG	vim.h	866;"	d
HIST_EXPR	vim.h	864;"	d
HIST_INPUT	vim.h	865;"	d
HIST_SEARCH	vim.h	863;"	d
HITRETURN	vim.h	525;"	d
HLF_8	vim.h	/^    HLF_8 = 0	    \/* Meta & special keys listed with ":map", text that is$/;"	e	enum:hlf_value
HLF_ADD	vim.h	/^    , HLF_ADD	    \/* Added diff line *\/$/;"	e	enum:hlf_value
HLF_AT	vim.h	/^    , HLF_AT	    \/* @ and ~ characters at end of screen, characters that$/;"	e	enum:hlf_value
HLF_C	vim.h	/^    , HLF_C	    \/* column to separate vertically split windows *\/$/;"	e	enum:hlf_value
HLF_CHD	vim.h	/^    , HLF_CHD	    \/* Changed diff line *\/$/;"	e	enum:hlf_value
HLF_CM	vim.h	/^    , HLF_CM	    \/* Mode (e.g., "-- INSERT --") *\/$/;"	e	enum:hlf_value
HLF_COUNT	vim.h	/^    , HLF_COUNT	    \/* MUST be the last one *\/$/;"	e	enum:hlf_value
HLF_D	vim.h	/^    , HLF_D	    \/* directories in CTRL-D listing *\/$/;"	e	enum:hlf_value
HLF_DED	vim.h	/^    , HLF_DED	    \/* Deleted diff line *\/$/;"	e	enum:hlf_value
HLF_E	vim.h	/^    , HLF_E	    \/* error messages *\/$/;"	e	enum:hlf_value
HLF_FC	vim.h	/^    , HLF_FC	    \/* Fold column *\/$/;"	e	enum:hlf_value
HLF_FL	vim.h	/^    , HLF_FL	    \/* Folded line *\/$/;"	e	enum:hlf_value
HLF_H	vim.h	/^    , HLF_H	    \/* obsolete, ignored *\/$/;"	e	enum:hlf_value
HLF_I	vim.h	/^    , HLF_I	    \/* incremental search *\/$/;"	e	enum:hlf_value
HLF_L	vim.h	/^    , HLF_L	    \/* last search string *\/$/;"	e	enum:hlf_value
HLF_M	vim.h	/^    , HLF_M	    \/* "--More--" message *\/$/;"	e	enum:hlf_value
HLF_N	vim.h	/^    , HLF_N	    \/* line number for ":number" and ":#" commands *\/$/;"	e	enum:hlf_value
HLF_R	vim.h	/^    , HLF_R	    \/* return to continue message and yes\/no questions *\/$/;"	e	enum:hlf_value
HLF_S	vim.h	/^    , HLF_S	    \/* status lines *\/$/;"	e	enum:hlf_value
HLF_SC	vim.h	/^    , HLF_SC	    \/* Sign column *\/$/;"	e	enum:hlf_value
HLF_SNC	vim.h	/^    , HLF_SNC	    \/* status lines of not-current windows *\/$/;"	e	enum:hlf_value
HLF_T	vim.h	/^    , HLF_T	    \/* Titles for output from ":set all", ":autocmd" etc. *\/$/;"	e	enum:hlf_value
HLF_TXD	vim.h	/^    , HLF_TXD	    \/* Text Changed in diff line *\/$/;"	e	enum:hlf_value
HLF_V	vim.h	/^    , HLF_V	    \/* Visual mode *\/$/;"	e	enum:hlf_value
HLF_VNC	vim.h	/^    , HLF_VNC	    \/* Visual mode, autoselecting and not clipboard owner *\/$/;"	e	enum:hlf_value
HLF_W	vim.h	/^    , HLF_W	    \/* warning messages *\/$/;"	e	enum:hlf_value
HLF_WM	vim.h	/^    , HLF_WM	    \/* Wildmenu highlight *\/$/;"	e	enum:hlf_value
HL_ALL	vim.h	493;"	d
HL_BOLD	vim.h	489;"	d
HL_CONTAINED	syntax.c	161;"	d	file:
HL_DISPLAY	syntax.c	173;"	d	file:
HL_EXCLUDENL	syntax.c	172;"	d	file:
HL_EXTEND	syntax.c	175;"	d	file:
HL_FLAGS	vim.h	1083;"	d
HL_FOLD	syntax.c	174;"	d	file:
HL_HAS_EOL	syntax.c	164;"	d	file:
HL_INVERSE	vim.h	488;"	d
HL_ITALIC	vim.h	490;"	d
HL_KEEPEND	syntax.c	171;"	d	file:
HL_MATCH	syntax.c	167;"	d	file:
HL_MATCHCONT	syntax.c	178;"	d	file:
HL_NORMAL	vim.h	487;"	d
HL_ONELINE	syntax.c	163;"	d	file:
HL_SKIPEMPTY	syntax.c	170;"	d	file:
HL_SKIPNL	syntax.c	168;"	d	file:
HL_SKIPWHITE	syntax.c	169;"	d	file:
HL_STANDOUT	vim.h	492;"	d
HL_SYNC_HERE	syntax.c	165;"	d	file:
HL_SYNC_THERE	syntax.c	166;"	d	file:
HL_TABLE	syntax.c	61;"	d	file:
HL_TRANSP	syntax.c	162;"	d	file:
HL_TRANS_CONT	syntax.c	179;"	d	file:
HL_UNDERLINE	vim.h	491;"	d
HMT_DEC	term.c	2046;"	d	file:
HMT_JSBTERM	term.c	2047;"	d	file:
HMT_NETTERM	term.c	2045;"	d	file:
HMT_NORMAL	term.c	2044;"	d	file:
HMT_PTERM	term.c	2048;"	d	file:
HOTK_LEN	message.c	2803;"	d	file:
HWND	globals.h	/^typedef int HWND;$/;"	t
I	testdir/test49.vim	/^    function I()$/;"	f
I	testdir/test49.vim	/^    function! I(jump)$/;"	f
I	testdir/test49.vim	/^function! I() abort$/;"	f
I	testdir/test49.vim	/^function! I()$/;"	f
ICONV_E2BIG	vim.h	1689;"	d
ICONV_E2BIG	vim.h	1694;"	d
ICONV_EILSEQ	vim.h	1691;"	d
ICONV_EILSEQ	vim.h	1696;"	d
ICONV_EINVAL	vim.h	1690;"	d
ICONV_EINVAL	vim.h	1695;"	d
ICONV_ERRNO	vim.h	1688;"	d
ICONV_ERRNO	vim.h	1693;"	d
ICONV_MULT	fileio.c	102;"	d	file:
ICONV_TESTLEN	mbyte.c	2924;"	d	file:
IDENT	regexp.c	165;"	d	file:
IDX_BIG5	mbyte.c	258;"	d	file:
IDX_COUNT	mbyte.c	264;"	d	file:
IDX_CP1251	mbyte.c	260;"	d	file:
IDX_CP1255	mbyte.c	204;"	d	file:
IDX_CP932	mbyte.c	240;"	d	file:
IDX_CP936	mbyte.c	244;"	d	file:
IDX_CP949	mbyte.c	242;"	d	file:
IDX_CP950	mbyte.c	246;"	d	file:
IDX_DEBUG	mbyte.c	238;"	d	file:
IDX_EUC_CN	mbyte.c	254;"	d	file:
IDX_EUC_JP	mbyte.c	248;"	d	file:
IDX_EUC_KR	mbyte.c	252;"	d	file:
IDX_EUC_TW	mbyte.c	256;"	d	file:
IDX_ISO_10	mbyte.c	210;"	d	file:
IDX_ISO_11	mbyte.c	212;"	d	file:
IDX_ISO_13	mbyte.c	214;"	d	file:
IDX_ISO_14	mbyte.c	216;"	d	file:
IDX_ISO_15	mbyte.c	218;"	d	file:
IDX_ISO_2	mbyte.c	192;"	d	file:
IDX_ISO_3	mbyte.c	194;"	d	file:
IDX_ISO_4	mbyte.c	196;"	d	file:
IDX_ISO_5	mbyte.c	198;"	d	file:
IDX_ISO_6	mbyte.c	200;"	d	file:
IDX_ISO_7	mbyte.c	202;"	d	file:
IDX_ISO_8	mbyte.c	206;"	d	file:
IDX_ISO_9	mbyte.c	208;"	d	file:
IDX_KOI8_R	mbyte.c	220;"	d	file:
IDX_KOI8_U	mbyte.c	222;"	d	file:
IDX_LATIN_1	mbyte.c	190;"	d	file:
IDX_MACROMAN	mbyte.c	262;"	d	file:
IDX_SJIS	mbyte.c	250;"	d	file:
IDX_UCS2	mbyte.c	226;"	d	file:
IDX_UCS2LE	mbyte.c	228;"	d	file:
IDX_UCS4	mbyte.c	234;"	d	file:
IDX_UCS4LE	mbyte.c	236;"	d	file:
IDX_UTF16	mbyte.c	230;"	d	file:
IDX_UTF16LE	mbyte.c	232;"	d	file:
IDX_UTF8	mbyte.c	224;"	d	file:
ID_LIST_ALL	syntax.c	289;"	d	file:
IE	farsi.h	61;"	d
IE_	farsi.h	60;"	d
IF_EB	ascii.h	17;"	d
IF_EB	ascii.h	90;"	d
IMLEN_MAX	mbyte.c	4721;"	d	file:
INBUFLEN	ui.c	1480;"	d	file:
INBUFLEN	ui.c	1482;"	d	file:
INC	option.c	7240;"	d	file:
INC	term.c	4996;"	d	file:
INCL	Make_manx.mak	/^INCL = vim.h feature.h keymap.h macros.h ascii.h term.h structs.h os_amiga.h$/;"	m
INCSTACK_SIZE	tag.c	1146;"	d	file:
INDENT_DEC	vim.h	753;"	d
INDENT_FILE	os_amiga.h	112;"	d
INDENT_INC	vim.h	752;"	d
INDENT_SET	vim.h	751;"	d
INDEX_SIZE	memline.c	125;"	d	file:
INDOFF_FILE	os_amiga.h	121;"	d
INET_SOCKETS	netbeans.c	58;"	d	file:
INIT	option.h	15;"	d
INIT	option.h	18;"	d
INIT	vim.h	1562;"	d
INIT	vim.h	1565;"	d
INIT_POS_T	structs.h	36;"	d
INIT_POS_T	structs.h	38;"	d
INPUT_BUFLEN	edit.c	4285;"	d	file:
INSCHAR_CTRLV	vim.h	851;"	d
INSCHAR_DO_COM	vim.h	850;"	d
INSCHAR_FORMAT	vim.h	849;"	d
INSERT	vim.h	511;"	d
INT	testdir/test49.vim	/^    function! INT()$/;"	f
INT	testdir/test49.vim	/^    function! INT(n)$/;"	f
INVALCOLOR	gui.h	230;"	d
INVALID_STATE	syntax.c	314;"	d	file:
INVERTED	vim.h	442;"	d
INVERTED_ALL	vim.h	443;"	d
IN_BUFFER	vim.h	1420;"	d
IN_OPTION_C	option.c	34;"	d	file:
IN_OTHER_WIN	vim.h	1423;"	d
IN_SEP_LINE	vim.h	1422;"	d
IN_STATUS_LINE	vim.h	1421;"	d
IN_UNKNOWN	vim.h	1419;"	d
IOSIZE	vim.h	1157;"	d
IObuff	globals.h	/^EXTERN char_u	*IObuff;		\/* sprintf's are done in this buffer,$/;"	v
ISSPECIAL	edit.c	3842;"	d	file:
ISSPECIAL	edit.c	3844;"	d	file:
ISSYMLINK	vim.h	1706;"	d
ISSYMLINK	vim.h	1708;"	d
IS_NONPRINTABLE	gui_beval.c	815;"	d	file:
IS_NONPRINTABLE	gui_beval.c	953;"	d	file:
IS_SPECIAL	keymap.h	37;"	d
ITALIC	Make_agui.mak	/^ITALIC = *e[3m$/;"	m
ITEM_END	syntax.c	4552;"	d	file:
ITEM_MATCHGROUP	syntax.c	4553;"	d	file:
ITEM_SKIP	syntax.c	4551;"	d	file:
ITEM_START	syntax.c	4550;"	d	file:
Insstart	globals.h	/^EXTERN pos_T	Insstart;		\/* This is where the latest$/;"	v
Insstart_blank_vcol	edit.c	/^static colnr_T	Insstart_blank_vcol;	\/* vcol for first inserted blank *\/$/;"	v	file:
Insstart_textlen	edit.c	/^static colnr_T	Insstart_textlen;	\/* length of line when insert started *\/$/;"	v	file:
Interrupt	testdir/test49.vim	/^    function! Interrupt()$/;"	f
IntuitionBase	os_amiga.c	/^struct IntuitionBase	*IntuitionBase = NULL;$/;"	v	typeref:struct:IntuitionBase
J	testdir/test49.vim	/^function! J()$/;"	f
JAZR	farsi.h	159;"	d
JAZR_N	farsi.h	162;"	d
JE	farsi.h	124;"	d
JIM	farsi.h	116;"	d
JUMPLISTSIZE	structs.h	98;"	d
JUST_CALC_SIZE	regexp.c	365;"	d	file:
K	testdir/test49.vim	/^function! K()$/;"	f
KAF	farsi.h	135;"	d
KEEP_ROOM	misc2.c	729;"	d	file:
KEEP_ROOM	misc2.c	731;"	d	file:
KEY2TERMCAP0	keymap.h	113;"	d
KEY2TERMCAP1	keymap.h	114;"	d
KEYBACKSPACE	gui_amiga.c	41;"	d	file:
KEYDELETE	gui_amiga.c	42;"	d	file:
KEYDOWN	gui_amiga.c	38;"	d	file:
KEYEND	gui_amiga.c	45;"	d	file:
KEYHOME	gui_amiga.c	44;"	d	file:
KEYINSERT	gui_amiga.c	43;"	d	file:
KEYLEFT	gui_amiga.c	40;"	d	file:
KEYMAP_INIT	structs.h	1064;"	d
KEYMAP_LOADED	structs.h	1065;"	d
KEYRIGHT	gui_amiga.c	39;"	d	file:
KEYUP	gui_amiga.c	37;"	d	file:
KEYWHEELDOWN	gui_amiga.c	47;"	d	file:
KEYWHEELUP	gui_amiga.c	46;"	d	file:
KEYWORD_IDX	syntax.c	288;"	d	file:
KEY_COMPLETE	vim.h	721;"	d
KEY_NAMES_TABLE_LEN	misc2.c	1919;"	d	file:
KEY_OPEN_BACK	vim.h	720;"	d
KEY_OPEN_FORW	vim.h	719;"	d
KE_CMDWIN	keymap.h	/^    , KE_CMDWIN		\/* open command-line window from Command-line Mode *\/$/;"	e	enum:key_extra
KE_CSI	keymap.h	/^    , KE_CSI		\/* CSI typed directly *\/$/;"	e	enum:key_extra
KE_C_END	keymap.h	/^    , KE_C_END		\/* control-end *\/$/;"	e	enum:key_extra
KE_C_HOME	keymap.h	/^    , KE_C_HOME		\/* control-home *\/$/;"	e	enum:key_extra
KE_C_LEFT	keymap.h	/^    , KE_C_LEFT		\/* control-left *\/$/;"	e	enum:key_extra
KE_C_RIGHT	keymap.h	/^    , KE_C_RIGHT	\/* control-right *\/$/;"	e	enum:key_extra
KE_DROP	keymap.h	/^    , KE_DROP		\/* DnD data is available *\/$/;"	e	enum:key_extra
KE_FILLER	keymap.h	107;"	d
KE_IGNORE	keymap.h	/^    , KE_IGNORE		\/* Ignored mouse drag\/release *\/$/;"	e	enum:key_extra
KE_KDEL	keymap.h	/^    , KE_KDEL		\/* keypad Delete key *\/$/;"	e	enum:key_extra
KE_KINS	keymap.h	/^    , KE_KINS		\/* keypad Insert key *\/$/;"	e	enum:key_extra
KE_LEFTDRAG	keymap.h	/^    , KE_LEFTDRAG	\/* Drag with left mouse button down *\/$/;"	e	enum:key_extra
KE_LEFTMOUSE	keymap.h	/^    , KE_LEFTMOUSE	\/* Left mouse button click *\/$/;"	e	enum:key_extra
KE_LEFTMOUSE_NM	keymap.h	/^    , KE_LEFTMOUSE_NM	\/* non-mappable Left mouse button click *\/$/;"	e	enum:key_extra
KE_LEFTRELEASE	keymap.h	/^    , KE_LEFTRELEASE	\/* Left mouse button release *\/$/;"	e	enum:key_extra
KE_LEFTRELEASE_NM	keymap.h	/^    , KE_LEFTRELEASE_NM	\/* non-mappable left mouse button release *\/$/;"	e	enum:key_extra
KE_MIDDLEDRAG	keymap.h	/^    , KE_MIDDLEDRAG	\/* Drag with middle mouse button down *\/$/;"	e	enum:key_extra
KE_MIDDLEMOUSE	keymap.h	/^    , KE_MIDDLEMOUSE	\/* Middle mouse button click *\/$/;"	e	enum:key_extra
KE_MIDDLERELEASE	keymap.h	/^    , KE_MIDDLERELEASE	\/* Middle mouse button release *\/$/;"	e	enum:key_extra
KE_MOUSE	keymap.h	/^    , KE_MOUSE		\/* mouse event start *\/$/;"	e	enum:key_extra
KE_MOUSEDOWN	keymap.h	/^    , KE_MOUSEDOWN	\/* scroll wheel pseudo-button Down *\/$/;"	e	enum:key_extra
KE_MOUSEUP	keymap.h	/^    , KE_MOUSEUP		\/* scroll wheel pseudo-button Up *\/$/;"	e	enum:key_extra
KE_NAME	keymap.h	/^    KE_NAME = 3		\/* name of this terminal entry *\/$/;"	e	enum:key_extra
KE_PLUG	keymap.h	/^    , KE_PLUG		\/* <Plug> *\/$/;"	e	enum:key_extra
KE_RIGHTDRAG	keymap.h	/^    , KE_RIGHTDRAG	\/* Drag with right mouse button down *\/$/;"	e	enum:key_extra
KE_RIGHTMOUSE	keymap.h	/^    , KE_RIGHTMOUSE	\/* Right mouse button click *\/$/;"	e	enum:key_extra
KE_RIGHTRELEASE	keymap.h	/^    , KE_RIGHTRELEASE	\/* Right mouse button release *\/$/;"	e	enum:key_extra
KE_SNIFF	keymap.h	/^    , KE_SNIFF		\/* SNiFF+ input waiting *\/$/;"	e	enum:key_extra
KE_SNR	keymap.h	/^    , KE_SNR		\/* <SNR> *\/$/;"	e	enum:key_extra
KE_S_DOWN	keymap.h	/^    , KE_S_DOWN		\/* shift-down *\/$/;"	e	enum:key_extra
KE_S_F1	keymap.h	/^    , KE_S_F1		\/* shifted function keys *\/$/;"	e	enum:key_extra
KE_S_F10	keymap.h	/^    , KE_S_F10$/;"	e	enum:key_extra
KE_S_F11	keymap.h	/^    , KE_S_F11$/;"	e	enum:key_extra
KE_S_F12	keymap.h	/^    , KE_S_F12$/;"	e	enum:key_extra
KE_S_F13	keymap.h	/^    , KE_S_F13$/;"	e	enum:key_extra
KE_S_F14	keymap.h	/^    , KE_S_F14$/;"	e	enum:key_extra
KE_S_F15	keymap.h	/^    , KE_S_F15$/;"	e	enum:key_extra
KE_S_F16	keymap.h	/^    , KE_S_F16$/;"	e	enum:key_extra
KE_S_F17	keymap.h	/^    , KE_S_F17$/;"	e	enum:key_extra
KE_S_F18	keymap.h	/^    , KE_S_F18$/;"	e	enum:key_extra
KE_S_F19	keymap.h	/^    , KE_S_F19$/;"	e	enum:key_extra
KE_S_F2	keymap.h	/^    , KE_S_F2$/;"	e	enum:key_extra
KE_S_F20	keymap.h	/^    , KE_S_F20$/;"	e	enum:key_extra
KE_S_F21	keymap.h	/^    , KE_S_F21$/;"	e	enum:key_extra
KE_S_F22	keymap.h	/^    , KE_S_F22$/;"	e	enum:key_extra
KE_S_F23	keymap.h	/^    , KE_S_F23$/;"	e	enum:key_extra
KE_S_F24	keymap.h	/^    , KE_S_F24$/;"	e	enum:key_extra
KE_S_F25	keymap.h	/^    , KE_S_F25$/;"	e	enum:key_extra
KE_S_F26	keymap.h	/^    , KE_S_F26$/;"	e	enum:key_extra
KE_S_F27	keymap.h	/^    , KE_S_F27$/;"	e	enum:key_extra
KE_S_F28	keymap.h	/^    , KE_S_F28$/;"	e	enum:key_extra
KE_S_F29	keymap.h	/^    , KE_S_F29$/;"	e	enum:key_extra
KE_S_F3	keymap.h	/^    , KE_S_F3$/;"	e	enum:key_extra
KE_S_F30	keymap.h	/^    , KE_S_F30$/;"	e	enum:key_extra
KE_S_F31	keymap.h	/^    , KE_S_F31$/;"	e	enum:key_extra
KE_S_F32	keymap.h	/^    , KE_S_F32$/;"	e	enum:key_extra
KE_S_F33	keymap.h	/^    , KE_S_F33$/;"	e	enum:key_extra
KE_S_F34	keymap.h	/^    , KE_S_F34$/;"	e	enum:key_extra
KE_S_F35	keymap.h	/^    , KE_S_F35$/;"	e	enum:key_extra
KE_S_F36	keymap.h	/^    , KE_S_F36$/;"	e	enum:key_extra
KE_S_F37	keymap.h	/^    , KE_S_F37$/;"	e	enum:key_extra
KE_S_F4	keymap.h	/^    , KE_S_F4$/;"	e	enum:key_extra
KE_S_F5	keymap.h	/^    , KE_S_F5$/;"	e	enum:key_extra
KE_S_F6	keymap.h	/^    , KE_S_F6$/;"	e	enum:key_extra
KE_S_F7	keymap.h	/^    , KE_S_F7$/;"	e	enum:key_extra
KE_S_F8	keymap.h	/^    , KE_S_F8$/;"	e	enum:key_extra
KE_S_F9	keymap.h	/^    , KE_S_F9$/;"	e	enum:key_extra
KE_S_TAB_OLD	keymap.h	/^    , KE_S_TAB_OLD	\/* shifted TAB key (no longer used) *\/$/;"	e	enum:key_extra
KE_S_UP	keymap.h	/^    , KE_S_UP		\/* shift-up *\/$/;"	e	enum:key_extra
KE_S_XF1	keymap.h	/^    , KE_S_XF1		\/* extra vt100 shifted function keys for xterm *\/$/;"	e	enum:key_extra
KE_S_XF2	keymap.h	/^    , KE_S_XF2$/;"	e	enum:key_extra
KE_S_XF3	keymap.h	/^    , KE_S_XF3$/;"	e	enum:key_extra
KE_S_XF4	keymap.h	/^    , KE_S_XF4$/;"	e	enum:key_extra
KE_TAB	keymap.h	/^    , KE_TAB		\/* unshifted TAB key *\/$/;"	e	enum:key_extra
KE_X1DRAG	keymap.h	/^    , KE_X1DRAG$/;"	e	enum:key_extra
KE_X1MOUSE	keymap.h	/^    , KE_X1MOUSE	\/* X1\/X2 mouse-buttons *\/$/;"	e	enum:key_extra
KE_X1RELEASE	keymap.h	/^    , KE_X1RELEASE$/;"	e	enum:key_extra
KE_X2DRAG	keymap.h	/^    , KE_X2DRAG$/;"	e	enum:key_extra
KE_X2MOUSE	keymap.h	/^    , KE_X2MOUSE$/;"	e	enum:key_extra
KE_X2RELEASE	keymap.h	/^    , KE_X2RELEASE$/;"	e	enum:key_extra
KE_XEND	keymap.h	/^    , KE_XEND		\/* extra (vt100) end key for xterm *\/$/;"	e	enum:key_extra
KE_XF1	keymap.h	/^    , KE_XF1		\/* extra vt100 function keys for xterm *\/$/;"	e	enum:key_extra
KE_XF2	keymap.h	/^    , KE_XF2$/;"	e	enum:key_extra
KE_XF3	keymap.h	/^    , KE_XF3$/;"	e	enum:key_extra
KE_XF4	keymap.h	/^    , KE_XF4$/;"	e	enum:key_extra
KE_XHOME	keymap.h	/^    , KE_XHOME		\/* extra (vt100) home key for xterm *\/$/;"	e	enum:key_extra
KHASH_MASK	syntax.c	198;"	d	file:
KHASH_SIZE	syntax.c	197;"	d	file:
KL_PART_KEY	getchar.c	1426;"	d	file:
KL_PART_MAP	getchar.c	1427;"	d	file:
KMAP_LLEN	digraph.c	2405;"	d	file:
KMAP_MAXLEN	digraph.c	2343;"	d	file:
KS_AL	term.h	/^    KS_AL,	\/* add new blank line *\/$/;"	e	enum:SpecialKey
KS_BC	term.h	/^    KS_BC,	\/* backspace character (cursor left) *\/$/;"	e	enum:SpecialKey
KS_CAB	term.h	/^    KS_CAB,	\/* set background color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAF	term.h	/^    KS_CAF,	\/* set foreground color (ANSI) *\/$/;"	e	enum:SpecialKey
KS_CAL	term.h	/^    KS_CAL,	\/* add number of blank lines *\/$/;"	e	enum:SpecialKey
KS_CCO	term.h	/^    KS_CCO,	\/* number of colors *\/$/;"	e	enum:SpecialKey
KS_CCS	term.h	/^    KS_CCS,	\/* cur is relative to scroll region *\/$/;"	e	enum:SpecialKey
KS_CD	term.h	/^    KS_CD,	\/* clear to end of display *\/$/;"	e	enum:SpecialKey
KS_CDL	term.h	/^    KS_CDL,	\/* delete number of lines *\/$/;"	e	enum:SpecialKey
KS_CE	term.h	/^    KS_CE,	\/* clear to end of line *\/$/;"	e	enum:SpecialKey
KS_CIE	term.h	/^    KS_CIE,	\/* set icon text end *\/$/;"	e	enum:SpecialKey
KS_CIS	term.h	/^    KS_CIS,	\/* set icon text start *\/$/;"	e	enum:SpecialKey
KS_CL	term.h	/^    KS_CL,	\/* clear screen *\/$/;"	e	enum:SpecialKey
KS_CM	term.h	/^    KS_CM,	\/* cursor motion *\/$/;"	e	enum:SpecialKey
KS_CRI	term.h	/^    KS_CRI,	\/* cursor number of chars right *\/$/;"	e	enum:SpecialKey
KS_CRV	term.h	/^    KS_CRV,	\/* request version string *\/$/;"	e	enum:SpecialKey
KS_CS	term.h	/^    KS_CS,	\/* scroll region *\/$/;"	e	enum:SpecialKey
KS_CSB	term.h	/^    KS_CSB,	\/* set background color *\/$/;"	e	enum:SpecialKey
KS_CSF	term.h	/^    KS_CSF,	\/* set foreground color *\/$/;"	e	enum:SpecialKey
KS_CSV	term.h	/^    KS_CSV,	\/* scroll region vertical *\/$/;"	e	enum:SpecialKey
KS_CWP	term.h	/^    KS_CWP,	\/* set window position in pixels *\/$/;"	e	enum:SpecialKey
KS_CWS	term.h	/^    KS_CWS,	\/* set window size in characters *\/$/;"	e	enum:SpecialKey
KS_CZH	term.h	/^    KS_CZH,	\/* italic mode start *\/$/;"	e	enum:SpecialKey
KS_CZR	term.h	/^    KS_CZR,	\/* italic mode end *\/$/;"	e	enum:SpecialKey
KS_DA	term.h	/^    KS_DA,	\/* text may be scrolled down from up *\/$/;"	e	enum:SpecialKey
KS_DB	term.h	/^    KS_DB,	\/* text may be scrolled up from down *\/$/;"	e	enum:SpecialKey
KS_DEC_MOUSE	keymap.h	82;"	d
KS_DL	term.h	/^    KS_DL,	\/* delete line *\/$/;"	e	enum:SpecialKey
KS_EXTRA	keymap.h	61;"	d
KS_FS	term.h	/^    KS_FS,	\/* set window title end (from status line) *\/$/;"	e	enum:SpecialKey
KS_HOR_SCROLLBAR	keymap.h	76;"	d
KS_JSBTERM_MOUSE	keymap.h	96;"	d
KS_KE	term.h	/^    KS_KE,	\/* out of "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_KEY	keymap.h	99;"	d
KS_KS	term.h	/^    KS_KS,	\/* put term in "keypad transmit" mode *\/$/;"	e	enum:SpecialKey
KS_LAST	term.h	85;"	d
KS_LE	term.h	/^    KS_LE,	\/* cursor left (mostly backspace) *\/$/;"	e	enum:SpecialKey
KS_MB	term.h	/^    KS_MB,	\/* blink mode *\/$/;"	e	enum:SpecialKey
KS_MD	term.h	/^    KS_MD,	\/* bold mode *\/$/;"	e	enum:SpecialKey
KS_ME	term.h	/^    KS_ME,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_MENU	keymap.h	74;"	d
KS_MODIFIER	keymap.h	67;"	d
KS_MOUSE	keymap.h	73;"	d
KS_MR	term.h	/^    KS_MR,	\/* reverse mode *\/$/;"	e	enum:SpecialKey
KS_MS	term.h	/^    KS_MS,	\/* save to move cur in reverse mode *\/$/;"	e	enum:SpecialKey
KS_NAME	term.h	/^    KS_NAME = 0,\/* name of this terminal entry *\/$/;"	e	enum:SpecialKey
KS_ND	term.h	/^    KS_ND,	\/* cursor right *\/$/;"	e	enum:SpecialKey
KS_NETTERM_MOUSE	keymap.h	81;"	d
KS_OP	term.h	/^    KS_OP	\/* original color pair *\/$/;"	e	enum:SpecialKey
KS_PTERM_MOUSE	keymap.h	102;"	d
KS_SE	term.h	/^    KS_SE,	\/* normal mode *\/$/;"	e	enum:SpecialKey
KS_SELECT	keymap.h	87;"	d
KS_SO	term.h	/^    KS_SO,	\/* standout mode *\/$/;"	e	enum:SpecialKey
KS_SPECIAL	keymap.h	55;"	d
KS_SR	term.h	/^    KS_SR,	\/* scroll reverse (backward) *\/$/;"	e	enum:SpecialKey
KS_TE	term.h	/^    KS_TE,	\/* out of termcap mode *\/$/;"	e	enum:SpecialKey
KS_TEAROFF	keymap.h	93;"	d
KS_TI	term.h	/^    KS_TI,	\/* put terminal in termcap mode *\/$/;"	e	enum:SpecialKey
KS_TS	term.h	/^    KS_TS,	\/* set window title start (to status line)*\/$/;"	e	enum:SpecialKey
KS_UE	term.h	/^    KS_UE,	\/* exit underscore mode *\/$/;"	e	enum:SpecialKey
KS_US	term.h	/^    KS_US,	\/* underscore mode *\/$/;"	e	enum:SpecialKey
KS_UT	term.h	/^    KS_UT,	\/* clearing uses current background color *\/$/;"	e	enum:SpecialKey
KS_VB	term.h	/^    KS_VB,	\/* visual bell *\/$/;"	e	enum:SpecialKey
KS_VE	term.h	/^    KS_VE,	\/* cursor visible *\/$/;"	e	enum:SpecialKey
KS_VER_SCROLLBAR	keymap.h	75;"	d
KS_VI	term.h	/^    KS_VI,	\/* cursor invisible *\/$/;"	e	enum:SpecialKey
KS_VS	term.h	/^    KS_VS,	\/* cursor very visible *\/$/;"	e	enum:SpecialKey
KS_XS	term.h	/^    KS_XS,	\/* standout not erased by overwriting (hpterm) *\/$/;"	e	enum:SpecialKey
KS_ZERO	keymap.h	49;"	d
KWORD	regexp.c	167;"	d	file:
K_BS	keymap.h	364;"	d
K_CMDWIN	keymap.h	452;"	d
K_CSI	keymap.h	449;"	d
K_C_END	keymap.h	263;"	d
K_C_HOME	keymap.h	261;"	d
K_C_LEFT	keymap.h	257;"	d
K_C_RIGHT	keymap.h	259;"	d
K_DEC_MOUSE	keymap.h	412;"	d
K_DEL	keymap.h	368;"	d
K_DOWN	keymap.h	251;"	d
K_DROP	keymap.h	454;"	d
K_END	keymap.h	373;"	d
K_F1	keymap.h	273;"	d
K_F10	keymap.h	282;"	d
K_F11	keymap.h	284;"	d
K_F12	keymap.h	285;"	d
K_F13	keymap.h	286;"	d
K_F14	keymap.h	287;"	d
K_F15	keymap.h	288;"	d
K_F16	keymap.h	289;"	d
K_F17	keymap.h	290;"	d
K_F18	keymap.h	291;"	d
K_F19	keymap.h	292;"	d
K_F2	keymap.h	274;"	d
K_F20	keymap.h	293;"	d
K_F21	keymap.h	295;"	d
K_F22	keymap.h	296;"	d
K_F23	keymap.h	297;"	d
K_F24	keymap.h	298;"	d
K_F25	keymap.h	299;"	d
K_F26	keymap.h	300;"	d
K_F27	keymap.h	301;"	d
K_F28	keymap.h	302;"	d
K_F29	keymap.h	303;"	d
K_F3	keymap.h	275;"	d
K_F30	keymap.h	304;"	d
K_F31	keymap.h	306;"	d
K_F32	keymap.h	307;"	d
K_F33	keymap.h	308;"	d
K_F34	keymap.h	309;"	d
K_F35	keymap.h	310;"	d
K_F36	keymap.h	311;"	d
K_F37	keymap.h	312;"	d
K_F4	keymap.h	276;"	d
K_F5	keymap.h	277;"	d
K_F6	keymap.h	278;"	d
K_F7	keymap.h	279;"	d
K_F8	keymap.h	280;"	d
K_F9	keymap.h	281;"	d
K_HELP	keymap.h	361;"	d
K_HOME	keymap.h	370;"	d
K_HOR_SCROLLBAR	keymap.h	409;"	d
K_IGNORE	keymap.h	442;"	d
K_INS	keymap.h	366;"	d
K_JSBTERM_MOUSE	keymap.h	413;"	d
K_K0	keymap.h	388;"	d
K_K1	keymap.h	389;"	d
K_K2	keymap.h	390;"	d
K_K3	keymap.h	391;"	d
K_K4	keymap.h	392;"	d
K_K5	keymap.h	393;"	d
K_K6	keymap.h	394;"	d
K_K7	keymap.h	395;"	d
K_K8	keymap.h	396;"	d
K_K9	keymap.h	397;"	d
K_KDEL	keymap.h	369;"	d
K_KDIVIDE	keymap.h	383;"	d
K_KEND	keymap.h	374;"	d
K_KENTER	keymap.h	385;"	d
K_KHOME	keymap.h	371;"	d
K_KINS	keymap.h	367;"	d
K_KMINUS	keymap.h	382;"	d
K_KMULTIPLY	keymap.h	384;"	d
K_KPAGEDOWN	keymap.h	379;"	d
K_KPAGEUP	keymap.h	378;"	d
K_KPLUS	keymap.h	381;"	d
K_KPOINT	keymap.h	386;"	d
K_LEFT	keymap.h	252;"	d
K_LEFTDRAG	keymap.h	425;"	d
K_LEFTMOUSE	keymap.h	423;"	d
K_LEFTMOUSE_NM	keymap.h	424;"	d
K_LEFTRELEASE	keymap.h	426;"	d
K_LEFTRELEASE_NM	keymap.h	427;"	d
K_MENU	keymap.h	407;"	d
K_MIDDLEDRAG	keymap.h	429;"	d
K_MIDDLEMOUSE	keymap.h	428;"	d
K_MIDDLERELEASE	keymap.h	430;"	d
K_MOUSE	keymap.h	406;"	d
K_MOUSEDOWN	keymap.h	446;"	d
K_MOUSEUP	keymap.h	447;"	d
K_NETTERM_MOUSE	keymap.h	411;"	d
K_NUL	keymap.h	13;"	d
K_PAGEDOWN	keymap.h	377;"	d
K_PAGEUP	keymap.h	376;"	d
K_PLUG	keymap.h	451;"	d
K_PTERM_MOUSE	keymap.h	414;"	d
K_RIGHT	keymap.h	253;"	d
K_RIGHTDRAG	keymap.h	432;"	d
K_RIGHTMOUSE	keymap.h	431;"	d
K_RIGHTRELEASE	keymap.h	433;"	d
K_SECOND	keymap.h	119;"	d
K_SELECT	keymap.h	416;"	d
K_SELECT_STRING	keymap.h	88;"	d
K_SNIFF	keymap.h	444;"	d
K_SNR	keymap.h	450;"	d
K_SPECIAL	keymap.h	29;"	d
K_S_DOWN	keymap.h	255;"	d
K_S_END	keymap.h	262;"	d
K_S_F1	keymap.h	320;"	d
K_S_F10	keymap.h	329;"	d
K_S_F11	keymap.h	331;"	d
K_S_F12	keymap.h	332;"	d
K_S_F13	keymap.h	333;"	d
K_S_F14	keymap.h	334;"	d
K_S_F15	keymap.h	335;"	d
K_S_F16	keymap.h	336;"	d
K_S_F17	keymap.h	337;"	d
K_S_F18	keymap.h	338;"	d
K_S_F19	keymap.h	339;"	d
K_S_F2	keymap.h	321;"	d
K_S_F20	keymap.h	340;"	d
K_S_F21	keymap.h	342;"	d
K_S_F22	keymap.h	343;"	d
K_S_F23	keymap.h	344;"	d
K_S_F24	keymap.h	345;"	d
K_S_F25	keymap.h	346;"	d
K_S_F26	keymap.h	347;"	d
K_S_F27	keymap.h	348;"	d
K_S_F28	keymap.h	349;"	d
K_S_F29	keymap.h	350;"	d
K_S_F3	keymap.h	322;"	d
K_S_F30	keymap.h	351;"	d
K_S_F31	keymap.h	353;"	d
K_S_F32	keymap.h	354;"	d
K_S_F33	keymap.h	355;"	d
K_S_F34	keymap.h	356;"	d
K_S_F35	keymap.h	357;"	d
K_S_F36	keymap.h	358;"	d
K_S_F37	keymap.h	359;"	d
K_S_F4	keymap.h	323;"	d
K_S_F5	keymap.h	324;"	d
K_S_F6	keymap.h	325;"	d
K_S_F7	keymap.h	326;"	d
K_S_F8	keymap.h	327;"	d
K_S_F9	keymap.h	328;"	d
K_S_HOME	keymap.h	260;"	d
K_S_LEFT	keymap.h	256;"	d
K_S_RIGHT	keymap.h	258;"	d
K_S_TAB	keymap.h	265;"	d
K_S_UP	keymap.h	254;"	d
K_S_XF1	keymap.h	315;"	d
K_S_XF2	keymap.h	316;"	d
K_S_XF3	keymap.h	317;"	d
K_S_XF4	keymap.h	318;"	d
K_TAB	keymap.h	264;"	d
K_TEAROFF	keymap.h	417;"	d
K_THIRD	keymap.h	121;"	d
K_UNDO	keymap.h	362;"	d
K_UP	keymap.h	250;"	d
K_VER_SCROLLBAR	keymap.h	408;"	d
K_X1DRAG	keymap.h	436;"	d
K_X1MOUSE	keymap.h	434;"	d
K_X1MOUSE	keymap.h	435;"	d
K_X1RELEASE	keymap.h	437;"	d
K_X2DRAG	keymap.h	439;"	d
K_X2MOUSE	keymap.h	438;"	d
K_X2RELEASE	keymap.h	440;"	d
K_XEND	keymap.h	375;"	d
K_XF1	keymap.h	268;"	d
K_XF2	keymap.h	269;"	d
K_XF3	keymap.h	270;"	d
K_XF4	keymap.h	271;"	d
K_XHOME	keymap.h	372;"	d
K_ZERO	keymap.h	248;"	d
KeyNoremap	getchar.c	/^static int		KeyNoremap = FALSE; \/* remapping disabled *\/$/;"	v	file:
KeyStuffed	globals.h	/^EXTERN int	KeyStuffed;		\/* TRUE if current char from stuffbuf *\/$/;"	v
KeyTyped	globals.h	/^EXTERN int	KeyTyped;		\/* TRUE if user typed current char *\/$/;"	v
L	testdir/test49.vim	/^function! L()$/;"	f
LA	farsi.h	53;"	d
LAM	farsi.h	137;"	d
LANGMAP	vim.h	512;"	d
LANGMAP_ADJUST	macros.h	131;"	d
LAST_KEYPAD	keymap.h	404;"	d
LAST_NL	regexp.c	191;"	d	file:
LBUFLEN	diff.c	56;"	d	file:
LD	Make_aros.mak	/^LD     = i386-linux-aros-gcc$/;"	m
LD	Make_dice.mak	/^LD = dcc$/;"	m
LD	Make_morph.mak	/^LD =		gcc$/;"	m
LEN_FROM_CONV	mbyte.c	425;"	d	file:
LIBS	Make_aros.mak	/^LIBS   =$/;"	m
LIBS	Make_dice.mak	/^LIBS = -la$/;"	m
LIBS	Make_manx.mak	/^LIBS = -lc16$/;"	m
LIBS	Make_morph.mak	/^LIBS =		-noixemul -s$/;"	m
LINE_ATTR	screen.c	2560;"	d	file:
LISPWORD_VALUE	option.h	279;"	d
LISTCOUNT	quickfix.c	48;"	d	file:
LIST_ATTR	syntax.c	7507;"	d	file:
LIST_INT	syntax.c	7509;"	d	file:
LIST_STRING	syntax.c	7508;"	d	file:
LLEN	xxd/xxd.c	206;"	d	file:
LN	Make_manx.mak	/^LN = ln$/;"	m
LNFLAGS	Make_manx.mak	/^LNFLAGS = +q$/;"	m
LN_DEBUG	xxd/Make_amiga.mak	/^LN_DEBUG =$/;"	m
LOOKFOR_ANY	misc1.c	5512;"	d	file:
LOOKFOR_CASE	misc1.c	5511;"	d	file:
LOOKFOR_CPP_BASECLASS	misc1.c	5517;"	d	file:
LOOKFOR_DO	misc1.c	5510;"	d	file:
LOOKFOR_ENUM_OR_INIT	misc1.c	5518;"	d	file:
LOOKFOR_IF	misc1.c	5509;"	d	file:
LOOKFOR_INITIAL	misc1.c	5508;"	d	file:
LOOKFOR_NOBREAK	misc1.c	5516;"	d	file:
LOOKFOR_SCOPEDECL	misc1.c	5515;"	d	file:
LOOKFOR_TERM	misc1.c	5513;"	d	file:
LOOKFOR_UNTERM	misc1.c	5514;"	d	file:
LOWER	regexp.c	187;"	d	file:
LPBOOL	proto.h	/^   typedef int LPBOOL;$/;"	t
LPCWSTR	proto.h	/^   typedef LPCSTR LPCWSTR;$/;"	t
LPWSTR	proto.h	/^   typedef LPSTR LPWSTR;$/;"	t
LREPLACE	vim.h	522;"	d
LSIZE	vim.h	1155;"	d
L_MATCH	screen.c	4808;"	d	file:
L_SHOWFILE	ex_getln.c	3360;"	d	file:
LineNumber	testdir/test49.vim	/^    function! LineNumber()$/;"	f
LineOffset	globals.h	/^EXTERN unsigned	*LineOffset INIT(= NULL);$/;"	v
LineWraps	globals.h	/^EXTERN char_u	*LineWraps INIT(= NULL);$/;"	v
M	testdir/test49.vim	/^function! M()$/;"	f
MACOS	vim.h	72;"	d
MACOS_CLASSIC	vim.h	63;"	d
MACOS_X	vim.h	66;"	d
MAD	farsi.h	158;"	d
MAD_N	farsi.h	161;"	d
MAGIC_ALL	regexp.c	636;"	d	file:
MAGIC_NONE	regexp.c	633;"	d	file:
MAGIC_OFF	regexp.c	634;"	d	file:
MAGIC_ON	regexp.c	635;"	d	file:
MAP_ALL_MODES	vim.h	514;"	d
MAP_HASH	getchar.c	66;"	d	file:
MATCH	regexp.c	143;"	d	file:
MATCH	testdir/test49.vim	/^function! MATCH(expected, msg, enr, emsg)$/;"	f
MAUTO	vim.h	1138;"	d
MAX	vim.h	1760;"	d
MAXCOL	vim.h	1288;"	d
MAXCOL	vim.h	1290;"	d
MAXCOL	vim.h	1293;"	d
MAXKEYWLEN	syntax.c	199;"	d	file:
MAXLNUM	vim.h	1275;"	d
MAXMAPLEN	vim.h	1175;"	d
MAXMSGSIZE	netbeans.c	686;"	d	file:
MAXPATHL	vim.h	278;"	d
MAXSUFLEN	misc1.c	7756;"	d	file:
MAX_ARG_CMDS	main.c	75;"	d	file:
MAX_FUNC_ARGS	eval.c	3022;"	d	file:
MAX_KEY_CODE_LEN	keymap.h	484;"	d
MAX_KEY_NAME_LEN	keymap.h	474;"	d
MAX_LEVEL	fold.c	43;"	d	file:
MAX_LIMIT	regexp.c	321;"	d	file:
MAX_SWAP_PAGE_SIZE	vim.h	971;"	d
MAX_TYPENR	ex_cmds.c	5569;"	d	file:
MAYBE	vim.h	1095;"	d
MAY_FORK	gui.c	57;"	d	file:
MBLOCK	vim.h	1136;"	d
MB_BYTE2LEN	vim.h	1660;"	d
MB_BYTE2LEN_CHECK	vim.h	1661;"	d
MB_ISLOWER	macros.h	87;"	d
MB_ISLOWER	macros.h	92;"	d
MB_ISUPPER	macros.h	88;"	d
MB_ISUPPER	macros.h	93;"	d
MB_MAXBYTES	vim.h	1652;"	d
MB_STRICMP	vim.h	1234;"	d
MB_STRICMP	vim.h	1237;"	d
MB_STRNICMP	vim.h	1235;"	d
MB_STRNICMP	vim.h	1238;"	d
MB_TOLOWER	macros.h	89;"	d
MB_TOLOWER	macros.h	94;"	d
MB_TOUPPER	macros.h	90;"	d
MB_TOUPPER	macros.h	95;"	d
MCHAR	vim.h	1134;"	d
MCH_CURSOR_SHAPE	feature.h	1057;"	d
MCLOSE	regexp.c	197;"	d	file:
MEMBLOCKSIZE	undo.c	1039;"	d	file:
MEMFILE_PAGE_SIZE	memfile.c	76;"	d	file:
MEMHASH	structs.h	428;"	d
MEMHASHSIZE	structs.h	427;"	d
MEMORYTYPE	Make_agui.mak	/^MEMORYTYPE=ANY$/;"	m
MEMORYTYPE	Make_sas.mak	/^MEMORYTYPE=ANY$/;"	m
MEMSIZE	Make_agui.mak	/^MEMSIZE=HUGE$/;"	m
MEMSIZE	Make_sas.mak	/^MEMSIZE=LARGE$/;"	m
MEM_SIZES	misc2.c	616;"	d	file:
MENUDEPTH	menu.c	19;"	d	file:
MENU_ALL_MODES	structs.h	1732;"	d
MENU_CMDLINE_MODE	structs.h	1730;"	d
MENU_DEFAULT_HEIGHT	gui.h	142;"	d
MENU_INDEX_CMDLINE	structs.h	1721;"	d
MENU_INDEX_INSERT	structs.h	1720;"	d
MENU_INDEX_INVALID	structs.h	1716;"	d
MENU_INDEX_NORMAL	structs.h	1717;"	d
MENU_INDEX_OP_PENDING	structs.h	1719;"	d
MENU_INDEX_TIP	structs.h	1722;"	d
MENU_INDEX_VISUAL	structs.h	1718;"	d
MENU_INSERT_MODE	structs.h	1729;"	d
MENU_MODES	structs.h	1723;"	d
MENU_NORMAL_MODE	structs.h	1726;"	d
MENU_OP_PENDING_MODE	structs.h	1728;"	d
MENU_TIP_MODE	structs.h	1731;"	d
MENU_VISUAL_MODE	structs.h	1727;"	d
MESSAGES	testdir/test49.vim	/^function! MESSAGES(...)$/;"	f
MESSAGE_FILE	message.c	14;"	d	file:
META	regexp.c	/^static char_u META[] = "%&()*+.123456789<=>?@ACDFHIKLMOPSUVWX[_acdfhiklmnopsuvwxz{|~";$/;"	v	file:
META_flags	regexp.c	/^static char_u META_flags[] = {$/;"	v	file:
ME_ARG_MISSING	main.c	65;"	d	file:
ME_EXTRA_CMD	main.c	69;"	d	file:
ME_GARBAGE	main.c	67;"	d	file:
ME_INVALID_ARG	main.c	71;"	d	file:
ME_TOO_MANY_ARGS	main.c	63;"	d	file:
ME_UNKNOWN_OPTION	main.c	61;"	d	file:
MFS_ALL	vim.h	826;"	d
MFS_FLUSH	vim.h	828;"	d
MFS_STOP	vim.h	827;"	d
MFS_ZERO	vim.h	829;"	d
MIM	farsi.h	138;"	d
MIN	fileio.c	2550;"	d	file:
MIN	vim.h	1763;"	d
MINIMAL_SIZE	getchar.c	41;"	d	file:
MIN_COLUMNS	vim.h	1143;"	d
MIN_LINES	vim.h	1144;"	d
MIN_SPACE	edit.c	3206;"	d	file:
MIN_SWAP_PAGE_SIZE	vim.h	970;"	d
MKSESSION_NL	ex_docmd.c	7528;"	d	file:
MLCS_MAXL	memline.c	3981;"	d	file:
MLCS_MINL	memline.c	3982;"	d	file:
MLEN	syntax.c	4104;"	d	file:
MLINE	vim.h	1135;"	d
ML_CHNK_ADDLINE	structs.h	475;"	d
ML_CHNK_DELLINE	structs.h	476;"	d
ML_CHNK_UPDLINE	structs.h	477;"	d
ML_DELETE	memline.c	184;"	d	file:
ML_EMPTY	structs.h	489;"	d
ML_EXTRA	tag.c	2027;"	d	file:
ML_FIND	memline.c	186;"	d	file:
ML_FLUSH	memline.c	187;"	d	file:
ML_HELP_LEN	tag.c	2045;"	d	file:
ML_INSERT	memline.c	185;"	d	file:
ML_LINE_DIRTY	structs.h	490;"	d
ML_LOCKED_DIRTY	structs.h	491;"	d
ML_LOCKED_POS	structs.h	492;"	d
ML_SIMPLE	memline.c	188;"	d	file:
MNU_HIDDEN_CHAR	structs.h	1736;"	d
MODBY_LEN	version.c	1142;"	d	file:
MODIFY	ex_cmds.h	55;"	d
MOD_KEYS_ENTRY_SIZE	misc2.c	1681;"	d	file:
MOD_MASK_2CLICK	keymap.h	461;"	d
MOD_MASK_3CLICK	keymap.h	462;"	d
MOD_MASK_4CLICK	keymap.h	463;"	d
MOD_MASK_ALT	keymap.h	460;"	d
MOD_MASK_CMD	keymap.h	465;"	d
MOD_MASK_CTRL	keymap.h	459;"	d
MOD_MASK_MULTI_CLICK	keymap.h	468;"	d
MOD_MASK_SHIFT	keymap.h	458;"	d
MOPEN	regexp.c	194;"	d	file:
MOUSEWHEEL_LOW	vim.h	1405;"	d
MOUSE_4	vim.h	1393;"	d
MOUSE_5	vim.h	1394;"	d
MOUSE_A	option.h	173;"	d
MOUSE_ALL	option.h	174;"	d
MOUSE_ALT	vim.h	1389;"	d
MOUSE_CLICK_MASK	vim.h	1407;"	d
MOUSE_COMMAND	option.h	170;"	d
MOUSE_CTRL	vim.h	1390;"	d
MOUSE_DID_MOVE	vim.h	1431;"	d
MOUSE_DRAG	vim.h	1402;"	d
MOUSE_DRAG_XTERM	vim.h	1400;"	d
MOUSE_FOCUS	vim.h	1429;"	d
MOUSE_FOLD_CLOSE	vim.h	1425;"	d
MOUSE_FOLD_OPEN	vim.h	1426;"	d
MOUSE_HELP	option.h	171;"	d
MOUSE_INSERT	option.h	169;"	d
MOUSE_LEFT	vim.h	1382;"	d
MOUSE_MAY_STOP_VIS	vim.h	1433;"	d
MOUSE_MAY_VIS	vim.h	1430;"	d
MOUSE_MIDDLE	vim.h	1383;"	d
MOUSE_NONE	option.h	175;"	d
MOUSE_NONEF	option.h	176;"	d
MOUSE_NORMAL	option.h	167;"	d
MOUSE_RELEASE	vim.h	1385;"	d
MOUSE_RELEASED	vim.h	1434;"	d
MOUSE_RETURN	option.h	172;"	d
MOUSE_RIGHT	vim.h	1384;"	d
MOUSE_SETPOS	vim.h	1432;"	d
MOUSE_SHIFT	vim.h	1388;"	d
MOUSE_VISUAL	option.h	168;"	d
MOUSE_X1	vim.h	1396;"	d
MOUSE_X2	vim.h	1397;"	d
MP	os_amiga.c	917;"	d	file:
MSDOS	xxd/xxd.c	68;"	d	file:
MSG	testdir/test49.vim	/^    function! MSG(n)$/;"	f
MSG	testdir/test49.vim	/^    function! MSG(n, enr, emsg)$/;"	f
MSG	testdir/test49.vim	/^function! MSG(enr, emsg)$/;"	f
MSG	vim.h	1249;"	d
MSG_ATTR	vim.h	1250;"	d
MSG_BUF_LEN	vim.h	1160;"	d
MSG_BUF_LEN	vim.h	1162;"	d
MSG_HIST	vim.h	496;"	d
MSG_PUTS	vim.h	1257;"	d
MSG_PUTS_ATTR	vim.h	1258;"	d
MSG_PUTS_LONG	vim.h	1260;"	d
MSG_PUTS_LONG_ATTR	vim.h	1261;"	d
MSG_PUTS_TITLE	vim.h	1259;"	d
MSHAPE_HIDE	structs.h	1693;"	d
MSHAPE_NUMBERED	structs.h	1692;"	d
MSWIN	vim.h	101;"	d
MSWIN_FIND_REPLACE	feature.h	1029;"	d
MSWIN_FR_BUFSIZE	feature.h	1030;"	d
MT_COUNT	tag.c	62;"	d	file:
MT_GL_CUR	tag.c	52;"	d	file:
MT_GL_OTH	tag.c	53;"	d	file:
MT_IC_GL_CUR	tag.c	56;"	d	file:
MT_IC_GL_OTH	tag.c	57;"	d	file:
MT_IC_OFF	tag.c	59;"	d	file:
MT_IC_ST_CUR	tag.c	55;"	d	file:
MT_IC_ST_OTH	tag.c	58;"	d	file:
MT_MASK	tag.c	61;"	d	file:
MT_RE_OFF	tag.c	60;"	d	file:
MT_ST_CUR	tag.c	51;"	d	file:
MT_ST_OTH	tag.c	54;"	d	file:
MULTIBYTECODE	regexp.c	214;"	d	file:
MULTISIGN_BYTE	vim.h	1716;"	d
MULTI_MULT	regexp.c	334;"	d	file:
MULTI_ONE	regexp.c	333;"	d	file:
M_OFFSET	undo.c	1056;"	d	file:
M_OFFSET	undo.c	1059;"	d	file:
MacOSHaveCntxMenu	gui.h	/^    int		MacOSHaveCntxMenu;  \/* Contextual menu available *\/$/;"	m	struct:Gui
MacOSHelpItems	gui.h	/^    int		MacOSHelpItems;	    \/* Nr of help-items supplied by MacOS *\/$/;"	m	struct:Gui
MacOSHelpMenu	gui.h	/^    MenuHandle	MacOSHelpMenu;	    \/* Help menu provided by the MacOS *\/$/;"	m	struct:Gui
Magic	regexp.c	228;"	d	file:
MakeScript	testdir/test49.vim	/^function! MakeScript(funcname, ...)$/;"	f
Meta	ascii.h	45;"	d
MetaChar	ascii.h	173;"	d
MyColor	gui_amiga.c	/^struct MyColor$/;"	s	file:
MyColorTable	gui_amiga.c	/^struct MyColor MyColorTable[256];$/;"	v	typeref:struct:MyColor
MyMenuItem	gui_amiga.h	/^struct MyMenuItem {$/;"	s
N	testdir/test49.vim	/^function! N()$/;"	f
NALPHA	regexp.c	186;"	d	file:
NAME	testdir/test49.vim	/^function! NAME(x, n)$/;"	f
NBDEBUG_H	nbdebug.h	12;"	d
NBDEBUG_TRACE	nbdebug.h	35;"	d
NBDLEVEL	nbdebug.h	33;"	d
NB_DEBUG_ALL	nbdebug.h	31;"	d
NB_DEF_ADDR	netbeans.c	225;"	d	file:
NB_DEF_HOST	netbeans.c	224;"	d	file:
NB_DEF_PASS	netbeans.c	226;"	d	file:
NB_TRACE	nbdebug.h	28;"	d
NB_TRACE_COLONCMD	nbdebug.h	30;"	d
NB_TRACE_VERBOSE	nbdebug.h	29;"	d
NCLOSE	regexp.c	212;"	d	file:
NDIGIT	regexp.c	176;"	d	file:
NEEDARG	ex_cmds.h	41;"	d
NEWL	regexp.c	154;"	d	file:
NEXT	regexp.c	299;"	d	file:
NEXT	testdir/test49.vim	/^function! NEXT(cmd)$/;"	f
NHEAD	regexp.c	184;"	d	file:
NHEX	regexp.c	178;"	d	file:
NL	ascii.h	112;"	d
NL	ascii.h	28;"	d
NLOWER	regexp.c	188;"	d	file:
NL_STR	ascii.h	113;"	d
NL_STR	ascii.h	29;"	d
NMARKS	structs.h	97;"	d
NOBEHIND	regexp.c	146;"	d	file:
NOCTAL	regexp.c	180;"	d	file:
NODE_NORMAL	vim.h	738;"	d
NODE_OTHER	vim.h	741;"	d
NODE_WRITABLE	vim.h	739;"	d
NOFONT	gui.h	242;"	d
NOFONT	gui.h	248;"	d
NOFONT	gui.h	254;"	d
NOFONT	gui.h	259;"	d
NOFONTSET	gui.h	243;"	d
NOFONTSET	gui.h	249;"	d
NOFONTSET	gui.h	255;"	d
NOFONTSET	gui.h	260;"	d
NOMATCH	regexp.c	144;"	d	file:
NONE_IDX	syntax.c	183;"	d	file:
NOON	farsi.h	139;"	d
NOPEN	regexp.c	210;"	d	file:
NOPROTO	vim.h	1756;"	d
NORMAL	vim.h	1750;"	d
NORMAL	vim.h	506;"	d
NORMAL_BUSY	vim.h	524;"	d
NOSPC	ex_cmds.h	37;"	d
NOTADR	ex_cmds.h	48;"	d
NOTAGFILE	tag.c	67;"	d	file:
NOTHING	regexp.c	138;"	d	file:
NOTRLCOM	ex_cmds.h	45;"	d
NOT_MULTI	regexp.c	332;"	d	file:
NOT_VALID	vim.h	445;"	d
NOWIN	window.c	75;"	d	file:
NO_BUFFERS	vim.h	955;"	d
NO_CONSOLE_INPUT	gui.h	175;"	d
NO_SCREEN	vim.h	954;"	d
NR_TRANS	structs.h	/^typedef struct nr_trans NR_TRANS;$/;"	t	typeref:struct:nr_trans
NSCRIPT	globals.h	869;"	d
NSUBEXP	regexp.h	22;"	d
NUL	ascii.h	108;"	d
NUL	ascii.h	24;"	d
NULL	testdir/test49.vim	/^function! NULL()$/;"	f
NUMBUFLEN	vim.h	293;"	d
NUM_EVENTS	vim.h	/^    NUM_EVENTS			\/* MUST be the last one *\/$/;"	e	enum:auto_event
NUM_MOUSE_CLICKS	vim.h	1409;"	d
NUM_REGISTERS	ops.c	44;"	d	file:
NUM_REGISTERS	ops.c	46;"	d	file:
NUM_REGISTERS	ops.c	49;"	d	file:
NUPPER	regexp.c	190;"	d	file:
NV_CMDS_SIZE	normal.c	432;"	d	file:
NV_KEEPREG	normal.c	192;"	d	file:
NV_LANG	normal.c	186;"	d	file:
NV_NCH	normal.c	183;"	d	file:
NV_NCH_ALW	normal.c	185;"	d	file:
NV_NCH_NOP	normal.c	184;"	d	file:
NV_NCW	normal.c	193;"	d	file:
NV_RL	normal.c	191;"	d	file:
NV_SS	normal.c	188;"	d	file:
NV_SSS	normal.c	189;"	d	file:
NV_STS	normal.c	190;"	d	file:
NWHITE	regexp.c	174;"	d	file:
NWORD	regexp.c	182;"	d	file:
N_	vim.h	411;"	d
N_	vim.h	418;"	d
N_	vim.h	420;"	d
N_	vim.h	425;"	d
NameBuff	globals.h	/^EXTERN char_u	*NameBuff;		\/* file names are expanded in this$/;"	v
O	testdir/test49.vim	/^function! O()$/;"	f
OBJ	Make_agui.mak	/^OBJ = buffer.o charset.o diff.o digraph.o edit.o eval.o ex_cmds.o ex_cmds2.o ex_docmd.o ex_eval.o ex_getln.o \\$/;"	m
OBJ	Make_dice.mak	/^OBJ =	o\/buffer.o \\$/;"	m
OBJ	Make_manx.mak	/^OBJ =	obj\/buffer.o \\$/;"	m
OBJ	Make_morph.mak	/^OBJ =	$(SRC:.c=.o)$/;"	m
OBJ	Make_sas.mak	/^OBJ = \\$/;"	m
OBJDUMP	Make_morph.mak	/^OBJDUMP =	objdump$/;"	m
OBJS	Make_aros.mak	/^OBJS   = $(SRCS:.c=.o)$/;"	m
OCTAL	regexp.c	179;"	d	file:
OK	testdir/test49.vim	/^function! OK()$/;"	f
OK	vim.h	542;"	d
OO	farsi.h	165;"	d
OP	regexp.c	298;"	d	file:
OPEN	xxd/xxd.c	178;"	d	file:
OPEN	xxd/xxd.c	180;"	d	file:
OPENLINE_DELSPACES	vim.h	854;"	d
OPENLINE_DO_COM	vim.h	855;"	d
OPENLINE_KEEPTRAIL	vim.h	856;"	d
OPENLINE_MARKFIX	vim.h	857;"	d
OPERAND	regexp.c	300;"	d	file:
OPERAND_CMP	regexp.c	307;"	d	file:
OPERAND_MAX	regexp.c	305;"	d	file:
OPERAND_MIN	regexp.c	302;"	d	file:
OPTIMIZE	Make_agui.mak	/^OPTIMIZE=OPT  OPTIMIZERTIME NoOPTIMIZERALIAS \\$/;"	m
OPTIMIZE	Make_sas.mak	/^OPTIMIZE  = OPT$/;"	m
OPTIONS	Make_manx.mak	/^OPTIONS = -so$/;"	m
OPTIONS	xxd/Make_amiga.mak	/^OPTIONS = -so$/;"	m
OPT_BOTH	option.c	44;"	d	file:
OPT_FREE	vim.h	944;"	d
OPT_GLOBAL	vim.h	945;"	d
OPT_LOCAL	vim.h	946;"	d
OPT_MODELINE	vim.h	947;"	d
OPT_PRINT_BOT	globals.h	1055;"	d
OPT_PRINT_COLLATE	globals.h	1065;"	d
OPT_PRINT_DUPLEX	globals.h	1062;"	d
OPT_PRINT_FORMFEED	globals.h	1067;"	d
OPT_PRINT_HEADERHEIGHT	globals.h	1058;"	d
OPT_PRINT_JOBSPLIT	globals.h	1066;"	d
OPT_PRINT_LEFT	globals.h	1056;"	d
OPT_PRINT_NUMBER	globals.h	1060;"	d
OPT_PRINT_NUM_OPTIONS	globals.h	1069;"	d
OPT_PRINT_PAPER	globals.h	1064;"	d
OPT_PRINT_PORTRAIT	globals.h	1063;"	d
OPT_PRINT_RIGHT	globals.h	1057;"	d
OPT_PRINT_SYNTAX	globals.h	1059;"	d
OPT_PRINT_TOP	globals.h	1054;"	d
OPT_PRINT_WRAP	globals.h	1061;"	d
OP_APPEND	vim.h	1121;"	d
OP_CHANGE	vim.h	1106;"	d
OP_COLON	vim.h	1113;"	d
OP_DELETE	vim.h	1104;"	d
OP_DELETE	vim.h	1753;"	d
OP_FILTER	vim.h	1109;"	d
OP_FOLD	vim.h	1122;"	d
OP_FOLDCLOSE	vim.h	1125;"	d
OP_FOLDCLOSEREC	vim.h	1126;"	d
OP_FOLDDEL	vim.h	1127;"	d
OP_FOLDDELREC	vim.h	1128;"	d
OP_FOLDOPEN	vim.h	1123;"	d
OP_FOLDOPENREC	vim.h	1124;"	d
OP_FORMAT	vim.h	1112;"	d
OP_FORMAT2	vim.h	1129;"	d
OP_INDENT	vim.h	1111;"	d
OP_INSERT	vim.h	1120;"	d
OP_JOIN	vim.h	1116;"	d
OP_JOIN	vim.h	1754;"	d
OP_JOIN_NS	vim.h	1117;"	d
OP_LOWER	vim.h	1115;"	d
OP_LSHIFT	vim.h	1107;"	d
OP_NOP	vim.h	1103;"	d
OP_PENDING	vim.h	508;"	d
OP_REPLACE	vim.h	1119;"	d
OP_ROT13	vim.h	1118;"	d
OP_RSHIFT	vim.h	1108;"	d
OP_TILDE	vim.h	1110;"	d
OP_UPPER	vim.h	1114;"	d
OP_YANK	vim.h	1105;"	d
ORIGINAL_TEXT	edit.c	72;"	d	file:
OS2	xxd/xxd.c	71;"	d	file:
OUT_SIZE	term.c	2502;"	d	file:
OUT_SIZE	term.c	2505;"	d	file:
OUT_SIZE	term.c	2507;"	d	file:
OUT_STR	vim.h	1255;"	d
OUT_STR_NF	vim.h	1256;"	d
OW	farsi.h	160;"	d
OW_OW	farsi.h	163;"	d
O_EXTRA	vim.h	1192;"	d
O_EXTRA	vim.h	1194;"	d
P	testdir/test49.vim	/^function! P(num)$/;"	f
PARAM_COUNT	option.c	2389;"	d	file:
PATHSEP	ascii.h	186;"	d
PATHSEP	ascii.h	190;"	d
PATHSEP	ascii.h	194;"	d
PATHSEP	ascii.h	197;"	d
PATHSEPSTR	ascii.h	187;"	d
PATHSEPSTR	ascii.h	191;"	d
PATHSEPSTR	ascii.h	195;"	d
PATHSEPSTR	ascii.h	198;"	d
PATH_ESC_CHARS	vim.h	284;"	d
PATH_SEP	xxd/xxd.c	155;"	d	file:
PATH_SEP	xxd/xxd.c	157;"	d	file:
PATH_SEP	xxd/xxd.c	165;"	d	file:
PATH_SEP	xxd/xxd.c	172;"	d	file:
PC	term.c	/^char *UP, *BC, PC;$/;"	v
PC	termlib.c	/^char	PC = 0;		      \/* Pad character, default NULL *\/$/;"	v
PC_STATUS_LEFT	edit.c	1414;"	d	file:
PC_STATUS_RIGHT	edit.c	1413;"	d	file:
PC_STATUS_SET	edit.c	1415;"	d	file:
PC_STATUS_UNSET	edit.c	1412;"	d	file:
PE	farsi.h	113;"	d
PERROR	vim.h	1266;"	d
PERROR	vim.h	1268;"	d
PLAN_CR	screen.c	6901;"	d	file:
PLAN_LE	screen.c	6900;"	d	file:
PLAN_NL	screen.c	6902;"	d	file:
PLAN_WRITE	screen.c	6903;"	d	file:
PLUS	regexp.c	141;"	d	file:
PLUS_REGISTER	ops.c	33;"	d	file:
PLUS_REGISTER	ops.c	35;"	d	file:
POUND	ascii.h	127;"	d
POUND	ascii.h	42;"	d
PRCOLOR_BLACK	ex_cmds2.c	2955;"	d	file:
PRCOLOR_WHITE	ex_cmds2.c	2956;"	d	file:
PRE	Make_dice.mak	/^PRE = -H${SYMS}=vim.h$/;"	m
PRG	Make_aros.mak	/^PRG    = VIM$/;"	m
PRG	Make_morph.mak	/^PRG =		Vim$/;"	m
PRINT	regexp.c	171;"	d	file:
PRINT_NUMBER_WIDTH	structs.h	1900;"	d
PRO	Make_agui.mak	/^PRO = \\$/;"	m
PRO	Make_manx.mak	/^PRO =	proto\/buffer.pro \\$/;"	m
PRO	Make_sas.mak	/^PRO = \\$/;"	m
PROPT	Make_agui.mak	/^PROPT = DEF=PROTO GPROTO GPPARM MAXIMUMERRORS=999 GENPROTOSTATICS GENPROTOPARAMETERS$/;"	m
PROPT	Make_sas.mak	/^PROPT = DEF=PROTO GPROTO GPPARM MAXIMUMERRORS=999 GENPROTOSTATICS GENPROTOPARAMETERS$/;"	m
PRT_MEDIASIZE_LEN	ex_cmds2.c	3734;"	d	file:
PRT_PROLOG_VERSION	ex_cmds2.c	3799;"	d	file:
PRT_PS_DEFAULT_BUFFER_SIZE	ex_cmds2.c	3725;"	d	file:
PRT_PS_DEFAULT_DPI	ex_cmds2.c	3723;"	d	file:
PRT_PS_DEFAULT_FONTSIZE	ex_cmds2.c	3724;"	d	file:
PRT_PS_FONT_BOLD	ex_cmds2.c	3766;"	d	file:
PRT_PS_FONT_BOLDOBLIQUE	ex_cmds2.c	3768;"	d	file:
PRT_PS_FONT_OBLIQUE	ex_cmds2.c	3767;"	d	file:
PRT_PS_FONT_ROMAN	ex_cmds2.c	3765;"	d	file:
PRT_PS_FONT_TO_USER	ex_cmds2.c	4075;"	d	file:
PRT_RESOURCE_ENCODING	ex_cmds2.c	3814;"	d	file:
PRT_RESOURCE_HEADER	ex_cmds2.c	3811;"	d	file:
PRT_RESOURCE_PROCSET	ex_cmds2.c	3813;"	d	file:
PRT_RESOURCE_RESOURCE	ex_cmds2.c	3812;"	d	file:
PRT_RESOURCE_TITLE	ex_cmds2.c	3815;"	d	file:
PRT_RESOURCE_TYPE_ENCODING	ex_cmds2.c	3789;"	d	file:
PRT_RESOURCE_TYPE_PROCSET	ex_cmds2.c	3788;"	d	file:
PRT_RESOURCE_VERSION	ex_cmds2.c	3816;"	d	file:
PRT_UNIT_INCH	globals.h	1096;"	d
PRT_UNIT_MM	globals.h	1097;"	d
PRT_UNIT_NAMES	globals.h	1099;"	d
PRT_UNIT_NONE	globals.h	1094;"	d
PRT_UNIT_PERC	globals.h	1095;"	d
PRT_UNIT_POINT	globals.h	1098;"	d
PSCR	ex_cmds2.c	4182;"	d	file:
PSLF	ex_cmds2.c	4181;"	d	file:
PTR_BL	memline.c	/^typedef struct pointer_block	PTR_BL;	    \/* contents of a pointer block *\/$/;"	t	typeref:struct:pointer_block	file:
PTR_EN	memline.c	/^typedef struct pointer_entry	PTR_EN;	    \/* block\/line-count pair *\/$/;"	t	typeref:struct:pointer_entry	file:
PTR_ID	memline.c	67;"	d	file:
PUT_CURSEND	vim.h	838;"	d
PUT_FIXINDENT	vim.h	837;"	d
PUT_LINE	vim.h	839;"	d
PUT_LINE_FORWARD	vim.h	841;"	d
PUT_LINE_SPLIT	vim.h	840;"	d
PV_AI	option.c	/^    , PV_AI$/;"	e	enum:__anon9	file:
PV_AR	option.c	/^    , PV_AR$/;"	e	enum:__anon9	file:
PV_ARAB	option.c	/^    , PV_ARAB$/;"	e	enum:__anon9	file:
PV_BH	option.c	/^    , PV_BH$/;"	e	enum:__anon9	file:
PV_BIN	option.c	/^    , PV_BIN$/;"	e	enum:__anon9	file:
PV_BL	option.c	/^    , PV_BL$/;"	e	enum:__anon9	file:
PV_BOMB	option.c	/^    , PV_BOMB$/;"	e	enum:__anon9	file:
PV_BOTH	option.c	43;"	d	file:
PV_BT	option.c	/^    , PV_BT$/;"	e	enum:__anon9	file:
PV_CI	option.c	/^    , PV_CI$/;"	e	enum:__anon9	file:
PV_CIN	option.c	/^    , PV_CIN$/;"	e	enum:__anon9	file:
PV_CINK	option.c	/^    , PV_CINK$/;"	e	enum:__anon9	file:
PV_CINO	option.c	/^    , PV_CINO$/;"	e	enum:__anon9	file:
PV_CINW	option.c	/^    , PV_CINW$/;"	e	enum:__anon9	file:
PV_CMS	option.c	/^    , PV_CMS$/;"	e	enum:__anon9	file:
PV_COM	option.c	/^    , PV_COM$/;"	e	enum:__anon9	file:
PV_CPT	option.c	/^    , PV_CPT$/;"	e	enum:__anon9	file:
PV_DEF	option.c	/^    , PV_DEF$/;"	e	enum:__anon9	file:
PV_DICT	option.c	/^    , PV_DICT$/;"	e	enum:__anon9	file:
PV_DIFF	option.c	/^    , PV_DIFF$/;"	e	enum:__anon9	file:
PV_EFM	option.c	/^    , PV_EFM$/;"	e	enum:__anon9	file:
PV_EOL	option.c	/^    , PV_EOL$/;"	e	enum:__anon9	file:
PV_EP	option.c	/^    , PV_EP$/;"	e	enum:__anon9	file:
PV_ET	option.c	/^    , PV_ET$/;"	e	enum:__anon9	file:
PV_FDC	option.c	/^    , PV_FDC$/;"	e	enum:__anon9	file:
PV_FDE	option.c	/^    , PV_FDE$/;"	e	enum:__anon9	file:
PV_FDI	option.c	/^    , PV_FDI$/;"	e	enum:__anon9	file:
PV_FDL	option.c	/^    , PV_FDL$/;"	e	enum:__anon9	file:
PV_FDM	option.c	/^    , PV_FDM$/;"	e	enum:__anon9	file:
PV_FDN	option.c	/^    , PV_FDN$/;"	e	enum:__anon9	file:
PV_FDT	option.c	/^    , PV_FDT$/;"	e	enum:__anon9	file:
PV_FEN	option.c	/^    , PV_FEN$/;"	e	enum:__anon9	file:
PV_FENC	option.c	/^    , PV_FENC$/;"	e	enum:__anon9	file:
PV_FF	option.c	/^    , PV_FF$/;"	e	enum:__anon9	file:
PV_FML	option.c	/^    , PV_FML$/;"	e	enum:__anon9	file:
PV_FMR	option.c	/^    , PV_FMR$/;"	e	enum:__anon9	file:
PV_FO	option.c	/^    , PV_FO$/;"	e	enum:__anon9	file:
PV_FT	option.c	/^    , PV_FT$/;"	e	enum:__anon9	file:
PV_GP	option.c	/^    , PV_GP$/;"	e	enum:__anon9	file:
PV_IMI	option.c	/^    , PV_IMI$/;"	e	enum:__anon9	file:
PV_IMS	option.c	/^    , PV_IMS$/;"	e	enum:__anon9	file:
PV_INC	option.c	/^    , PV_INC$/;"	e	enum:__anon9	file:
PV_INDE	option.c	/^    , PV_INDE$/;"	e	enum:__anon9	file:
PV_INDK	option.c	/^    , PV_INDK$/;"	e	enum:__anon9	file:
PV_INEX	option.c	/^    , PV_INEX$/;"	e	enum:__anon9	file:
PV_INF	option.c	/^    , PV_INF$/;"	e	enum:__anon9	file:
PV_ISK	option.c	/^    , PV_ISK$/;"	e	enum:__anon9	file:
PV_KEY	option.c	/^    , PV_KEY$/;"	e	enum:__anon9	file:
PV_KMAP	option.c	/^    , PV_KMAP$/;"	e	enum:__anon9	file:
PV_KP	option.c	/^    , PV_KP$/;"	e	enum:__anon9	file:
PV_LBR	option.c	/^    , PV_LBR$/;"	e	enum:__anon9	file:
PV_LISP	option.c	/^    , PV_LISP$/;"	e	enum:__anon9	file:
PV_LIST	option.c	/^    , PV_LIST$/;"	e	enum:__anon9	file:
PV_MA	option.c	/^    , PV_MA$/;"	e	enum:__anon9	file:
PV_ML	option.c	/^    , PV_ML$/;"	e	enum:__anon9	file:
PV_MOD	option.c	/^    , PV_MOD$/;"	e	enum:__anon9	file:
PV_MP	option.c	/^    , PV_MP$/;"	e	enum:__anon9	file:
PV_MPS	option.c	/^    , PV_MPS$/;"	e	enum:__anon9	file:
PV_NF	option.c	/^    , PV_NF$/;"	e	enum:__anon9	file:
PV_NONE	option.c	/^    PV_NONE = 0$/;"	e	enum:__anon9	file:
PV_NU	option.c	/^    , PV_NU$/;"	e	enum:__anon9	file:
PV_OFT	option.c	/^    , PV_OFT$/;"	e	enum:__anon9	file:
PV_PATH	option.c	/^    , PV_PATH$/;"	e	enum:__anon9	file:
PV_PI	option.c	/^    , PV_PI$/;"	e	enum:__anon9	file:
PV_PVW	option.c	/^    , PV_PVW$/;"	e	enum:__anon9	file:
PV_RL	option.c	/^    , PV_RL$/;"	e	enum:__anon9	file:
PV_RLC	option.c	/^    , PV_RLC$/;"	e	enum:__anon9	file:
PV_RO	option.c	/^    , PV_RO$/;"	e	enum:__anon9	file:
PV_SCBIND	option.c	/^    , PV_SCBIND$/;"	e	enum:__anon9	file:
PV_SCROLL	option.c	/^    , PV_SCROLL$/;"	e	enum:__anon9	file:
PV_SI	option.c	/^    , PV_SI$/;"	e	enum:__anon9	file:
PV_SN	option.c	/^    , PV_SN$/;"	e	enum:__anon9	file:
PV_STS	option.c	/^    , PV_STS$/;"	e	enum:__anon9	file:
PV_SUA	option.c	/^    , PV_SUA$/;"	e	enum:__anon9	file:
PV_SW	option.c	/^    , PV_SW$/;"	e	enum:__anon9	file:
PV_SWF	option.c	/^    , PV_SWF$/;"	e	enum:__anon9	file:
PV_SYN	option.c	/^    , PV_SYN$/;"	e	enum:__anon9	file:
PV_TAGS	option.c	/^    , PV_TAGS$/;"	e	enum:__anon9	file:
PV_TS	option.c	/^    , PV_TS$/;"	e	enum:__anon9	file:
PV_TSR	option.c	/^    , PV_TSR$/;"	e	enum:__anon9	file:
PV_TW	option.c	/^    , PV_TW$/;"	e	enum:__anon9	file:
PV_TX	option.c	/^    , PV_TX$/;"	e	enum:__anon9	file:
PV_WFH	option.c	/^    , PV_WFH$/;"	e	enum:__anon9	file:
PV_WM	option.c	/^    , PV_WM$/;"	e	enum:__anon9	file:
PV_WRAP	option.c	/^    , PV_WRAP$/;"	e	enum:__anon9	file:
PWLEN	macros.h	213;"	d
P_ALLOCED	option.c	269;"	d	file:
P_BOOL	option.c	266;"	d	file:
P_COMMA	option.c	289;"	d	file:
P_DEF_ALLOCED	option.c	275;"	d	file:
P_EXPAND	option.c	272;"	d	file:
P_FLAGLIST	option.c	291;"	d	file:
P_GETTEXT	option.c	294;"	d	file:
P_HID	option.h	491;"	d
P_HID	option.h	493;"	d
P_NFNAME	option.c	296;"	d	file:
P_NODEFAULT	option.c	274;"	d	file:
P_NODUP	option.c	290;"	d	file:
P_NOGLOB	option.c	295;"	d	file:
P_NO_MKRC	option.c	278;"	d	file:
P_NUM	option.c	267;"	d	file:
P_RALL	option.c	286;"	d	file:
P_RBUF	option.c	285;"	d	file:
P_RCLR	option.c	287;"	d	file:
P_RSTAT	option.c	283;"	d	file:
P_RWIN	option.c	284;"	d	file:
P_SECURE	option.c	293;"	d	file:
P_STRING	option.c	268;"	d	file:
P_VIM	option.c	280;"	d	file:
P_VI_DEF	option.c	279;"	d	file:
P_WAS_SET	option.c	277;"	d	file:
QF_WINHEIGHT	vim.h	1146;"	d
R	testdir/test49.vim	/^    function! R(jump, retval) abort$/;"	f
R	testdir/test49.vim	/^function! R()$/;"	f
R13_	ascii.h	105;"	d
RANGE	ex_cmds.h	30;"	d
RANGE	ex_cmds.h	33;"	d
RE	farsi.h	122;"	d
READBIN	vim.h	1179;"	d
READBIN	vim.h	1183;"	d
READ_BUFFER	vim.h	747;"	d
READ_DUMMY	vim.h	748;"	d
READ_FILTER	vim.h	745;"	d
READ_NEW	vim.h	744;"	d
READ_STDIN	vim.h	746;"	d
REDRAW_TOP	vim.h	444;"	d
REGEXP_ABBR	regexp.c	/^static char_u REGEXP_ABBR[] = "nrteb";$/;"	v	file:
REGEXP_INRANGE	regexp.c	/^static char_u REGEXP_INRANGE[] = "]^-n\\\\";$/;"	v	file:
REGMAGIC	regexp.c	259;"	d	file:
REGSTR	ex_cmds.h	43;"	d
REG_MULTI	regexp.c	2730;"	d	file:
REG_NOPAREN	regexp.c	670;"	d	file:
REG_NPAREN	regexp.c	673;"	d	file:
REG_PAREN	regexp.c	671;"	d	file:
REG_ZPAREN	regexp.c	672;"	d	file:
REMAP_NONE	vim.h	726;"	d
REMAP_SCRIPT	vim.h	727;"	d
REMAP_SKIP	vim.h	728;"	d
REMAP_YES	vim.h	725;"	d
REN	Make_manx.mak	/^REN = $(SHELL) -c mv -f$/;"	m
REPLACE	vim.h	517;"	d
REPLACE_FLAG	vim.h	516;"	d
REPLACE_NORMAL	macros.h	231;"	d
REPLACE_NORMAL	macros.h	233;"	d
RESET_CHARTAB	charset.c	27;"	d	file:
RETURN	testdir/test49.vim	/^command! -nargs=? RETURN$/;"	c
RET_ERROR	vim.h	1098;"	d
RET_WIN_BUF_CHARTABSIZE	charset.c	760;"	d	file:
REX_SET	vim.h	787;"	d
REX_USE	vim.h	788;"	d
RE_BOF	regexp.c	215;"	d	file:
RE_BOTH	vim.h	778;"	d
RE_COL	regexp.c	220;"	d	file:
RE_EOF	regexp.c	216;"	d	file:
RE_LAST	vim.h	779;"	d
RE_LNUM	regexp.c	219;"	d	file:
RE_MAGIC	vim.h	782;"	d
RE_SEARCH	vim.h	776;"	d
RE_STRING	vim.h	783;"	d
RE_SUBST	vim.h	777;"	d
RE_VCOL	regexp.c	221;"	d	file:
RF_HASNL	regexp.c	604;"	d	file:
RF_ICASE	regexp.c	602;"	d	file:
RF_ICOMBINE	regexp.c	605;"	d	file:
RF_LOOKBH	regexp.c	606;"	d	file:
RF_NOICASE	regexp.c	603;"	d	file:
RGB	gui_amiga.c	1257;"	d	file:
RI_ALPHA	regexp.c	531;"	d	file:
RI_DIGIT	regexp.c	526;"	d	file:
RI_HEAD	regexp.c	530;"	d	file:
RI_HEX	regexp.c	527;"	d	file:
RI_LOWER	regexp.c	532;"	d	file:
RI_OCTAL	regexp.c	528;"	d	file:
RI_UPPER	regexp.c	533;"	d	file:
RI_WHITE	regexp.c	534;"	d	file:
RI_WORD	regexp.c	529;"	d	file:
RLADDSUBFIX	ops.c	4733;"	d	file:
RLADDSUBFIX	ops.c	4735;"	d	file:
RL_MEMSET	screen.c	2065;"	d	file:
RM	Make_aros.mak	/^RM     = rm$/;"	m
RM	Make_morph.mak	/^RM =		rm$/;"	m
RM_ABBR	getchar.c	103;"	d	file:
RM_NONE	getchar.c	101;"	d	file:
RM_SCRIPT	getchar.c	102;"	d	file:
RM_YES	getchar.c	100;"	d	file:
ROT13	ascii.h	106;"	d
ROT13	ascii.h	22;"	d
RP_DISCARD	ex_eval.c	690;"	d	file:
RP_MAKE	ex_eval.c	688;"	d	file:
RP_RESUME	ex_eval.c	689;"	d	file:
RUNTIME_DIRNAME	feature.h	900;"	d
R_OK	vim.h	1201;"	d
Recording	globals.h	/^EXTERN int	Recording INIT(= FALSE);\/* TRUE when recording into a reg. *\/$/;"	v
RedrawingDisabled	globals.h	/^EXTERN int	RedrawingDisabled INIT(= 0);$/;"	v
ResetRedobuff	getchar.c	/^ResetRedobuff()$/;"	f
Rows	globals.h	/^EXTERN long	Rows			\/* nr of rows in the screen *\/$/;"	v
S	testdir/test49.vim	/^function! S(n) abort$/;"	f
SAD	farsi.h	127;"	d
SBAR_BOTTOM	gui.h	132;"	d
SBAR_HORIZ	gui.h	136;"	d
SBAR_LEFT	gui.h	130;"	d
SBAR_NONE	gui.h	129;"	d
SBAR_RIGHT	gui.h	131;"	d
SBAR_VERT	gui.h	135;"	d
SBOXOK	ex_cmds.h	53;"	d
SB_DEFAULT_WIDTH	gui.h	139;"	d
SCREEN_LINE	screen.c	141;"	d	file:
SCREEN_LINE	screen.c	144;"	d	file:
SCRIPTS	testdir/Make_amiga.mak	/^SCRIPTS = test1.out test3.out test4.out test5.out test6.out \\$/;"	m
SCRIPT_DEV	ex_cmds2.c	2101;"	d	file:
SCRIPT_INO	ex_cmds2.c	2102;"	d	file:
SCRIPT_NAME	ex_cmds2.c	2100;"	d	file:
SCRIPT_VARS	eval.c	68;"	d	file:
SCROLL_PAST_END	gui.c	42;"	d	file:
SE	farsi.h	115;"	d
SEARCH_ECHO	vim.h	683;"	d
SEARCH_END	vim.h	688;"	d
SEARCH_HIS	vim.h	687;"	d
SEARCH_KEEP	vim.h	692;"	d
SEARCH_MARK	vim.h	691;"	d
SEARCH_MSG	vim.h	684;"	d
SEARCH_NFMSG	vim.h	685;"	d
SEARCH_NOOF	vim.h	689;"	d
SEARCH_OPT	vim.h	686;"	d
SEARCH_PEEK	vim.h	693;"	d
SEARCH_REV	vim.h	682;"	d
SEARCH_START	vim.h	690;"	d
SEA_DIALOG	vim.h	960;"	d
SEA_NONE	vim.h	959;"	d
SEA_QUIT	vim.h	961;"	d
SEA_RECOVER	vim.h	962;"	d
SEEK_END	misc1.c	8344;"	d	file:
SEEK_SET	misc1.c	8341;"	d	file:
SELECT_CLEARED	vim.h	1491;"	d
SELECT_DONE	vim.h	1493;"	d
SELECT_IN_PROGRESS	vim.h	1492;"	d
SELECT_MODE_CHAR	vim.h	1495;"	d
SELECT_MODE_LINE	vim.h	1497;"	d
SELECT_MODE_WORD	vim.h	1496;"	d
SESSION_FILE	feature.h	817;"	d
SETWSIZE	vim.h	527;"	d
SET_CHARTAB	charset.c	26;"	d	file:
SET_NUM_MOUSE_CLICKS	vim.h	1412;"	d
SFNAME	regexp.c	170;"	d	file:
SF_CCOMMENT	syntax.c	188;"	d	file:
SF_MATCH	syntax.c	189;"	d	file:
SG_CTERM	syntax.c	55;"	d	file:
SG_GUI	syntax.c	56;"	d	file:
SG_LINK	syntax.c	57;"	d	file:
SG_TERM	syntax.c	54;"	d	file:
SHAPE_BLOCK	structs.h	1688;"	d
SHAPE_CURSOR	structs.h	1696;"	d
SHAPE_HOR	structs.h	1689;"	d
SHAPE_IDX_C	structs.h	1673;"	d
SHAPE_IDX_CI	structs.h	1674;"	d
SHAPE_IDX_CLINE	structs.h	1678;"	d
SHAPE_IDX_COUNT	structs.h	1686;"	d
SHAPE_IDX_CR	structs.h	1675;"	d
SHAPE_IDX_I	structs.h	1671;"	d
SHAPE_IDX_MORE	structs.h	1683;"	d
SHAPE_IDX_MOREL	structs.h	1684;"	d
SHAPE_IDX_N	structs.h	1669;"	d
SHAPE_IDX_O	structs.h	1676;"	d
SHAPE_IDX_R	structs.h	1672;"	d
SHAPE_IDX_SDRAG	structs.h	1680;"	d
SHAPE_IDX_SM	structs.h	1685;"	d
SHAPE_IDX_STATUS	structs.h	1679;"	d
SHAPE_IDX_V	structs.h	1670;"	d
SHAPE_IDX_VDRAG	structs.h	1682;"	d
SHAPE_IDX_VE	structs.h	1677;"	d
SHAPE_IDX_VSEP	structs.h	1681;"	d
SHAPE_MOUSE	structs.h	1695;"	d
SHAPE_VER	structs.h	1690;"	d
SHELL	Make_manx.mak	/^SHELL = csh$/;"	m
SHELL	Make_sas.mak	/^SHELL	= csh$/;"	m
SHELL_COOKED	vim.h	733;"	d
SHELL_DOOUT	vim.h	734;"	d
SHELL_EXPAND	vim.h	732;"	d
SHELL_FILTER	vim.h	731;"	d
SHELL_SILENT	vim.h	735;"	d
SHIN	farsi.h	126;"	d
SHM_A	option.h	187;"	d
SHM_ALL	option.h	196;"	d
SHM_ATTENTION	option.h	194;"	d
SHM_FILE	option.h	181;"	d
SHM_INTRO	option.h	195;"	d
SHM_LAST	option.h	182;"	d
SHM_LINES	option.h	184;"	d
SHM_MOD	option.h	180;"	d
SHM_NEW	option.h	185;"	d
SHM_OVER	option.h	191;"	d
SHM_OVERALL	option.h	192;"	d
SHM_RO	option.h	179;"	d
SHM_SEARCH	option.h	193;"	d
SHM_TEXT	option.h	183;"	d
SHM_TRUNC	option.h	189;"	d
SHM_TRUNCALL	option.h	190;"	d
SHM_WRI	option.h	186;"	d
SHM_WRITE	option.h	188;"	d
SHOWCMD_BUFLEN	normal.c	3463;"	d	file:
SHOWCMD_BUFLEN	normal.c	3465;"	d	file:
SHOWCMD_COLS	vim.h	1296;"	d
SHOWMATCH	vim.h	530;"	d
SIDENT	regexp.c	166;"	d	file:
SID_CARG	vim.h	976;"	d
SID_CMDARG	vim.h	975;"	d
SID_ENV	vim.h	977;"	d
SID_MODELINE	vim.h	974;"	d
SIGNCMD_DEFINE	ex_cmds.c	5590;"	d	file:
SIGNCMD_JUMP	ex_cmds.c	5600;"	d	file:
SIGNCMD_LAST	ex_cmds.c	5601;"	d	file:
SIGNCMD_LIST	ex_cmds.c	5594;"	d	file:
SIGNCMD_PLACE	ex_cmds.c	5596;"	d	file:
SIGNCMD_UNDEFINE	ex_cmds.c	5592;"	d	file:
SIGNCMD_UNPLACE	ex_cmds.c	5598;"	d	file:
SIGN_ANY	structs.h	528;"	d
SIGN_BYTE	vim.h	1712;"	d
SIGN_ICON	structs.h	530;"	d
SIGN_LINEHL	structs.h	529;"	d
SIGN_TEXT	structs.h	531;"	d
SIMPLE	regexp.c	355;"	d	file:
SIN	farsi.h	125;"	d
SIN_CHANGED	vim.h	844;"	d
SIN_INSERT	vim.h	845;"	d
SIN_UNDO	vim.h	846;"	d
SIZEOF_INT	vim.h	113;"	d
SIZEOF_INT	vim.h	118;"	d
SIZEOF_INT	vim.h	135;"	d
SIZEOF_INT	vim.h	144;"	d
SIZEOF_INT	vim.h	150;"	d
SKIP	testdir/test49.vim	/^function! SKIP(x, n)$/;"	f
SKIP_STOP	netbeans.c	1200;"	d	file:
SKWORD	regexp.c	168;"	d	file:
SMALL_MEM	misc2.c	728;"	d	file:
SMBUFSIZE	fileio.c	37;"	d	file:
SOME_BUILTIN_TCAPS	feature.h	514;"	d
SPACE_IN_FILENAME	os_amiga.h	14;"	d
SPEC_ABUF	ex_docmd.c	8234;"	d	file:
SPEC_AFILE	ex_docmd.c	8232;"	d	file:
SPEC_AMATCH	ex_docmd.c	8236;"	d	file:
SPEC_CCWORD	ex_docmd.c	8225;"	d	file:
SPEC_CFILE	ex_docmd.c	8227;"	d	file:
SPEC_CLIENT	ex_docmd.c	8240;"	d	file:
SPEC_COUNT	ex_docmd.c	8243;"	d	file:
SPEC_CWORD	ex_docmd.c	8223;"	d	file:
SPEC_HASH	ex_docmd.c	8221;"	d	file:
SPEC_PERC	ex_docmd.c	8219;"	d	file:
SPEC_SFILE	ex_docmd.c	8229;"	d	file:
SPO_COUNT	syntax.c	115;"	d	file:
SPO_HE_OFF	syntax.c	111;"	d	file:
SPO_HS_OFF	syntax.c	110;"	d	file:
SPO_LC_OFF	syntax.c	114;"	d	file:
SPO_ME_OFF	syntax.c	109;"	d	file:
SPO_MS_OFF	syntax.c	108;"	d	file:
SPO_RE_OFF	syntax.c	113;"	d	file:
SPO_RS_OFF	syntax.c	112;"	d	file:
SPRINT	regexp.c	172;"	d	file:
SPSTART	regexp.c	356;"	d	file:
SPTYPE_END	syntax.c	158;"	d	file:
SPTYPE_MATCH	syntax.c	156;"	d	file:
SPTYPE_SKIP	syntax.c	159;"	d	file:
SPTYPE_START	syntax.c	157;"	d	file:
SP_NOMOVE	eval.c	6163;"	d	file:
SP_REPEAT	eval.c	6164;"	d	file:
SP_RETCOUNT	eval.c	6165;"	d	file:
SRC	Make_agui.mak	/^SRC = \\$/;"	m
SRC	Make_dice.mak	/^SRC = \\$/;"	m
SRC	Make_manx.mak	/^SRC =	buffer.c \\$/;"	m
SRC	Make_morph.mak	/^SRC =	buffer.c						\\$/;"	m
SRC	Make_sas.mak	/^SRC = \\$/;"	m
SRCS	Make_aros.mak	/^SRCS   = buffer.c charset.c diff.c digraph.c edit.c eval.c ex_cmds.c          \\$/;"	m
SRC_CMD	farsi.h	176;"	d
SRC_EDT	farsi.h	175;"	d
SSOP_BLANK	option.h	631;"	d
SSOP_BUFFERS	option.h	624;"	d
SSOP_CURDIR	option.h	636;"	d
SSOP_CURSOR	option.h	638;"	d
SSOP_FOLDS	option.h	637;"	d
SSOP_GLOBALS	option.h	632;"	d
SSOP_HELP	option.h	630;"	d
SSOP_LOCALOPTIONS	option.h	628;"	d
SSOP_OPTIONS	option.h	629;"	d
SSOP_RESIZE	option.h	626;"	d
SSOP_SESDIR	option.h	635;"	d
SSOP_SLASH	option.h	633;"	d
SSOP_UNIX	option.h	634;"	d
SSOP_WINPOS	option.h	625;"	d
SSOP_WINSIZE	option.h	627;"	d
SST_DIST	vim.h	677;"	d
SST_FIX_STATES	vim.h	676;"	d
SST_INVALID	vim.h	678;"	d
SST_MAX_ENTRIES	vim.h	672;"	d
SST_MAX_ENTRIES	vim.h	674;"	d
SST_MIN_ENTRIES	vim.h	670;"	d
STACK_INCR	memline.c	171;"	d	file:
STAR	regexp.c	139;"	d	file:
STAR_REGISTER	ops.c	31;"	d	file:
STATFS	memfile.c	49;"	d	file:
STATFS	memfile.c	55;"	d	file:
STATUS_HEIGHT	vim.h	1145;"	d
STERM	ascii.h	125;"	d
STERM	ascii.h	40;"	d
STL_ALL	option.h	267;"	d
STL_ALTPERCENT	option.h	260;"	d
STL_ARGLISTSTAT	option.h	261;"	d
STL_BUFNO	option.h	243;"	d
STL_BYTEVAL	option.h	247;"	d
STL_BYTEVAL_X	option.h	248;"	d
STL_COLUMN	option.h	238;"	d
STL_FILENAME	option.h	237;"	d
STL_FILEPATH	option.h	235;"	d
STL_FILETYPE	option.h	253;"	d
STL_FILETYPE_ALT	option.h	254;"	d
STL_FULLPATH	option.h	236;"	d
STL_HELPFLAG	option.h	251;"	d
STL_HELPFLAG_ALT	option.h	252;"	d
STL_HIGHLIGHT	option.h	266;"	d
STL_IN_ICON	globals.h	1038;"	d
STL_IN_TITLE	globals.h	1039;"	d
STL_KEYMAP	option.h	244;"	d
STL_LINE	option.h	241;"	d
STL_MAX_ITEM	vim.h	1297;"	d
STL_MIDDLEMARK	option.h	264;"	d
STL_MODIFIED	option.h	257;"	d
STL_MODIFIED_ALT	option.h	258;"	d
STL_NUMLINES	option.h	242;"	d
STL_OFFSET	option.h	245;"	d
STL_OFFSET_X	option.h	246;"	d
STL_PAGENUM	option.h	262;"	d
STL_PERCENTAGE	option.h	259;"	d
STL_PREVIEWFLAG	option.h	255;"	d
STL_PREVIEWFLAG_ALT	option.h	256;"	d
STL_ROFLAG	option.h	249;"	d
STL_ROFLAG_ALT	option.h	250;"	d
STL_TRUNCMARK	option.h	265;"	d
STL_VIM_EXPR	option.h	263;"	d
STL_VIRTCOL	option.h	239;"	d
STL_VIRTCOL_ALT	option.h	240;"	d
STRCAT	vim.h	1242;"	d
STRCMP	vim.h	1211;"	d
STRCPY	vim.h	1209;"	d
STRICMP	vim.h	1214;"	d
STRICMP	vim.h	1217;"	d
STRICMP	vim.h	1219;"	d
STRLEN	vim.h	1208;"	d
STRLEN	vim.h	1751;"	d
STRNCAT	vim.h	1243;"	d
STRNCMP	vim.h	1212;"	d
STRNCMP	xxd/xxd.c	184;"	d	file:
STRNCMP	xxd/xxd.c	186;"	d	file:
STRNCPY	vim.h	1210;"	d
STRNICMP	vim.h	1224;"	d
STRNICMP	vim.h	1227;"	d
STRNICMP	vim.h	1229;"	d
STRPTR	gui_amiga.c	51;"	d	file:
SUBPAT	regexp.c	147;"	d	file:
SUBST	testdir/test49.vim	/^function! SUBST(x, n)$/;"	f
SYMS	Make_dice.mak	/^SYMS = vim.syms$/;"	m
SYMS	Make_manx.mak	/^SYMS = vim.syms$/;"	m
SYNID_ALLBUT	syntax.c	234;"	d	file:
SYNID_CLUSTER	syntax.c	237;"	d	file:
SYNID_CONTAINED	syntax.c	236;"	d	file:
SYNID_TOP	syntax.c	235;"	d	file:
SYNTAX_FNAME	os_amiga.h	124;"	d
SYN_CLSTR	syntax.c	224;"	d	file:
SYN_ITEMS	syntax.c	181;"	d	file:
SYN_NAMELEN	syntax.c	105;"	d	file:
SYN_STATE_P	syntax.c	191;"	d	file:
SYS_GVIMRC_FILE	os_amiga.h	97;"	d
SYS_MENU_FILE	os_amiga.h	100;"	d
SYS_OPTWIN_FILE	feature.h	888;"	d
SYS_VIMRC_FILE	os_amiga.h	94;"	d
ScreenAttrs	globals.h	/^EXTERN sattr_T	*ScreenAttrs INIT(= NULL);$/;"	v
ScreenLines	globals.h	/^EXTERN schar_T	*ScreenLines INIT(= NULL);$/;"	v
ScreenLines2	globals.h	/^EXTERN schar_T	*ScreenLines2 INIT(= NULL);$/;"	v
ScreenLinesC1	globals.h	/^EXTERN u8char_T	*ScreenLinesC1 INIT(= NULL);	\/* first composing char *\/$/;"	v
ScreenLinesC2	globals.h	/^EXTERN u8char_T	*ScreenLinesC2 INIT(= NULL);	\/* second composing char *\/$/;"	v
ScreenLinesUC	globals.h	/^EXTERN u8char_T	*ScreenLinesUC INIT(= NULL);	\/* decoded UTF-8 characters *\/$/;"	v
SearchedFile	search.c	/^typedef struct SearchedFile$/;"	s	file:
SearchedFile	search.c	/^} SearchedFile;$/;"	t	typeref:struct:SearchedFile	file:
SetAttrib	gui_amiga.h	15;"	d
SetLineNumber	testdir/test49.vim	/^    command! -nargs=1 SetLineNumber$/;"	c
ShS_NEUTRAL	gui_beval.h	/^    ShS_NEUTRAL,			\/* nothing showing or pending *\/$/;"	e	enum:__anon2
ShS_PENDING	gui_beval.h	/^    ShS_PENDING,			\/* data requested from debugger *\/$/;"	e	enum:__anon2
ShS_SHOWING	gui_beval.h	/^    ShS_SHOWING				\/* the balloon is being displayed *\/$/;"	e	enum:__anon2
ShS_UPDATE_PENDING	gui_beval.h	/^    ShS_UPDATE_PENDING,			\/* switching information displayed *\/$/;"	e	enum:__anon2
SpecialKey	term.h	/^enum SpecialKey$/;"	g
State	globals.h	/^EXTERN int	State INIT(= NORMAL);	\/* This is the current state of the$/;"	v
T	testdir/test49.vim	/^    function! T()$/;"	f
T	testdir/test49.vim	/^    function! T(jump)$/;"	f
T	testdir/test49.vim	/^    function! T(line)$/;"	f
T	testdir/test49.vim	/^function! T(arg, line)$/;"	f
T1	testdir/test49.vim	/^function! T1()$/;"	f
T2	testdir/test49.vim	/^function! T2()$/;"	f
TAB	ascii.h	111;"	d
TAB	ascii.h	27;"	d
TAGSTACKSIZE	structs.h	99;"	d
TAG_CSCOPE	vim.h	899;"	d
TAG_HELP	vim.h	894;"	d
TAG_INS_COMP	vim.h	902;"	d
TAG_KEEP_LANG	vim.h	903;"	d
TAG_MANY	vim.h	905;"	d
TAG_NAMES	vim.h	895;"	d
TAG_NOIC	vim.h	897;"	d
TAG_REGEXP	vim.h	896;"	d
TAG_VERBOSE	vim.h	901;"	d
TASH	farsi.h	164;"	d
TBIS_LARGE	option.h	731;"	d
TBIS_MEDIUM	option.h	730;"	d
TBIS_SMALL	option.h	729;"	d
TBIS_TINY	option.h	728;"	d
TBUFSZ	vim.h	1166;"	d
TBUFSZ	vim.h	1168;"	d
TE	farsi.h	114;"	d
TEAR_LEN	gui.h	162;"	d
TEAR_STRING	gui.h	161;"	d
TEE	farsi.h	143;"	d
TEE_	farsi.h	27;"	d
TEMPNAME	os_amiga.h	42;"	d
TEMPNAMELEN	os_amiga.h	43;"	d
TERMCAP2KEY	keymap.h	112;"	d
TERMCAPFILE	termlib.c	58;"	d	file:
TERMCAPFILE	termlib.c	61;"	d	file:
TERMCAPFILE	termlib.c	63;"	d	file:
TERMLIB	Make_agui.mak	/^TERMLIB =$/;"	m
TERMLIB	Make_dice.mak	/^TERMLIB = o\/termlib.o$/;"	m
TERMLIB	Make_manx.mak	/^TERMLIB =$/;"	m
TERMLIB	Make_sas.mak	/^TERMLIB =$/;"	m
TERM_ATTR_ENTRY	syntax.c	7334;"	d	file:
TEXT_X	gui.h	112;"	d
TEXT_X	gui.h	119;"	d
TEXT_Y	gui.h	113;"	d
TEXT_Y	gui.h	122;"	d
TGETENT	term.c	141;"	d	file:
TGETSTR	term.c	140;"	d	file:
THR	testdir/test49.vim	/^    function! THR(n)$/;"	f
THROW	testdir/test49.vim	/^function! THROW(x)$/;"	f
THROW	testdir/test49.vim	/^function! THROW(x, n)$/;"	f
THROW1	testdir/test49.vim	/^command! -nargs=? THROW1    throw <args> | throw 1$/;"	c
THROW2	testdir/test49.vim	/^command! -nargs=? THROW2    try | throw <args> | endtry | throw 2$/;"	c
THROW3	testdir/test49.vim	/^command! -nargs=? THROW3    try | throw 3 | catch \/3\/ | throw <args> | endtry$/;"	c
THROW4	testdir/test49.vim	/^command! -nargs=? THROW4    try | throw 4 | finally   | throw <args> | endtry$/;"	c
THROW_ON_ERROR	ex_eval.c	63;"	d	file:
THROW_ON_INTERRUPT	ex_eval.c	64;"	d	file:
TILDE_REGISTER	ops.c	39;"	d	file:
TIME_MSG	macros.h	225;"	d
TIME_MSG	macros.h	227;"	d
TMODE_COOK	term.h	154;"	d
TMODE_RAW	term.h	156;"	d
TMODE_SLEEP	term.h	155;"	d
TMP	testdir/test49.vim	/^		aug TMP$/;"	a
TMP	testdir/test49.vim	/^	    aug TMP$/;"	a
TMP	testdir/test49.vim	/^    aug TMP$/;"	a
TMP	testdir/test49.vim	/^augroup TMP$/;"	a
TMPLEN	buffer.c	3140;"	d	file:
TOLOWER_ASC	macros.h	76;"	d
TOLOWER_ASC	macros.h	79;"	d
TOLOWER_LOC	macros.h	62;"	d
TOLOWER_LOC	macros.h	66;"	d
TOLOWER_LOC	macros.h	69;"	d
TOOLBAR_BORDER_HEIGHT	gui.h	172;"	d
TOOLBAR_BUTTON_HEIGHT	gui.h	166;"	d
TOOLBAR_BUTTON_HEIGHT	gui.h	169;"	d
TOOLBAR_BUTTON_WIDTH	gui.h	167;"	d
TOOLBAR_BUTTON_WIDTH	gui.h	170;"	d
TOOLBAR_HORIZ	option.h	720;"	d
TOOLBAR_ICONS	option.h	718;"	d
TOOLBAR_NAME_COUNT	menu.c	79;"	d	file:
TOOLBAR_TEXT	option.h	717;"	d
TOOLBAR_TOOLTIPS	option.h	719;"	d
TOUPPER_ASC	macros.h	75;"	d
TOUPPER_ASC	macros.h	78;"	d
TOUPPER_LOC	macros.h	61;"	d
TOUPPER_LOC	macros.h	65;"	d
TOUPPER_LOC	macros.h	68;"	d
TO_SPECIAL	keymap.h	126;"	d
TPUTSFUNCAST	term.c	41;"	d	file:
TPUTSFUNCAST	term.c	44;"	d	file:
TPUTSFUNCAST	term.c	46;"	d	file:
TRLBAR	ex_cmds.h	42;"	d
TRUE	os_amiga.c	26;"	d	file:
TRUE	os_amiga.c	54;"	d	file:
TRUE	os_amiga.c	55;"	d	file:
TRUE	vim.h	1092;"	d
TRY_SEEK	xxd/xxd.c	204;"	d	file:
TTYM_DEC	option.h	742;"	d
TTYM_JSBTERM	option.h	744;"	d
TTYM_NETTERM	option.h	743;"	d
TTYM_PTERM	option.h	745;"	d
TTYM_XTERM	option.h	740;"	d
TTYM_XTERM2	option.h	741;"	d
TYPELEN_INIT	getchar.c	109;"	d	file:
TYPE_EQUAL	eval.c	/^    , TYPE_EQUAL	\/* == *\/$/;"	e	enum:__anon18	file:
TYPE_GEQUAL	eval.c	/^    , TYPE_GEQUAL	\/* >= *\/$/;"	e	enum:__anon18	file:
TYPE_GREATER	eval.c	/^    , TYPE_GREATER	\/* >  *\/$/;"	e	enum:__anon18	file:
TYPE_MATCH	eval.c	/^    , TYPE_MATCH	\/* =~ *\/$/;"	e	enum:__anon18	file:
TYPE_NEQUAL	eval.c	/^    , TYPE_NEQUAL	\/* != *\/$/;"	e	enum:__anon18	file:
TYPE_NOMATCH	eval.c	/^    , TYPE_NOMATCH	\/* !~ *\/$/;"	e	enum:__anon18	file:
TYPE_SEQUAL	eval.c	/^    , TYPE_SEQUAL	\/* <= *\/$/;"	e	enum:__anon18	file:
TYPE_SMALLER	eval.c	/^    , TYPE_SMALLER	\/* <  *\/$/;"	e	enum:__anon18	file:
TYPE_UNKNOWN	eval.c	/^    TYPE_UNKNOWN = 0$/;"	e	enum:__anon18	file:
T_AL	term.h	102;"	d
T_BC	term.h	134;"	d
T_CAB	term.h	142;"	d
T_CAF	term.h	141;"	d
T_CAL	term.h	103;"	d
T_CCO	term.h	136;"	d
T_CCS	term.h	135;"	d
T_CD	term.h	109;"	d
T_CDL	term.h	105;"	d
T_CE	term.h	101;"	d
T_CIE	term.h	146;"	d
T_CIS	term.h	145;"	d
T_CL	term.h	108;"	d
T_CM	term.h	126;"	d
T_CRI	term.h	128;"	d
T_CRV	term.h	151;"	d
T_CS	term.h	106;"	d
T_CSB	term.h	138;"	d
T_CSF	term.h	137;"	d
T_CSV	term.h	107;"	d
T_CWP	term.h	149;"	d
T_CWS	term.h	150;"	d
T_CZH	term.h	121;"	d
T_CZR	term.h	122;"	d
T_DA	term.h	111;"	d
T_DB	term.h	112;"	d
T_DL	term.h	104;"	d
T_FS	term.h	148;"	d
T_KE	term.h	131;"	d
T_KS	term.h	130;"	d
T_LE	term.h	143;"	d
T_MB	term.h	140;"	d
T_MD	term.h	118;"	d
T_ME	term.h	116;"	d
T_MR	term.h	117;"	d
T_MS	term.h	125;"	d
T_NAME	term.h	100;"	d
T_ND	term.h	144;"	d
T_OP	term.h	152;"	d
T_SE	term.h	119;"	d
T_SO	term.h	120;"	d
T_SR	term.h	127;"	d
T_TE	term.h	133;"	d
T_TI	term.h	132;"	d
T_TS	term.h	147;"	d
T_UE	term.h	123;"	d
T_US	term.h	124;"	d
T_UT	term.h	110;"	d
T_VB	term.h	129;"	d
T_VE	term.h	114;"	d
T_VI	term.h	113;"	d
T_VS	term.h	115;"	d
T_XS	term.h	139;"	d
TextDimensions	gui_amiga.c	/^TextDimensions(void)$/;"	f	file:
Throw	testdir/test49.vim	/^    function! Throw()$/;"	f
ThrowOnError	testdir/test49.vim	/^    function! ThrowOnError()$/;"	f
ThrowOnInterrupt	testdir/test49.vim	/^    function! ThrowOnInterrupt()$/;"	f
TimerIO	gui_amiga.c	/^static struct timerequest *TimerIO;$/;"	v	typeref:struct:timerequest	file:
TimerMP	gui_amiga.c	/^static struct MsgPort	  *TimerMP;$/;"	v	typeref:struct:MsgPort	file:
TimerSent	gui_amiga.c	/^static BOOL		   TimerSent;$/;"	v	file:
UBYTE	gui_amiga.c	53;"	d	file:
UCHARAT	regexp.c	312;"	d	file:
UC_BUFFER	ex_docmd.c	40;"	d	file:
UH_CHANGED	structs.h	264;"	d
UH_EMPTYBUF	structs.h	265;"	d
UNDERLI	Make_agui.mak	/^UNDERLI = *e[4m$/;"	m
UNIX	vim.h	68;"	d
UNKNOWN	fileio.c	242;"	d	file:
UP	term.c	/^char *UP, *BC, PC;$/;"	v
UP	termlib.c	/^char	*UP = 0, *BC = 0;     \/* Pointers to UP and BC strings from database *\/$/;"	v
UPPER	regexp.c	189;"	d	file:
URL_BACKSLASH	window.c	73;"	d	file:
URL_SLASH	window.c	72;"	d	file:
USECTRLV	ex_cmds.h	47;"	d
USER_CMD	ex_docmd.c	44;"	d	file:
USER_CMDIDX	ex_cmds.h	915;"	d
USER_CMD_GA	ex_docmd.c	45;"	d	file:
USER_HIGHLIGHT	globals.h	306;"	d
USE_DLOPEN	feature.h	657;"	d
USE_FNAME_CASE	os_amiga.h	15;"	d
USE_FSTATFS	memfile.c	133;"	d	file:
USE_ICONV	feature.h	605;"	d
USE_IM_CONTROL	vim.h	387;"	d
USE_INPUT_BUF	vim.h	1350;"	d
USE_MCH_ACCESS	fileio.c	46;"	d	file:
USE_MCH_ERRMSG	vim.h	1584;"	d
USE_NL	screen.c	7423;"	d	file:
USE_ON_FLY_SCROLL	gui.h	81;"	d
USE_REDRAW	screen.c	7425;"	d	file:
USE_TERM_CONSOLE	os_amiga.h	16;"	d
USE_TMPNAM	os_amiga.h	68;"	d
USE_T_AL	screen.c	7419;"	d	file:
USE_T_CAL	screen.c	7417;"	d	file:
USE_T_CD	screen.c	7424;"	d	file:
USE_T_CDL	screen.c	7418;"	d	file:
USE_T_CE	screen.c	7420;"	d	file:
USE_T_DL	screen.c	7421;"	d	file:
USE_T_SR	screen.c	7422;"	d	file:
USE_UNICODE_DIGRAPHS	digraph.c	816;"	d	file:
USE_X11R6_XIM	mbyte.c	4625;"	d	file:
USE_XIM	feature.h	620;"	d
USE_XSMP	feature.h	948;"	d
USE_XSMP_INTERACT	feature.h	951;"	d
USR_EXRC_FILE	os_amiga.h	128;"	d
USR_EXRC_FILE2	os_amiga.h	131;"	d
USR_GVIMRC_FILE	os_amiga.h	148;"	d
USR_GVIMRC_FILE2	os_amiga.h	151;"	d
USR_GVIMRC_FILE3	os_amiga.h	154;"	d
USR_VIMRC_FILE	os_amiga.h	135;"	d
USR_VIMRC_FILE2	os_amiga.h	138;"	d
USR_VIMRC_FILE3	os_amiga.h	141;"	d
UTF_COMPOSINGLIKE	macros.h	237;"	d
UTF_COMPOSINGLIKE	macros.h	239;"	d
V0	testdir/test49.vim	/^let V0 = 1$/;"	v
VALID	vim.h	440;"	d
VALID_BOTLINE	vim.h	479;"	d
VALID_BOTLINE_AP	vim.h	480;"	d
VALID_CHEIGHT	vim.h	477;"	d
VALID_CROW	vim.h	478;"	d
VALID_HEAD	vim.h	1444;"	d
VALID_PATH	vim.h	1443;"	d
VALID_STATE	syntax.c	315;"	d	file:
VALID_TOPLINE	vim.h	481;"	d
VALID_VIRTCOL	vim.h	476;"	d
VALID_WCOL	vim.h	475;"	d
VALID_WROW	vim.h	474;"	d
VAR	eval.c	/^typedef var *	VAR;$/;"	t	file:
VAR_ENTRY	eval.c	71;"	d	file:
VAR_FLAVOUR_DEFAULT	eval.c	/^    VAR_FLAVOUR_DEFAULT,$/;"	e	enum:__anon19	file:
VAR_FLAVOUR_SESSION	eval.c	/^    VAR_FLAVOUR_SESSION,$/;"	e	enum:__anon19	file:
VAR_FLAVOUR_VIMINFO	eval.c	/^    VAR_FLAVOUR_VIMINFO$/;"	e	enum:__anon19	file:
VAR_GAP_ENTRY	eval.c	72;"	d	file:
VAR_NUMBER	eval.c	54;"	d	file:
VAR_STRING	eval.c	55;"	d	file:
VAR_UNKNOWN	eval.c	53;"	d	file:
VAR_WIN	option.c	138;"	d	file:
VE_ALL	option.h	770;"	d
VE_BLOCK	option.h	768;"	d
VE_INSERT	option.h	769;"	d
VIEW_FILE	feature.h	812;"	d
VIMENC_ATOM_NAME	vim.h	1488;"	d
VIMINFO_FILE	os_amiga.h	159;"	d
VIMPACKAGE	vim.h	163;"	d
VIMPROG	testdir/Make_amiga.mak	/^VIMPROG = \/vim$/;"	m
VIMRC_FILE	os_amiga.h	168;"	d
VIM_ALL	vim.h	925;"	d
VIM_ATOM_NAME	vim.h	1487;"	d
VIM_BACKTICK	feature.h	201;"	d
VIM_CANCEL	vim.h	924;"	d
VIM_DEFAULT	option.c	261;"	d	file:
VIM_DISCARDALL	vim.h	926;"	d
VIM_ERROR	vim.h	912;"	d
VIM_GENERIC	vim.h	911;"	d
VIM_INFO	vim.h	914;"	d
VIM_ISDIGIT	macros.h	116;"	d
VIM_LAST_TYPE	vim.h	916;"	d
VIM_LC_MESSAGES	ex_cmds2.c	5585;"	d	file:
VIM_MEMCMP	vim.h	1344;"	d
VIM_NO	vim.h	923;"	d
VIM_OK	vim.h	921;"	d
VIM_QUESTION	vim.h	915;"	d
VIM_VERSION_100	version.h	20;"	d
VIM_VERSION_BUILD	version.h	22;"	d
VIM_VERSION_BUILD_BCD	version.h	23;"	d
VIM_VERSION_BUILD_STR	version.h	24;"	d
VIM_VERSION_LONG	version.h	39;"	d
VIM_VERSION_LONG_DATE	version.h	40;"	d
VIM_VERSION_MAJOR	version.h	16;"	d
VIM_VERSION_MAJOR_STR	version.h	17;"	d
VIM_VERSION_MEDIUM	version.h	38;"	d
VIM_VERSION_MINOR	version.h	18;"	d
VIM_VERSION_MINOR_STR	version.h	19;"	d
VIM_VERSION_NODOT	version.h	36;"	d
VIM_VERSION_PATCHLEVEL	version.h	25;"	d
VIM_VERSION_PATCHLEVEL_STR	version.h	26;"	d
VIM_VERSION_RELEASE	version.h	28;"	d
VIM_VERSION_SHORT	version.h	37;"	d
VIM_WARNING	vim.h	913;"	d
VIM_YES	vim.h	922;"	d
VIM__H	vim.h	10;"	d
VISUAL	vim.h	507;"	d
VI_DEFAULT	option.c	260;"	d	file:
VIsual	globals.h	/^EXTERN pos_T	VIsual;		\/* start position of active Visual selection *\/$/;"	v
VIsual_active	globals.h	/^EXTERN int	VIsual_active INIT(= FALSE);$/;"	v
VIsual_mode	globals.h	/^EXTERN int	VIsual_mode INIT(= 'v');$/;"	v
VIsual_reselect	globals.h	/^EXTERN int	VIsual_reselect;$/;"	v
VIsual_select	globals.h	/^EXTERN int	VIsual_select INIT(= FALSE);$/;"	v
VREPLACE	vim.h	520;"	d
VREPLACE_FLAG	vim.h	519;"	d
VV_CC_FROM	vim.h	1462;"	d
VV_CC_TO	vim.h	1463;"	d
VV_CMDARG	vim.h	1468;"	d
VV_CMDBANG	vim.h	1479;"	d
VV_COMPAT	eval.c	187;"	d	file:
VV_COUNT	vim.h	1447;"	d
VV_COUNT1	vim.h	1448;"	d
VV_CTYPE	vim.h	1461;"	d
VV_DYING	vim.h	1475;"	d
VV_ERRMSG	vim.h	1450;"	d
VV_EXCEPTION	vim.h	1476;"	d
VV_FNAME	vim.h	1458;"	d
VV_FNAME_DIFF	vim.h	1467;"	d
VV_FNAME_IN	vim.h	1464;"	d
VV_FNAME_NEW	vim.h	1466;"	d
VV_FNAME_OUT	vim.h	1465;"	d
VV_FOLDDASHES	vim.h	1471;"	d
VV_FOLDEND	vim.h	1470;"	d
VV_FOLDLEVEL	vim.h	1472;"	d
VV_FOLDSTART	vim.h	1469;"	d
VV_LANG	vim.h	1459;"	d
VV_LC_TIME	vim.h	1460;"	d
VV_LEN	vim.h	1480;"	d
VV_LNUM	vim.h	1456;"	d
VV_PREVCOUNT	vim.h	1449;"	d
VV_PROGNAME	vim.h	1473;"	d
VV_REG	vim.h	1478;"	d
VV_RO	eval.c	188;"	d	file:
VV_SEND_SERVER	vim.h	1474;"	d
VV_SHELL_ERROR	vim.h	1453;"	d
VV_STATUSMSG	vim.h	1452;"	d
VV_TERMRESPONSE	vim.h	1457;"	d
VV_THIS_SESSION	vim.h	1454;"	d
VV_THROWPOINT	vim.h	1477;"	d
VV_VERSION	vim.h	1455;"	d
VV_WARNINGMSG	vim.h	1451;"	d
VW_POS_CENTER	gui.h	/^    VW_POS_CENTER,$/;"	e	enum:__anon21
VW_POS_MOUSE	gui.h	/^    VW_POS_MOUSE,$/;"	e	enum:__anon21
VW_POS_TOP_CENTER	gui.h	/^    VW_POS_TOP_CENTER$/;"	e	enum:__anon21
Version	version.c	/^char	*Version = VIM_VERSION_SHORT;$/;"	v
VimClipboard	vim.h	/^typedef int VimClipboard;	\/* This is required for the prototypes. *\/$/;"	t
VimClipboard	vim.h	/^typedef struct VimClipboard$/;"	s
VimClipboard	vim.h	/^} VimClipboard;$/;"	t	typeref:struct:VimClipboard
VimMain	main.c	/^VimMain$/;"	f
VimMenu	structs.h	/^struct VimMenu$/;"	s
VimWindow	gui.h	/^    WindowPtr	VimWindow;$/;"	m	struct:Gui
WANT_X11	feature.h	935;"	d
WARGCOUNT	structs.h	566;"	d
WARGLIST	structs.h	562;"	d
WAW	farsi.h	140;"	d
WAW_H	farsi.h	167;"	d
WBOLD	Make_agui.mak	/^WBOLD = *e[2m$/;"	m
WHITE	regexp.c	173;"	d	file:
WHITECHAR	edit.c	3848;"	d	file:
WHITECHAR	edit.c	3850;"	d	file:
WHOLEFOLD	ex_cmds.h	39;"	d
WILD_ADD_SLASH	vim.h	618;"	d
WILD_ALL	vim.h	611;"	d
WILD_ESCAPE	vim.h	621;"	d
WILD_EXPAND_FREE	vim.h	607;"	d
WILD_EXPAND_KEEP	vim.h	608;"	d
WILD_FREE	vim.h	606;"	d
WILD_HOME_REPLACE	vim.h	615;"	d
WILD_KEEP_ALL	vim.h	619;"	d
WILD_LIST_NOTFOUND	vim.h	614;"	d
WILD_LONGEST	vim.h	612;"	d
WILD_NEXT	vim.h	609;"	d
WILD_NO_BEEP	vim.h	617;"	d
WILD_PREV	vim.h	610;"	d
WILD_SILENT	vim.h	620;"	d
WILD_USE_NL	vim.h	616;"	d
WIM_FULL	option.h	270;"	d
WIM_LIST	option.h	272;"	d
WIM_LONGEST	option.h	271;"	d
WIN32	mbyte.c	88;"	d	file:
WIN3264	vim.h	105;"	d
WIN32_LEAN_AND_MEAN	mbyte.c	84;"	d	file:
WITH_NL	regexp.c	192;"	d	file:
WITH_OFF	screen.c	8266;"	d	file:
WITH_WIDTH	screen.c	8267;"	d	file:
WL_CMDLINE	screen.c	2574;"	d	file:
WL_FOLD	screen.c	2579;"	d	file:
WL_LINE	screen.c	2594;"	d	file:
WL_NR	screen.c	2588;"	d	file:
WL_SBR	screen.c	2590;"	d	file:
WL_SIGN	screen.c	2584;"	d	file:
WL_START	screen.c	2572;"	d	file:
WM_NETBEANS	vim.h	1505;"	d
WM_OLE	vim.h	1501;"	d
WM_SCROLLED	globals.h	957;"	d
WM_SHOWN	globals.h	956;"	d
WORD	regexp.c	181;"	d	file:
WORD1	ex_cmds.h	57;"	d
WORST	regexp.c	359;"	d	file:
WRITEBIN	vim.h	1178;"	d
WRITEBIN	vim.h	1182;"	d
WSP_ABOVE	vim.h	937;"	d
WSP_BELOW	vim.h	936;"	d
WSP_BOT	vim.h	934;"	d
WSP_HELP	vim.h	935;"	d
WSP_ROOM	vim.h	931;"	d
WSP_TOP	vim.h	933;"	d
WSP_VERT	vim.h	932;"	d
WT_ENV	nbdebug.h	/^		WT_ENV = 1,		\/* look for env var if set *\/$/;"	e	enum:__anon24
WT_STOP	nbdebug.h	/^		WT_STOP			\/* look for ~\/.gvimstop if set *\/$/;"	e	enum:__anon24
WT_WAIT	nbdebug.h	/^		WT_WAIT,		\/* look for ~\/.gvimwait if set *\/$/;"	e	enum:__anon24
WVAR_ENTRY	eval.c	74;"	d	file:
WW_ALL	option.h	164;"	d
W_CONV	farsi.h	183;"	d
W_ENDCOL	vim.h	636;"	d
W_ENDCOL	vim.h	641;"	d
W_NEXT	globals.h	462;"	d
W_NEXT	globals.h	467;"	d
W_OK	vim.h	1198;"	d
W_R_L	farsi.h	184;"	d
W_STATUS_HEIGHT	vim.h	645;"	d
W_STATUS_HEIGHT	vim.h	648;"	d
W_VSEP_WIDTH	vim.h	637;"	d
W_VSEP_WIDTH	vim.h	642;"	d
W_WIDTH	vim.h	635;"	d
W_WIDTH	vim.h	640;"	d
W_WINCOL	vim.h	634;"	d
W_WINCOL	vim.h	639;"	d
W_WINROW	vim.h	646;"	d
W_WINROW	vim.h	649;"	d
WantQueryMouse	globals.h	/^EXTERN int	WantQueryMouse INIT(= 0);$/;"	v
Widget	proto.h	25;"	d
Window	os_amiga.c	19;"	d	file:
WtWait	nbdebug.h	/^} WtWait;$/;"	t	typeref:enum:__anon24
XE	farsi.h	119;"	d
XFILE	ex_cmds.h	36;"	d
XIMPreeditDisable	mbyte.c	4227;"	d	file:
XIMPreeditEnable	mbyte.c	4226;"	d	file:
XIMPreeditUnKnown	mbyte.c	4225;"	d	file:
XImage	proto.h	32;"	d
XNPreeditState	mbyte.c	4228;"	d	file:
XP_BS_NONE	structs.h	397;"	d
XP_BS_ONE	structs.h	398;"	d
XP_BS_THREE	structs.h	399;"	d
XT_LEN	term.c	5167;"	d	file:
X_2_COL	gui.h	116;"	d
X_2_COL	gui.h	121;"	d
X_DISPLAY	vim.h	1724;"	d
X_DISPLAY	vim.h	1726;"	d
X_DISPLAY	vim.h	1731;"	d
X_DISPLAY	vim.h	1733;"	d
X_DISPLAY	vim.h	1736;"	d
Xcheck	testdir/test49.vim	/^    function! Xcheck()$/;"	f
Xcheck	testdir/test49.vim	/^com! -count	    Xcheck	let Xresult = "*** Test " .$/;"	c
Xcomment	testdir/test49.vim	/^    function! Xcomment(num)$/;"	f
Xloop	testdir/test49.vim	/^    com! -count=1 -bar  Xloop	exec "!echo " . (g:Xnext * <count>) . " >>" .$/;"	c
Xloop	testdir/test49.vim	/^    com! -count=1 -bar  Xloop	let g:Xpath = g:Xpath + g:Xnext * <count>$/;"	c
Xloop	testdir/test49.vim	/^    function! Xloop()$/;"	f
XloopINIT	testdir/test49.vim	/^		  \\ XloopINIT	let g:Xnext = <count> |$/;"	c
Xout	testdir/test49.vim	/^    com! -nargs=+    Xout	exec "exec \\"!echo @R:'\\" ."$/;"	c
Xout	testdir/test49.vim	/^    com! -nargs=+    Xout	exec 'let @R = "--- Test ' .$/;"	c
Xpath	testdir/test49.vim	/^    aug Xpath$/;"	a
Xpath	testdir/test49.vim	/^    com! -count -bar    Xpath	exec "!echo <count> >>" . g:ExtraVimResult$/;"	c
Xpath	testdir/test49.vim	/^    com! -count -bar    Xpath	let g:Xpath = g:Xpath + <count>$/;"	c
Xpath	testdir/test49.vim	/^    function! Xpath(loopinit)$/;"	f
Xpath	testdir/test49.vim	/^    let Xpath = Xpath + 2147483648		" X: 0$/;"	v
Xsum	testdir/test49.vim	/^    function! Xsum()$/;"	f
Xtest	testdir/test49.vim	/^let Xtest = 1$/;"	v
YE	farsi.h	142;"	d
YEE	farsi.h	145;"	d
YEE_	farsi.h	63;"	d
YE_	farsi.h	64;"	d
Y_2_ROW	gui.h	117;"	d
Y_2_ROW	gui.h	125;"	d
ZAD	farsi.h	128;"	d
ZAL	farsi.h	121;"	d
ZCLOSE	regexp.c	204;"	d	file:
ZDECODE	macros.h	220;"	d
ZE	farsi.h	123;"	d
ZENCODE	macros.h	217;"	d
ZERO	testdir/test49.vim	/^function! ZERO()$/;"	f
ZEROR	ex_cmds.h	46;"	d
ZERO_BL	memline.c	/^typedef struct block0		ZERO_BL;    \/* contents of the first block *\/$/;"	t	typeref:struct:block0	file:
ZOPEN	regexp.c	202;"	d	file:
ZREF	regexp.c	205;"	d	file:
_	vim.h	1767;"	d
_	vim.h	410;"	d
_	vim.h	416;"	d
_	vim.h	424;"	d
_AYN	farsi.h	42;"	d
_AYN_	farsi.h	43;"	d
_BE	farsi.h	30;"	d
_CHE	farsi.h	35;"	d
_DEBUG	vim.h	1773;"	d
_FE	farsi.h	48;"	d
_GAF	farsi.h	51;"	d
_GHAF	farsi.h	49;"	d
_GHAYN	farsi.h	45;"	d
_GHAYN_	farsi.h	46;"	d
_HE	farsi.h	56;"	d
_HE_	farsi.h	57;"	d
_HE_J	farsi.h	36;"	d
_IE	farsi.h	59;"	d
_JIM	farsi.h	34;"	d
_KAF	farsi.h	50;"	d
_KAF_H	farsi.h	144;"	d
_LAM	farsi.h	52;"	d
_MIM	farsi.h	54;"	d
_NOON	farsi.h	55;"	d
_PE	farsi.h	31;"	d
_PROTO_H	proto.h	249;"	d
_REGEXP_H	regexp.h	14;"	d
_SAD	farsi.h	40;"	d
_SE	farsi.h	33;"	d
_SHIN	farsi.h	39;"	d
_SIN	farsi.h	38;"	d
_TA	farsi.h	129;"	d
_TE	farsi.h	32;"	d
_XE	farsi.h	37;"	d
_YE	farsi.h	58;"	d
_YEE	farsi.h	62;"	d
_ZA	farsi.h	130;"	d
_ZAD	farsi.h	41;"	d
__ARGS	regexp.c	/^typedef void (*(*fptr) __ARGS((char_u *, int)))();$/;"	t	file:
__ARGS	regexp.c	5520;"	d	file:
__ARGS	regexp.c	5521;"	d	file:
__ARGS	vim.h	171;"	d
__ARGS	vim.h	176;"	d
__ARGS	vim.h	181;"	d
__ARGS	vim.h	185;"	d
__ARGS	vim.h	190;"	d
__ARGS	vim.h	200;"	d
__ARGS	vim.h	204;"	d
__GUI_AMIGA__H	gui_amiga.h	13;"	d
__P	xxd/xxd.c	113;"	d	file:
__P	xxd/xxd.c	192;"	d	file:
__P	xxd/xxd.c	194;"	d	file:
__PARMS	vim.h	212;"	d
__USE_FIXED_PROTOTYPES__	xxd/xxd.c	100;"	d	file:
__chkabort	os_amiga.c	/^void __regargs __chkabort(void)$/;"	f
_addfmt	termlib.c	/^_addfmt(buf, fmt, val)$/;"	f	file:
_bauds	termlib.c	/^long _bauds[16]={$/;"	v
_cdecl	misc1.c	7786;"	d	file:
_cdecl	misc1.c	7789;"	d	file:
_find	termlib.c	/^_find(s, set)$/;"	f	file:
_match	termlib.c	/^_match(s1, s2)		\/* returns length of text common to s1 and s2 *\/$/;"	f	file:
_stati64	vim.h	1785;"	d
a	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
a0_var	eval.c	/^    var		a0_var;		\/* "a:0" variable *\/$/;"	m	struct:funccall	file:
a_AIN	arabic.h	59;"	d
a_ALEF	arabic.h	41;"	d
a_ALEF_HAMZA_ABOVE	arabic.h	37;"	d
a_ALEF_HAMZA_BELOW	arabic.h	39;"	d
a_ALEF_MADDA	arabic.h	36;"	d
a_ALEF_MAKSURA	arabic.h	70;"	d
a_BEH	arabic.h	42;"	d
a_BYTE_ORDER_MARK	arabic.h	255;"	d
a_COMMA	arabic.h	32;"	d
a_DAD	arabic.h	56;"	d
a_DAL	arabic.h	49;"	d
a_DAMMA	arabic.h	77;"	d
a_DAMMATAN	arabic.h	74;"	d
a_DECIMAL	arabic.h	97;"	d
a_EIGHT	arabic.h	94;"	d
a_FATHA	arabic.h	76;"	d
a_FATHATAN	arabic.h	73;"	d
a_FEH	arabic.h	62;"	d
a_FIVE	arabic.h	91;"	d
a_FOUR	arabic.h	90;"	d
a_GHAIN	arabic.h	60;"	d
a_HAH	arabic.h	47;"	d
a_HAMZA	arabic.h	35;"	d
a_HAMZA_ABOVE	arabic.h	83;"	d
a_HAMZA_BELOW	arabic.h	84;"	d
a_HEH	arabic.h	68;"	d
a_JEEM	arabic.h	46;"	d
a_KAF	arabic.h	64;"	d
a_KASRA	arabic.h	78;"	d
a_KASRATAN	arabic.h	75;"	d
a_KHAH	arabic.h	48;"	d
a_LAM	arabic.h	65;"	d
a_MADDA_ABOVE	arabic.h	82;"	d
a_MEEM	arabic.h	66;"	d
a_MINI_ALEF	arabic.h	100;"	d
a_NINE	arabic.h	95;"	d
a_NOON	arabic.h	67;"	d
a_ONE	arabic.h	87;"	d
a_PERCENT	arabic.h	96;"	d
a_QAF	arabic.h	63;"	d
a_QUESTION	arabic.h	34;"	d
a_REH	arabic.h	51;"	d
a_SAD	arabic.h	55;"	d
a_SEEN	arabic.h	53;"	d
a_SEMICOLON	arabic.h	33;"	d
a_SEVEN	arabic.h	93;"	d
a_SHADDA	arabic.h	79;"	d
a_SHEEN	arabic.h	54;"	d
a_SIX	arabic.h	92;"	d
a_STAR	arabic.h	99;"	d
a_SUKUN	arabic.h	80;"	d
a_TAH	arabic.h	57;"	d
a_TATWEEL	arabic.h	61;"	d
a_TEH	arabic.h	44;"	d
a_TEH_MARBUTA	arabic.h	43;"	d
a_THAL	arabic.h	50;"	d
a_THEH	arabic.h	45;"	d
a_THOUSANDS	arabic.h	98;"	d
a_THREE	arabic.h	89;"	d
a_TWO	arabic.h	88;"	d
a_WAW	arabic.h	69;"	d
a_WAW_HAMZA	arabic.h	38;"	d
a_YEH	arabic.h	71;"	d
a_YEH_HAMZA	arabic.h	40;"	d
a_ZAH	arabic.h	58;"	d
a_ZAIN	arabic.h	52;"	d
a_ZERO	arabic.h	86;"	d
a_f_AIN	arabic.h	203;"	d
a_f_ALEF	arabic.h	143;"	d
a_f_ALEF_HAMZA_ABOVE	arabic.h	133;"	d
a_f_ALEF_HAMZA_BELOW	arabic.h	137;"	d
a_f_ALEF_MADDA	arabic.h	131;"	d
a_f_ALEF_MAKSURA	arabic.h	241;"	d
a_f_BEH	arabic.h	145;"	d
a_f_DAD	arabic.h	191;"	d
a_f_DAL	arabic.h	171;"	d
a_f_FEH	arabic.h	211;"	d
a_f_GHAIN	arabic.h	207;"	d
a_f_HAH	arabic.h	163;"	d
a_f_HEH	arabic.h	235;"	d
a_f_JEEM	arabic.h	159;"	d
a_f_KAF	arabic.h	219;"	d
a_f_KHAH	arabic.h	167;"	d
a_f_LAM	arabic.h	223;"	d
a_f_LAM_ALEF	arabic.h	253;"	d
a_f_LAM_ALEF_HAMZA_ABOVE	arabic.h	249;"	d
a_f_LAM_ALEF_HAMZA_BELOW	arabic.h	251;"	d
a_f_LAM_ALEF_MADDA_ABOVE	arabic.h	247;"	d
a_f_MEEM	arabic.h	227;"	d
a_f_NOON	arabic.h	231;"	d
a_f_QAF	arabic.h	215;"	d
a_f_REH	arabic.h	175;"	d
a_f_SAD	arabic.h	187;"	d
a_f_SEEN	arabic.h	179;"	d
a_f_SHEEN	arabic.h	183;"	d
a_f_TAH	arabic.h	195;"	d
a_f_TEH	arabic.h	151;"	d
a_f_TEH_MARBUTA	arabic.h	149;"	d
a_f_THAL	arabic.h	173;"	d
a_f_THEH	arabic.h	155;"	d
a_f_WAW	arabic.h	239;"	d
a_f_WAW_HAMZA	arabic.h	135;"	d
a_f_YEH	arabic.h	243;"	d
a_f_YEH_HAMZA	arabic.h	139;"	d
a_f_ZAH	arabic.h	199;"	d
a_f_ZAIN	arabic.h	177;"	d
a_i_AIN	arabic.h	204;"	d
a_i_BEH	arabic.h	146;"	d
a_i_DAD	arabic.h	192;"	d
a_i_FEH	arabic.h	212;"	d
a_i_GHAIN	arabic.h	208;"	d
a_i_HAH	arabic.h	164;"	d
a_i_HEH	arabic.h	236;"	d
a_i_JEEM	arabic.h	160;"	d
a_i_KAF	arabic.h	220;"	d
a_i_KHAH	arabic.h	168;"	d
a_i_LAM	arabic.h	224;"	d
a_i_MEEM	arabic.h	228;"	d
a_i_NOON	arabic.h	232;"	d
a_i_QAF	arabic.h	216;"	d
a_i_SAD	arabic.h	188;"	d
a_i_SEEN	arabic.h	180;"	d
a_i_SHEEN	arabic.h	184;"	d
a_i_TAH	arabic.h	196;"	d
a_i_TEH	arabic.h	152;"	d
a_i_THEH	arabic.h	156;"	d
a_i_YEH	arabic.h	244;"	d
a_i_YEH_HAMZA	arabic.h	140;"	d
a_i_ZAH	arabic.h	200;"	d
a_m_AIN	arabic.h	205;"	d
a_m_BEH	arabic.h	147;"	d
a_m_DAD	arabic.h	193;"	d
a_m_DAMMA	arabic.h	121;"	d
a_m_FATHA	arabic.h	119;"	d
a_m_FEH	arabic.h	213;"	d
a_m_GHAIN	arabic.h	209;"	d
a_m_HAH	arabic.h	165;"	d
a_m_HEH	arabic.h	237;"	d
a_m_JEEM	arabic.h	161;"	d
a_m_KAF	arabic.h	221;"	d
a_m_KASRA	arabic.h	123;"	d
a_m_KHAH	arabic.h	169;"	d
a_m_LAM	arabic.h	225;"	d
a_m_MEEM	arabic.h	229;"	d
a_m_NOON	arabic.h	233;"	d
a_m_QAF	arabic.h	217;"	d
a_m_SAD	arabic.h	189;"	d
a_m_SEEN	arabic.h	181;"	d
a_m_SHADDA	arabic.h	125;"	d
a_m_SHEEN	arabic.h	185;"	d
a_m_SUKUN	arabic.h	127;"	d
a_m_TAH	arabic.h	197;"	d
a_m_TATWEEL_FATHATAN	arabic.h	113;"	d
a_m_TEH	arabic.h	153;"	d
a_m_THEH	arabic.h	157;"	d
a_m_YEH	arabic.h	245;"	d
a_m_YEH_HAMZA	arabic.h	141;"	d
a_m_ZAH	arabic.h	201;"	d
a_s_AIN	arabic.h	202;"	d
a_s_ALEF	arabic.h	142;"	d
a_s_ALEF_HAMZA_ABOVE	arabic.h	132;"	d
a_s_ALEF_HAMZA_BELOW	arabic.h	136;"	d
a_s_ALEF_MADDA	arabic.h	130;"	d
a_s_ALEF_MAKSURA	arabic.h	240;"	d
a_s_BEH	arabic.h	144;"	d
a_s_DAD	arabic.h	190;"	d
a_s_DAL	arabic.h	170;"	d
a_s_DAMMA	arabic.h	120;"	d
a_s_DAMMATAN	arabic.h	114;"	d
a_s_FATHA	arabic.h	118;"	d
a_s_FATHATAN	arabic.h	112;"	d
a_s_FEH	arabic.h	210;"	d
a_s_GHAIN	arabic.h	206;"	d
a_s_HAH	arabic.h	162;"	d
a_s_HAMZA	arabic.h	129;"	d
a_s_HEH	arabic.h	234;"	d
a_s_JEEM	arabic.h	158;"	d
a_s_KAF	arabic.h	218;"	d
a_s_KASRA	arabic.h	122;"	d
a_s_KASRATAN	arabic.h	116;"	d
a_s_KHAH	arabic.h	166;"	d
a_s_LAM	arabic.h	222;"	d
a_s_LAM_ALEF	arabic.h	252;"	d
a_s_LAM_ALEF_HAMZA_ABOVE	arabic.h	248;"	d
a_s_LAM_ALEF_HAMZA_BELOW	arabic.h	250;"	d
a_s_LAM_ALEF_MADDA_ABOVE	arabic.h	246;"	d
a_s_MEEM	arabic.h	226;"	d
a_s_NOON	arabic.h	230;"	d
a_s_QAF	arabic.h	214;"	d
a_s_REH	arabic.h	174;"	d
a_s_SAD	arabic.h	186;"	d
a_s_SEEN	arabic.h	178;"	d
a_s_SHADDA	arabic.h	124;"	d
a_s_SHEEN	arabic.h	182;"	d
a_s_SUKUN	arabic.h	126;"	d
a_s_TAH	arabic.h	194;"	d
a_s_TEH	arabic.h	150;"	d
a_s_TEH_MARBUTA	arabic.h	148;"	d
a_s_THAL	arabic.h	172;"	d
a_s_THEH	arabic.h	154;"	d
a_s_WAW	arabic.h	238;"	d
a_s_WAW_HAMZA	arabic.h	134;"	d
a_s_YEH	arabic.h	242;"	d
a_s_YEH_HAMZA	arabic.h	138;"	d
a_s_ZAH	arabic.h	198;"	d
a_s_ZAIN	arabic.h	176;"	d
aborted_in_try	ex_eval.c	/^aborted_in_try()$/;"	f
aborting	ex_eval.c	/^aborting()$/;"	f
accel_group	gui.h	/^    GtkAccelGroup *accel_group;$/;"	m	struct:Gui
aco_save_T	structs.h	/^} aco_save_T;$/;"	t	typeref:struct:__anon42
actext	structs.h	/^    char_u	*actext;	    \/* accelerator text (after TAB) *\/$/;"	m	struct:VimMenu
active	gui_amiga.c	/^    BOOL	active;$/;"	m	struct:__anon26	file:
addEventHandler	gui_beval.c	/^addEventHandler(GtkWidget *target, BalloonEval *beval)$/;"	f	file:
addEventHandler	gui_beval.c	/^addEventHandler(target, beval)$/;"	f	file:
add_buff	getchar.c	/^add_buff(buf, s, slen)$/;"	f	file:
add_char2buf	edit.c	/^add_char2buf(c, s)$/;"	f
add_char_buff	getchar.c	/^add_char_buff(buf, c)$/;"	f	file:
add_keyword	syntax.c	/^add_keyword(name, id, flags, cont_in_list, next_list)$/;"	f	file:
add_long_to_buf	term.c	/^add_long_to_buf(val, dst)$/;"	f
add_map	getchar.c	/^add_map(map, mode)$/;"	f
add_menu_path	menu.c	/^add_menu_path(menu_path, menuarg, pri_tab, call_data$/;"	f	file:
add_msg_hist	message.c	/^add_msg_hist(s, len, attr)$/;"	f	file:
add_num_buff	getchar.c	/^add_num_buff(buf, n)$/;"	f	file:
add_pathsep	misc1.c	/^add_pathsep(p)$/;"	f
add_termcap_entry	term.c	/^add_termcap_entry(name, force)$/;"	f
add_termcode	term.c	/^add_termcode(name, string, use_8bit)$/;"	f
add_to_history	ex_getln.c	/^add_to_history(histype, new_entry, in_map, sep)$/;"	f
add_to_input_buf	ui.c	/^add_to_input_buf(s, len)$/;"	f
add_to_input_buf_csi	ui.c	/^add_to_input_buf_csi(char_u *str, int len)$/;"	f
add_to_showcmd	normal.c	/^add_to_showcmd(c)$/;"	f
add_to_showcmd_c	normal.c	/^add_to_showcmd_c(c)$/;"	f
addfile	misc1.c	/^addfile(gap, f, flags)$/;"	f
addpath	testdir/test49.vim	/^    let addpath = ""$/;"	v
addr	quickfix.c	/^    char_u	    addr[FMT_PATTERNS]; \/* indices of used % patterns *\/$/;"	m	struct:eformat	file:
addr_count	ex_cmds.h	/^    int		addr_count;	\/* the number of addresses given *\/$/;"	m	struct:exarg
addsigntype	netbeans.c	/^addsigntype($/;"	f	file:
addstar	ex_getln.c	/^addstar(fname, len, context)$/;"	f
adjust_clip_reg	ops.c	/^adjust_clip_reg(rp)$/;"	f
adjust_cursor_col	misc2.c	/^adjust_cursor_col()$/;"	f
adjust_for_sel	normal.c	/^adjust_for_sel(cap)$/;"	f	file:
advance_reginput	regexp.c	/^advance_reginput()$/;"	f	file:
ae_attr	structs.h	/^    short	    ae_attr;		\/* HL_BOLD, etc. *\/$/;"	m	struct:attr_entry
ae_fname	structs.h	/^    char_u	*ae_fname;	\/* file name as specified *\/$/;"	m	struct:argentry
ae_fnum	structs.h	/^    int		ae_fnum;	\/* buffer number with expanded file name *\/$/;"	m	struct:argentry
ae_u	structs.h	/^    } ae_u;$/;"	m	struct:attr_entry	typeref:union:attr_entry::__anon34
aentry_T	structs.h	/^} aentry_T;$/;"	t	typeref:struct:argentry
after_label	misc1.c	/^after_label(l)$/;"	f	file:
ai_col	globals.h	/^EXTERN colnr_T	ai_col INIT(= 0);$/;"	v
al_ga	structs.h	/^    garray_T	al_ga;		\/* growarray with the array of file names *\/$/;"	m	struct:arglist
al_refcount	structs.h	/^    int		al_refcount;	\/* number of windows using this arglist *\/$/;"	m	struct:arglist
alist_T	structs.h	/^} alist_T;$/;"	t	typeref:struct:arglist
alist_add	ex_docmd.c	/^alist_add(al, fname, set_fnum)$/;"	f
alist_add_list	ex_cmds2.c	/^alist_add_list(count, files, after)$/;"	f	file:
alist_check_arg_idx	ex_cmds2.c	/^alist_check_arg_idx()$/;"	f	file:
alist_clear	ex_docmd.c	/^alist_clear(al)$/;"	f	file:
alist_expand	ex_docmd.c	/^alist_expand()$/;"	f
alist_init	ex_docmd.c	/^alist_init(al)$/;"	f
alist_name	buffer.c	/^alist_name(aep)$/;"	f
alist_new	ex_docmd.c	/^alist_new()$/;"	f
alist_set	ex_docmd.c	/^alist_set(al, count, files, use_curbuf)$/;"	f
alist_slash_adjust	ex_docmd.c	/^alist_slash_adjust()$/;"	f
alist_unlink	ex_docmd.c	/^alist_unlink(al)$/;"	f
alloc	misc2.c	/^alloc(size)$/;"	f
alloc_check	misc2.c	/^alloc_check(size)$/;"	f
alloc_clear	misc2.c	/^alloc_clear(size)$/;"	f
alloc_cmdbuff	ex_getln.c	/^alloc_cmdbuff(len)$/;"	f	file:
alloc_string_var	eval.c	/^alloc_string_var(s)$/;"	f	file:
alloc_typebuf	getchar.c	/^alloc_typebuf()$/;"	f
alloc_var	eval.c	/^alloc_var()$/;"	f	file:
alloced	gui_amiga.c	/^    BOOL alloced;$/;"	m	struct:MyColor	file:
allow_dirs	fileio.c	/^    char	    allow_dirs;		\/* Pattern may match whole path *\/$/;"	m	struct:AutoPat	file:
allow_keys	globals.h	/^EXTERN int	allow_keys INIT(= FALSE);   \/* allow key codes when no_mapping$/;"	v
already_warned	fileio.c	/^static int already_warned = FALSE;$/;"	v	file:
amount	ex_cmds.h	/^    int		amount;		\/* number of '>' or '<' for shift command *\/$/;"	m	struct:exarg
app_context	globals.h	/^EXTERN XtAppContext app_context INIT(= (XtAppContext)NULL);$/;"	v
append	ex_cmds.h	/^    int		append;		\/* TRUE with ":w >>file" command *\/$/;"	m	struct:exarg
append_arg_number	buffer.c	/^append_arg_number(wp, buf, add_file, maxlen)$/;"	f
append_redir	ex_cmds.c	/^append_redir(buf, opt, fname)$/;"	f
appended_lines	misc1.c	/^appended_lines(lnum, count)$/;"	f
appended_lines_mark	misc1.c	/^appended_lines_mark(lnum, count)$/;"	f
apply_autocmds	fileio.c	/^apply_autocmds(event, fname, fname_io, force, buf)$/;"	f
apply_autocmds_exarg	fileio.c	/^apply_autocmds_exarg(event, fname, fname_io, force, buf, eap)$/;"	f	file:
apply_autocmds_group	fileio.c	/^apply_autocmds_group(event, fname, fname_io, force, group, buf, eap)$/;"	f	file:
apply_autocmds_retval	fileio.c	/^apply_autocmds_retval(event, fname, fname_io, force, buf, retval)$/;"	f
approximate_botline_win	move.c	/^approximate_botline_win(wp)$/;"	f
arabic_combine	mbyte.c	/^arabic_combine(one, two)$/;"	f
arabic_maycombine	mbyte.c	/^arabic_maycombine(two)$/;"	f
arabic_shape	arabic.c	/^arabic_shape(c, ccp, c1p, prev_c, prev_c1, next_c)$/;"	f
arg	ex_cmds.h	/^    char_u	*arg;		\/* argument of the command *\/$/;"	m	struct:exarg
arg	getchar.c	/^    char_u	*arg;$/;"	m	struct:initmap	file:
arg	structs.h	/^    int		arg;		\/* extra argument from nv_cmds[] *\/$/;"	m	struct:cmdarg
arg_all	ex_docmd.c	/^arg_all()$/;"	f	file:
arg_had_last	globals.h	/^EXTERN int	arg_had_last INIT(= FALSE); \/* accessed last file in$/;"	v
argcount	eval.c	/^    int		argcount;	\/* nr of arguments *\/$/;"	m	struct:funccall	file:
argentry	structs.h	/^typedef struct argentry$/;"	s
arglist	structs.h	/^typedef struct arglist$/;"	s
args	eval.c	/^    garray_T	args;		\/* arguments *\/$/;"	m	struct:ufunc	file:
argt	ex_cmds.h	/^    long	argt;		\/* flags for the command *\/$/;"	m	struct:exarg
arguments	structs.h	/^    char_u	*arguments;$/;"	m	struct:__anon45
argvars	eval.c	/^    VAR		argvars;	\/* arguments *\/$/;"	m	struct:funccall	file:
arrow_used	globals.h	/^EXTERN int	arrow_used;		\/* Normally FALSE, set to TRUE after$/;"	v
ascii_font	gui.h	/^    PangoFont	     *ascii_font;   \/* cached font for ASCII strings *\/$/;"	m	struct:Gui
ascii_glyphs	gui.h	/^    PangoGlyphString *ascii_glyphs; \/* cached code point -> glyph map *\/$/;"	m	struct:Gui
ask_yesno	misc1.c	/^ask_yesno(str, direct)$/;"	f
at_start	regexp.c	/^static int	at_start;	\/* True when on the first character *\/$/;"	v	file:
atexitDoThis	gui_amiga.c	/^atexitDoThis(void)$/;"	f
attr	message.c	/^    int			attr;$/;"	m	struct:msg_hist	file:
attr	screen.c	/^    int		attr;	\/* attributes to be used for a match *\/$/;"	m	struct:__anon1	file:
attr_cur	screen.c	/^    int		attr_cur; \/* attributes currently active in win_line() *\/$/;"	m	struct:__anon1	file:
attr_entry	structs.h	/^typedef struct attr_entry$/;"	s
attrentry_T	structs.h	/^} attrentry_T;$/;"	t	typeref:struct:attr_entry
au_cleanup	fileio.c	/^au_cleanup()$/;"	f	file:
au_del_group	fileio.c	/^au_del_group(name)$/;"	f	file:
au_exists	fileio.c	/^au_exists(name, name_end, pattern)$/;"	f
au_find_group	fileio.c	/^au_find_group(name)$/;"	f	file:
au_get_grouparg	fileio.c	/^au_get_grouparg(argp)$/;"	f	file:
au_need_clean	fileio.c	/^static int au_need_clean = FALSE;   \/* need to delete marked patterns *\/$/;"	v	file:
au_new_curbuf	globals.h	/^EXTERN buf_T	*au_new_curbuf INIT(= NULL);$/;"	v
au_new_group	fileio.c	/^au_new_group(name)$/;"	f	file:
au_remove_cmds	fileio.c	/^au_remove_cmds(ap)$/;"	f	file:
au_remove_pat	fileio.c	/^au_remove_pat(ap)$/;"	f	file:
aucmd_prepbuf	fileio.c	/^aucmd_prepbuf(aco, buf)$/;"	f
aucmd_restbuf	fileio.c	/^aucmd_restbuf(aco)$/;"	f
augroups	fileio.c	/^garray_T augroups = {0, 0, sizeof(char_u *), 10, NULL};$/;"	v
auto_event	vim.h	/^enum auto_event$/;"	g
auto_format	edit.c	/^auto_format(trailblank, prev_line)$/;"	f
auto_next_pat	fileio.c	/^auto_next_pat(apc, stop_at_last)$/;"	f	file:
autocmd_block	globals.h	/^EXTERN int	autocmd_block INIT(= 0);	\/* block all autocmds *\/$/;"	v
autocmd_bufnr	globals.h	/^EXTERN int	autocmd_bufnr INIT(= 0);     \/* fnum for <abuf> on cmdline *\/$/;"	v
autocmd_busy	globals.h	/^EXTERN int	autocmd_busy INIT(= FALSE);	\/* Is apply_autocmds() busy? *\/$/;"	v
autocmd_fname	globals.h	/^EXTERN char_u	*autocmd_fname INIT(= NULL); \/* fname for <afile> on cmdline *\/$/;"	v
autocmd_match	globals.h	/^EXTERN char_u	*autocmd_match INIT(= NULL); \/* name for <amatch> on cmdline *\/$/;"	v
autocmd_nested	fileio.c	/^static int	autocmd_nested = FALSE;$/;"	v	file:
autocmd_no_enter	globals.h	/^EXTERN int	autocmd_no_enter INIT(= FALSE); \/* *Enter autocmds disabled *\/$/;"	v
autocmd_no_leave	globals.h	/^EXTERN int	autocmd_no_leave INIT(= FALSE); \/* *Leave autocmds disabled *\/$/;"	v
autowrite	ex_cmds2.c	/^autowrite(buf, forceit)$/;"	f
autowrite_all	ex_cmds2.c	/^autowrite_all()$/;"	f
available	vim.h	/^    int		available;	\/* Is clipboard available? *\/$/;"	m	struct:VimClipboard
b	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
b0_dirty	memline.c	169;"	d	file:
b0_fname	memline.c	/^    char_u	b0_fname[B0_FNAME_SIZE]; \/* name of file being edited *\/$/;"	m	struct:block0	file:
b0_hname	memline.c	/^    char_u	b0_hname[B0_HNAME_SIZE]; \/* host name (if it has a name) *\/$/;"	m	struct:block0	file:
b0_id	memline.c	/^    char_u	b0_id[2];	\/* id for block 0: BLOCK0_ID0 and BLOCK0_ID1 *\/$/;"	m	struct:block0	file:
b0_ino	memline.c	/^    char_u	b0_ino[4];	\/* inode of b0_fname *\/$/;"	m	struct:block0	file:
b0_magic_char	memline.c	/^    char_u	b0_magic_char;	\/* check for last char *\/$/;"	m	struct:block0	file:
b0_magic_int	memline.c	/^    int		b0_magic_int;	\/* check for byte order of int *\/$/;"	m	struct:block0	file:
b0_magic_long	memline.c	/^    long	b0_magic_long;	\/* check for byte order of long *\/$/;"	m	struct:block0	file:
b0_magic_short	memline.c	/^    short	b0_magic_short;	\/* check for byte order of short *\/$/;"	m	struct:block0	file:
b0_magic_wrong	memline.c	/^b0_magic_wrong(b0p)$/;"	f	file:
b0_mtime	memline.c	/^    char_u	b0_mtime[4];	\/* last modification time of file *\/$/;"	m	struct:block0	file:
b0_page_size	memline.c	/^    char_u	b0_page_size[4];\/* number of bytes per page *\/$/;"	m	struct:block0	file:
b0_pid	memline.c	/^    char_u	b0_pid[4];	\/* process id of creator (or 0) *\/$/;"	m	struct:block0	file:
b0_uname	memline.c	/^    char_u	b0_uname[B0_UNAME_SIZE]; \/* name of user (uid if no name) *\/$/;"	m	struct:block0	file:
b0_version	memline.c	/^    char_u	b0_version[10];	\/* Vim version string *\/$/;"	m	struct:block0	file:
b_FSSpec	structs.h	/^    FSSpec	b_FSSpec;	\/* MacOS File Identification *\/$/;"	m	struct:file_buffer
b_block_head	structs.h	/^    mblock_T	b_block_head;	\/* head of allocated memory block list *\/$/;"	m	struct:file_buffer
b_changed	structs.h	/^    int		b_changed;	\/* 'modified': Set to TRUE if something in the$/;"	m	struct:file_buffer
b_changedtick	structs.h	/^    int		b_changedtick;	\/* incremented for each change, also for undo *\/$/;"	m	struct:file_buffer
b_changelist	structs.h	/^    pos_T	b_changelist[JUMPLISTSIZE];$/;"	m	struct:file_buffer
b_changelistlen	structs.h	/^    int		b_changelistlen;	\/* number of active entries *\/$/;"	m	struct:file_buffer
b_chartab	structs.h	/^    char_u	b_chartab[32];$/;"	m	struct:file_buffer
b_dev	structs.h	/^    int		b_dev;		\/* device number (-1 if not set) *\/$/;"	m	struct:file_buffer
b_did_warn	structs.h	/^    int		b_did_warn;	\/* Set to 1 if user has been warned on first$/;"	m	struct:file_buffer
b_fab_mrs	structs.h	/^    unsigned int b_fab_mrs;	\/* Max record size  *\/$/;"	m	struct:file_buffer
b_fab_rat	structs.h	/^    char	 b_fab_rat;	\/* Record attribute *\/$/;"	m	struct:file_buffer
b_fab_rfm	structs.h	/^    char	 b_fab_rfm;	\/* Record format    *\/$/;"	m	struct:file_buffer
b_ffname	structs.h	/^    char_u	*b_ffname;	\/* full path file name *\/$/;"	m	struct:file_buffer
b_first_abbr	structs.h	/^    mapblock_T	*b_first_abbr;$/;"	m	struct:file_buffer
b_flags	structs.h	/^    int		b_flags;	\/* various BF_ flags *\/$/;"	m	struct:file_buffer
b_fname	structs.h	/^    char_u	*b_fname;	\/* current file name *\/$/;"	m	struct:file_buffer
b_fnum	structs.h	/^    int		b_fnum;		\/* buffer number for this file. *\/$/;"	m	struct:file_buffer
b_help	structs.h	/^    int		b_help;		\/* buffer for help file (when set b_p_bt is$/;"	m	struct:file_buffer
b_ino	structs.h	/^    ino_t	b_ino;		\/* inode number *\/$/;"	m	struct:file_buffer
b_keywtab	structs.h	/^    keyentry_T	**b_keywtab;		\/* syntax keywords hash table *\/$/;"	m	struct:file_buffer
b_keywtab_ic	structs.h	/^    keyentry_T	**b_keywtab_ic;		\/* idem, ignore case *\/$/;"	m	struct:file_buffer
b_kmap_ga	structs.h	/^    garray_T	b_kmap_ga;	\/* the keymap table *\/$/;"	m	struct:file_buffer
b_kmap_state	structs.h	/^    short	b_kmap_state;	\/* using "lmap" mappings *\/$/;"	m	struct:file_buffer
b_last_change	structs.h	/^    pos_T	b_last_change;	\/* position of last change: '. mark *\/$/;"	m	struct:file_buffer
b_last_cursor	structs.h	/^    pos_T	b_last_cursor;	\/* cursor position when last unloading this$/;"	m	struct:file_buffer
b_last_insert	structs.h	/^    pos_T	b_last_insert;	\/* where Insert mode was left *\/$/;"	m	struct:file_buffer
b_m_search	structs.h	/^    minfo_T	*b_m_search;	\/* pointer to chunk before previously$/;"	m	struct:file_buffer
b_maphash	structs.h	/^    mapblock_T	*(b_maphash[256]);$/;"	m	struct:file_buffer
b_marks_read	structs.h	/^    int		b_marks_read;	\/* Have we read viminfo marks yet? *\/$/;"	m	struct:file_buffer
b_may_swap	structs.h	/^    int		b_may_swap;$/;"	m	struct:file_buffer
b_mb_current	structs.h	/^    mblock_T	*b_mb_current;	\/* block where m_search points in *\/$/;"	m	struct:file_buffer
b_ml	structs.h	/^    memline_T	b_ml;		\/* associated memline (also contains line$/;"	m	struct:file_buffer
b_mod_bot	structs.h	/^    linenr_T	b_mod_bot;	\/* lnum below last changed line, AFTER the$/;"	m	struct:file_buffer
b_mod_set	structs.h	/^    int		b_mod_set;	\/* TRUE when there are changes since the last$/;"	m	struct:file_buffer
b_mod_top	structs.h	/^    linenr_T	b_mod_top;	\/* topmost lnum that was changed *\/$/;"	m	struct:file_buffer
b_mod_xlines	structs.h	/^    long	b_mod_xlines;	\/* number of extra buffer lines inserted;$/;"	m	struct:file_buffer
b_mtime	structs.h	/^    long	b_mtime;	\/* last change time of original file *\/$/;"	m	struct:file_buffer
b_mtime_read	structs.h	/^    long	b_mtime_read;	\/* last change time when reading *\/$/;"	m	struct:file_buffer
b_namedm	structs.h	/^    pos_T	b_namedm[NMARKS]; \/* current named marks (mark.c) *\/$/;"	m	struct:file_buffer
b_netbeans_file	structs.h	/^    int		b_netbeans_file;    \/* TRUE when buffer is owned by NetBeans *\/$/;"	m	struct:file_buffer
b_new_change	structs.h	/^    int		b_new_change;		\/* set by u_savecommon() *\/$/;"	m	struct:file_buffer
b_next	structs.h	/^    buf_T	*b_next;	\/* links in list of buffers *\/$/;"	m	struct:file_buffer
b_next	structs.h	/^    struct buffblock	*b_next;	\/* pointer to next buffblock *\/$/;"	m	struct:buffblock	typeref:struct:buffblock::buffblock
b_nwindows	structs.h	/^    int		b_nwindows;	\/* nr of windows open on this buffer *\/$/;"	m	struct:file_buffer
b_op_end	structs.h	/^    pos_T	b_op_end;$/;"	m	struct:file_buffer
b_op_start	structs.h	/^    pos_T	b_op_start;$/;"	m	struct:file_buffer
b_orig_mode	structs.h	/^    int		b_orig_mode;	\/* mode of original file *\/$/;"	m	struct:file_buffer
b_orig_size	structs.h	/^    size_t	b_orig_size;	\/* size of original file in bytes *\/$/;"	m	struct:file_buffer
b_p_ai	structs.h	/^    int		b_p_ai;		\/* 'autoindent' *\/$/;"	m	struct:file_buffer
b_p_ai_nopaste	structs.h	/^    int		b_p_ai_nopaste;	\/* b_p_ai saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_ar	structs.h	/^    int		b_p_ar;		\/* 'autoread' local value *\/$/;"	m	struct:file_buffer
b_p_bh	structs.h	/^    char_u	*b_p_bh;	\/* 'bufhidden' *\/$/;"	m	struct:file_buffer
b_p_bin	structs.h	/^    int		b_p_bin;	\/* 'binary' *\/$/;"	m	struct:file_buffer
b_p_bl	structs.h	/^    int		b_p_bl;		\/* 'buflisted' *\/$/;"	m	struct:file_buffer
b_p_bomb	structs.h	/^    int		b_p_bomb;	\/* 'bomb' *\/$/;"	m	struct:file_buffer
b_p_bt	structs.h	/^    char_u	*b_p_bt;	\/* 'buftype' *\/$/;"	m	struct:file_buffer
b_p_ci	structs.h	/^    int		b_p_ci;		\/* 'copyindent' *\/$/;"	m	struct:file_buffer
b_p_cin	structs.h	/^    int		b_p_cin;	\/* 'cindent' *\/$/;"	m	struct:file_buffer
b_p_cink	structs.h	/^    char_u	*b_p_cink;	\/* 'cinkeys' *\/$/;"	m	struct:file_buffer
b_p_cino	structs.h	/^    char_u	*b_p_cino;	\/* 'cinoptions' *\/$/;"	m	struct:file_buffer
b_p_cinw	structs.h	/^    char_u	*b_p_cinw;	\/* 'cinwords' *\/$/;"	m	struct:file_buffer
b_p_cms	structs.h	/^    char_u	*b_p_cms;	\/* 'commentstring' *\/$/;"	m	struct:file_buffer
b_p_com	structs.h	/^    char_u	*b_p_com;	\/* 'comments' *\/$/;"	m	struct:file_buffer
b_p_cpt	structs.h	/^    char_u	*b_p_cpt;	\/* 'complete' *\/$/;"	m	struct:file_buffer
b_p_def	structs.h	/^    char_u	*b_p_def;	\/* 'define' local value *\/$/;"	m	struct:file_buffer
b_p_dict	structs.h	/^    char_u	*b_p_dict;	\/* 'dictionary' local value *\/$/;"	m	struct:file_buffer
b_p_efm	structs.h	/^    char_u	*b_p_efm;	\/* 'errorformat' local value *\/$/;"	m	struct:file_buffer
b_p_eol	structs.h	/^    int		b_p_eol;	\/* 'endofline' *\/$/;"	m	struct:file_buffer
b_p_ep	structs.h	/^    char_u	*b_p_ep;	\/* 'equalprg' local value *\/$/;"	m	struct:file_buffer
b_p_et	structs.h	/^    int		b_p_et;		\/* 'expandtab' *\/$/;"	m	struct:file_buffer
b_p_et_nobin	structs.h	/^    int		b_p_et_nobin;	\/* b_p_et saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_fenc	structs.h	/^    char_u	*b_p_fenc;	\/* 'fileencoding' *\/$/;"	m	struct:file_buffer
b_p_ff	structs.h	/^    char_u	*b_p_ff;	\/* 'fileformat' *\/$/;"	m	struct:file_buffer
b_p_fo	structs.h	/^    char_u	*b_p_fo;	\/* 'formatoptions' *\/$/;"	m	struct:file_buffer
b_p_ft	structs.h	/^    char_u	*b_p_ft;	\/* 'filetype' *\/$/;"	m	struct:file_buffer
b_p_gp	structs.h	/^    char_u	*b_p_gp;	\/* 'grepprg' local value *\/$/;"	m	struct:file_buffer
b_p_iminsert	structs.h	/^    long	b_p_iminsert;	\/* input mode for insert *\/$/;"	m	struct:file_buffer
b_p_imsearch	structs.h	/^    long	b_p_imsearch;	\/* input mode for search *\/$/;"	m	struct:file_buffer
b_p_inc	structs.h	/^    char_u	*b_p_inc;	\/* 'include' *\/$/;"	m	struct:file_buffer
b_p_inde	structs.h	/^    char_u	*b_p_inde;	\/* 'indentexpr' *\/$/;"	m	struct:file_buffer
b_p_indk	structs.h	/^    char_u	*b_p_indk;	\/* 'indentkeys' *\/$/;"	m	struct:file_buffer
b_p_inex	structs.h	/^    char_u	*b_p_inex;	\/* 'includeexpr' *\/$/;"	m	struct:file_buffer
b_p_inf	structs.h	/^    int		b_p_inf;	\/* 'infercase' *\/$/;"	m	struct:file_buffer
b_p_initialized	structs.h	/^    int		b_p_initialized;	\/* set when options initialized *\/$/;"	m	struct:file_buffer
b_p_isk	structs.h	/^    char_u	*b_p_isk;	\/* 'iskeyword' *\/$/;"	m	struct:file_buffer
b_p_key	structs.h	/^    char_u	*b_p_key;	\/* 'key' *\/$/;"	m	struct:file_buffer
b_p_keymap	structs.h	/^    char_u	*b_p_keymap;	\/* 'keymap' *\/$/;"	m	struct:file_buffer
b_p_kp	structs.h	/^    char_u	*b_p_kp;	\/* 'keywordprg' *\/$/;"	m	struct:file_buffer
b_p_lisp	structs.h	/^    int		b_p_lisp;	\/* 'lisp' *\/$/;"	m	struct:file_buffer
b_p_ma	structs.h	/^    int		b_p_ma;		\/* 'modifiable' *\/$/;"	m	struct:file_buffer
b_p_ml	structs.h	/^    int		b_p_ml;		\/* 'modeline' *\/$/;"	m	struct:file_buffer
b_p_ml_nobin	structs.h	/^    int		b_p_ml_nobin;	\/* b_p_ml saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_mp	structs.h	/^    char_u	*b_p_mp;	\/* 'makeprg' local value *\/$/;"	m	struct:file_buffer
b_p_mps	structs.h	/^    char_u	*b_p_mps;	\/* 'matchpairs' *\/$/;"	m	struct:file_buffer
b_p_nf	structs.h	/^    char_u	*b_p_nf;	\/* 'nrformats' *\/$/;"	m	struct:file_buffer
b_p_oft	structs.h	/^    char_u	*b_p_oft;	\/* 'osfiletype' *\/$/;"	m	struct:file_buffer
b_p_path	structs.h	/^    char_u	*b_p_path;	\/* 'path' local value *\/$/;"	m	struct:file_buffer
b_p_pi	structs.h	/^    int		b_p_pi;		\/* 'preserveindent' *\/$/;"	m	struct:file_buffer
b_p_ro	structs.h	/^    int		b_p_ro;		\/* 'readonly' *\/$/;"	m	struct:file_buffer
b_p_si	structs.h	/^    int		b_p_si;		\/* 'smartindent' *\/$/;"	m	struct:file_buffer
b_p_sn	structs.h	/^    int		b_p_sn;		\/* 'shortname' *\/$/;"	m	struct:file_buffer
b_p_sts	structs.h	/^    long	b_p_sts;	\/* 'softtabstop' *\/$/;"	m	struct:file_buffer
b_p_sts_nopaste	structs.h	/^    long	b_p_sts_nopaste; \/* b_p_sts saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_sua	structs.h	/^    char_u	*b_p_sua;	\/* 'suffixesadd' *\/$/;"	m	struct:file_buffer
b_p_sw	structs.h	/^    long	b_p_sw;		\/* 'shiftwidth' *\/$/;"	m	struct:file_buffer
b_p_swf	structs.h	/^    int		b_p_swf;	\/* 'swapfile' *\/$/;"	m	struct:file_buffer
b_p_syn	structs.h	/^    char_u	*b_p_syn;	\/* 'syntax' *\/$/;"	m	struct:file_buffer
b_p_tags	structs.h	/^    char_u	*b_p_tags;	\/* 'tags' local value *\/$/;"	m	struct:file_buffer
b_p_ts	structs.h	/^    long	b_p_ts;		\/* 'tabstop' *\/$/;"	m	struct:file_buffer
b_p_tsr	structs.h	/^    char_u	*b_p_tsr;	\/* 'thesaurus' local value *\/$/;"	m	struct:file_buffer
b_p_tw	structs.h	/^    long	b_p_tw;		\/* 'textwidth' *\/$/;"	m	struct:file_buffer
b_p_tw_nobin	structs.h	/^    long	b_p_tw_nobin;	\/* b_p_tw saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_tw_nopaste	structs.h	/^    long	b_p_tw_nopaste;	\/* b_p_tw saved for paste mode *\/$/;"	m	struct:file_buffer
b_p_tx	structs.h	/^    int		b_p_tx;		\/* 'textmode' *\/$/;"	m	struct:file_buffer
b_p_wm	structs.h	/^    long	b_p_wm;		\/* 'wrapmargin' *\/$/;"	m	struct:file_buffer
b_p_wm_nobin	structs.h	/^    long	b_p_wm_nobin;	\/* b_p_wm saved for binary mode *\/$/;"	m	struct:file_buffer
b_p_wm_nopaste	structs.h	/^    long	b_p_wm_nopaste;	\/* b_p_wm saved for paste mode *\/$/;"	m	struct:file_buffer
b_prev	structs.h	/^    buf_T	*b_prev;$/;"	m	struct:file_buffer
b_saving	structs.h	/^    int		b_saving;	\/* Set to TRUE if we are in the middle of$/;"	m	struct:file_buffer
b_scanned	structs.h	/^    int		b_scanned;	\/* ^N\/^P have scanned this buffer *\/$/;"	m	struct:file_buffer
b_sfname	structs.h	/^    char_u	*b_sfname;	\/* short file name *\/$/;"	m	struct:file_buffer
b_shortname	structs.h	/^    int		b_shortname;	\/* this file has an 8.3 file name *\/$/;"	m	struct:file_buffer
b_signlist	structs.h	/^    signlist_T	*b_signlist;	\/* list of signs to draw *\/$/;"	m	struct:file_buffer
b_sniff	structs.h	/^    int		b_sniff;	\/* file was loaded through Sniff *\/$/;"	m	struct:file_buffer
b_sst_array	structs.h	/^    synstate_T	*b_sst_array;$/;"	m	struct:file_buffer
b_sst_check_lnum	structs.h	/^    linenr_T	b_sst_check_lnum;$/;"	m	struct:file_buffer
b_sst_first	structs.h	/^    synstate_T	*b_sst_first;$/;"	m	struct:file_buffer
b_sst_firstfree	structs.h	/^    synstate_T	*b_sst_firstfree;$/;"	m	struct:file_buffer
b_sst_freecount	structs.h	/^    int		b_sst_freecount;$/;"	m	struct:file_buffer
b_sst_lasttick	structs.h	/^    short_u	b_sst_lasttick;	\/* last display tick *\/$/;"	m	struct:file_buffer
b_sst_len	structs.h	/^    int		b_sst_len;$/;"	m	struct:file_buffer
b_start_eol	structs.h	/^    int		b_start_eol;	\/* last line had eol when it was read *\/$/;"	m	struct:file_buffer
b_start_fenc	structs.h	/^    char_u	*b_start_fenc;	\/* 'fileencoding' when edit started or NULL *\/$/;"	m	struct:file_buffer
b_start_ffc	structs.h	/^    int		b_start_ffc;	\/* first char of 'ff' when edit started *\/$/;"	m	struct:file_buffer
b_str	structs.h	/^    char_u		b_str[1];	\/* contents (actually longer) *\/$/;"	m	struct:buffblock
b_syn_clusters	structs.h	/^    garray_T	b_syn_clusters;		\/* table for syntax clusters *\/$/;"	m	struct:file_buffer
b_syn_containedin	structs.h	/^    int		b_syn_containedin;	\/* TRUE when there is an item with a$/;"	m	struct:file_buffer
b_syn_folditems	structs.h	/^    int		b_syn_folditems;	\/* number of patterns with the HL_FOLD$/;"	m	struct:file_buffer
b_syn_ic	structs.h	/^    int		b_syn_ic;		\/* ignore case for :syn cmds *\/$/;"	m	struct:file_buffer
b_syn_linecont_ic	structs.h	/^    int		b_syn_linecont_ic;	\/* ignore-case flag for above *\/$/;"	m	struct:file_buffer
b_syn_linecont_pat	structs.h	/^    char_u	*b_syn_linecont_pat;	\/* line continuation pattern *\/$/;"	m	struct:file_buffer
b_syn_linecont_prog	structs.h	/^    regprog_T	*b_syn_linecont_prog;	\/* line continuation program *\/$/;"	m	struct:file_buffer
b_syn_patterns	structs.h	/^    garray_T	b_syn_patterns;		\/* table for syntax patterns *\/$/;"	m	struct:file_buffer
b_syn_sync_flags	structs.h	/^    int		b_syn_sync_flags;	\/* flags about how to sync *\/$/;"	m	struct:file_buffer
b_syn_sync_id	structs.h	/^    short	b_syn_sync_id;		\/* group to sync on *\/$/;"	m	struct:file_buffer
b_syn_sync_linebreaks	structs.h	/^    long	b_syn_sync_linebreaks;	\/* offset for multi-line pattern *\/$/;"	m	struct:file_buffer
b_syn_sync_maxlines	structs.h	/^    long	b_syn_sync_maxlines;	\/* maximal sync lines offset *\/$/;"	m	struct:file_buffer
b_syn_sync_minlines	structs.h	/^    long	b_syn_sync_minlines;	\/* minimal sync lines offset *\/$/;"	m	struct:file_buffer
b_syn_topgrp	structs.h	/^    int		b_syn_topgrp;		\/* for ":syntax include" *\/$/;"	m	struct:file_buffer
b_u_curhead	structs.h	/^    u_header_T	*b_u_curhead;	\/* pointer to current header *\/$/;"	m	struct:file_buffer
b_u_line_colnr	structs.h	/^    colnr_T	b_u_line_colnr;	\/* optional column number *\/$/;"	m	struct:file_buffer
b_u_line_lnum	structs.h	/^    linenr_T	b_u_line_lnum;	\/* line number of line in u_line *\/$/;"	m	struct:file_buffer
b_u_line_ptr	structs.h	/^    char_u	*b_u_line_ptr;	\/* saved line for "U" command *\/$/;"	m	struct:file_buffer
b_u_newhead	structs.h	/^    u_header_T	*b_u_newhead;	\/* pointer to newest header *\/$/;"	m	struct:file_buffer
b_u_numhead	structs.h	/^    int		b_u_numhead;	\/* current number of headers *\/$/;"	m	struct:file_buffer
b_u_oldhead	structs.h	/^    u_header_T	*b_u_oldhead;	\/* pointer to oldest header *\/$/;"	m	struct:file_buffer
b_u_synced	structs.h	/^    int		b_u_synced;	\/* entry lists are synced *\/$/;"	m	struct:file_buffer
b_ucmds	structs.h	/^    garray_T	b_ucmds;$/;"	m	struct:file_buffer
b_vars	structs.h	/^    garray_T	b_vars;		\/* internal variables, local to buffer *\/$/;"	m	struct:file_buffer
b_visual_curswant	structs.h	/^    colnr_T	b_visual_curswant;   \/* MAXCOL from w_curswant *\/$/;"	m	struct:file_buffer
b_visual_end	structs.h	/^    pos_T	b_visual_end;	\/* end position of last VIsual *\/$/;"	m	struct:file_buffer
b_visual_mode	structs.h	/^    int		b_visual_mode;	\/* VIsual_mode of last VIsual *\/$/;"	m	struct:file_buffer
b_visual_mode_eval	structs.h	/^    int		b_visual_mode_eval;  \/* b_visual_mode for visualmode() *\/$/;"	m	struct:file_buffer
b_visual_start	structs.h	/^    pos_T	b_visual_start;	\/* start pos of last VIsual *\/$/;"	m	struct:file_buffer
b_was_netbeans_file	structs.h	/^    int		b_was_netbeans_file;\/* TRUE if b_netbeans_file was once set *\/$/;"	m	struct:file_buffer
b_wininfo	structs.h	/^    wininfo_T	*b_wininfo;	\/* list of last used info for each window *\/$/;"	m	struct:file_buffer
back_gc	gui.h	/^    GC		back_gc;$/;"	m	struct:Gui
back_in_line	search.c	/^back_in_line()$/;"	f	file:
back_pixel	gui.h	/^    guicolor_T	back_pixel;	    \/* Color of background *\/$/;"	m	struct:Gui
background_argument	globals.h	/^EXTERN char	*background_argument INIT(= NULL);$/;"	v
backslash_halve	charset.c	/^backslash_halve(p)$/;"	f
backslash_halve_save	charset.c	/^backslash_halve_save(p)$/;"	f
backslash_trans	regexp.c	/^backslash_trans(c)$/;"	f	file:
backspace_until_column	edit.c	/^backspace_until_column(col)$/;"	f
balloonEval	netbeans.c	/^BalloonEval	*balloonEval = NULL;$/;"	v
balloonLabel	gui_beval.h	/^    GtkWidget		*balloonLabel;$/;"	m	struct:BalloonEvalStruct
balloonShell	gui_beval.h	/^    GtkWidget		*balloonShell;$/;"	m	struct:BalloonEvalStruct
balloon_draw_cb	gui_beval.c	/^balloon_draw_cb(GtkWidget *widget, GdkRectangle *area, gpointer data)$/;"	f	file:
balloon_expose_event_cb	gui_beval.c	/^balloon_expose_event_cb(GtkWidget *widget, GdkEventExpose *event, gpointer data)$/;"	f	file:
bangredo	globals.h	/^EXTERN int	bangredo INIT(= FALSE);	    \/* set to TRUE whith ! command *\/$/;"	v
bbox_max_y	ex_cmds2.c	/^    int		bbox_max_y;$/;"	m	struct:prt_ps_font_S	file:
bbox_min_y	ex_cmds2.c	/^    int		bbox_min_y;$/;"	m	struct:prt_ps_font_S	file:
bck_word	search.c	/^bck_word(count, bigword, stop)$/;"	f
bckend_word	search.c	/^bckend_word(count, bigword, eol)$/;"	f
beep_count	globals.h	/^EXTERN int	beep_count INIT(= 0);	\/* nr of beeps since last char typed *\/$/;"	v
beep_flush	misc1.c	/^beep_flush()$/;"	f
beginline	edit.c	/^beginline(flags)$/;"	f
behind_pos	regexp.c	/^static regsave_T behind_pos;$/;"	v	file:
bg_color	structs.h	/^	    char_u	    bg_color;	\/* background color number *\/$/;"	m	struct:attr_entry::__anon34::__anon36
bg_color	structs.h	/^	    guicolor_T	    bg_color;	\/* background color handle *\/$/;"	m	struct:attr_entry::__anon34::__anon37
bg_color	structs.h	/^    long_u	bg_color;$/;"	m	struct:__anon44
bg_colour	gui.h	/^    int		bg_colour;$/;"	m	struct:Gui
bgcolor	gui.h	/^    GdkColor	*bgcolor;	    \/* GDK-styled background color *\/$/;"	m	struct:Gui
bh_bnum	structs.h	/^    blocknr_T	bh_bnum;		\/* block number *\/$/;"	m	struct:block_hdr
bh_curr	structs.h	/^    struct buffblock	*bh_curr;	\/* buffblock for appending *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::buffblock
bh_data	structs.h	/^    char_u	*bh_data;	    \/* pointer to memory (for used block) *\/$/;"	m	struct:block_hdr
bh_first	structs.h	/^    struct buffblock	bh_first;	\/* first (dummy) block of list *\/$/;"	m	struct:buffheader	typeref:struct:buffheader::buffblock
bh_flags	structs.h	/^    char	bh_flags;	    \/* BH_DIRTY or BH_LOCKED *\/$/;"	m	struct:block_hdr
bh_hash_next	structs.h	/^    bhdr_T	*bh_hash_next;	    \/* next block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_hash_prev	structs.h	/^    bhdr_T	*bh_hash_prev;	    \/* previous block_hdr in hash list *\/$/;"	m	struct:block_hdr
bh_index	structs.h	/^    int			bh_index;	\/* index for reading *\/$/;"	m	struct:buffheader
bh_next	structs.h	/^    bhdr_T	*bh_next;	    \/* next block_hdr in free or used list *\/$/;"	m	struct:block_hdr
bh_page_count	structs.h	/^    int		bh_page_count;	    \/* number of pages in this block *\/$/;"	m	struct:block_hdr
bh_prev	structs.h	/^    bhdr_T	*bh_prev;	    \/* previous block_hdr in used list *\/$/;"	m	struct:block_hdr
bh_space	structs.h	/^    int			bh_space;	\/* space in bh_curr for appending *\/$/;"	m	struct:buffheader
bhdr_T	structs.h	/^typedef struct block_hdr    bhdr_T;$/;"	t	typeref:struct:block_hdr
bindtextdomain	vim.h	412;"	d
bindtextdomain	vim.h	427;"	d
bindtextdomain	vim.h	429;"	d
bkc_flags	option.h	/^EXTERN unsigned	bkc_flags;$/;"	v
bl_maxval	regexp.c	/^static long	bl_maxval;$/;"	v	file:
bl_minval	regexp.c	/^static long	bl_minval;$/;"	v	file:
blank_pointer	gui.h	/^    Cursor	blank_pointer;	    \/* Blank pointer *\/$/;"	m	struct:Gui
blank_pointer	gui.h	/^    GdkCursor	*blank_pointer;	    \/* Blank pointer *\/$/;"	m	struct:Gui
blinkoff	structs.h	/^    long	blinkoff;	\/* blinking, off time *\/$/;"	m	struct:cursor_entry
blinkon	structs.h	/^    long	blinkon;	\/* blinking, on time *\/$/;"	m	struct:cursor_entry
blinkwait	structs.h	/^    long	blinkwait;	\/* blinking, wait time before blinking starts *\/$/;"	m	struct:cursor_entry
block0	memline.c	/^struct block0$/;"	s	file:
block_def	ops.c	/^struct block_def$/;"	s	file:
block_hdr	structs.h	/^struct block_hdr$/;"	s
block_insert	ops.c	/^block_insert(oap, s, b_insert, bdp)$/;"	f	file:
block_mode	structs.h	/^    int		block_mode;	\/* current operator is Visual block mode *\/$/;"	m	struct:oparg
block_prep	ops.c	/^block_prep(oap, bdp, lnum, is_del)$/;"	f	file:
block_redo	getchar.c	/^static int	block_redo = FALSE;$/;"	v	file:
blocknr_T	structs.h	/^typedef long		    blocknr_T;$/;"	t
blue	gui_amiga.c	/^	UBYTE		blue;$/;"	m	struct:guicolor_tTable	file:
bold	structs.h	/^    int		bold;$/;"	m	struct:__anon44
bold_font	gui.h	/^    GuiFont	bold_font;	    \/* Bold font *\/$/;"	m	struct:Gui
boldital_font	gui.h	/^    GuiFont	boldital_font;	    \/* Bold-Italic font *\/$/;"	m	struct:Gui
bomb_size	mbyte.c	/^bomb_size()$/;"	f
bool	vim.h	1780;"	d
boolvar	testdir/test49.vim	/^let boolvar = 1$/;"	v
border_offset	gui.h	/^    int		border_offset;	    \/* Total pixel offset for all borders *\/$/;"	m	struct:Gui
border_width	gui.h	/^    int		border_width;	    \/* Width of our border around text area *\/$/;"	m	struct:Gui
bot_top_msg	search.c	/^static char_u *bot_top_msg = (char_u *)N_("search hit BOTTOM, continuing at TOP");$/;"	v	file:
botline_forw	move.c	/^botline_forw(lp)$/;"	f	file:
botline_topline	move.c	/^botline_topline(lp)$/;"	f	file:
bottom_sbar	gui.h	/^    scrollbar_T bottom_sbar;	    \/* Bottom scrollbar *\/$/;"	m	struct:Gui
bottommsg	tag.c	/^static char_u *bottommsg = (char_u *)N_("E555: at bottom of tag stack");$/;"	v	file:
brace_count	regexp.c	/^static int	brace_count[10]; \/* Current counts for complex brace repeats *\/$/;"	v	file:
brace_max	regexp.c	/^static long	brace_max[10];	\/* Maximums for complex brace repeats *\/$/;"	v	file:
brace_min	regexp.c	/^static long	brace_min[10];	\/* Minimums for complex brace repeats *\/$/;"	v	file:
break_err	testdir/test49.vim	/^	    let break_err = 1$/;"	v
breakat_flags	globals.h	/^EXTERN char	breakat_flags[256];	\/* which characters are in 'breakat' *\/$/;"	v
breakcheck_count	misc1.c	/^static int	breakcheck_count = 0;$/;"	v	file:
breakpoint	eval.c	/^    linenr_T	breakpoint;	\/* next line with breakpoint or zero *\/$/;"	m	struct:funccall	file:
breakpoint	ex_cmds2.c	/^    linenr_T	breakpoint;	\/* next line with breakpoint or zero *\/$/;"	m	struct:source_cookie	file:
browse	structs.h	/^    int		browse;			\/* TRUE to invoke file dialog *\/$/;"	m	struct:__anon31
browse_fname	gui.h	/^    char_u	*browse_fname;	    \/* file name from filedlg *\/$/;"	m	struct:Gui
browse_save_fname	ex_cmds2.c	/^browse_save_fname(buf)$/;"	f
bs_extmatch	structs.h	/^    reg_extmatch_T *bs_extmatch; \/* external matches from start pattern *\/$/;"	m	struct:buf_state
bs_flags	structs.h	/^    long	    bs_flags;	 \/* flags for pattern *\/$/;"	m	struct:buf_state
bs_idx	structs.h	/^    int		    bs_idx;	 \/* index of pattern *\/$/;"	m	struct:buf_state
bt_dontwrite	quickfix.c	/^bt_dontwrite(buf)$/;"	f
bt_dontwrite_msg	quickfix.c	/^bt_dontwrite_msg(buf)$/;"	f
bt_entry	term.c	/^    int		bt_entry;$/;"	m	struct:builtin_term	file:
bt_nofile	quickfix.c	/^bt_nofile(buf)$/;"	f
bt_quickfix	quickfix.c	/^bt_quickfix(buf)$/;"	f
bt_string	term.c	/^    char	*bt_string;$/;"	m	struct:builtin_term	file:
buf	screen.c	/^    buf_T	*buf;	\/* the buffer to search for a match *\/$/;"	m	struct:__anon1	file:
bufIsChanged	undo.c	/^bufIsChanged(buf)$/;"	f
buf_T	structs.h	/^typedef struct file_buffer buf_T;$/;"	t	typeref:struct:file_buffer
buf_addsign	buffer.c	/^buf_addsign(buf, id, lnum, typenr)$/;"	f
buf_change_sign_type	buffer.c	/^buf_change_sign_type(buf, markId, typenr)$/;"	f
buf_check_timestamp	fileio.c	/^buf_check_timestamp(buf, focus)$/;"	f
buf_clear_file	buffer.c	/^buf_clear_file(buf)$/;"	f
buf_contents_changed	buffer.c	/^buf_contents_changed(buf)$/;"	f
buf_copy_options	option.c	/^buf_copy_options(buf, flags)$/;"	f
buf_delete_all_signs	buffer.c	/^buf_delete_all_signs()$/;"	f
buf_delete_signs	buffer.c	/^buf_delete_signs(buf)$/;"	f	file:
buf_delsign	buffer.c	/^buf_delsign(buf, id)$/;"	f
buf_findsign	buffer.c	/^buf_findsign(buf, id)$/;"	f
buf_findsign_id	buffer.c	/^buf_findsign_id(buf, lnum)$/;"	f
buf_findsigntype_id	buffer.c	/^buf_findsigntype_id(buf, lnum, typenr)$/;"	f
buf_freeall	buffer.c	/^buf_freeall(buf, del_buf, wipe_buf)$/;"	f
buf_getsigntype	buffer.c	/^buf_getsigntype(buf, lnum, type)$/;"	f
buf_hide	quickfix.c	/^buf_hide(buf)$/;"	f
buf_init_chartab	charset.c	/^buf_init_chartab(buf, global)$/;"	f
buf_jump_open_win	window.c	/^buf_jump_open_win(buf)$/;"	f
buf_list	netbeans.c	/^static nbbuf_T *buf_list = 0;$/;"	v	file:
buf_list_size	netbeans.c	/^int buf_list_size = 0;	\/* size of buf_list *\/$/;"	v
buf_list_used	netbeans.c	/^int buf_list_used = 0;	\/* nr of entries in buf_list actually in use *\/$/;"	v
buf_modname	fileio.c	/^buf_modname(shortname, fname, ext, prepend_dot)$/;"	f
buf_name_changed	buffer.c	/^buf_name_changed(buf)$/;"	f
buf_same_ino	buffer.c	/^buf_same_ino(buf, stp)$/;"	f	file:
buf_setino	buffer.c	/^buf_setino(buf)$/;"	f
buf_signcount	buffer.c	/^buf_signcount(buf, lnum)$/;"	f
buf_spname	buffer.c	/^buf_spname(buf)$/;"	f
buf_state	structs.h	/^typedef struct buf_state$/;"	s
buf_store_time	fileio.c	/^buf_store_time(buf, st, fname)$/;"	f
buf_valid	buffer.c	/^buf_valid(buf)$/;"	f
buf_write	fileio.c	/^buf_write(buf, fname, sfname, start, end, eap, append, forceit,$/;"	f
buf_write_all	ex_cmds2.c	/^buf_write_all(buf, forceit)$/;"	f
buf_write_bytes	fileio.c	/^buf_write_bytes(ip)$/;"	f	file:
bufempty	macros.h	51;"	d
buffblock	structs.h	/^struct buffblock$/;"	s
buffer	netbeans.c	/^    char_u	    *buffer;$/;"	m	struct:cmdqueue	file:
buffheader	structs.h	/^struct buffheader$/;"	s
buflist_add	buffer.c	/^buflist_add(fname, flags)$/;"	f
buflist_altfpos	buffer.c	/^buflist_altfpos()$/;"	f
buflist_findfpos	buffer.c	/^buflist_findfpos(buf)$/;"	f
buflist_findlnum	buffer.c	/^buflist_findlnum(buf)$/;"	f
buflist_findname	buffer.c	/^buflist_findname(ffname)$/;"	f
buflist_findname_stat	buffer.c	/^buflist_findname_stat(ffname, stp)$/;"	f	file:
buflist_findnr	buffer.c	/^buflist_findnr(nr)$/;"	f
buflist_findpat	buffer.c	/^buflist_findpat(pattern, pattern_end, unlisted, diffmode)$/;"	f
buflist_getfile	buffer.c	/^buflist_getfile(n, lnum, options, forceit)$/;"	f
buflist_getfpos	buffer.c	/^buflist_getfpos()$/;"	f
buflist_list	buffer.c	/^buflist_list(eap)$/;"	f
buflist_list	ex_docmd.c	104;"	d	file:
buflist_match	buffer.c	/^buflist_match(prog, buf)$/;"	f	file:
buflist_name_nr	buffer.c	/^buflist_name_nr(fnum, fname, lnum)$/;"	f
buflist_new	buffer.c	/^buflist_new(ffname, sfname, lnum, flags)$/;"	f
buflist_nr2name	buffer.c	/^buflist_nr2name(n, fullname, helptail)$/;"	f
buflist_setfpos	buffer.c	/^buflist_setfpos(buf, win, lnum, col, copy_options)$/;"	f	file:
buflist_slash_adjust	buffer.c	/^buflist_slash_adjust()$/;"	f
bufp	netbeans.c	/^    buf_T		*bufp;$/;"	m	struct:nbbuf_struct	file:
bufstate_T	structs.h	/^} bufstate_T;$/;"	t	typeref:struct:buf_state
build_drop_cmd	main.c	/^build_drop_cmd(filec, filev, sendReply)$/;"	f	file:
build_stl_str_hl	buffer.c	/^build_stl_str_hl(wp, out, outlen, fmt, fillchar, maxwidth, hl)$/;"	f
builtin_term	term.c	/^struct builtin_term$/;"	s	file:
builtin_termcaps	term.c	/^struct builtin_term builtin_termcaps[] =$/;"	v	typeref:struct:builtin_term
button	misc2.c	/^    int	    button;		\/* Which mouse button is it? *\/$/;"	m	struct:mousetable	file:
bw_buf	fileio.c	/^    char_u	*bw_buf;	\/* buffer with data to be written *\/$/;"	m	struct:bw_info	file:
bw_conv_buf	fileio.c	/^    char_u	*bw_conv_buf;	\/* buffer for writing converted chars *\/$/;"	m	struct:bw_info	file:
bw_conv_buflen	fileio.c	/^    int		bw_conv_buflen; \/* size of bw_conv_buf *\/$/;"	m	struct:bw_info	file:
bw_conv_error	fileio.c	/^    int		bw_conv_error;	\/* set for conversion error *\/$/;"	m	struct:bw_info	file:
bw_fd	fileio.c	/^    int		bw_fd;		\/* file descriptor *\/$/;"	m	struct:bw_info	file:
bw_first	fileio.c	/^    int		bw_first;	\/* first write call *\/$/;"	m	struct:bw_info	file:
bw_flags	fileio.c	/^    int		bw_flags;	\/* FIO_ flags *\/$/;"	m	struct:bw_info	file:
bw_iconv_fd	fileio.c	/^    iconv_t	bw_iconv_fd;	\/* descriptor for iconv() or -1 *\/$/;"	m	struct:bw_info	file:
bw_info	fileio.c	/^struct bw_info$/;"	s	file:
bw_len	fileio.c	/^    int		bw_len;	\/* lenght of data *\/$/;"	m	struct:bw_info	file:
bw_rest	fileio.c	/^    char_u	bw_rest[CONV_RESTLEN]; \/* not converted bytes *\/$/;"	m	struct:bw_info	file:
bw_restlen	fileio.c	/^    int		bw_restlen;	\/* nr of bytes in bw_rest[] *\/$/;"	m	struct:bw_info	file:
byte2cells	charset.c	/^byte2cells(b)$/;"	f
bytes_printed	ex_cmds2.c	/^    long_u	bytes_printed;	    \/* bytes printed so far *\/$/;"	m	struct:__anon10	file:
c	regexp.c	/^    int a, b, c;$/;"	m	struct:__anon52	file:
calc_hist_idx	ex_getln.c	/^calc_hist_idx(histype, num)$/;"	f	file:
call_func	eval.c	/^call_func(name, len, retvar, argcount, argvars, firstline, lastline,$/;"	f	file:
call_shell	misc2.c	/^call_shell(cmd, opt)$/;"	f
call_user_func	eval.c	/^call_user_func(fp, argcount, argvars, retvar, firstline, lastline)$/;"	f	file:
call_vim_function	eval.c	/^call_vim_function(func, argc, argv, safe)$/;"	f
called_emsg	globals.h	/^EXTERN int	called_emsg;		    \/* always set by emsg() *\/$/;"	v
calls	eval.c	/^    int		calls;		\/* nr of active calls *\/$/;"	m	struct:ufunc	file:
calls	testdir/test49.vim	/^    let calls = ""$/;"	v
calls	testdir/test49.vim	/^let calls = 0$/;"	v
canF_Ljoin	farsi.c	/^canF_Ljoin(c)$/;"	f	file:
canF_Rjoin	farsi.c	/^canF_Rjoin(c)$/;"	f	file:
can_abandon	ex_cmds2.c	/^can_abandon(buf, forceit)$/;"	f
can_bs	option.c	/^can_bs(what)$/;"	f
can_cindent	edit.c	/^static int	can_cindent;		\/* may do cindenting on this line *\/$/;"	v	file:
can_clear	screen.c	/^can_clear(p)$/;"	f
can_f_submatch	regexp.c	/^static int can_f_submatch = FALSE;	\/* TRUE when submatch() can be used *\/$/;"	v	file:
can_si	globals.h	/^EXTERN int	can_si INIT(= FALSE);$/;"	v
can_si_back	globals.h	/^EXTERN int	can_si_back INIT(= FALSE);$/;"	v
can_update_cursor	gui.c	/^static int can_update_cursor = TRUE; \/* can display the cursor *\/$/;"	v	file:
cancelBalloon	gui_beval.c	/^cancelBalloon(BalloonEval *beval)$/;"	f	file:
cancelBalloon	gui_beval.c	/^cancelBalloon(beval)$/;"	f	file:
canon	mbyte.c	/^{   char *name;		int canon;}$/;"	m	struct:__anon12	file:
case_args	syntax.c	/^static char *(case_args[]) = {"match", "ignore", NULL};$/;"	v	file:
cat_func_name	eval.c	/^cat_func_name(buf, fp)$/;"	f	file:
cat_prefix_varname	eval.c	/^cat_prefix_varname(prefix, name)$/;"	f	file:
catch_exception	ex_eval.c	/^catch_exception(excp)$/;"	f	file:
caught	structs.h	/^    except_T		*caught;	\/* next exception on the caught stack *\/$/;"	m	struct:vim_exception
caught	testdir/test49.vim	/^		let caught = 0$/;"	v
caught	testdir/test49.vim	/^		let caught = 1$/;"	v
caught	testdir/test49.vim	/^	    let caught = 0$/;"	v
caught	testdir/test49.vim	/^	    let caught = 1$/;"	v
caught	testdir/test49.vim	/^	let caught = 0$/;"	v
caught_stack	globals.h	/^EXTERN except_T *caught_stack INIT(= NULL);$/;"	v
cause_abort	ex_eval.c	/^static int cause_abort = FALSE;$/;"	v	file:
cause_errthrow	ex_eval.c	/^cause_errthrow(mesg, severe, ignore)$/;"	f
cb	structs.h	/^    void	(*cb)();	    \/* Call-back routine *\/$/;"	m	struct:VimMenu
ccheck_abbr	ex_getln.c	/^ccheck_abbr(c)$/;"	f	file:
ccline	ex_getln.c	/^static struct cmdline_info ccline;	\/* current cmdline_info *\/$/;"	v	typeref:struct:cmdline_info	file:
cedit_key	globals.h	/^EXTERN int	cedit_key INIT(= -1);	\/* key value of 'cedit' option *\/$/;"	v
change_compatible	option.c	/^change_compatible(on)$/;"	f
change_indent	edit.c	/^change_indent(type, amount, round, replaced)$/;"	f
change_warning	misc1.c	/^change_warning(col)$/;"	f
changed	misc1.c	/^changed()$/;"	f
changedOneline	misc1.c	/^changedOneline(lnum)$/;"	f	file:
changed_bytes	misc1.c	/^changed_bytes(lnum, col)$/;"	f
changed_cline_bef_curs	move.c	/^changed_cline_bef_curs()$/;"	f
changed_cline_bef_curs_win	move.c	/^changed_cline_bef_curs_win(wp)$/;"	f
changed_common	misc1.c	/^changed_common(lnum, col, lnume, xtra)$/;"	f	file:
changed_line_abv_curs	move.c	/^changed_line_abv_curs()$/;"	f
changed_line_abv_curs_win	move.c	/^changed_line_abv_curs_win(wp)$/;"	f
changed_lines	misc1.c	/^changed_lines(lnum, col, lnume, xtra)$/;"	f
changed_window_setting	move.c	/^changed_window_setting()$/;"	f
changed_window_setting_win	move.c	/^changed_window_setting_win(wp)$/;"	f
char1	digraph.c	/^    char_u	char1;$/;"	m	struct:digraph	file:
char2	digraph.c	/^    char_u	char2;$/;"	m	struct:digraph	file:
char2cells	charset.c	/^char2cells(c)$/;"	f
charEventHandler	gui_amiga.c	/^charEventHandler(int wtime)$/;"	f	file:
char_ascent	gui.h	/^    int		char_ascent;	    \/* Ascent of char in pixels *\/$/;"	m	struct:Gui
char_avail	getchar.c	/^char_avail()$/;"	f
char_height	gui.h	/^    int		char_height;	    \/* Height of char in pixels + 'linespace' *\/$/;"	m	struct:Gui
char_needs_redraw	screen.c	/^char_needs_redraw(off_from, off_to, cols)$/;"	f	file:
char_to_long	memline.c	/^char_to_long(s)$/;"	f	file:
char_u	term.h	/^typedef unsigned char char_u;$/;"	t
char_u	vim.h	/^typedef unsigned char	char_u;$/;"	t
char_width	gui.h	/^    int		char_width;	    \/* Width of char in pixels *\/$/;"	m	struct:Gui
characterHeight	gui_amiga.c	/^static int characterHeight = -1;$/;"	v	file:
characterWidth	gui_amiga.c	/^static int characterWidth = -1;$/;"	v	file:
chars_per_line	structs.h	/^    int		chars_per_line;$/;"	m	struct:__anon45
chartab	globals.h	/^EXTERN char_u	chartab[256];		\/* table used in charset.c; See$/;"	v
chartab_initialized	charset.c	/^static int    chartab_initialized = FALSE;$/;"	v	file:
chartabsize	charset.c	/^chartabsize(p, col)$/;"	f
chdir	vim.h	221;"	d
checkCloseRec	fold.c	/^checkCloseRec(gap, lnum, level)$/;"	f	file:
checkEventHandler	gui_amiga.c	/^checkEventHandler(void)$/;"	f	file:
checkSmall	fold.c	/^checkSmall(wp, fp, lnum_off)$/;"	f	file:
check_abbr	getchar.c	/^check_abbr(c, ptr, col, mincol)$/;"	f
check_arg_idx	ex_cmds2.c	/^check_arg_idx(win)$/;"	f
check_auto_format	edit.c	/^check_auto_format(end_insert)$/;"	f	file:
check_buf_options	option.c	/^check_buf_options(buf)$/;"	f
check_cedit	option.c	/^check_cedit()$/;"	f	file:
check_changed	ex_cmds2.c	/^check_changed(buf, checkaw, mult_win, forceit, allbuf)$/;"	f
check_changed_any	ex_cmds2.c	/^check_changed_any(hidden)$/;"	f
check_clipboard_option	option.c	/^check_clipboard_option()$/;"	f	file:
check_closed	fold.c	/^check_closed(win, fp, use_levelp, level, maybe_smallp, lnum_off)$/;"	f	file:
check_col	ui.c	/^check_col(col)$/;"	f
check_connection	eval.c	/^check_connection()$/;"	f	file:
check_cstack	globals.h	/^EXTERN int check_cstack INIT(= FALSE);$/;"	v
check_cursor	misc2.c	/^check_cursor()$/;"	f
check_cursor_col	misc2.c	/^check_cursor_col()$/;"	f
check_cursor_lnum	misc2.c	/^check_cursor_lnum()$/;"	f
check_cursor_moved	move.c	/^check_cursor_moved(wp)$/;"	f
check_ei	fileio.c	/^check_ei()$/;"	f
check_ff_value	option.c	/^check_ff_value(p)$/;"	f
check_fname	ex_cmds2.c	/^check_fname()$/;"	f
check_for_bom	fileio.c	/^check_for_bom(p, size, lenp, flags)$/;"	f	file:
check_for_codes	term.c	/^static int	check_for_codes = FALSE;	\/* check for key code reponse *\/$/;"	v	file:
check_for_codes_from_term	term.c	/^check_for_codes_from_term()$/;"	f	file:
check_for_cryptkey	fileio.c	/^check_for_cryptkey(cryptkey, ptr, sizep, filesizep, newfile)$/;"	f	file:
check_for_delay	screen.c	/^check_for_delay(check_msg_scroll)$/;"	f
check_keepend	syntax.c	/^check_keepend()$/;"	f	file:
check_keyword_id	syntax.c	/^check_keyword_id(line, startcol, endcolp, flagsp, next_listp, cur_si)$/;"	f	file:
check_linecomment	search.c	/^check_linecomment(line)$/;"	f	file:
check_lnums	window.c	/^check_lnums(do_curwin)$/;"	f
check_map	getchar.c	/^check_map(keys, mode, exact)$/;"	f
check_map_keycodes	getchar.c	/^check_map_keycodes()$/;"	f
check_mark	mark.c	/^check_mark(pos)$/;"	f
check_marks_read	fileio.c	/^check_marks_read()$/;"	f	file:
check_more	ex_docmd.c	/^check_more(message, forceit)$/;"	f	file:
check_mtime	fileio.c	/^check_mtime(buf, st)$/;"	f	file:
check_need_swap	memline.c	/^check_need_swap(newfile)$/;"	f
check_nextcmd	ex_docmd.c	/^check_nextcmd(p)$/;"	f
check_opt_strings	option.c	/^check_opt_strings(val, values, list)$/;"	f	file:
check_opt_wim	option.c	/^check_opt_wim()$/;"	f	file:
check_options	option.c	/^check_options()$/;"	f
check_overwrite	ex_cmds.c	/^check_overwrite(eap, buf, fname, ffname, other)$/;"	f	file:
check_prevcol	search.c	/^check_prevcol(linep, col, ch, prevcol)$/;"	f	file:
check_readonly	ex_cmds.c	/^check_readonly(forceit, buf)$/;"	f	file:
check_redraw	option.c	/^check_redraw(flags)$/;"	f	file:
check_restricted	ex_cmds.c	/^check_restricted()$/;"	f
check_row	ui.c	/^check_row(row)$/;"	f
check_scrollbind	normal.c	/^check_scrollbind(topline_diff, leftcol_diff)$/;"	f
check_secure	ex_cmds.c	/^check_secure()$/;"	f
check_shellsize	term.c	/^check_shellsize()$/;"	f
check_snapshot_rec	window.c	/^check_snapshot_rec(sn, fr)$/;"	f	file:
check_state_ends	syntax.c	/^check_state_ends()$/;"	f	file:
check_status	misc1.c	/^check_status(buf)$/;"	f
check_stl_option	option.c	/^check_stl_option(s)$/;"	f
check_string_option	option.c	/^check_string_option(pp)$/;"	f	file:
check_swap_exists_action	main.c	/^check_swap_exists_action()$/;"	f	file:
check_termcode	term.c	/^check_termcode(max_offset, buf, buflen)$/;"	f
check_timestamps	fileio.c	/^check_timestamps(focus)$/;"	f
check_top_offset	move.c	/^check_top_offset()$/;"	f	file:
check_topfill	move.c	/^check_topfill(wp, down)$/;"	f
check_visual_highlight	normal.c	/^check_visual_highlight()$/;"	f
check_win_options	option.c	/^check_win_options(win)$/;"	f
check_winopt	option.c	/^check_winopt(wop)$/;"	f
checkclearop	normal.c	/^checkclearop(oap)$/;"	f	file:
checkclearopq	normal.c	/^checkclearopq(oap)$/;"	f	file:
checkforcmd	ex_docmd.c	/^checkforcmd(pp, cmd, len)$/;"	f	file:
checkpcmark	mark.c	/^checkpcmark()$/;"	f
checkupdate	fold.c	/^checkupdate(wp)$/;"	f	file:
chg_c_a2f	arabic.c	/^chg_c_a2f(cur_c)$/;"	f	file:
chg_c_a2i	arabic.c	/^chg_c_a2i(cur_c)$/;"	f	file:
chg_c_a2m	arabic.c	/^chg_c_a2m(cur_c)$/;"	f	file:
chg_c_a2s	arabic.c	/^chg_c_a2s(cur_c)$/;"	f	file:
chg_c_f2m	arabic.c	/^chg_c_f2m(cur_c)$/;"	f	file:
chg_c_i2m	arabic.c	/^chg_c_i2m(cur_c)$/;"	f	file:
chg_c_laa2f	arabic.c	/^chg_c_laa2f(hid_c)$/;"	f	file:
chg_c_laa2i	arabic.c	/^chg_c_laa2i(hid_c)$/;"	f	file:
chg_c_toX_orX	farsi.c	/^chg_c_toX_orX()$/;"	f	file:
chg_c_to_X_orX_	farsi.c	/^chg_c_to_X_orX_()$/;"	f	file:
chg_c_to_X_or_X	farsi.c	/^chg_c_to_X_or_X ()$/;"	f	file:
chg_l_toXor_X	farsi.c	/^chg_l_toXor_X ()$/;"	f	file:
chg_l_to_X_orX_	farsi.c	/^chg_l_to_X_orX_ ()$/;"	f	file:
chg_r_to_Xor_X_	farsi.c	/^chg_r_to_Xor_X_()$/;"	f	file:
children	structs.h	/^    vimmenu_T	*children;	    \/* Children of sub-menu *\/$/;"	m	struct:VimMenu
chk_modeline	buffer.c	/^chk_modeline(lnum)$/;"	f	file:
chunksize_T	structs.h	/^} chunksize_T;$/;"	t	typeref:struct:ml_chunksize
cin_ends_in	misc1.c	/^cin_ends_in(s, find, ignore)$/;"	f	file:
cin_first_id_amount	misc1.c	/^cin_first_id_amount()$/;"	f	file:
cin_get_equal_amount	misc1.c	/^cin_get_equal_amount(lnum)$/;"	f	file:
cin_is_cinword	misc1.c	/^cin_is_cinword(line)$/;"	f	file:
cin_is_cpp_baseclass	misc1.c	/^cin_is_cpp_baseclass(line, col)$/;"	f	file:
cin_isbreak	misc1.c	/^cin_isbreak(p)$/;"	f	file:
cin_iscase	misc1.c	/^cin_iscase(s)$/;"	f
cin_iscomment	misc1.c	/^cin_iscomment(p)$/;"	f	file:
cin_isdefault	misc1.c	/^cin_isdefault(s)$/;"	f	file:
cin_isdo	misc1.c	/^cin_isdo(p)$/;"	f	file:
cin_iselse	misc1.c	/^cin_iselse(p)$/;"	f	file:
cin_isfuncdecl	misc1.c	/^cin_isfuncdecl(sp, first_lnum)$/;"	f	file:
cin_isif	misc1.c	/^cin_isif(p)$/;"	f	file:
cin_isinit	misc1.c	/^cin_isinit(void)$/;"	f	file:
cin_islabel	misc1.c	/^cin_islabel(ind_maxcomment)		\/* XXX *\/$/;"	f
cin_islabel_skip	misc1.c	/^cin_islabel_skip(s)$/;"	f	file:
cin_islinecomment	misc1.c	/^cin_islinecomment(p)$/;"	f	file:
cin_ispreproc	misc1.c	/^cin_ispreproc(s)$/;"	f	file:
cin_ispreproc_cont	misc1.c	/^cin_ispreproc_cont(pp, lnump)$/;"	f	file:
cin_isscopedecl	misc1.c	/^cin_isscopedecl(s)$/;"	f
cin_isterminated	misc1.c	/^cin_isterminated(s, incl_open, incl_comma)$/;"	f	file:
cin_iswhileofdo	misc1.c	/^cin_iswhileofdo(p, lnum, ind_maxparen)	    \/* XXX *\/$/;"	f	file:
cin_nocode	misc1.c	/^cin_nocode(s)$/;"	f	file:
cin_skip2pos	misc1.c	/^cin_skip2pos(trypos)$/;"	f	file:
cin_skipcomment	misc1.c	/^cin_skipcomment(s)$/;"	f	file:
cindent_on	edit.c	/^cindent_on()$/;"	f	file:
class_tab	regexp.c	/^static short	class_tab[256];$/;"	v	file:
cleanup_T	structs.h	/^typedef struct cleanup_stuff cleanup_T;$/;"	t	typeref:struct:cleanup_stuff
cleanup_conditionals	ex_eval.c	/^cleanup_conditionals(cstack, searched_cond, inclusive)$/;"	f
cleanup_help_tags	ex_getln.c	/^cleanup_help_tags(num_file, file)$/;"	f	file:
cleanup_jumplist	mark.c	/^cleanup_jumplist()$/;"	f	file:
cleanup_stuff	structs.h	/^struct cleanup_stuff$/;"	s
cleanup_subexpr	regexp.c	/^cleanup_subexpr()$/;"	f	file:
cleanup_zsubexpr	regexp.c	/^cleanup_zsubexpr()$/;"	f	file:
clearFolding	fold.c	/^clearFolding(win)$/;"	f
clear_cmdline	globals.h	/^EXTERN int	clear_cmdline INIT(= FALSE);	\/* cmdline must be cleared *\/$/;"	v
clear_current_state	syntax.c	/^clear_current_state()$/;"	f	file:
clear_oparg	ops.c	/^clear_oparg(oap)$/;"	f
clear_showcmd	normal.c	/^clear_showcmd()$/;"	f
clear_snapshot	window.c	/^clear_snapshot()$/;"	f	file:
clear_snapshot_rec	window.c	/^clear_snapshot_rec(fr)$/;"	f	file:
clear_string_option	option.c	/^clear_string_option(pp)$/;"	f
clear_syn_state	syntax.c	/^clear_syn_state(p)$/;"	f	file:
clear_termcodes	term.c	/^clear_termcodes()$/;"	f
clear_termoptions	option.c	/^clear_termoptions()$/;"	f
clear_var	eval.c	/^clear_var(varp)$/;"	f	file:
clear_wininfo	buffer.c	/^clear_wininfo(buf)$/;"	f	file:
clear_winopt	option.c	/^clear_winopt(wop)$/;"	f
clearop	normal.c	/^clearop(oap)$/;"	f	file:
clearopbeep	normal.c	/^clearopbeep(oap)$/;"	f	file:
clientData	gui_beval.h	/^    void		*clientData;	\/* For callback *\/$/;"	m	struct:BalloonEvalStruct
clientWindow	globals.h	/^EXTERN HWND	clientWindow INIT(= 0);$/;"	v
clientWindow	globals.h	/^EXTERN Window	clientWindow INIT(= None);$/;"	v
clip_auto_select	ui.c	/^clip_auto_select()$/;"	f
clip_autoselect	option.h	/^EXTERN int	clip_autoselect INIT(= FALSE);$/;"	v
clip_autoselectml	option.h	/^EXTERN int	clip_autoselectml INIT(= FALSE);$/;"	v
clip_clear_selection	ui.c	/^clip_clear_selection()$/;"	f
clip_compare_pos	ui.c	/^clip_compare_pos(row1, col1, row2, col2)$/;"	f	file:
clip_convert_selection	ops.c	/^clip_convert_selection(str, len, cbd)$/;"	f
clip_copy_modeless_selection	ui.c	/^clip_copy_modeless_selection(both)$/;"	f
clip_copy_selection	ui.c	/^clip_copy_selection()$/;"	f
clip_exclude_prog	option.h	/^EXTERN regprog_T *clip_exclude_prog INIT(= NULL);$/;"	v
clip_free_selection	ops.c	/^clip_free_selection(cbd)$/;"	f
clip_gen_lose_selection	ui.c	/^clip_gen_lose_selection(cbd)$/;"	f
clip_gen_own_selection	ui.c	/^clip_gen_own_selection(cbd)$/;"	f
clip_gen_request_selection	ui.c	/^clip_gen_request_selection(cbd)$/;"	f
clip_gen_set_selection	ui.c	/^clip_gen_set_selection(cbd)$/;"	f
clip_get_line_end	ui.c	/^clip_get_line_end(row)$/;"	f	file:
clip_get_selection	ops.c	/^clip_get_selection(cbd)$/;"	f
clip_get_word_boundaries	ui.c	/^clip_get_word_boundaries(cb, row, col)$/;"	f	file:
clip_init	ui.c	/^clip_init(can_use)$/;"	f
clip_invert_area	ui.c	/^clip_invert_area(row1, col1, row2, col2, how)$/;"	f	file:
clip_invert_rectangle	ui.c	/^clip_invert_rectangle(row, col, height, width, invert)$/;"	f	file:
clip_isautosel	ui.c	/^clip_isautosel()$/;"	f
clip_lose_selection	ui.c	/^clip_lose_selection(cbd)$/;"	f
clip_may_clear_selection	ui.c	/^clip_may_clear_selection(row1, row2)$/;"	f
clip_may_redraw_selection	ui.c	/^clip_may_redraw_selection(row, col, len)$/;"	f
clip_mch_lose_selection	gui_amiga.c	/^clip_mch_lose_selection(VimClipboard *cbd)$/;"	f
clip_mch_own_selection	gui_amiga.c	/^clip_mch_own_selection(VimClipboard *cbd)$/;"	f
clip_mch_request_selection	gui_amiga.c	/^clip_mch_request_selection(VimClipboard *cbd)$/;"	f
clip_mch_set_selection	gui_amiga.c	/^clip_mch_set_selection(VimClipboard *cbd)$/;"	f
clip_modeless	ui.c	/^clip_modeless(button, is_click, is_drag)$/;"	f
clip_own_selection	ui.c	/^clip_own_selection(cbd)$/;"	f
clip_plus	globals.h	/^EXTERN VimClipboard clip_plus;	\/* CLIPBOARD selection in X11 *\/$/;"	v
clip_plus	globals.h	448;"	d
clip_process_selection	ui.c	/^clip_process_selection(button, col, row, repeated_click)$/;"	f
clip_scroll_selection	ui.c	/^clip_scroll_selection(rows)$/;"	f
clip_star	globals.h	/^EXTERN VimClipboard clip_star;	\/* PRIMARY selection in X11 *\/$/;"	v
clip_start_selection	ui.c	/^clip_start_selection(col, row, repeated_click)$/;"	f
clip_unnamed	option.h	/^EXTERN int	clip_unnamed INIT(= FALSE);$/;"	v
clip_update_modeless_selection	ui.c	/^clip_update_modeless_selection(cb, row1, col1, row2, col2)$/;"	f	file:
clip_update_selection	ui.c	/^clip_update_selection()$/;"	f
clip_x11_convert_selection_cb	ui.c	/^clip_x11_convert_selection_cb(w, sel_atom, target, type, value, length, format)$/;"	f	file:
clip_x11_lose_ownership_cb	ui.c	/^clip_x11_lose_ownership_cb(w, sel_atom)$/;"	f	file:
clip_x11_lose_selection	ui.c	/^clip_x11_lose_selection(myShell, cbd)$/;"	f
clip_x11_own_selection	ui.c	/^clip_x11_own_selection(myShell, cbd)$/;"	f
clip_x11_request_selection	ui.c	/^clip_x11_request_selection(myShell, dpy, cbd)$/;"	f
clip_x11_request_selection_cb	ui.c	/^clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,$/;"	f	file:
clip_x11_set_selection	ui.c	/^clip_x11_set_selection(cbd)$/;"	f
clip_yank_selection	ops.c	/^clip_yank_selection(type, str, len, cbd)$/;"	f
cloneFoldGrowArray	fold.c	/^cloneFoldGrowArray(from, to)$/;"	f
closeFold	fold.c	/^closeFold(lnum, count)$/;"	f
closeFoldRecurse	fold.c	/^closeFoldRecurse(lnum)$/;"	f
close_buffer	buffer.c	/^close_buffer(win, buf, action)$/;"	f
close_others	window.c	/^close_others(message, forceit)$/;"	f
close_redir	ex_docmd.c	/^close_redir()$/;"	f	file:
close_win	os_amiga.c	/^static int		close_win = FALSE;  \/* set if Vim opened the window *\/$/;"	v	file:
close_windows	window.c	/^close_windows(buf)$/;"	f
closescript	getchar.c	/^closescript()$/;"	f	file:
clr_history	ex_getln.c	/^clr_history(histype)$/;"	f
clrallmarks	mark.c	/^clrallmarks(buf)$/;"	f
cls	search.c	/^cls()$/;"	f	file:
cls_bigword	search.c	/^static int	cls_bigword;	\/* TRUE for "W", "B" or "E" *\/$/;"	v	file:
cmd	ex_cmds.h	/^    char_u	*cmd;		\/* the name of the command (except for :make) *\/$/;"	m	struct:exarg
cmd	fileio.c	/^    char_u	    *cmd;		\/* The command to be executed (NULL$/;"	m	struct:AutoCmd	file:
cmd	testdir/test49.vim	/^		let cmd = ""$/;"	v
cmd	testdir/test49.vim	/^		let cmd = "unlet"$/;"	v
cmd	testdir/test49.vim	/^    let cmd = "let"$/;"	v
cmd_arg	normal.c	/^    short	cmd_arg;	\/* value for ca.arg *\/$/;"	m	struct:nv_cmd	file:
cmd_argt	ex_cmds.h	/^    long_u	cmd_argt;	\/* flags declared above *\/$/;"	m	struct:cmdname
cmd_char	normal.c	/^    int		cmd_char;	\/* (first) command character *\/$/;"	m	struct:nv_cmd	file:
cmd_exists	ex_docmd.c	/^cmd_exists(name)$/;"	f
cmd_fkmap	ex_getln.c	/^static int	cmd_fkmap = 0;	\/* Farsi mapping during command line *\/$/;"	v	file:
cmd_flags	normal.c	/^    short_u	cmd_flags;	\/* NV_ flags *\/$/;"	m	struct:nv_cmd	file:
cmd_func	ex_cmds.h	/^    ex_func_T   cmd_func;	\/* function for this command *\/$/;"	m	struct:cmdname
cmd_func	normal.c	/^    nv_func_T   cmd_func;	\/* function for this command *\/$/;"	m	struct:nv_cmd	file:
cmd_gchar	ex_getln.c	/^cmd_gchar(offset)$/;"	f
cmd_hkmap	ex_getln.c	/^static int	cmd_hkmap = 0;	\/* Hebrew mapping during command line *\/$/;"	v	file:
cmd_name	ex_cmds.h	/^    char_u	*cmd_name;	\/* name of the command *\/$/;"	m	struct:cmdname
cmd_pchar	ex_getln.c	/^cmd_pchar(c, offset)$/;"	f
cmd_runtime	ex_cmds2.c	/^cmd_runtime(name, all)$/;"	f
cmd_showtail	ex_getln.c	/^static int	cmd_showtail;		\/* Only show path tail in lists ? *\/$/;"	v	file:
cmd_silent	globals.h	/^EXTERN int	cmd_silent INIT(= FALSE); \/* don't echo the command line *\/$/;"	v
cmd_source	ex_cmds2.c	/^cmd_source(fname, eap)$/;"	f	file:
cmdarg	structs.h	/^typedef struct cmdarg$/;"	s
cmdarg_T	structs.h	/^} cmdarg_T;$/;"	t	typeref:struct:cmdarg
cmdattr	ex_getln.c	/^    int		cmdattr;	\/* attributes for prompt *\/$/;"	m	struct:cmdline_info	file:
cmdbuff	ex_getln.c	/^    char_u	*cmdbuff;	\/* pointer to command line buffer *\/$/;"	m	struct:cmdline_info	file:
cmdbufflen	ex_getln.c	/^    int		cmdbufflen;	\/* length of cmdbuff *\/$/;"	m	struct:cmdline_info	file:
cmdchar	structs.h	/^    int		cmdchar;	\/* command character *\/$/;"	m	struct:cmdarg
cmdfirstc	ex_getln.c	/^    int		cmdfirstc;	\/* ':', '\/', '?', '=' or NUL *\/$/;"	m	struct:cmdline_info	file:
cmdidx	ex_cmds.h	/^    cmdidx_T	cmdidx;		\/* the index for the command *\/$/;"	m	struct:exarg
cmdidx_T	ex_cmds.h	/^typedef enum CMD_index cmdidx_T;$/;"	t	typeref:enum:CMD_index
cmdidxs	ex_docmd.c	/^cmdidx_T cmdidxs[27] =$/;"	v
cmdindent	ex_getln.c	/^    int		cmdindent;	\/* number of spaces before cmdline *\/$/;"	m	struct:cmdline_info	file:
cmdl_fkmap	farsi.c	/^cmdl_fkmap(c)$/;"	f
cmdlen	ex_getln.c	/^    int		cmdlen;		\/* number of chars in command line *\/$/;"	m	struct:cmdline_info	file:
cmdline_at_end	ex_getln.c	/^cmdline_at_end()$/;"	f
cmdline_charsize	ex_getln.c	/^cmdline_charsize(idx)$/;"	f	file:
cmdline_del	ex_getln.c	/^cmdline_del(from)$/;"	f	file:
cmdline_getvcol_cursor	ex_getln.c	/^cmdline_getvcol_cursor()$/;"	f
cmdline_info	ex_getln.c	/^struct cmdline_info$/;"	s	file:
cmdline_overstrike	ex_getln.c	/^cmdline_overstrike()$/;"	f
cmdline_paste	ex_getln.c	/^cmdline_paste(regname, literally)$/;"	f	file:
cmdline_paste_reg	ops.c	/^cmdline_paste_reg(regname, literally)$/;"	f
cmdline_paste_str	ex_getln.c	/^cmdline_paste_str(s, literally)$/;"	f
cmdline_row	globals.h	/^EXTERN int	cmdline_row;$/;"	v
cmdline_star	globals.h	/^EXTERN int	cmdline_star INIT(= FALSE);	\/* cmdline is crypted *\/$/;"	v
cmdlinep	ex_cmds.h	/^    char_u	**cmdlinep;	\/* pointer to pointer of allocated cmdline *\/$/;"	m	struct:exarg
cmdmod	globals.h	/^EXTERN cmdmod_T	cmdmod;			\/* Ex command modifiers *\/$/;"	v
cmdmod_T	structs.h	/^} cmdmod_T;$/;"	t	typeref:struct:__anon31
cmdmsg_rl	globals.h	/^EXTERN int	cmdmsg_rl INIT(= FALSE);    \/* cmdline is drawn right to left *\/$/;"	v
cmdname	ex_cmds.h	/^static struct cmdname$/;"	s
cmdnames	ex_cmds.h	/^cmdnames[] =$/;"	v	typeref:struct:cmdname
cmdno	netbeans.c	/^static int cmdno;			\/* current command number for reply *\/$/;"	v	file:
cmdpos	ex_getln.c	/^    int		cmdpos;		\/* current cursor position *\/$/;"	m	struct:cmdline_info	file:
cmdprompt	ex_getln.c	/^    char_u	*cmdprompt;	\/* message in front of cmdline *\/$/;"	m	struct:cmdline_info	file:
cmdqueue	netbeans.c	/^struct cmdqueue$/;"	s	file:
cmds	fileio.c	/^    AutoCmd	    *cmds;		\/* list of commands to do *\/$/;"	m	struct:AutoPat	file:
cmdspos	ex_getln.c	/^    int		cmdspos;	\/* cursor column on screen *\/$/;"	m	struct:cmdline_info	file:
cmdsrv_main	main.c	/^cmdsrv_main(argc, argv, serverName_arg, serverStr)$/;"	f	file:
cmdwin_result	globals.h	/^EXTERN int	cmdwin_result INIT(= 0); \/* result of cmdline window or 0 *\/$/;"	v
cmdwin_type	globals.h	/^EXTERN int	cmdwin_type INIT(= 0);	\/* type of cmdline window or 0 *\/$/;"	v
cmp_flags	option.h	/^EXTERN unsigned	cmp_flags;$/;"	v
code	term.c	/^    char_u  *code;	    \/* terminal code (in allocated memory) *\/$/;"	m	struct:termcode	file:
codepage	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon11	file:
col	gui.h	/^    int		col;		    \/* Current cursor column in GUI display *\/$/;"	m	struct:Gui
col	structs.h	/^    colnr_T	col;	\/* column number *\/$/;"	m	struct:__anon28
col	structs.h	/^    colnr_T	col;	\/* column number *\/$/;"	m	struct:__anon29
col_adjust	mark.c	1031;"	d	file:
col_print	buffer.c	/^col_print(buf, col, vcol)$/;"	f
coladd	structs.h	/^    colnr_T	coladd;$/;"	m	struct:__anon28
coladvance	misc2.c	/^coladvance(wcol)$/;"	f
coladvance2	misc2.c	/^coladvance2(pos, addspaces, finetune, wcol)$/;"	f	file:
coladvance_force	misc2.c	/^coladvance_force(wcol)$/;"	f
colnr_T	structs.h	/^typedef unsigned	colnr_T;$/;"	t
colnr_T	vim.h	/^typedef unsigned    colnr_T;		\/* column number type *\/$/;"	t
cologne	testdir/test49.vim	/^    let cologne = 4711$/;"	v
coloncmd	netbeans.c	/^coloncmd(char *cmd, ...)$/;"	f	file:
color	gui_amiga.c	/^	unsigned long    color;$/;"	m	struct:guicolor_tTable	file:
color_approx	gui.h	/^    Bool	color_approx;	    \/* Some color was approximated *\/$/;"	m	struct:Gui
color_name2handle	syntax.c	/^color_name2handle(name)$/;"	f	file:
column	ex_cmds2.c	/^    colnr_T	column;		    \/* byte column *\/$/;"	m	struct:__anon10	file:
commProperty	globals.h	/^EXTERN Atom	commProperty INIT(= None);$/;"	v
commWindow	globals.h	/^EXTERN Window	commWindow INIT(= None);$/;"	v
command	tag.c	/^    char_u	*command;	\/* first char of command *\/$/;"	m	struct:tag_pointers	file:
command_complete	ex_docmd.c	/^} command_complete[] =$/;"	v	typeref:struct:__anon23	file:
command_end	tag.c	/^    char_u	*command_end;	\/* first char after command *\/$/;"	m	struct:tag_pointers	file:
command_height	window.c	/^command_height(old_p_ch)$/;"	f
comp_botline	move.c	/^comp_botline(wp)$/;"	f	file:
comp_col	option.c	/^comp_col()$/;"	f
comp_textwidth	edit.c	/^comp_textwidth(ff)$/;"	f
compatible_set	option.c	/^compatible_set()$/;"	f	file:
complete_col	edit.c	/^static colnr_T		    complete_col = 0;	\/* column where the text starts$/;"	v	file:
complete_direction	edit.c	/^static int		    complete_direction = FORWARD;$/;"	v	file:
complete_pat	edit.c	/^static char_u		    *complete_pat = NULL;$/;"	v	file:
complete_xp	edit.c	/^static expand_T		    complete_xp;$/;"	v	file:
completion_interrupted	globals.h	/^EXTERN int	completion_interrupted INIT(= FALSE);$/;"	v
completion_length	globals.h	/^EXTERN int	completion_length INIT(= 0);$/;"	v
completion_matches	edit.c	/^static int		    completion_matches = 0;$/;"	v	file:
completion_pending	edit.c	/^static int		    completion_pending = FALSE;$/;"	v	file:
composing_hangul	globals.h	/^EXTERN int		composing_hangul INIT(= 0);$/;"	v
composing_hangul_buffer	globals.h	/^EXTERN char_u		composing_hangul_buffer[5];$/;"	v
compound_text_atom	ui.c	/^static Atom	compound_text_atom;$/;"	v	file:
compute_cmdrow	ex_getln.c	/^compute_cmdrow()$/;"	f
concat_esc	gui.c	/^concat_esc(gap, text, what)$/;"	f	file:
concat_fnames	misc1.c	/^concat_fnames(fname1, fname2, sep)$/;"	f
condstack	structs.h	/^struct condstack$/;"	s
confirm	structs.h	/^    int		confirm;		\/* TRUE to invoke yes\/no dialog *\/$/;"	m	struct:__anon31
confirm_msg	message.c	/^static char_u	*confirm_msg = NULL;		\/* ":confirm" message *\/$/;"	v	file:
confirm_msg_tail	message.c	/^static char_u	*confirm_msg_tail;		\/* tail of confirm_msg *\/$/;"	v	file:
confirm_msg_used	message.c	/^static int	confirm_msg_used = FALSE;	\/* displaying confirm_msg *\/$/;"	v	file:
cont_in_list	structs.h	/^    short	*cont_in_list;	\/* cont.in group IDs, if non-zero *\/$/;"	m	struct:sp_syn
continue_mode	edit.c	/^static int		    continue_mode = 0;$/;"	v	file:
continue_status	globals.h	/^EXTERN int	continue_status   INIT(= 0);$/;"	v
conv	ex_cmds2.c	/^    vimconv_T	conv;		\/* type of conversion *\/$/;"	m	struct:source_cookie	file:
conv_to_pstd	farsi.c	/^conv_to_pstd()$/;"	f
conv_to_pvim	farsi.c	/^conv_to_pvim()$/;"	f
convertStruct	mbyte.c	/^} convertStruct;$/;"	t	typeref:struct:__anon13	file:
convert_input	mbyte.c	/^convert_input(ptr, len, maxlen)$/;"	f
convert_input_safe	mbyte.c	/^convert_input_safe(ptr, len, maxlen, restp, restlenp)$/;"	f
convert_setup	mbyte.c	/^convert_setup(vcp, from, to)$/;"	f
cookie	ex_cmds.h	/^    void	*cookie;	\/* argument for getline() *\/$/;"	m	struct:exarg
cookie	ex_docmd.c	/^    void	*cookie;$/;"	m	struct:while_cookie	file:
copyFoldingState	fold.c	/^copyFoldingState(wp_from, wp_to)$/;"	f
copy_char	message.c	/^copy_char(from, to, lowercase)$/;"	f	file:
copy_chars	misc2.c	/^copy_chars(ptr, count, c)$/;"	f
copy_id_list	syntax.c	/^copy_id_list(list)$/;"	f	file:
copy_indent	misc1.c	/^copy_indent(size, src)$/;"	f	file:
copy_jumplist	mark.c	/^copy_jumplist(from, to)$/;"	f
copy_option_part	misc2.c	/^copy_option_part(option, buf, maxlen, sep_chars)$/;"	f
copy_redo	getchar.c	/^copy_redo(old_redo)$/;"	f	file:
copy_spaces	misc2.c	/^copy_spaces(ptr, count)$/;"	f
copy_text_attr	screen.c	/^copy_text_attr(off, buf, len, attr)$/;"	f	file:
copy_var	eval.c	/^copy_var(from, to)$/;"	f	file:
copy_viminfo_marks	mark.c	/^copy_viminfo_marks(virp, fp_out, count, eof)$/;"	f
copy_winopt	option.c	/^copy_winopt(from, to)$/;"	f
copy_yank_reg	ops.c	/^copy_yank_reg(reg)$/;"	f	file:
corr_ind_maxparen	misc1.c	/^corr_ind_maxparen(ind_maxparen, startpos)$/;"	f	file:
correct_cmdspos	ex_getln.c	/^correct_cmdspos(idx, cells)$/;"	f	file:
correct_range	ex_docmd.c	/^correct_range(eap)$/;"	f	file:
count0	structs.h	/^    long	count0;		\/* count before command, default 0 *\/$/;"	m	struct:cmdarg
count1	structs.h	/^    long	count1;		\/* count before command, default 1 *\/$/;"	m	struct:cmdarg
count_changed_buffers	netbeans.c	/^count_changed_buffers(void)$/;"	f	file:
crc_32_tab	misc2.c	/^ulg crc_32_tab[256];$/;"	v
createBalloonEvalWindow	gui_beval.c	/^createBalloonEvalWindow(BalloonEval *beval)$/;"	f	file:
createBalloonEvalWindow	gui_beval.c	/^createBalloonEvalWindow(beval)$/;"	f	file:
crv_status	term.c	/^static int crv_status = CRV_GET;$/;"	v	file:
crypt_init_keys	misc2.c	/^crypt_init_keys(passwd)$/;"	f
cs_emsg_silent_list	structs.h	/^    eslist_T	*cs_emsg_silent_list;	\/* saved values of "emsg_silent" *\/$/;"	m	struct:condstack
cs_exception	structs.h	606;"	d
cs_flags	structs.h	/^    char	cs_flags[CSTACK_LEN];	\/* CSF_ flags *\/$/;"	m	struct:condstack
cs_had_continue	structs.h	/^    char	cs_had_continue;	\/* just found ":continue" *\/$/;"	m	struct:condstack
cs_had_endwhile	structs.h	/^    char	cs_had_endwhile;	\/* just found ":endwhile" *\/$/;"	m	struct:condstack
cs_had_finally	structs.h	/^    char	cs_had_finally;		\/* just found ":finally" *\/$/;"	m	struct:condstack
cs_had_while	structs.h	/^    char	cs_had_while;		\/* just found ":while" *\/$/;"	m	struct:condstack
cs_idx	structs.h	/^    int		cs_idx;			\/* current entry, or -1 if none *\/$/;"	m	struct:condstack
cs_line	structs.h	/^    int		cs_line[CSTACK_LEN];	\/* line number of ":while" line *\/$/;"	m	struct:condstack
cs_pend	structs.h	/^    }		cs_pend;$/;"	m	struct:condstack	typeref:union:condstack::__anon32
cs_pend_ex	structs.h	/^	void   *cs_pend_ex[CSTACK_LEN];	\/* exception for pending throw *\/$/;"	m	union:condstack::__anon32
cs_pend_rv	structs.h	/^	void   *cs_pend_rv[CSTACK_LEN];	\/* returnval for pending return *\/$/;"	m	union:condstack::__anon32
cs_pending	structs.h	/^    char	cs_pending[CSTACK_LEN];	\/* CSTP_: what's pending in ":finally"*\/$/;"	m	struct:condstack
cs_retvar	structs.h	605;"	d
cs_trylevel	structs.h	/^    int		cs_trylevel;		\/* number of nested ":try"s *\/$/;"	m	struct:condstack
cs_whilelevel	structs.h	/^    int		cs_whilelevel;		\/* number of nested ":while"s *\/$/;"	m	struct:condstack
cstack	ex_cmds.h	/^    struct condstack *cstack;	\/* condition stack for ":if" etc. *\/$/;"	m	struct:exarg	typeref:struct:exarg::condstack
cstrchr	regexp.c	/^cstrchr(s, c)$/;"	f	file:
cstrncmp	regexp.c	/^cstrncmp(s1, s2, n)$/;"	f	file:
cterm	structs.h	/^	} cterm;$/;"	m	union:attr_entry::__anon34	typeref:struct:attr_entry::__anon34::__anon36
cterm_attr_table	syntax.c	/^garray_T	cterm_attr_table = {0, 0, 0, 0, NULL};$/;"	v
cterm_color_16	ex_cmds2.c	/^static const long_u  cterm_color_16[16] =$/;"	v	file:
cterm_color_8	ex_cmds2.c	/^static const long_u  cterm_color_8[8] =$/;"	v	file:
cterm_normal_bg_color	globals.h	/^EXTERN int	cterm_normal_bg_color INIT(= 0);$/;"	v
cterm_normal_fg_bold	globals.h	/^EXTERN int	cterm_normal_fg_bold INIT(= 0);$/;"	v
cterm_normal_fg_color	globals.h	/^EXTERN int	cterm_normal_fg_color INIT(= 0);$/;"	v
ctrl_c_interrupts	globals.h	/^EXTERN int	ctrl_c_interrupts INIT(= TRUE);	\/* CTRL-C sets got_int *\/$/;"	v
ctrl_x_mode	globals.h	/^EXTERN int	ctrl_x_mode INIT(= 0);	\/* Which Ctrl-X mode are we in? *\/$/;"	v
ctrl_x_msgs	edit.c	/^static char *ctrl_x_msgs[] =$/;"	v	file:
curPCtype	netbeans.c	/^static int curPCtype = -1;$/;"	v	file:
cur_fnum	structs.h	/^    int		cur_fnum;	\/* buffer number used for cur_match *\/$/;"	m	struct:taggy
cur_match	structs.h	/^    int		cur_match;	\/* match number *\/$/;"	m	struct:taggy
cur_tmode	globals.h	/^EXTERN int	cur_tmode INIT(= TMODE_COOK);	\/* input terminal mode *\/$/;"	v
curbuf	globals.h	/^EXTERN buf_T	*curbuf INIT(= NULL);	\/* currently active buffer *\/$/;"	v
curbufIsChanged	undo.c	/^curbufIsChanged()$/;"	f
curchr	regexp.c	/^static int	curchr;$/;"	v	file:
curpat	fileio.c	/^    AutoPat	*curpat;	\/* next AutoPat to examine *\/$/;"	m	struct:AutoPatCmd	file:
currBgColor	gui.h	/^    guicolor_T	currBgColor;	    \/* Current background text color *\/$/;"	m	struct:Gui
currFgColor	gui.h	/^    guicolor_T	currFgColor;	    \/* Current foreground text color *\/$/;"	m	struct:Gui
currFont	gui.h	/^    GuiFont	currFont;	    \/* Current font *\/$/;"	m	struct:Gui
curr_bg	ex_cmds2.c	/^static long_u	curr_bg;$/;"	v	file:
curr_bold	ex_cmds2.c	/^static int	curr_bold;$/;"	v	file:
curr_fg	ex_cmds2.c	/^static long_u	curr_fg;$/;"	v	file:
curr_italic	ex_cmds2.c	/^static int	curr_italic;$/;"	v	file:
curr_match	edit.c	/^static struct Completion    *curr_match = NULL;$/;"	v	typeref:struct:Completion	file:
curr_underline	ex_cmds2.c	/^static int	curr_underline;$/;"	v	file:
current	gui_amiga.c	/^    int		current;$/;"	m	struct:__anon26	file:
current_SID	globals.h	/^EXTERN scid_T	current_SID INIT(= 0);	    \/* ID of script being sourced or$/;"	v
current_ScreenLine	screen.c	/^static schar_T	*current_ScreenLine;$/;"	v	file:
current_attr	syntax.c	/^static int current_attr = 0;	    \/* attr of current syntax word *\/$/;"	v	file:
current_augroup	fileio.c	/^static int current_augroup = AUGROUP_DEFAULT;$/;"	v	file:
current_beval	gui_beval.c	/^static BalloonEval *current_beval = NULL;$/;"	v	file:
current_block	search.c	/^current_block(oap, count, include, what, other)$/;"	f
current_col	syntax.c	/^static colnr_T	current_col = 0;	\/* column of current state *\/$/;"	v	file:
current_exception	globals.h	/^EXTERN except_T *current_exception;$/;"	v
current_finished	syntax.c	/^static int	current_finished = 0;	\/* current line has been finished *\/$/;"	v	file:
current_font	gui.h	/^    GuiFont	current_font;$/;"	m	struct:Gui
current_func_returned	eval.c	/^current_func_returned()$/;"	f
current_funccal	eval.c	/^struct funccall *current_funccal = NULL;$/;"	v	typeref:struct:funccall
current_id	syntax.c	/^static int current_id = 0;	    \/* ID of current char for syn_get_id() *\/$/;"	v	file:
current_line	ex_docmd.c	/^    int		current_line;		\/* last read line from growarray *\/$/;"	m	struct:while_cookie	file:
current_line_id	syntax.c	/^static int	current_line_id = 0;	\/* unique number for current line *\/$/;"	v	file:
current_lnum	syntax.c	/^static linenr_T current_lnum = 0;	\/* lnum of current state *\/$/;"	v	file:
current_menu	globals.h	/^EXTERN vimmenu_T	*current_menu;$/;"	v
current_next_flags	syntax.c	/^static int	current_next_flags = 0; \/* flags for current_next_list *\/$/;"	v	file:
current_next_list	syntax.c	/^static short	*current_next_list = NULL; \/* when non-zero, nextgroup list *\/$/;"	v	file:
current_par	search.c	/^current_par(oap, count, include, type)$/;"	f
current_scrollbar	globals.h	/^EXTERN int	current_scrollbar;$/;"	v
current_sent	search.c	/^current_sent(oap, count, include)$/;"	f
current_state	syntax.c	/^static garray_T current_state		\/* current stack of state_items *\/$/;"	v	file:
current_state_stored	syntax.c	/^static int	current_state_stored = 0; \/* TRUE if stored current state$/;"	v	file:
current_syn_id	ex_cmds2.c	/^static int		current_syn_id;$/;"	v	file:
current_syn_inc_tag	syntax.c	/^static int current_syn_inc_tag = 0;$/;"	v	file:
current_trans_id	syntax.c	/^static int current_trans_id = 0;    \/* idem, transparancy removed *\/$/;"	v	file:
current_word	search.c	/^current_word(oap, count, include, bigword)$/;"	f
curs_columns	move.c	/^curs_columns(scroll)$/;"	f
curs_rows	move.c	/^curs_rows(wp, do_botline)$/;"	f	file:
curscript	globals.h	/^EXTERN int	curscript INIT(= 0);	    \/* index in scriptin[] *\/$/;"	v
cursor	gui_amiga.c	/^} cursor =$/;"	v	typeref:struct:__anon26	file:
cursor_col	gui.h	/^    int		cursor_col;	    \/* Physical cursor column in GUI display *\/$/;"	m	struct:Gui
cursor_correct	move.c	/^cursor_correct()$/;"	f
cursor_down	edit.c	/^cursor_down(n, upd_topline)$/;"	f
cursor_entry	structs.h	/^typedef struct cursor_entry$/;"	s
cursor_is_off	term.c	/^static int cursor_is_off = FALSE;$/;"	v	file:
cursor_is_valid	gui.h	/^    char	cursor_is_valid;    \/* There is a cursor at cursor_row\/col *\/$/;"	m	struct:Gui
cursor_off	term.c	/^cursor_off()$/;"	f
cursor_on	term.c	/^cursor_on()$/;"	f
cursor_pos_info	ops.c	/^cursor_pos_info()$/;"	f
cursor_row	gui.h	/^    int		cursor_row;	    \/* Physical cursor row in GUI display *\/$/;"	m	struct:Gui
cursor_start	structs.h	/^    pos_T	cursor_start;	\/* cursor position before motion for "gw" *\/$/;"	m	struct:oparg
cursor_up	edit.c	/^cursor_up(n, upd_topline)$/;"	f
cursor_valid	move.c	/^cursor_valid()$/;"	f
cursorcmd	ex_getln.c	/^cursorcmd()$/;"	f	file:
cursorentry_T	structs.h	/^} cursorentry_T;$/;"	t	typeref:struct:cursor_entry
curwin	globals.h	/^EXTERN win_T	*curwin;	\/* currently active window *\/$/;"	v
curwin_col_off	move.c	/^curwin_col_off()$/;"	f
curwin_col_off2	move.c	/^curwin_col_off2()$/;"	f
darken_rgb	ex_cmds2.c	/^darken_rgb(rgb)$/;"	f	file:
data_block	memline.c	/^struct data_block$/;"	s	file:
db_free	memline.c	/^    unsigned	db_free;	\/* free space available *\/$/;"	m	struct:data_block	file:
db_id	memline.c	/^    short_u	db_id;		\/* ID for data block: DATA_ID *\/$/;"	m	struct:data_block	file:
db_index	memline.c	/^    unsigned	db_index[1];	\/* index for start of line (actually bigger)$/;"	m	struct:data_block	file:
db_line_count	memline.c	/^    linenr_T	db_line_count;	\/* number of lines in this block *\/$/;"	m	struct:data_block	file:
db_txt_end	memline.c	/^    unsigned	db_txt_end;	\/* byte just after data block *\/$/;"	m	struct:data_block	file:
db_txt_start	memline.c	/^    unsigned	db_txt_start;	\/* byte where text starts *\/$/;"	m	struct:data_block	file:
dbcs_char2bytes	mbyte.c	/^dbcs_char2bytes(c, buf)$/;"	f	file:
dbcs_char2cells	mbyte.c	/^dbcs_char2cells(c)$/;"	f	file:
dbcs_char2len	mbyte.c	/^dbcs_char2len(c)$/;"	f	file:
dbcs_class	mbyte.c	/^dbcs_class(lead, trail)$/;"	f
dbcs_head_off	mbyte.c	/^dbcs_head_off(base, p)$/;"	f
dbcs_off2cells	mbyte.c	/^dbcs_off2cells(off)$/;"	f
dbcs_ptr2cells	mbyte.c	/^dbcs_ptr2cells(p)$/;"	f
dbcs_ptr2char	mbyte.c	/^dbcs_ptr2char(p)$/;"	f	file:
dbcs_ptr2len_check	mbyte.c	/^dbcs_ptr2len_check(p)$/;"	f	file:
dbcs_screen_head_off	mbyte.c	/^dbcs_screen_head_off(base, p)$/;"	f
dbcs_screen_tail_off	mbyte.c	/^dbcs_screen_tail_off(base, p)$/;"	f
dbg_breakp	ex_cmds2.c	/^static garray_T dbg_breakp = {0, 0, sizeof(struct debuggy), 4, NULL};$/;"	v	file:
dbg_breakpoint	ex_cmds2.c	/^dbg_breakpoint(name, lnum)$/;"	f
dbg_check_breakpoint	ex_cmds2.c	/^dbg_check_breakpoint(eap)$/;"	f
dbg_check_skipped	ex_cmds2.c	/^dbg_check_skipped(eap)$/;"	f
dbg_find_breakpoint	ex_cmds2.c	/^dbg_find_breakpoint(file, fname, after)$/;"	f
dbg_lnum	ex_cmds2.c	/^    linenr_T	dbg_lnum;	\/* line number in function or file *\/$/;"	m	struct:debuggy	file:
dbg_name	ex_cmds2.c	/^    char_u	*dbg_name;	\/* function or file name *\/$/;"	m	struct:debuggy	file:
dbg_nr	ex_cmds2.c	/^    int		dbg_nr;		\/* breakpoint number *\/$/;"	m	struct:debuggy	file:
dbg_parsearg	ex_cmds2.c	/^dbg_parsearg(arg)$/;"	f	file:
dbg_prog	ex_cmds2.c	/^    regprog_T	*dbg_prog;	\/* regexp program *\/$/;"	m	struct:debuggy	file:
dbg_tick	eval.c	/^    int		dbg_tick;	\/* debug_tick when breakpoint was set *\/$/;"	m	struct:funccall	file:
dbg_tick	ex_cmds2.c	/^    int		dbg_tick;	\/* debug_tick when breakpoint was set *\/$/;"	m	struct:source_cookie	file:
dbg_type	ex_cmds2.c	/^    int		dbg_type;	\/* DBG_FUNC or DBG_FILE *\/$/;"	m	struct:debuggy	file:
debug_break_level	globals.h	/^EXTERN int	debug_break_level INIT(= -1);	\/* break below this level *\/$/;"	v
debug_breakpoint_lnum	ex_cmds2.c	/^static linenr_T	debug_breakpoint_lnum;$/;"	v	file:
debug_breakpoint_name	ex_cmds2.c	/^static char_u	*debug_breakpoint_name = NULL;$/;"	v	file:
debug_did_msg	globals.h	/^EXTERN int	debug_did_msg INIT(= FALSE);	\/* did "debug mode" message *\/$/;"	v
debug_greedy	ex_cmds2.c	/^static int debug_greedy = FALSE;	\/* batch mode debugging: don't save$/;"	v	file:
debug_skipped	ex_cmds2.c	/^static int	debug_skipped;$/;"	v	file:
debug_skipped_name	ex_cmds2.c	/^static char_u	*debug_skipped_name;$/;"	v	file:
debug_tick	globals.h	/^EXTERN int	debug_tick INIT(= 0);		\/* breakpoint change count *\/$/;"	v
debugfp	globals.h	/^EXTERN FILE *debugfp INIT(= NULL);$/;"	v
debuggy	ex_cmds2.c	/^struct debuggy$/;"	s	file:
dec	misc2.c	/^dec(lp)$/;"	f
dec_cursor	misc2.c	/^dec_cursor()$/;"	f
decl	misc2.c	/^decl(lp)$/;"	f
decomp_T	regexp.c	/^} decomp_T;$/;"	t	typeref:struct:__anon52	file:
decomp_table	regexp.c	/^decomp_T decomp_table[0xfb4f-0xfb20+1] =$/;"	v
decrypt_byte	misc2.c	/^decrypt_byte()$/;"	f
def_back_pixel	gui.h	/^    guicolor_T	def_back_pixel;	    \/* default Color of background *\/$/;"	m	struct:Gui
def_norm_pixel	gui.h	/^    guicolor_T	def_norm_pixel;	    \/* default Color of normal text *\/$/;"	m	struct:Gui
def_val	option.c	/^    char_u	*def_val[2];	\/* default values for variable (vi and vim) *\/$/;"	m	struct:vimoption	file:
default_fileformat	misc2.c	/^default_fileformat()$/;"	f
del_bytes	misc1.c	/^del_bytes(count, fixpos)$/;"	f
del_char	misc1.c	/^del_char(fixpos)$/;"	f
del_chars	misc1.c	/^del_chars(count, fixpos)$/;"	f
del_from_showcmd	normal.c	/^del_from_showcmd(len)$/;"	f	file:
del_history_entry	ex_getln.c	/^del_history_entry(histype, str)$/;"	f
del_history_idx	ex_getln.c	/^del_history_idx(histype, idx)$/;"	f
del_lines	misc1.c	/^del_lines(nlines, undo)$/;"	f
del_menutrans_vars	eval.c	/^del_menutrans_vars()$/;"	f
del_mouse_termcode	term.c	/^del_mouse_termcode(n)$/;"	f
del_termcode	term.c	/^del_termcode(name)$/;"	f
del_termcode_idx	term.c	/^del_termcode_idx(idx)$/;"	f	file:
del_trailing_spaces	misc2.c	/^del_trailing_spaces(ptr)$/;"	f
del_typebuf	getchar.c	/^del_typebuf(len, offset)$/;"	f
delbuf_msg	ex_cmds.c	/^delbuf_msg(name)$/;"	f	file:
deleteFold	fold.c	/^deleteFold(start, end, recursive, had_visual)$/;"	f
deleteFoldEntry	fold.c	/^deleteFoldEntry(gap, idx, recursive)$/;"	f	file:
deleteFoldMarkers	fold.c	/^deleteFoldMarkers(fp, recursive, lnum_off)$/;"	f	file:
deleteFoldRecurse	fold.c	/^deleteFoldRecurse(gap)$/;"	f
deleted_lines	misc1.c	/^deleted_lines(lnum, count)$/;"	f
deleted_lines_mark	misc1.c	/^deleted_lines_mark(lnum, count)$/;"	f
detected_8bit	term.c	/^static int  detected_8bit = FALSE;	\/* detected 8-bit terminal *\/$/;"	v	file:
dev	ex_cmds2.c	/^    int		dev;$/;"	m	struct:scriptstuff	file:
dev_T	buffer.c	53;"	d	file:
dev_T	buffer.c	55;"	d	file:
df_count	diff.c	/^    linenr_T	df_count[DB_COUNT];	\/* nr of inserted\/changed lines *\/$/;"	m	struct:diffblock	file:
df_lnum	diff.c	/^    linenr_T	df_lnum[DB_COUNT];	\/* line number in buffer *\/$/;"	m	struct:diffblock	file:
df_next	diff.c	/^    diff_T	*df_next;$/;"	m	struct:diffblock	file:
dialog_changed	ex_cmds2.c	/^dialog_changed(buf, checkall)$/;"	f
dialog_msg	ex_docmd.c	/^dialog_msg(buff, format, fname)$/;"	f
did_add_space	edit.c	/^static int	did_add_space = FALSE;	\/* auto_format() added an extra space$/;"	v	file:
did_ai	globals.h	/^EXTERN int     did_ai INIT(= FALSE);$/;"	v
did_check_timestamps	globals.h	/^EXTERN int	did_check_timestamps INIT(= FALSE); \/* did check timestamps$/;"	v
did_emsg	globals.h	/^EXTERN int	did_emsg;		    \/* set by emsg() when the message$/;"	v
did_endif	globals.h	/^EXTERN int	did_endif INIT(= FALSE);    \/* just had ":endif" *\/$/;"	v
did_filetype	globals.h	/^EXTERN int	did_filetype INIT(= FALSE);	\/* FileType event found *\/$/;"	v
did_match_already	syntax.c	/^did_match_already(idx, gap)$/;"	f	file:
did_outofmem_msg	globals.h	/^EXTERN int	did_outofmem_msg INIT(= FALSE);$/;"	v
did_set_string_option	option.c	/^did_set_string_option(opt_idx, varp, new_value_alloced, oldval, errbuf,$/;"	f	file:
did_set_title	option.c	/^did_set_title(icon)$/;"	f	file:
did_si	globals.h	/^EXTERN int	did_si INIT(= FALSE);$/;"	v
did_swapwrite_msg	globals.h	/^EXTERN int	did_swapwrite_msg INIT(= FALSE);$/;"	v
did_syncbind	globals.h	/^EXTERN int     did_syncbind INIT(= FALSE);$/;"	v
did_throw	globals.h	/^EXTERN int did_throw INIT(= FALSE);$/;"	v
did_wait_return	globals.h	/^EXTERN int	did_wait_return INIT(= FALSE);	\/* wait_return() was used and$/;"	v
didset_options	option.c	/^didset_options()$/;"	f	file:
didset_vim	globals.h	/^EXTERN int	didset_vim INIT(= FALSE);   \/* did set $VIM ourselves *\/$/;"	v
didset_vimruntime	globals.h	/^EXTERN int	didset_vimruntime INIT(= FALSE);   \/* idem for $VIMRUNTIME *\/$/;"	v
diff_T	diff.c	/^typedef struct diffblock diff_T;$/;"	t	typeref:struct:diffblock	file:
diff_a_works	diff.c	/^static int diff_a_works = MAYBE; \/* TRUE when "diff -a" works, FALSE when it$/;"	v	file:
diff_alloc_new	diff.c	/^diff_alloc_new(dprev, dp)$/;"	f	file:
diff_bin_works	diff.c	/^static int diff_bin_works = MAYBE; \/* TRUE when "diff --binary" works, FALSE$/;"	v	file:
diff_buf_add	diff.c	/^diff_buf_add(buf)$/;"	f
diff_buf_delete	diff.c	/^diff_buf_delete(buf)$/;"	f
diff_buf_idx	diff.c	/^diff_buf_idx(buf)$/;"	f	file:
diff_busy	diff.c	/^static int	diff_busy = FALSE;	\/* ex_diffgetput() is busy *\/$/;"	v	file:
diff_check	diff.c	/^diff_check(wp, lnum)$/;"	f
diff_check_fill	diff.c	/^diff_check_fill(wp, lnum)$/;"	f
diff_check_sanity	diff.c	/^diff_check_sanity(dp)$/;"	f	file:
diff_check_unchanged	diff.c	/^diff_check_unchanged(dp)$/;"	f	file:
diff_clear	diff.c	/^diff_clear()$/;"	f	file:
diff_cmp	diff.c	/^diff_cmp(s1, s2)$/;"	f	file:
diff_context	globals.h	/^EXTERN int	diff_context INIT(= 6);	\/* context for folds *\/$/;"	v
diff_copy_entry	diff.c	/^diff_copy_entry(dprev, dp, idx_orig, idx_new)$/;"	f	file:
diff_equal_entry	diff.c	/^diff_equal_entry(dp, idx1, idx2)$/;"	f	file:
diff_file	diff.c	/^diff_file(tmp_orig, tmp_new, tmp_diff)$/;"	f	file:
diff_find_change	diff.c	/^diff_find_change(wp, lnum, startp, endp)$/;"	f
diff_flags	diff.c	/^static int	diff_flags = DIFF_FILLER;$/;"	v	file:
diff_fold_update	diff.c	/^diff_fold_update(dp, skip_idx)$/;"	f	file:
diff_infold	diff.c	/^diff_infold(wp, lnum)$/;"	f
diff_invalid	diff.c	/^static int	diff_invalid = TRUE;	\/* list of diffs is outdated *\/$/;"	v	file:
diff_invalidate	diff.c	/^diff_invalidate()$/;"	f
diff_lnum_win	diff.c	/^diff_lnum_win(lnum, wp)$/;"	f
diff_mark_adjust	diff.c	/^diff_mark_adjust(line1, line2, amount, amount_after)$/;"	f
diff_mode_buf	diff.c	/^diff_mode_buf(buf)$/;"	f
diff_move_to	diff.c	/^diff_move_to(dir, count)$/;"	f
diff_new_buffer	diff.c	/^diff_new_buffer()$/;"	f
diff_read	diff.c	/^diff_read(idx_orig, idx_new, fname)$/;"	f	file:
diff_redraw	diff.c	/^diff_redraw(dofold)$/;"	f	file:
diff_set_topline	diff.c	/^diff_set_topline(fromwin, towin)$/;"	f
diff_win_options	diff.c	/^diff_win_options(wp, addbuf)$/;"	f
diff_write	diff.c	/^diff_write(buf, fname)$/;"	f	file:
diffblock	diff.c	/^struct diffblock$/;"	s	file:
diffbuf	diff.c	/^static buf_T	*(diffbuf[DB_COUNT]);$/;"	v	file:
diffopt_changed	diff.c	/^diffopt_changed()$/;"	f
digr_T	digraph.c	/^} digr_T;$/;"	t	typeref:struct:digraph	file:
digraph	digraph.c	/^typedef struct digraph$/;"	s	file:
digraphdefault	digraph.c	/^digr_T	digraphdefault[] =$/;"	v
dir	search.c	/^    int		dir;		\/* search direction *\/$/;"	m	struct:soffset	file:
dir_stack	quickfix.c	/^static struct dir_stack_T   *dir_stack = NULL;$/;"	v	typeref:struct:dir_stack_T	file:
dir_stack_T	quickfix.c	/^struct dir_stack_T$/;"	s	file:
dirname	quickfix.c	/^    char_u		*dirname;$/;"	m	struct:dir_stack_T	file:
dis_msg	ops.c	/^dis_msg(p, skip_esc)$/;"	f	file:
disallow_gui	globals.h	/^EXTERN short disallow_gui	INIT(= FALSE);$/;"	v
discard_current_exception	ex_eval.c	/^discard_current_exception()$/;"	f
discard_exception	ex_eval.c	/^discard_exception(excp, was_finished)$/;"	f	file:
discard_pending_return	eval.c	/^discard_pending_return(retvar)$/;"	f
display_confirm_msg	message.c	/^display_confirm_msg()$/;"	f
display_dollar	edit.c	/^display_dollar(col)$/;"	f
display_errors	gui.c	/^display_errors()$/;"	f
display_errors	vim.h	1581;"	d
display_showcmd	normal.c	/^display_showcmd()$/;"	f	file:
display_tick	globals.h	/^EXTERN disptick_T	display_tick INIT(= 0);$/;"	v
displayname	netbeans.c	/^    char		*displayname;$/;"	m	struct:nbbuf_struct	file:
disptick_T	vim.h	/^typedef unsigned short disptick_T;	\/* display tick type *\/$/;"	t
dname	structs.h	/^    char_u	*dname;		    \/* Displayed Name (without '&') *\/$/;"	m	struct:VimMenu
dnd_yank_drag_data	ops.c	/^dnd_yank_drag_data(str, len)$/;"	f
do_Lower	regexp.c	/^do_Lower(d, c)$/;"	f	file:
do_Upper	regexp.c	/^do_Upper(d, c)$/;"	f	file:
do_addsub	ops.c	/^do_addsub(command, Prenum1)$/;"	f
do_arg_all	buffer.c	/^do_arg_all(count, forceit)$/;"	f
do_argfile	ex_cmds2.c	/^do_argfile(eap, argn)$/;"	f
do_arglist	ex_cmds2.c	/^do_arglist(str, what, after)$/;"	f	file:
do_ascii	ex_cmds.c	/^do_ascii(eap)$/;"	f
do_augroup	fileio.c	/^do_augroup(arg, del_group)$/;"	f
do_autocmd	fileio.c	/^do_autocmd(arg, forceit)$/;"	f
do_autocmd_event	fileio.c	/^do_autocmd_event(event, pat, nested, cmd, forceit, group)$/;"	f	file:
do_bang	ex_cmds.c	/^do_bang(addr_count, eap, forceit, do_in, do_out)$/;"	f
do_browse	message.c	/^do_browse(saving, title, dflt, ext, initdir, filter, buf)$/;"	f
do_bufdel	buffer.c	/^do_bufdel(command, arg, addr_count, start_bnr, end_bnr, forceit)$/;"	f
do_buffer	buffer.c	/^do_buffer(action, start, dir, count, forceit)$/;"	f
do_c_expr_indent	misc1.c	/^do_c_expr_indent()$/;"	f
do_check_scrollbind	normal.c	/^do_check_scrollbind(check)$/;"	f
do_cmdline	ex_docmd.c	/^do_cmdline(cmdline, getline, cookie, flags)$/;"	f
do_cmdline_cmd	ex_docmd.c	/^do_cmdline_cmd(cmd)$/;"	f
do_cscope	ex_docmd.c	216;"	d	file:
do_cstag	ex_docmd.c	218;"	d	file:
do_debug	ex_cmds2.c	/^do_debug(cmd)$/;"	f
do_dialog	message.c	/^do_dialog(type, title, message, buttons, dfltbutton, textfield)$/;"	f
do_dialog	vim.h	1603;"	d
do_digraph	digraph.c	/^do_digraph(c)$/;"	f
do_do_join	ops.c	/^do_do_join(count, insert_space)$/;"	f
do_doautocmd	fileio.c	/^do_doautocmd(arg, do_msg)$/;"	f
do_ecmd	ex_cmds.c	/^do_ecmd(fnum, ffname, sfname, eap, newlnum, flags)$/;"	f
do_ecmd_cmd	ex_cmds.h	/^    char_u	*do_ecmd_cmd;	\/* +command arg to be used in edited file *\/$/;"	m	struct:exarg
do_ecmd_lnum	ex_cmds.h	/^    linenr_T	do_ecmd_lnum;	\/* the line number in an edited file *\/$/;"	m	struct:exarg
do_errthrow	ex_eval.c	/^do_errthrow(cstack, cmdname)$/;"	f
do_execreg	ops.c	/^do_execreg(regname, colon, addcr)$/;"	f
do_exedit	ex_docmd.c	/^do_exedit(eap, old_curwin)$/;"	f
do_exmap	ex_docmd.c	/^do_exmap(eap, isabbrev)$/;"	f	file:
do_exmode	ex_docmd.c	/^do_exmode(improved)$/;"	f
do_filter	ex_cmds.c	/^do_filter(line1, line2, eap, cmd, do_in, do_out)$/;"	f	file:
do_finish	ex_cmds2.c	/^do_finish(eap, reanimate)$/;"	f
do_fixdel	ex_cmds.c	/^do_fixdel(eap)$/;"	f
do_highlight	syntax.c	/^do_highlight(line, forceit, init)$/;"	f
do_in_runtimepath	ex_cmds2.c	/^do_in_runtimepath(name, all, callback)$/;"	f
do_intro_line	version.c	/^do_intro_line(row, mesg, add_version, attr)$/;"	f	file:
do_intthrow	ex_eval.c	/^do_intthrow(cstack)$/;"	f
do_join	ops.c	/^do_join(insert_space)$/;"	f
do_lower	regexp.c	/^do_lower(d, c)$/;"	f	file:
do_map	getchar.c	/^do_map(maptype, arg, mode, abbrev)$/;"	f
do_marks	mark.c	/^do_marks(eap)$/;"	f
do_modelines	buffer.c	/^do_modelines()$/;"	f
do_mouse	normal.c	/^do_mouse(oap, c, dir, count, fixindent)$/;"	f
do_move	ex_cmds.c	/^do_move(line1, line2, dest)$/;"	f
do_nv_ident	normal.c	/^do_nv_ident(c1, c2)$/;"	f
do_one_arg	ex_cmds2.c	/^do_one_arg(str)$/;"	f
do_one_cmd	ex_docmd.c	/^do_one_cmd(cmdlinep, sourcing,$/;"	f	file:
do_outofmem_msg	misc2.c	/^do_outofmem_msg(size)$/;"	f
do_pending_operator	normal.c	/^do_pending_operator(cap, old_col, gui_yank)$/;"	f
do_put	ops.c	/^do_put(regname, dir, count, flags)$/;"	f
do_record	ops.c	/^do_record(c)$/;"	f
do_redraw	globals.h	/^EXTERN int	do_redraw INIT(= FALSE);    \/* extra redraw once *\/$/;"	v
do_return	eval.c	/^do_return(eap, reanimate, is_cmd, value)$/;"	f
do_scscope	ex_docmd.c	217;"	d	file:
do_search	search.c	/^do_search(oap, dirc, pat, count, options)$/;"	f
do_set	option.c	/^do_set(arg, opt_flags)$/;"	f
do_shell	ex_cmds.c	/^do_shell(cmd, flags)$/;"	f
do_sleep	ex_docmd.c	/^do_sleep(msec)$/;"	f
do_source	ex_cmds2.c	/^do_source(fname, check_other, is_vimrc)$/;"	f
do_string_sub	eval.c	/^do_string_sub(str, pat, sub, flags)$/;"	f
do_sub	ex_cmds.c	/^do_sub(eap)$/;"	f
do_sub_msg	ex_cmds.c	/^do_sub_msg()$/;"	f	file:
do_syntax	structs.h	/^    int		do_syntax;$/;"	m	struct:__anon45
do_tag	tag.c	/^do_tag(tag, type, count, forceit, verbose)$/;"	f
do_tags	tag.c	/^do_tags(eap)$/;"	f
do_throw	ex_eval.c	/^do_throw(cstack)$/;"	f
do_ucmd	ex_docmd.c	/^do_ucmd(eap)$/;"	f	file:
do_unlet	eval.c	/^do_unlet(name)$/;"	f
do_upper	regexp.c	/^do_upper(d, c)$/;"	f	file:
do_viminfo	ex_cmds.c	/^do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)$/;"	f	file:
do_window	window.c	/^do_window(nchar, Prenum, xchar)$/;"	f
do_wqall	ex_cmds.c	/^do_wqall(eap)$/;"	f
do_write	ex_cmds.c	/^do_write(eap)$/;"	f
dofork	gui.h	/^    int		dofork;		    \/* Use fork() when GUI is starting *\/$/;"	m	struct:Gui
dollar_command	ex_docmd.c	/^static char_u dollar_command[2] = {'$', 0};$/;"	v	file:
dollar_vcol	globals.h	/^EXTERN colnr_T	dollar_vcol INIT(= 0);$/;"	v
dont_release	memfile.c	/^static int	dont_release = FALSE;	\/* don't release blocks *\/$/;"	v	file:
dont_scroll	globals.h	/^EXTERN int	dont_scroll INIT(= FALSE);\/* don't use scrollbars when TRUE *\/$/;"	v
dos2	os_amiga.c	/^int			dos2 = FALSE;	    \/* Amiga DOS 2.0x or higher *\/$/;"	v
dos_expandpath	misc1.c	/^dos_expandpath($/;"	f	file:
dos_packet	os_amiga.c	/^dos_packet(pid, action, arg)$/;"	f	file:
dpy	gui.h	/^    Display	*dpy;		    \/* X display *\/$/;"	m	struct:Gui
drag_sep_line	globals.h	/^EXTERN int	drag_sep_line INIT(= FALSE);	\/* dragging vert separator *\/$/;"	v
drag_status_line	globals.h	/^EXTERN int	drag_status_line INIT(= FALSE);	\/* dragging the status line *\/$/;"	v
dragged_sb	gui.h	/^    int		dragged_sb;	    \/* Which scrollbar being dragged, if any? *\/$/;"	m	struct:Gui
dragged_wp	gui.h	/^    win_T	*dragged_wp;	    \/* Which WIN's sb being dragged, if any? *\/$/;"	m	struct:Gui
drawBalloon	gui_beval.c	/^drawBalloon(BalloonEval *beval)$/;"	f	file:
drawBalloon	gui_beval.c	/^drawBalloon(beval)$/;"	f	file:
drawBox	gui_amiga.c	/^drawBox(enum DrawBoxMode mode, unsigned short col, unsigned short row, int w, int h, guicolor_T color)$/;"	f	file:
draw_cmdline	ex_getln.c	/^draw_cmdline(start, len)$/;"	f	file:
draw_feedback	globals.h	/^EXTERN char		*draw_feedback INIT(= NULL);$/;"	v
draw_signcolumn	screen.c	/^draw_signcolumn(wp)$/;"	f	file:
draw_vsep_win	screen.c	/^draw_vsep_win(wp, row)$/;"	f	file:
drawarea	gui.h	/^    GtkWidget	*drawarea;	    \/* the "text" area *\/$/;"	m	struct:Gui
dummy	testdir/test49.vim	/^		    let dummy = 0$/;"	v
duplex	structs.h	/^    int		duplex;$/;"	m	struct:__anon45
dy_flags	option.h	/^EXTERN unsigned	dy_flags;$/;"	v
dying	gui.h	/^    int		dying;		    \/* Is vim dying? Then output to terminal *\/$/;"	m	struct:Gui
e_abort	globals.h	/^EXTERN char_u e_abort[]		INIT(=N_("E470: Command aborted"));$/;"	v
e_argreq	globals.h	/^EXTERN char_u e_argreq[]	INIT(=N_("E471: Argument required"));$/;"	v
e_backslash	globals.h	/^EXTERN char_u e_backslash[]	INIT(=N_("E10: \\\\ should be followed by \/, ? or &"));$/;"	v
e_cmdwin	globals.h	/^EXTERN char_u e_cmdwin[]	INIT(=N_("E11: Invalid in command-line window; <CR> executes, CTRL-C quits"));$/;"	v
e_curdir	globals.h	/^EXTERN char_u e_curdir[]	INIT(=N_("E12: Command not allowed from exrc\/vimrc in current dir or tag search"));$/;"	v
e_endif	globals.h	/^EXTERN char_u e_endif[]		INIT(=N_("E171: Missing :endif"));$/;"	v
e_endtry	globals.h	/^EXTERN char_u e_endtry[]	INIT(=N_("E600: Missing :endtry"));$/;"	v
e_endwhile	globals.h	/^EXTERN char_u e_endwhile[]	INIT(=N_("E170: Missing :endwhile"));$/;"	v
e_exists	globals.h	/^EXTERN char_u e_exists[]	INIT(=N_("E13: File exists (add ! to override)"));$/;"	v
e_failed	globals.h	/^EXTERN char_u e_failed[]	INIT(=N_("E472: Command failed"));$/;"	v
e_font	globals.h	/^EXTERN char_u e_font[]		INIT(=N_("E235: Unknown font: %s"));$/;"	v
e_fontset	globals.h	/^EXTERN char_u e_fontset[]	INIT(=N_("E234: Unknown fontset: %s"));$/;"	v
e_fontwidth	globals.h	/^EXTERN char_u e_fontwidth[]	INIT(=N_("E236: Font \\"%s\\" is not fixed-width"));$/;"	v
e_guarded	globals.h	/^EXTERN char_u e_guarded[]	INIT(=N_("E463: Region is guarded, cannot modify"));$/;"	v
e_hitend	edit.c	/^static char_u e_hitend[] = N_("Hit end of paragraph");$/;"	v	file:
e_internal	globals.h	/^EXTERN char_u e_internal[]	INIT(=N_("E473: Internal error"));$/;"	v
e_interr	globals.h	/^EXTERN char_u e_interr[]	INIT(=N_("Interrupted"));$/;"	v
e_invaddr	globals.h	/^EXTERN char_u e_invaddr[]	INIT(=N_("E14: Invalid address"));$/;"	v
e_invarg	globals.h	/^EXTERN char_u e_invarg[]	INIT(=N_("E474: Invalid argument"));$/;"	v
e_invarg2	globals.h	/^EXTERN char_u e_invarg2[]	INIT(=N_("E475: Invalid argument: %s"));$/;"	v
e_invcmd	globals.h	/^EXTERN char_u e_invcmd[]	INIT(=N_("E476: Invalid command"));$/;"	v
e_invexpr2	globals.h	/^EXTERN char_u e_invexpr2[]	INIT(=N_("E15: Invalid expression: %s"));$/;"	v
e_invexprmsg	globals.h	/^EXTERN char_u e_invexprmsg[]	INIT(=N_("E449: Invalid expression received"));$/;"	v
e_invrange	globals.h	/^EXTERN char_u e_invrange[]	INIT(=N_("E16: Invalid range"));$/;"	v
e_isadir2	globals.h	/^EXTERN char_u e_isadir2[]	INIT(=N_("E17: \\"%s\\" is a directory"));$/;"	v
e_letunexp	globals.h	/^EXTERN char_u e_letunexp[]	INIT(=N_("E18: Unexpected characters before '='"));$/;"	v
e_libcall	globals.h	/^EXTERN char_u e_libcall[]	INIT(=N_("E364: Library call failed for \\"%s()\\""));$/;"	v
e_loadfunc	globals.h	/^EXTERN char_u e_loadfunc[]	INIT(=N_("E448: Could not load library function %s"));$/;"	v
e_loadlib	globals.h	/^EXTERN char_u e_loadlib[]	INIT(=N_("E370: Could not load library %s"));$/;"	v
e_longname	globals.h	/^EXTERN char_u e_longname[]	INIT(=N_("E75: Name too long"));$/;"	v
e_markinval	globals.h	/^EXTERN char_u e_markinval[]	INIT(=N_("E19: Mark has invalid line number"));$/;"	v
e_marknotset	globals.h	/^EXTERN char_u e_marknotset[]	INIT(=N_("E20: Mark not set"));$/;"	v
e_modifiable	globals.h	/^EXTERN char_u e_modifiable[]	INIT(=N_("E21: Cannot make changes, 'modifiable' is off"));$/;"	v
e_nesting	globals.h	/^EXTERN char_u e_nesting[]	INIT(=N_("E22: Scripts nested too deep"));$/;"	v
e_noabbr	globals.h	/^EXTERN char_u e_noabbr[]	INIT(=N_("E24: No such abbreviation"));$/;"	v
e_noalt	globals.h	/^EXTERN char_u e_noalt[]		INIT(=N_("E23: No alternate file"));$/;"	v
e_noarabic	globals.h	/^EXTERN char_u e_noarabic[]	INIT(=N_("E800: Arabic cannot be used: Not enabled at compile time\\n"));$/;"	v
e_nobang	globals.h	/^EXTERN char_u e_nobang[]	INIT(=N_("E477: No ! allowed"));$/;"	v
e_nofarsi	globals.h	/^EXTERN char_u e_nofarsi[]	INIT(=N_("E27: Farsi cannot be used: Not enabled at compile time\\n"));$/;"	v
e_nofold	fold.c	/^static char *e_nofold = N_("E490: No fold found");$/;"	v	file:
e_nogroup	globals.h	/^EXTERN char_u e_nogroup[]	INIT(=N_("E28: No such highlight group name: %s"));$/;"	v
e_nogvim	globals.h	/^EXTERN char_u e_nogvim[]	INIT(=N_("E25: GUI cannot be used: Not enabled at compile time"));$/;"	v
e_nohebrew	globals.h	/^EXTERN char_u e_nohebrew[]	INIT(=N_("E26: Hebrew cannot be used: Not enabled at compile time\\n"));$/;"	v
e_noinstext	globals.h	/^EXTERN char_u e_noinstext[]	INIT(=N_("E29: No inserted text yet"));$/;"	v
e_nolastcmd	globals.h	/^EXTERN char_u e_nolastcmd[]	INIT(=N_("E30: No previous command line"));$/;"	v
e_nomap	globals.h	/^EXTERN char_u e_nomap[]		INIT(=N_("E31: No such mapping"));$/;"	v
e_nomatch	globals.h	/^EXTERN char_u e_nomatch[]	INIT(=N_("E479: No match"));$/;"	v
e_nomatch2	globals.h	/^EXTERN char_u e_nomatch2[]	INIT(=N_("E480: No match: %s"));$/;"	v
e_nomenu	menu.c	/^static char_u e_nomenu[] = N_("E329: No menu of that name");$/;"	v	file:
e_noname	globals.h	/^EXTERN char_u e_noname[]	INIT(=N_("E32: No file name"));$/;"	v
e_nopresub	globals.h	/^EXTERN char_u e_nopresub[]	INIT(=N_("E33: No previous substitute regular expression"));$/;"	v
e_noprev	globals.h	/^EXTERN char_u e_noprev[]	INIT(=N_("E34: No previous command"));$/;"	v
e_noprevre	globals.h	/^EXTERN char_u e_noprevre[]	INIT(=N_("E35: No previous regular expression"));$/;"	v
e_norange	globals.h	/^EXTERN char_u e_norange[]	INIT(=N_("E481: No range allowed"));$/;"	v
e_noroom	globals.h	/^EXTERN char_u e_noroom[]	INIT(=N_("E36: Not enough room"));$/;"	v
e_noserver	globals.h	/^EXTERN char_u e_noserver[]	INIT(=N_("E247: no registered server named \\"%s\\""));$/;"	v
e_notcreate	globals.h	/^EXTERN char_u e_notcreate[]	INIT(=N_("E482: Can't create file %s"));$/;"	v
e_notmp	globals.h	/^EXTERN char_u e_notmp[]		INIT(=N_("E483: Can't get temp file name"));$/;"	v
e_notopen	globals.h	/^EXTERN char_u e_notopen[]	INIT(=N_("E484: Can't open file %s"));$/;"	v
e_notread	globals.h	/^EXTERN char_u e_notread[]	INIT(=N_("E485: Can't read file %s"));$/;"	v
e_notsubmenu	menu.c	/^static char_u e_notsubmenu[] = N_("E327: Part of menu-item path is not sub-menu");$/;"	v	file:
e_nowrtmsg	globals.h	/^EXTERN char_u e_nowrtmsg[]	INIT(=N_("E37: No write since last change (add ! to override)"));$/;"	v
e_null	globals.h	/^EXTERN char_u e_null[]		INIT(=N_("E38: Null argument"));$/;"	v
e_number_exp	globals.h	/^EXTERN char_u e_number_exp[]	INIT(=N_("E39: Number expected"));$/;"	v
e_opendisp	globals.h	/^EXTERN char_u e_opendisp[]	INIT(=N_("E233: cannot open display"));$/;"	v
e_openerrf	globals.h	/^EXTERN char_u e_openerrf[]	INIT(=N_("E40: Can't open errorfile %s"));$/;"	v
e_othermode	menu.c	/^static char_u e_othermode[] = N_("E328: Menu only exists in another mode");$/;"	v	file:
e_outofmem	globals.h	/^EXTERN char_u e_outofmem[]	INIT(=N_("E41: Out of memory!"));$/;"	v
e_overthespot	mbyte.c	/^static char e_overthespot[] = N_("E290: over-the-spot style requires fontset");$/;"	v	file:
e_patnotf	globals.h	/^EXTERN char_u e_patnotf[]	INIT(=N_("Pattern not found"));$/;"	v
e_patnotf2	globals.h	/^EXTERN char_u e_patnotf2[]	INIT(=N_("E486: Pattern not found: %s"));$/;"	v
e_positive	globals.h	/^EXTERN char_u e_positive[]	INIT(=N_("E487: Argument must be positive"));$/;"	v
e_prev_dir	globals.h	/^EXTERN char_u e_prev_dir[]	INIT(=N_("E459: Cannot go back to previous directory"));$/;"	v
e_quickfix	globals.h	/^EXTERN char_u e_quickfix[]	INIT(=N_("E42: No Errors"));$/;"	v
e_re_corr	globals.h	/^EXTERN char_u e_re_corr[]	INIT(=N_("E44: Corrupted regexp program"));$/;"	v
e_re_damg	globals.h	/^EXTERN char_u e_re_damg[]	INIT(=N_("E43: Damaged match string"));$/;"	v
e_readerrf	globals.h	/^EXTERN char_u e_readerrf[]	INIT(=N_("E47: Error while reading errorfile"));$/;"	v
e_readonly	globals.h	/^EXTERN char_u e_readonly[]	INIT(=N_("E45: 'readonly' option is set (add ! to override)"));$/;"	v
e_readonlyvar	globals.h	/^EXTERN char_u e_readonlyvar[]	INIT(=N_("E46: Cannot set read-only variable \\"%s\\""));$/;"	v
e_sandbox	globals.h	/^EXTERN char_u e_sandbox[]	INIT(=N_("E48: Not allowed in sandbox"));$/;"	v
e_screenmode	globals.h	/^EXTERN char_u e_screenmode[]	INIT(=N_("E359: Screen mode setting not supported"));$/;"	v
e_scroll	globals.h	/^EXTERN char_u e_scroll[]	INIT(=N_("E49: Invalid scroll size"));$/;"	v
e_secure	globals.h	/^EXTERN char_u e_secure[]	INIT(=N_("E523: Not allowed here"));$/;"	v
e_shellempty	globals.h	/^EXTERN char_u e_shellempty[]	INIT(=N_("E91: 'shell' option is empty"));$/;"	v
e_signdata	globals.h	/^EXTERN char_u e_signdata[]	INIT(=N_("E255: Couldn't read in sign data!"));$/;"	v
e_swapclose	globals.h	/^EXTERN char_u e_swapclose[]	INIT(=N_("E72: Close error on swap file"));$/;"	v
e_tagstack	globals.h	/^EXTERN char_u e_tagstack[]	INIT(=N_("E73: tag stack empty"));$/;"	v
e_toocompl	globals.h	/^EXTERN char_u e_toocompl[]	INIT(=N_("E74: Command too complex"));$/;"	v
e_toomany	globals.h	/^EXTERN char_u e_toomany[]	INIT(=N_("E77: Too many file names"));$/;"	v
e_toomsbra	globals.h	/^EXTERN char_u e_toomsbra[]	INIT(=N_("E76: Too many ["));$/;"	v
e_trailing	globals.h	/^EXTERN char_u e_trailing[]	INIT(=N_("E488: Trailing characters"));$/;"	v
e_umark	globals.h	/^EXTERN char_u e_umark[]		INIT(=N_("E78: Unknown mark"));$/;"	v
e_usingsid	globals.h	/^EXTERN char_u e_usingsid[]	INIT(=N_("E81: Using <SID> not in a script context"));$/;"	v
e_while	globals.h	/^EXTERN char_u e_while[]		INIT(=N_("E588: :endwhile without :while"));$/;"	v
e_wildexpand	globals.h	/^EXTERN char_u e_wildexpand[]	INIT(=N_("E79: Cannot expand wildcards"));$/;"	v
e_winheight	globals.h	/^EXTERN char_u e_winheight[]	INIT(=N_("E591: 'winheight' cannot be smaller than 'winminheight'"));$/;"	v
e_winwidth	globals.h	/^EXTERN char_u e_winwidth[]	INIT(=N_("E592: 'winwidth' cannot be smaller than 'winminwidth'"));$/;"	v
e_write	globals.h	/^EXTERN char_u e_write[]		INIT(=N_("E80: Error while writing"));$/;"	v
e_xim	mbyte.c	/^static char e_xim[] = N_("E285: Failed to create input context");$/;"	v	file:
e_zerocount	globals.h	/^EXTERN char_u e_zerocount[]	INIT(=N_("Zero count"));$/;"	v
ebcdic2ascii	charset.c	/^ebcdic2ascii(buffer, len)$/;"	f
ebcdic2ascii_tab	charset.c	/^static char_u ebcdic2ascii_tab[256] =$/;"	v	file:
echeck_abbr	edit.c	/^echeck_abbr(c)$/;"	f	file:
echo_attr	eval.c	/^static int echo_attr = 0;   \/* attributes used for ":echo" *\/$/;"	v	file:
echo_wid_arg	globals.h	/^EXTERN int	echo_wid_arg INIT(= FALSE);	\/* --echo-wid argument *\/$/;"	v
edit	edit.c	/^edit(cmdchar, startln, count)$/;"	f
edit_putchar	edit.c	/^edit_putchar(c, highlight)$/;"	f
edit_submode	globals.h	/^EXTERN char_u	*edit_submode INIT(= NULL); \/* msg for CTRL-X submode *\/$/;"	v
edit_submode_extra	globals.h	/^EXTERN char_u	*edit_submode_extra INIT(= NULL);\/* appended to edit_submode *\/$/;"	v
edit_submode_highl	globals.h	/^EXTERN enum hlf_value	edit_submode_highl; \/* highl. method for extra info *\/$/;"	v	typeref:enum:hlf_value
edit_submode_pre	globals.h	/^EXTERN char_u	*edit_submode_pre INIT(= NULL); \/* prepended to edit_submode *\/$/;"	v
edit_unputchar	edit.c	/^edit_unputchar()$/;"	f
eformat	quickfix.c	/^struct eformat$/;"	s	file:
empty	structs.h	/^    int		empty;		\/* op_start and op_end the same (only used by$/;"	m	struct:oparg
empty_option	globals.h	/^EXTERN char_u	*empty_option INIT(= (char_u *)"");$/;"	v
emsg	message.c	/^emsg(s)$/;"	f
emsg2	message.c	/^emsg2(s, a1)$/;"	f
emsg3	message.c	/^emsg3(s, a1, a2)$/;"	f
emsg_off	globals.h	/^EXTERN int	emsg_off INIT(= 0);	    \/* don't display errors for now,$/;"	v
emsg_on_display	globals.h	/^EXTERN int	emsg_on_display INIT(= FALSE);	\/* there is an error message *\/$/;"	v
emsg_severe	globals.h	/^EXTERN int	emsg_severe INIT(=FALSE);   \/* use message of next of several$/;"	v
emsg_silent	globals.h	/^EXTERN int	emsg_silent INIT(= 0);	\/* don't print error messages *\/$/;"	v
emsg_skip	globals.h	/^EXTERN int	emsg_skip INIT(= 0);	    \/* don't display errors for$/;"	v
emsgn	message.c	/^emsgn(s, n)$/;"	f
enabled	structs.h	/^    int		enabled;	    \/* for which modes the menu is enabled *\/$/;"	m	struct:VimMenu
enc_alias_search	mbyte.c	/^enc_alias_search(name)$/;"	f	file:
enc_alias_table	mbyte.c	/^enc_alias_table[] =$/;"	v	typeref:struct:__anon12	file:
enc_canon_props	mbyte.c	/^enc_canon_props(name)$/;"	f
enc_canon_search	mbyte.c	/^enc_canon_search(name)$/;"	f	file:
enc_canon_table	mbyte.c	/^enc_canon_table[] =$/;"	v	typeref:struct:__anon11	file:
enc_canonize	mbyte.c	/^enc_canonize(enc)$/;"	f
enc_codepage	globals.h	/^EXTERN int	enc_codepage INIT(= -1);$/;"	v
enc_dbcs	globals.h	/^EXTERN int	enc_dbcs INIT(= 0);		\/* One of DBCS_xxx values if$/;"	v
enc_locale	mbyte.c	/^enc_locale()$/;"	f
enc_skip	mbyte.c	/^enc_skip(p)$/;"	f
enc_unicode	globals.h	/^EXTERN int	enc_unicode INIT(= 0);	\/* 2: UCS-2 or UTF-16, 4: UCS-4 *\/$/;"	v
enc_utf8	globals.h	/^EXTERN int	enc_utf8 INIT(= FALSE);		\/* UTF-8 encoded Unicode *\/$/;"	v
encname2codepage	mbyte.c	/^encname2codepage(name)$/;"	f
end	fold.c	/^    int		end;		\/* level of fold that is forced to end below$/;"	m	struct:__anon15	file:
end	search.c	/^    int		end;		\/* search set cursor at end *\/$/;"	m	struct:soffset	file:
end	structs.h	/^    pos_T	end;		\/* end of the operator *\/$/;"	m	struct:oparg
end	vim.h	/^    pos_T	end;		\/* End of selected area *\/$/;"	m	struct:VimClipboard
end_adjusted	structs.h	/^    int		end_adjusted;	\/* backuped b_op_end one char (only used by$/;"	m	struct:oparg
end_char_vcols	ops.c	/^    colnr_T	end_char_vcols;	\/* number of vcols of post-block char *\/$/;"	m	struct:block_def	file:
end_comment_pending	globals.h	/^EXTERN int     end_comment_pending INIT(= NUL);$/;"	v
end_search_hl	screen.c	/^end_search_hl()$/;"	f	file:
end_vcol	ops.c	/^    colnr_T	end_vcol;	\/* start col of 1st char wholly after block *\/$/;"	m	struct:block_def	file:
end_vcol	structs.h	/^    colnr_T	end_vcol;	\/* end col for block mode operator *\/$/;"	m	struct:oparg
end_visual_mode	normal.c	/^end_visual_mode()$/;"	f
end_word	search.c	/^end_word(count, bigword, stop, empty)$/;"	f
endcol	screen.c	/^    colnr_T	endcol;	 \/* in win_line() points to char where HL ends *\/$/;"	m	struct:__anon1	file:
endp	regexp.h	/^    char_u		*endp[NSUBEXP];$/;"	m	struct:__anon4
endpos	regexp.h	/^    lpos_T		endpos[NSUBEXP];$/;"	m	struct:__anon5
ends_excmd	ex_docmd.c	/^ends_excmd(c)$/;"	f
ends_in_white	ops.c	/^ends_in_white(lnum)$/;"	f	file:
endspaces	ops.c	/^    int		endspaces;	\/* 'extra' cols of first char *\/$/;"	m	struct:block_def	file:
enter_buffer	buffer.c	/^enter_buffer(buf)$/;"	f
enter_cleanup	ex_eval.c	/^enter_cleanup(csp)$/;"	f
envsize	misc2.c	/^static int  envsize = -1;	\/* current size of environment *\/$/;"	v	file:
equalpos	macros.h	32;"	d
equalpos	macros.h	38;"	d
errcaught	testdir/test49.vim	/^		let errcaught = 1$/;"	v
errcaught	testdir/test49.vim	/^	    let errcaught = 0$/;"	v
errcaught	testdir/test49.vim	/^	let errcaught = 0$/;"	v
errcaught	testdir/test49.vim	/^	let errcaught = 1$/;"	v
errmsg	ex_cmds.h	/^    char_u	*errmsg;	\/* returned error message *\/$/;"	m	struct:exarg
error	ex_cmds2.c	/^    int		error;		\/* TRUE if LF found after CR-LF *\/$/;"	m	struct:source_cookie	file:
errorHandler	nbdebug.c	/^errorHandler($/;"	f	file:
error_ga	globals.h	/^EXTERN garray_T error_ga$/;"	v
escape_chars	globals.h	/^EXTERN char_u	*escape_chars INIT(= (char_u *)" \\t\\\\\\"|");$/;"	v
eslist_T	structs.h	/^typedef struct eslist_elem eslist_T;$/;"	t	typeref:struct:eslist_elem
eslist_elem	structs.h	/^struct eslist_elem$/;"	s
etoa64	xxd/xxd.c	/^static unsigned char etoa64[] =$/;"	v	file:
ev_CloseWindow	gui_amiga.h	/^    ev_CloseWindow,$/;"	e	enum:event
ev_GadgetDown	gui_amiga.h	/^    ev_GadgetDown,$/;"	e	enum:event
ev_GadgetHelp	gui_amiga.h	/^    ev_GadgetHelp,$/;"	e	enum:event
ev_GadgetUp	gui_amiga.h	/^    ev_GadgetUp,$/;"	e	enum:event
ev_Ignore	gui_amiga.h	/^    ev_Ignore$/;"	e	enum:event
ev_IntuiTicks	gui_amiga.h	/^    ev_IntuiTicks,$/;"	e	enum:event
ev_KeyStroke	gui_amiga.h	/^    ev_KeyStroke,$/;"	e	enum:event
ev_MenuHelp	gui_amiga.h	/^    ev_MenuHelp,$/;"	e	enum:event
ev_MenuPick	gui_amiga.h	/^    ev_MenuPick,$/;"	e	enum:event
ev_MenuVerify	gui_amiga.h	/^    ev_MenuVerify,$/;"	e	enum:event
ev_MouseButtons	gui_amiga.h	/^    ev_MouseButtons,$/;"	e	enum:event
ev_MouseMove	gui_amiga.h	/^    ev_MouseMove,$/;"	e	enum:event
ev_NewSize	gui_amiga.h	/^    ev_NewSize,$/;"	e	enum:event
ev_NullEvent	gui_amiga.h	/^    ev_NullEvent,$/;"	e	enum:event
ev_RefreshWindow	gui_amiga.h	/^    ev_RefreshWindow,$/;"	e	enum:event
eval0	eval.c	/^eval0(arg, retvar, nextcmd, evaluate)$/;"	f	file:
eval1	eval.c	/^eval1(arg, retvar, evaluate)$/;"	f	file:
eval2	eval.c	/^eval2(arg, retvar, evaluate)$/;"	f	file:
eval3	eval.c	/^eval3(arg, retvar, evaluate)$/;"	f	file:
eval4	eval.c	/^eval4(arg, retvar, evaluate)$/;"	f	file:
eval5	eval.c	/^eval5(arg, retvar, evaluate)$/;"	f	file:
eval6	eval.c	/^eval6(arg, retvar, evaluate)$/;"	f	file:
eval7	eval.c	/^eval7(arg, retvar, evaluate)$/;"	f	file:
eval_charconvert	eval.c	/^eval_charconvert(enc_from, enc_to, fname_from, fname_to)$/;"	f
eval_client_expr_to_string	main.c	/^eval_client_expr_to_string(expr)$/;"	f
eval_diff	eval.c	/^eval_diff(origfile, newfile, outfile)$/;"	f
eval_fname_script	eval.c	/^eval_fname_script(p)$/;"	f	file:
eval_fname_sid	eval.c	/^eval_fname_sid(p)$/;"	f	file:
eval_foldexpr	eval.c	/^eval_foldexpr(arg, cp)$/;"	f
eval_includeexpr	window.c	/^eval_includeexpr(ptr, len)$/;"	f	file:
eval_isnamec	eval.c	/^eval_isnamec(c)$/;"	f	file:
eval_patch	eval.c	/^eval_patch(origfile, difffile, outfile)$/;"	f
eval_printexpr	eval.c	/^eval_printexpr(fname, args)$/;"	f
eval_to_bool	eval.c	/^eval_to_bool(arg, error, nextcmd, skip)$/;"	f
eval_to_number	eval.c	/^eval_to_number(expr)$/;"	f
eval_to_string	eval.c	/^eval_to_string(arg, nextcmd)$/;"	f
eval_to_string_safe	eval.c	/^eval_to_string_safe(arg, nextcmd)$/;"	f
eval_to_string_skip	eval.c	/^eval_to_string_skip(arg, nextcmd, skip)$/;"	f
eval_vars	ex_docmd.c	/^eval_vars(src, usedlen, lnump, errormsg, srcstart)$/;"	f
event	fileio.c	/^    EVENT_T	event;		\/* current event *\/$/;"	m	struct:AutoPatCmd	file:
event	fileio.c	/^    EVENT_T	event;	\/* event number *\/$/;"	m	struct:event_name	file:
event	gui_amiga.h	/^enum event {$/;"	g
event_buffer	gui.h	/^    PhEvent_t	*event_buffer;$/;"	m	struct:Gui
event_ignored	fileio.c	/^event_ignored(event)$/;"	f	file:
event_name	fileio.c	/^static struct event_name$/;"	s	file:
event_name2nr	fileio.c	/^event_name2nr(start, end)$/;"	f	file:
event_names	fileio.c	/^} event_names[] =$/;"	v	typeref:struct:event_name	file:
event_nr2name	fileio.c	/^event_nr2name(event)$/;"	f	file:
ex_X	ex_docmd.c	/^ex_X(eap)$/;"	f	file:
ex_X	ex_docmd.c	383;"	d	file:
ex_abbreviate	ex_docmd.c	/^ex_abbreviate(eap)$/;"	f	file:
ex_abclear	ex_docmd.c	/^ex_abclear(eap)$/;"	f	file:
ex_align	ex_cmds.c	/^ex_align(eap)$/;"	f
ex_align	ex_docmd.c	290;"	d	file:
ex_all	ex_docmd.c	/^ex_all(eap)$/;"	f	file:
ex_all	ex_docmd.c	152;"	d	file:
ex_append	ex_cmds.c	/^ex_append(eap)$/;"	f
ex_argadd	ex_cmds2.c	/^ex_argadd(eap)$/;"	f
ex_argadd	ex_docmd.c	180;"	d	file:
ex_argdelete	ex_cmds2.c	/^ex_argdelete(eap)$/;"	f
ex_argdelete	ex_docmd.c	181;"	d	file:
ex_argedit	ex_cmds2.c	/^ex_argedit(eap)$/;"	f
ex_argedit	ex_docmd.c	179;"	d	file:
ex_args	ex_cmds2.c	/^ex_args(eap)$/;"	f
ex_argument	ex_cmds2.c	/^ex_argument(eap)$/;"	f
ex_at	ex_docmd.c	/^ex_at(eap)$/;"	f	file:
ex_autocmd	ex_docmd.c	/^ex_autocmd(eap)$/;"	f	file:
ex_autocmd	ex_docmd.c	84;"	d	file:
ex_bang	ex_docmd.c	/^ex_bang(eap)$/;"	f	file:
ex_behave	ex_docmd.c	/^ex_behave(eap)$/;"	f	file:
ex_blast	ex_docmd.c	/^ex_blast(eap)$/;"	f	file:
ex_blast	ex_docmd.c	103;"	d	file:
ex_bmodified	ex_docmd.c	/^ex_bmodified(eap)$/;"	f	file:
ex_bmodified	ex_docmd.c	99;"	d	file:
ex_bnext	ex_docmd.c	/^ex_bnext(eap)$/;"	f	file:
ex_bnext	ex_docmd.c	100;"	d	file:
ex_bprevious	ex_docmd.c	/^ex_bprevious(eap)$/;"	f	file:
ex_bprevious	ex_docmd.c	101;"	d	file:
ex_break	ex_docmd.c	322;"	d	file:
ex_break	ex_eval.c	/^ex_break(eap)$/;"	f
ex_breakadd	ex_cmds2.c	/^ex_breakadd(eap)$/;"	f
ex_breakadd	ex_docmd.c	407;"	d	file:
ex_breakdel	ex_cmds2.c	/^ex_breakdel(eap)$/;"	f
ex_breakdel	ex_docmd.c	409;"	d	file:
ex_breaklist	ex_cmds2.c	/^ex_breaklist(eap)$/;"	f
ex_breaklist	ex_docmd.c	410;"	d	file:
ex_brewind	ex_docmd.c	/^ex_brewind(eap)$/;"	f	file:
ex_brewind	ex_docmd.c	102;"	d	file:
ex_buffer	ex_docmd.c	/^ex_buffer(eap)$/;"	f	file:
ex_buffer	ex_docmd.c	98;"	d	file:
ex_buffer_all	buffer.c	/^ex_buffer_all(eap)$/;"	f
ex_buffer_all	ex_docmd.c	108;"	d	file:
ex_bunload	ex_docmd.c	/^ex_bunload(eap)$/;"	f	file:
ex_bunload	ex_docmd.c	97;"	d	file:
ex_call	eval.c	/^ex_call(eap)$/;"	f
ex_call	ex_docmd.c	316;"	d	file:
ex_catch	ex_docmd.c	326;"	d	file:
ex_catch	ex_eval.c	/^ex_catch(eap)$/;"	f
ex_cc	ex_docmd.c	115;"	d	file:
ex_cc	quickfix.c	/^ex_cc(eap)$/;"	f
ex_cclose	ex_docmd.c	123;"	d	file:
ex_cclose	quickfix.c	/^ex_cclose(eap)$/;"	f
ex_cd	ex_docmd.c	/^ex_cd(eap)$/;"	f	file:
ex_cfile	ex_docmd.c	117;"	d	file:
ex_cfile	quickfix.c	/^ex_cfile(eap)$/;"	f
ex_change	ex_cmds.c	/^ex_change(eap)$/;"	f
ex_changes	ex_docmd.c	418;"	d	file:
ex_changes	mark.c	/^ex_changes(eap)$/;"	f
ex_checkpath	ex_docmd.c	/^ex_checkpath(eap)$/;"	f	file:
ex_checkpath	ex_docmd.c	301;"	d	file:
ex_checktime	ex_cmds2.c	/^ex_checktime(eap)$/;"	f
ex_checktime	ex_docmd.c	105;"	d	file:
ex_close	ex_docmd.c	/^ex_close(eap)$/;"	f	file:
ex_close	ex_docmd.c	150;"	d	file:
ex_cnext	ex_docmd.c	116;"	d	file:
ex_cnext	quickfix.c	/^ex_cnext(eap)$/;"	f
ex_colorscheme	ex_docmd.c	/^ex_colorscheme(eap)$/;"	f	file:
ex_comclear	ex_docmd.c	/^ex_comclear(eap)$/;"	f	file:
ex_comclear	ex_docmd.c	57;"	d	file:
ex_command	ex_docmd.c	/^ex_command(eap)$/;"	f	file:
ex_command	ex_docmd.c	56;"	d	file:
ex_compiler	ex_cmds2.c	/^ex_compiler(eap)$/;"	f
ex_compiler	ex_docmd.c	346;"	d	file:
ex_continue	ex_docmd.c	321;"	d	file:
ex_continue	ex_eval.c	/^ex_continue(eap)$/;"	f
ex_copen	ex_docmd.c	124;"	d	file:
ex_copen	quickfix.c	/^ex_copen(eap)$/;"	f
ex_copy	ex_cmds.c	/^ex_copy(line1, line2, n)$/;"	f
ex_copymove	ex_docmd.c	/^ex_copymove(eap)$/;"	f	file:
ex_cquit	ex_docmd.c	/^ex_cquit(eap)$/;"	f	file:
ex_cwindow	ex_docmd.c	125;"	d	file:
ex_cwindow	quickfix.c	/^ex_cwindow(eap)$/;"	f
ex_debug	ex_cmds2.c	/^ex_debug(eap)$/;"	f
ex_debug	ex_docmd.c	406;"	d	file:
ex_debuggreedy	ex_cmds2.c	/^ex_debuggreedy(eap)$/;"	f
ex_debuggreedy	ex_docmd.c	408;"	d	file:
ex_delcommand	ex_docmd.c	/^ex_delcommand(eap)$/;"	f	file:
ex_delcommand	ex_docmd.c	58;"	d	file:
ex_delfunction	eval.c	/^ex_delfunction(eap)$/;"	f
ex_delfunction	ex_docmd.c	333;"	d	file:
ex_diffgetput	diff.c	/^ex_diffgetput(eap)$/;"	f
ex_diffgetput	ex_docmd.c	363;"	d	file:
ex_diffpatch	diff.c	/^ex_diffpatch(eap)$/;"	f
ex_diffpatch	ex_docmd.c	362;"	d	file:
ex_diffsplit	diff.c	/^ex_diffsplit(eap)$/;"	f
ex_diffsplit	ex_docmd.c	364;"	d	file:
ex_diffthis	diff.c	/^ex_diffthis(eap)$/;"	f
ex_diffthis	ex_docmd.c	365;"	d	file:
ex_diffupdate	diff.c	/^ex_diffupdate(eap)$/;"	f
ex_diffupdate	ex_docmd.c	366;"	d	file:
ex_digraphs	ex_docmd.c	/^ex_digraphs(eap)$/;"	f	file:
ex_display	ops.c	/^ex_display(eap)$/;"	f
ex_doautoall	ex_docmd.c	86;"	d	file:
ex_doautoall	fileio.c	/^ex_doautoall(eap)$/;"	f
ex_doautocmd	ex_docmd.c	/^ex_doautocmd(eap)$/;"	f	file:
ex_doautocmd	ex_docmd.c	85;"	d	file:
ex_drop	ex_cmds.c	/^ex_drop(eap)$/;"	f
ex_drop	ex_docmd.c	189;"	d	file:
ex_echo	eval.c	/^ex_echo(eap)$/;"	f
ex_echo	ex_docmd.c	313;"	d	file:
ex_echohl	eval.c	/^ex_echohl(eap)$/;"	f
ex_echohl	ex_docmd.c	314;"	d	file:
ex_edit	ex_docmd.c	/^ex_edit(eap)$/;"	f	file:
ex_else	ex_docmd.c	319;"	d	file:
ex_else	ex_eval.c	/^ex_else(eap)$/;"	f
ex_emenu	ex_docmd.c	76;"	d	file:
ex_emenu	menu.c	/^ex_emenu(eap)$/;"	f
ex_endfunction	ex_docmd.c	329;"	d	file:
ex_endfunction	ex_eval.c	/^ex_endfunction(eap)$/;"	f
ex_endif	ex_docmd.c	318;"	d	file:
ex_endif	ex_eval.c	/^ex_endif(eap)$/;"	f
ex_endtry	ex_docmd.c	328;"	d	file:
ex_endtry	ex_eval.c	/^ex_endtry(eap)$/;"	f
ex_endwhile	ex_docmd.c	323;"	d	file:
ex_endwhile	ex_eval.c	/^ex_endwhile(eap)$/;"	f
ex_equal	ex_docmd.c	/^ex_equal(eap)$/;"	f	file:
ex_execute	eval.c	/^ex_execute(eap)$/;"	f
ex_execute	ex_docmd.c	315;"	d	file:
ex_exit	ex_docmd.c	/^ex_exit(eap)$/;"	f	file:
ex_file	ex_cmds.c	/^ex_file(eap)$/;"	f
ex_filetype	ex_docmd.c	/^ex_filetype(eap)$/;"	f	file:
ex_filetype	ex_docmd.c	358;"	d	file:
ex_finally	ex_docmd.c	327;"	d	file:
ex_finally	ex_eval.c	/^ex_finally(eap)$/;"	f
ex_find	ex_docmd.c	/^ex_find(eap)$/;"	f	file:
ex_findpat	ex_docmd.c	/^ex_findpat(eap)$/;"	f	file:
ex_findpat	ex_docmd.c	300;"	d	file:
ex_finish	ex_cmds2.c	/^ex_finish(eap)$/;"	f
ex_finish	ex_docmd.c	312;"	d	file:
ex_fold	ex_docmd.c	/^ex_fold(eap)$/;"	f	file:
ex_fold	ex_docmd.c	390;"	d	file:
ex_folddo	ex_docmd.c	/^ex_folddo(eap)$/;"	f	file:
ex_folddo	ex_docmd.c	392;"	d	file:
ex_foldopen	ex_docmd.c	/^ex_foldopen(eap)$/;"	f	file:
ex_foldopen	ex_docmd.c	391;"	d	file:
ex_func_T	ex_cmds.h	/^typedef void (*ex_func_T) __ARGS((exarg_T *eap));$/;"	t
ex_function	eval.c	/^ex_function(eap)$/;"	f
ex_function	ex_docmd.c	332;"	d	file:
ex_global	ex_cmds.c	/^ex_global(eap)$/;"	f
ex_goto	ex_docmd.c	/^ex_goto(eap)$/;"	f	file:
ex_goto	ex_docmd.c	173;"	d	file:
ex_gui	ex_docmd.c	192;"	d	file:
ex_gui	gui.c	/^ex_gui(eap)$/;"	f
ex_hardcopy	ex_cmds2.c	/^ex_hardcopy(eap)$/;"	f
ex_hardcopy	ex_docmd.c	23;"	d	file:
ex_help	ex_cmds.c	/^ex_help(eap)$/;"	f
ex_helpfind	ex_docmd.c	213;"	d	file:
ex_helpgrep	ex_docmd.c	120;"	d	file:
ex_helpgrep	quickfix.c	/^ex_helpgrep(eap)$/;"	f
ex_helptags	ex_cmds.c	/^ex_helptags(eap)$/;"	f
ex_helptags	ex_docmd.c	294;"	d	file:
ex_hide	ex_docmd.c	/^ex_hide(eap)$/;"	f	file:
ex_highlight	ex_docmd.c	/^ex_highlight(eap)$/;"	f	file:
ex_history	ex_docmd.c	414;"	d	file:
ex_history	ex_getln.c	/^ex_history(eap)$/;"	f
ex_if	ex_docmd.c	317;"	d	file:
ex_if	ex_eval.c	/^ex_if(eap)$/;"	f
ex_intro	version.c	/^ex_intro(eap)$/;"	f
ex_join	ex_docmd.c	/^ex_join(eap)$/;"	f	file:
ex_jumps	ex_docmd.c	417;"	d	file:
ex_jumps	mark.c	/^ex_jumps(eap)$/;"	f
ex_language	ex_cmds2.c	/^ex_language(eap)$/;"	f
ex_language	ex_docmd.c	396;"	d	file:
ex_last	ex_cmds2.c	/^ex_last(eap)$/;"	f
ex_let	eval.c	/^ex_let(eap)$/;"	f
ex_let	ex_docmd.c	330;"	d	file:
ex_listdo	ex_cmds2.c	/^ex_listdo(eap)$/;"	f
ex_listdo	ex_docmd.c	182;"	d	file:
ex_loadkeymap	digraph.c	/^ex_loadkeymap(eap)$/;"	f
ex_loadkeymap	ex_docmd.c	245;"	d	file:
ex_loadview	ex_docmd.c	/^ex_loadview(eap)$/;"	f	file:
ex_loadview	ex_docmd.c	343;"	d	file:
ex_make	ex_docmd.c	114;"	d	file:
ex_make	quickfix.c	/^ex_make(eap)$/;"	f
ex_map	ex_docmd.c	/^ex_map(eap)$/;"	f	file:
ex_mapclear	ex_docmd.c	/^ex_mapclear(eap)$/;"	f	file:
ex_mark	ex_docmd.c	/^ex_mark(eap)$/;"	f	file:
ex_match	ex_docmd.c	/^ex_match(eap)$/;"	f	file:
ex_match	ex_docmd.c	378;"	d	file:
ex_menu	ex_docmd.c	77;"	d	file:
ex_menu	menu.c	/^ex_menu(eap)$/;"	f
ex_menutranslate	ex_docmd.c	78;"	d	file:
ex_menutranslate	menu.c	/^ex_menutranslate(eap)$/;"	f
ex_messages	message.c	/^ex_messages(eap)$/;"	f
ex_mkrc	ex_docmd.c	/^ex_mkrc(eap)$/;"	f	file:
ex_mode	ex_docmd.c	/^ex_mode(eap)$/;"	f	file:
ex_nesting_level	globals.h	/^EXTERN int	ex_nesting_level INIT(= 0);	\/* nesting level *\/$/;"	v
ex_next	ex_cmds2.c	/^ex_next(eap)$/;"	f
ex_ni	ex_docmd.c	/^ex_ni(eap)$/;"	f
ex_no_reprint	globals.h	/^EXTERN int ex_no_reprint INIT(= FALSE); \/* no need to print after z or p *\/$/;"	v
ex_nogui	ex_docmd.c	/^ex_nogui(eap)$/;"	f	file:
ex_nohlsearch	ex_docmd.c	/^ex_nohlsearch(eap)$/;"	f	file:
ex_nohlsearch	ex_docmd.c	377;"	d	file:
ex_normal	ex_docmd.c	/^ex_normal(eap)$/;"	f	file:
ex_normal	ex_docmd.c	289;"	d	file:
ex_normal_busy	globals.h	/^EXTERN int	ex_normal_busy INIT(= 0); \/* recursivenes of ex_normal() *\/$/;"	v
ex_only	ex_docmd.c	/^ex_only(eap)$/;"	f	file:
ex_only	ex_docmd.c	151;"	d	file:
ex_operators	ex_docmd.c	/^ex_operators(eap)$/;"	f	file:
ex_options	ex_cmds2.c	/^ex_options(eap)$/;"	f
ex_options	ex_docmd.c	371;"	d	file:
ex_pclose	ex_docmd.c	/^ex_pclose(eap)$/;"	f	file:
ex_pclose	ex_docmd.c	162;"	d	file:
ex_pedit	ex_docmd.c	/^ex_pedit(eap)$/;"	f	file:
ex_pedit	ex_docmd.c	164;"	d	file:
ex_perl	ex_docmd.c	224;"	d	file:
ex_perldo	ex_docmd.c	225;"	d	file:
ex_popup	ex_docmd.c	/^ex_popup(eap)$/;"	f	file:
ex_popup	ex_docmd.c	203;"	d	file:
ex_preserve	ex_docmd.c	/^ex_preserve(eap)$/;"	f	file:
ex_pressedreturn	ex_docmd.c	/^static int	ex_pressedreturn = FALSE;$/;"	v	file:
ex_previous	ex_cmds2.c	/^ex_previous(eap)$/;"	f
ex_print	ex_docmd.c	/^ex_print(eap)$/;"	f	file:
ex_psearch	ex_docmd.c	/^ex_psearch(eap)$/;"	f	file:
ex_psearch	ex_docmd.c	306;"	d	file:
ex_ptag	ex_docmd.c	/^ex_ptag(eap)$/;"	f	file:
ex_ptag	ex_docmd.c	163;"	d	file:
ex_put	ex_docmd.c	/^ex_put(eap)$/;"	f	file:
ex_pwd	ex_docmd.c	/^ex_pwd(eap)$/;"	f	file:
ex_pyfile	ex_docmd.c	229;"	d	file:
ex_python	ex_docmd.c	228;"	d	file:
ex_quit	ex_docmd.c	/^ex_quit(eap)$/;"	f	file:
ex_quit_all	ex_docmd.c	/^ex_quit_all(eap)$/;"	f	file:
ex_read	ex_docmd.c	/^ex_read(eap)$/;"	f	file:
ex_recover	ex_docmd.c	/^ex_recover(eap)$/;"	f	file:
ex_redir	ex_docmd.c	/^ex_redir(eap)$/;"	f	file:
ex_redo	ex_docmd.c	/^ex_redo(eap)$/;"	f	file:
ex_redraw	ex_docmd.c	/^ex_redraw(eap)$/;"	f	file:
ex_redrawstatus	ex_docmd.c	/^ex_redrawstatus(eap)$/;"	f	file:
ex_resize	ex_docmd.c	/^ex_resize(eap)$/;"	f	file:
ex_resize	ex_docmd.c	153;"	d	file:
ex_retab	ex_cmds.c	/^ex_retab(eap)$/;"	f
ex_retab	ex_docmd.c	291;"	d	file:
ex_return	eval.c	/^ex_return(eap)$/;"	f
ex_return	ex_docmd.c	334;"	d	file:
ex_rewind	ex_cmds2.c	/^ex_rewind(eap)$/;"	f
ex_ruby	ex_docmd.c	237;"	d	file:
ex_rubydo	ex_docmd.c	238;"	d	file:
ex_rubyfile	ex_docmd.c	239;"	d	file:
ex_runtime	ex_cmds2.c	/^ex_runtime(eap)$/;"	f
ex_script_ni	ex_docmd.c	/^ex_script_ni(eap)$/;"	f	file:
ex_scriptencoding	ex_cmds2.c	/^ex_scriptencoding(eap)$/;"	f
ex_scriptnames	ex_cmds2.c	/^ex_scriptnames(eap)$/;"	f
ex_scriptnames	ex_docmd.c	311;"	d	file:
ex_set	ex_docmd.c	/^ex_set(eap)$/;"	f	file:
ex_setfiletype	ex_docmd.c	/^ex_setfiletype(eap)$/;"	f	file:
ex_setfiletype	ex_docmd.c	359;"	d	file:
ex_shell	ex_docmd.c	/^ex_shell(eap)$/;"	f	file:
ex_sign	ex_cmds.c	/^ex_sign(eap)$/;"	f
ex_sign	ex_docmd.c	399;"	d	file:
ex_simalt	ex_docmd.c	206;"	d	file:
ex_sleep	ex_docmd.c	/^ex_sleep(eap)$/;"	f	file:
ex_sniff	ex_docmd.c	242;"	d	file:
ex_source	ex_cmds2.c	/^ex_source(eap)$/;"	f
ex_splitview	ex_docmd.c	/^ex_splitview(eap)$/;"	f
ex_splitview	ex_docmd.c	154;"	d	file:
ex_stag	ex_docmd.c	/^ex_stag(eap)$/;"	f	file:
ex_stag	ex_docmd.c	155;"	d	file:
ex_startinsert	ex_docmd.c	/^ex_startinsert(eap)$/;"	f	file:
ex_startinsert	ex_docmd.c	292;"	d	file:
ex_stop	ex_docmd.c	/^ex_stop(eap)$/;"	f	file:
ex_stopinsert	ex_docmd.c	/^ex_stopinsert(eap)$/;"	f	file:
ex_stopinsert	ex_docmd.c	293;"	d	file:
ex_submagic	ex_docmd.c	/^ex_submagic(eap)$/;"	f	file:
ex_swapname	ex_docmd.c	/^ex_swapname(eap)$/;"	f	file:
ex_syncbind	ex_docmd.c	/^ex_syncbind(eap)$/;"	f	file:
ex_syntax	ex_docmd.c	221;"	d	file:
ex_syntax	syntax.c	/^ex_syntax(eap)$/;"	f
ex_tag	ex_docmd.c	/^ex_tag(eap)$/;"	f	file:
ex_tag_cmd	ex_docmd.c	/^ex_tag_cmd(eap, name)$/;"	f	file:
ex_tcl	ex_docmd.c	232;"	d	file:
ex_tcldo	ex_docmd.c	233;"	d	file:
ex_tclfile	ex_docmd.c	234;"	d	file:
ex_tearoff	ex_docmd.c	/^ex_tearoff(eap)$/;"	f	file:
ex_tearoff	ex_docmd.c	198;"	d	file:
ex_throw	ex_docmd.c	324;"	d	file:
ex_throw	ex_eval.c	/^ex_throw(eap)$/;"	f
ex_try	ex_docmd.c	325;"	d	file:
ex_try	ex_eval.c	/^ex_try(eap)$/;"	f
ex_undo	ex_docmd.c	/^ex_undo(eap)$/;"	f	file:
ex_unlet	eval.c	/^ex_unlet(eap)$/;"	f
ex_unlet	ex_docmd.c	331;"	d	file:
ex_unmap	ex_docmd.c	/^ex_unmap(eap)$/;"	f	file:
ex_update	ex_cmds.c	/^ex_update(eap)$/;"	f
ex_version	version.c	/^ex_version(eap)$/;"	f
ex_viminfo	ex_docmd.c	/^ex_viminfo(eap)$/;"	f	file:
ex_viminfo	ex_docmd.c	351;"	d	file:
ex_while	ex_docmd.c	320;"	d	file:
ex_while	ex_eval.c	/^ex_while(eap)$/;"	f
ex_win_close	ex_docmd.c	/^ex_win_close(eap, win)$/;"	f	file:
ex_wincmd	ex_docmd.c	/^ex_wincmd(eap)$/;"	f	file:
ex_wincmd	ex_docmd.c	259;"	d	file:
ex_window	ex_getln.c	/^ex_window()$/;"	f	file:
ex_winpos	ex_docmd.c	/^ex_winpos(eap)$/;"	f	file:
ex_winpos	ex_docmd.c	264;"	d	file:
ex_winsize	ex_docmd.c	/^ex_winsize(eap)$/;"	f	file:
ex_wnext	ex_cmds.c	/^ex_wnext(eap)$/;"	f
ex_write	ex_cmds.c	/^ex_write(eap)$/;"	f
ex_wrongmodifier	ex_docmd.c	/^ex_wrongmodifier(eap)$/;"	f	file:
ex_wsverb	ex_docmd.c	402;"	d	file:
ex_z	ex_cmds.c	/^ex_z(eap)$/;"	f
exarg	ex_cmds.h	/^struct exarg$/;"	s
exarg_T	ex_cmds.h	/^typedef struct exarg exarg_T;$/;"	t	typeref:struct:exarg
except_T	structs.h	/^typedef struct vim_exception except_T;$/;"	t	typeref:struct:vim_exception
exception	structs.h	/^    except_T *exception;	\/* exception value *\/$/;"	m	struct:cleanup_stuff
exception	testdir/test49.vim	/^		let exception  = v:exception$/;"	v
exception	testdir/test49.vim	/^	    let exception  = v:exception$/;"	v
exception	testdir/test49.vim	/^	let exception  = v:exception$/;"	v
exception	testdir/test49.vim	/^    let exception  = v:exception$/;"	v
exe_name	globals.h	/^EXTERN char_u	*exe_name;		\/* the name of the executable *\/$/;"	v
execBase	gui_amiga.c	/^struct ExecBase		*execBase;$/;"	v	typeref:struct:ExecBase
exec_from_reg	globals.h	/^EXTERN int	exec_from_reg INIT(= FALSE);	\/* executing register *\/$/;"	v
exit_delay	netbeans.c	/^static int exit_delay = 2;		\/* exit delay in seconds *\/$/;"	v	file:
exit_with_usage	xxd/xxd.c	/^exit_with_usage(pname)$/;"	f	file:
exiting	globals.h	/^EXTERN int	exiting INIT(= FALSE);$/;"	v
exmode_active	globals.h	/^EXTERN int exmode_active INIT(= 0);	\/* zero, EXMODE_NORMAL or EXMODE_VIM *\/$/;"	v
expand	ex_docmd.c	/^    int	    expand;$/;"	m	struct:__anon23	file:
expand	structs.h	/^typedef struct expand$/;"	s
expand_T	structs.h	/^} expand_T;$/;"	t	typeref:struct:expand
expand_backtick	misc1.c	/^expand_backtick(gap, pat, flags)$/;"	f	file:
expand_buffer	getchar.c	/^static int	expand_buffer = FALSE;$/;"	v	file:
expand_cmdline	ex_getln.c	/^expand_cmdline(xp, str, col, matchcount, matches)$/;"	f
expand_emenu	menu.c	/^static int		expand_emenu;	\/* TRUE for ":emenu" command *\/$/;"	v	file:
expand_env	misc1.c	/^expand_env(src, dst, dstlen)$/;"	f
expand_env_esc	misc1.c	/^expand_env_esc(src, dst, dstlen, esc)$/;"	f
expand_env_save	misc1.c	/^expand_env_save(src)$/;"	f
expand_filename	ex_docmd.c	/^expand_filename(eap, cmdlinep, errormsgp)$/;"	f
expand_isabbrev	getchar.c	/^static int	expand_isabbrev = 0;$/;"	v	file:
expand_mapmodes	getchar.c	/^static int	expand_mapmodes = 0;$/;"	v	file:
expand_menu	menu.c	/^static vimmenu_T	*expand_menu = NULL;$/;"	v	file:
expand_modes	menu.c	/^static int		expand_modes = 0x0;$/;"	v	file:
expand_option_flags	option.c	/^static int expand_option_flags = 0;$/;"	v	file:
expand_option_idx	option.c	/^static int expand_option_idx = -1;$/;"	v	file:
expand_option_name	option.c	/^static char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};$/;"	v	file:
expand_sfile	ex_docmd.c	/^expand_sfile(arg)$/;"	f
expand_showtail	ex_getln.c	/^expand_showtail(xp)$/;"	f	file:
expand_tag_fname	tag.c	/^expand_tag_fname(fname, tag_fname, expand)$/;"	f	file:
expand_tags	tag.c	/^expand_tags(tagnames, pat, num_file, file)$/;"	f
expand_what	syntax.c	/^} expand_what;$/;"	v	typeref:enum:__anon7	file:
expand_wildcards	misc1.c	/^expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
expected	testdir/test49.vim	/^    let expected = ""$/;"	v
expected	testdir/test49.vim	/^    let expected = "E1T1E2T2S3(3)S4(5s)S4(7t)T4U6(1)U6(2)U9(4)U9(5t)T9T10"$/;"	v
expected	testdir/test49.vim	/^    let expected = "F1T1F2T2T3G4T4G5T5"$/;"	v
expected	testdir/test49.vim	/^    let expected = "G1EF1E(1)F1E(2)F1E(3)G2EF2E(1)G3IF3I(1)G4TF4T(1)G5AF5A(1)"$/;"	v
expected	testdir/test49.vim	/^    let expected = "T1T2T3T4T5"$/;"	v
expected	testdir/test49.vim	/^    let expected = 8 + 16 + 32 + 64 + 128 + 256$/;"	v
expected	testdir/test49.vim	/^let expected = "E1E2E3E4E5E6E7E8E9E10"$/;"	v
expected	testdir/test49.vim	/^let expected = 16  + 256 + 1024 + 16384 + 0   + 0   + 2097152 + 8388608$/;"	v
expected	testdir/test49.vim	/^let expected = expected + 33554432 + 134217728$/;"	v
expr_line	ops.c	/^static char_u	*expr_line = NULL;$/;"	v	file:
exptype_T	eval.c	/^} exptype_T;$/;"	t	typeref:enum:__anon18	file:
extra_char	structs.h	/^    int		extra_char;	\/* yet another character (optional) *\/$/;"	m	struct:cmdarg
extract_modifiers	misc2.c	/^extract_modifiers(key, modp)$/;"	f
f_append	eval.c	/^f_append(argvars, retvar)$/;"	f	file:
f_argc	eval.c	/^f_argc(argvars, retvar)$/;"	f	file:
f_argidx	eval.c	/^f_argidx(argvars, retvar)$/;"	f	file:
f_argv	eval.c	/^f_argv(argvars, retvar)$/;"	f	file:
f_browse	eval.c	/^f_browse(argvars, retvar)$/;"	f	file:
f_bufexists	eval.c	/^f_bufexists(argvars, retvar)$/;"	f	file:
f_buflisted	eval.c	/^f_buflisted(argvars, retvar)$/;"	f	file:
f_bufloaded	eval.c	/^f_bufloaded(argvars, retvar)$/;"	f	file:
f_bufname	eval.c	/^f_bufname(argvars, retvar)$/;"	f	file:
f_bufnr	eval.c	/^f_bufnr(argvars, retvar)$/;"	f	file:
f_bufwinnr	eval.c	/^f_bufwinnr(argvars, retvar)$/;"	f	file:
f_byte2line	eval.c	/^f_byte2line(argvars, retvar)$/;"	f	file:
f_char2nr	eval.c	/^f_char2nr(argvars, retvar)$/;"	f	file:
f_cindent	eval.c	/^f_cindent(argvars, retvar)$/;"	f	file:
f_col	eval.c	/^f_col(argvars, retvar)$/;"	f	file:
f_confirm	eval.c	/^f_confirm(argvars, retvar)$/;"	f	file:
f_cscope_connection	eval.c	/^f_cscope_connection(argvars, retvar)$/;"	f	file:
f_cursor	eval.c	/^f_cursor(argvars, retvar)$/;"	f	file:
f_delete	eval.c	/^f_delete(argvars, retvar)$/;"	f	file:
f_did_filetype	eval.c	/^f_did_filetype(argvars, retvar)$/;"	f	file:
f_escape	eval.c	/^f_escape(argvars, retvar)$/;"	f	file:
f_eventhandler	eval.c	/^f_eventhandler(argvars, retvar)$/;"	f	file:
f_executable	eval.c	/^f_executable(argvars, retvar)$/;"	f	file:
f_exists	eval.c	/^f_exists(argvars, retvar)$/;"	f	file:
f_expand	eval.c	/^f_expand(argvars, retvar)$/;"	f	file:
f_filereadable	eval.c	/^f_filereadable(argvars, retvar)$/;"	f	file:
f_filewritable	eval.c	/^f_filewritable(argvars, retvar)$/;"	f	file:
f_fnamemodify	eval.c	/^f_fnamemodify(argvars, retvar)$/;"	f	file:
f_foldclosed	eval.c	/^f_foldclosed(argvars, retvar)$/;"	f	file:
f_foldclosedend	eval.c	/^f_foldclosedend(argvars, retvar)$/;"	f	file:
f_foldlevel	eval.c	/^f_foldlevel(argvars, retvar)$/;"	f	file:
f_foldtext	eval.c	/^f_foldtext(argvars, retvar)$/;"	f	file:
f_foreground	eval.c	/^f_foreground(argvars, retvar)$/;"	f	file:
f_func	eval.c	/^    void	(*f_func) __ARGS((VAR args, VAR rvar)); \/* impl. function *\/$/;"	m	struct:fst	file:
f_getbufvar	eval.c	/^f_getbufvar(argvars, retvar)$/;"	f	file:
f_getchar	eval.c	/^f_getchar(argvars, retvar)$/;"	f	file:
f_getcharmod	eval.c	/^f_getcharmod(argvars, retvar)$/;"	f	file:
f_getcmdline	eval.c	/^f_getcmdline(argvars, retvar)$/;"	f	file:
f_getcmdpos	eval.c	/^f_getcmdpos(argvars, retvar)$/;"	f	file:
f_getcwd	eval.c	/^f_getcwd(argvars, retvar)$/;"	f	file:
f_getfsize	eval.c	/^f_getfsize(argvars, retvar)$/;"	f	file:
f_getftime	eval.c	/^f_getftime(argvars, retvar)$/;"	f	file:
f_getline	eval.c	/^f_getline(argvars, retvar)$/;"	f	file:
f_getreg	eval.c	/^f_getreg(argvars, retvar)$/;"	f	file:
f_getregtype	eval.c	/^f_getregtype(argvars, retvar)$/;"	f	file:
f_getwinposx	eval.c	/^f_getwinposx(argvars, retvar)$/;"	f	file:
f_getwinposy	eval.c	/^f_getwinposy(argvars, retvar)$/;"	f	file:
f_getwinvar	eval.c	/^f_getwinvar(argvars, retvar)$/;"	f	file:
f_glob	eval.c	/^f_glob(argvars, retvar)$/;"	f	file:
f_globpath	eval.c	/^f_globpath(argvars, retvar)$/;"	f	file:
f_has	eval.c	/^f_has(argvars, retvar)$/;"	f	file:
f_hasmapto	eval.c	/^f_hasmapto(argvars, retvar)$/;"	f	file:
f_histadd	eval.c	/^f_histadd(argvars, retvar)$/;"	f	file:
f_histdel	eval.c	/^f_histdel(argvars, retvar)$/;"	f	file:
f_histget	eval.c	/^f_histget(argvars, retvar)$/;"	f	file:
f_histnr	eval.c	/^f_histnr(argvars, retvar)$/;"	f	file:
f_hlID	eval.c	/^f_hlID(argvars, retvar)$/;"	f	file:
f_hlexists	eval.c	/^f_hlexists(argvars, retvar)$/;"	f	file:
f_hostname	eval.c	/^f_hostname(argvars, retvar)$/;"	f	file:
f_iconv	eval.c	/^f_iconv(argvars, retvar)$/;"	f	file:
f_indent	eval.c	/^f_indent(argvars, retvar)$/;"	f	file:
f_input	eval.c	/^f_input(argvars, retvar)$/;"	f	file:
f_inputdialog	eval.c	/^f_inputdialog(argvars, retvar)$/;"	f	file:
f_inputrestore	eval.c	/^f_inputrestore(argvars, retvar)$/;"	f	file:
f_inputsave	eval.c	/^f_inputsave(argvars, retvar)$/;"	f	file:
f_inputsecret	eval.c	/^f_inputsecret(argvars, retvar)$/;"	f	file:
f_isdirectory	eval.c	/^f_isdirectory(argvars, retvar)$/;"	f	file:
f_last_buffer_nr	eval.c	/^f_last_buffer_nr(argvars, retvar)$/;"	f	file:
f_libcall	eval.c	/^f_libcall(argvars, retvar)$/;"	f	file:
f_libcallnr	eval.c	/^f_libcallnr(argvars, retvar)$/;"	f	file:
f_line	eval.c	/^f_line(argvars, retvar)$/;"	f	file:
f_line2byte	eval.c	/^f_line2byte(argvars, retvar)$/;"	f	file:
f_lispindent	eval.c	/^f_lispindent(argvars, retvar)$/;"	f	file:
f_localtime	eval.c	/^f_localtime(argvars, retvar)$/;"	f	file:
f_maparg	eval.c	/^f_maparg(argvars, retvar)$/;"	f	file:
f_mapcheck	eval.c	/^f_mapcheck(argvars, retvar)$/;"	f	file:
f_match	eval.c	/^f_match(argvars, retvar)$/;"	f	file:
f_matchend	eval.c	/^f_matchend(argvars, retvar)$/;"	f	file:
f_matchstr	eval.c	/^f_matchstr(argvars, retvar)$/;"	f	file:
f_max_argc	eval.c	/^    char	f_max_argc;	\/* maximal number of arguments *\/$/;"	m	struct:fst	file:
f_min_argc	eval.c	/^    char	f_min_argc;	\/* minimal number of arguments *\/$/;"	m	struct:fst	file:
f_mode	eval.c	/^f_mode(argvars, retvar)$/;"	f	file:
f_name	eval.c	/^    char	*f_name;	\/* function name *\/$/;"	m	struct:fst	file:
f_nextnonblank	eval.c	/^f_nextnonblank(argvars, retvar)$/;"	f	file:
f_nr2char	eval.c	/^f_nr2char(argvars, retvar)$/;"	f	file:
f_prevnonblank	eval.c	/^f_prevnonblank(argvars, retvar)$/;"	f	file:
f_remote_expr	eval.c	/^f_remote_expr(argvars, retvar)$/;"	f	file:
f_remote_foreground	eval.c	/^f_remote_foreground(argvars, retvar)$/;"	f	file:
f_remote_peek	eval.c	/^f_remote_peek(argvars, retvar)$/;"	f	file:
f_remote_read	eval.c	/^f_remote_read(argvars, retvar)$/;"	f	file:
f_remote_send	eval.c	/^f_remote_send(argvars, retvar)$/;"	f	file:
f_rename	eval.c	/^f_rename(argvars, retvar)$/;"	f	file:
f_resolve	eval.c	/^f_resolve(argvars, retvar)$/;"	f	file:
f_search	eval.c	/^f_search(argvars, retvar)$/;"	f	file:
f_searchpair	eval.c	/^f_searchpair(argvars, retvar)$/;"	f	file:
f_server2client	eval.c	/^f_server2client(argvars, retvar)$/;"	f	file:
f_serverlist	eval.c	/^f_serverlist(argvars, retvar)$/;"	f	file:
f_setbufvar	eval.c	/^f_setbufvar(argvars, retvar)$/;"	f	file:
f_setcmdpos	eval.c	/^f_setcmdpos(argvars, retvar)$/;"	f	file:
f_setline	eval.c	/^f_setline(argvars, retvar)$/;"	f	file:
f_setreg	eval.c	/^f_setreg(argvars, retvar)$/;"	f	file:
f_setwinvar	eval.c	/^f_setwinvar(argvars, retvar)$/;"	f	file:
f_simplify	eval.c	/^f_simplify(argvars, retvar)$/;"	f	file:
f_strftime	eval.c	/^f_strftime(argvars, retvar)$/;"	f	file:
f_stridx	eval.c	/^f_stridx(argvars, retvar)$/;"	f	file:
f_strlen	eval.c	/^f_strlen(argvars, retvar)$/;"	f	file:
f_strpart	eval.c	/^f_strpart(argvars, retvar)$/;"	f	file:
f_strridx	eval.c	/^f_strridx(argvars, retvar)$/;"	f	file:
f_strtrans	eval.c	/^f_strtrans(argvars, retvar)$/;"	f	file:
f_submatch	eval.c	/^f_submatch(argvars, retvar)$/;"	f	file:
f_substitute	eval.c	/^f_substitute(argvars, retvar)$/;"	f	file:
f_synID	eval.c	/^f_synID(argvars, retvar)$/;"	f	file:
f_synIDattr	eval.c	/^f_synIDattr(argvars, retvar)$/;"	f	file:
f_synIDtrans	eval.c	/^f_synIDtrans(argvars, retvar)$/;"	f	file:
f_system	eval.c	/^f_system(argvars, retvar)$/;"	f	file:
f_tempname	eval.c	/^f_tempname(argvars, retvar)$/;"	f	file:
f_tolower	eval.c	/^f_tolower(argvars, retvar)$/;"	f	file:
f_toupper	eval.c	/^f_toupper(argvars, retvar)$/;"	f	file:
f_type	eval.c	/^f_type(argvars, retvar)$/;"	f	file:
f_virtcol	eval.c	/^f_virtcol(argvars, retvar)$/;"	f	file:
f_visualmode	eval.c	/^f_visualmode(argvars, retvar)$/;"	f	file:
f_winbufnr	eval.c	/^f_winbufnr(argvars, retvar)$/;"	f	file:
f_wincol	eval.c	/^f_wincol(argvars, retvar)$/;"	f	file:
f_winheight	eval.c	/^f_winheight(argvars, retvar)$/;"	f	file:
f_winline	eval.c	/^f_winline(argvars, retvar)$/;"	f	file:
f_winnr	eval.c	/^f_winnr(argvars, retvar)$/;"	f	file:
f_winrestcmd	eval.c	/^f_winrestcmd(argvars, retvar)$/;"	f	file:
f_winwidth	eval.c	/^f_winwidth(argvars, retvar)$/;"	f	file:
farsi_fkey	farsi.c	/^farsi_fkey(cap)$/;"	f
farsi_text_1	farsi.h	/^EXTERN char_u farsi_text_1[]$/;"	v
farsi_text_2	farsi.h	/^EXTERN char_u farsi_text_2[]$/;"	v
farsi_text_3	farsi.h	/^EXTERN char_u farsi_text_3[]$/;"	v
farsi_text_5	farsi.h	/^EXTERN char_u farsi_text_5[]$/;"	v
fast_breakcheck	misc1.c	/^fast_breakcheck()$/;"	f
fd_flags	fold.c	/^    char	fd_flags;	\/* see below *\/$/;"	m	struct:__anon14	file:
fd_len	fold.c	/^    linenr_T	fd_len;		\/* number of lines in the fold *\/$/;"	m	struct:__anon14	file:
fd_nested	fold.c	/^    garray_T	fd_nested;	\/* array of nested folds *\/$/;"	m	struct:__anon14	file:
fd_small	fold.c	/^    char	fd_small;	\/* TRUE, FALSE or MAYBE: fold smaller than$/;"	m	struct:__anon14	file:
fd_top	fold.c	/^    linenr_T	fd_top;		\/* first line of fold; for nested fold$/;"	m	struct:__anon14	file:
fdo_flags	option.h	/^EXTERN unsigned	fdo_flags;$/;"	v
fdtofh	memfile.c	/^fdtofh(int filedescriptor)$/;"	f	file:
features	version.c	/^static char *(features[]) =$/;"	v	file:
ff	ex_cmds2.c	/^    int		ff;		    \/* seen form feed character *\/$/;"	m	struct:__anon10	file:
ff_check_visited	misc2.c	/^ff_check_visited(visited_list, fname$/;"	f	file:
ff_clear	misc2.c	/^ff_clear()$/;"	f	file:
ff_create_stack_element	misc2.c	/^ff_create_stack_element(fix_part,$/;"	f	file:
ff_expand_buffer	misc2.c	/^static char_u		*ff_expand_buffer = NULL;$/;"	v	file:
ff_free_stack_element	misc2.c	/^ff_free_stack_element(ctx)$/;"	f	file:
ff_free_visited_list	misc2.c	/^ff_free_visited_list(vl)$/;"	f	file:
ff_get_visited_list	misc2.c	/^ff_get_visited_list(filename, list_headp)$/;"	f	file:
ff_path_in_stoplist	misc2.c	/^ff_path_in_stoplist(path, path_len, stopdirs_v)$/;"	f	file:
ff_pop	misc2.c	/^ff_pop()$/;"	f	file:
ff_push	misc2.c	/^ff_push(ctx)$/;"	f	file:
ff_search_ctx	misc2.c	/^static ff_search_ctx_T *ff_search_ctx = NULL;$/;"	v	file:
ff_search_ctx_T	misc2.c	/^typedef struct ff_search_ctx_T$/;"	s	file:
ff_search_ctx_T	misc2.c	/^}ff_search_ctx_T;$/;"	t	typeref:struct:ff_search_ctx_T	file:
ff_stack	misc2.c	/^typedef struct ff_stack$/;"	s	file:
ff_stack_T	misc2.c	/^} ff_stack_T;$/;"	t	typeref:struct:ff_stack	file:
ff_visited	misc2.c	/^typedef struct ff_visited$/;"	s	file:
ff_visited_T	misc2.c	/^} ff_visited_T;$/;"	t	typeref:struct:ff_visited	file:
ff_visited_list_hdr	misc2.c	/^typedef struct ff_visited_list_hdr$/;"	s	file:
ff_visited_list_hdr_T	misc2.c	/^} ff_visited_list_hdr_T;$/;"	t	typeref:struct:ff_visited_list_hdr	file:
ff_wc_equal	misc2.c	/^ff_wc_equal(s1, s2)$/;"	f	file:
ffs_filearray	misc2.c	/^    char_u		**ffs_filearray;$/;"	m	struct:ff_stack	file:
ffs_filearray_cur	misc2.c	/^    char_u		ffs_filearray_cur;   \/* needed for partly handled dirs *\/$/;"	m	struct:ff_stack	file:
ffs_filearray_size	misc2.c	/^    int			ffs_filearray_size;$/;"	m	struct:ff_stack	file:
ffs_fix_path	misc2.c	/^    char_u		*ffs_fix_path;$/;"	m	struct:ff_stack	file:
ffs_level	misc2.c	/^    int			ffs_level;$/;"	m	struct:ff_stack	file:
ffs_prev	misc2.c	/^    struct ff_stack	*ffs_prev;$/;"	m	struct:ff_stack	typeref:struct:ff_stack::ff_stack	file:
ffs_stage	misc2.c	/^    int			ffs_stage;$/;"	m	struct:ff_stack	file:
ffs_star_star_empty	misc2.c	/^    int			ffs_star_star_empty;$/;"	m	struct:ff_stack	file:
ffs_wc_path	misc2.c	/^    char_u		*ffs_wc_path;$/;"	m	struct:ff_stack	file:
ffsc_dir_visited_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_dir_visited_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_dir_visited_lists_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_dir_visited_lists_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_file_to_search	misc2.c	/^     char_u			*ffsc_file_to_search;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_fix_path	misc2.c	/^     char_u			*ffsc_fix_path;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_level	misc2.c	/^     int			ffsc_level;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_need_dir	misc2.c	/^     int			ffsc_need_dir;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_stack_ptr	misc2.c	/^     ff_stack_T			*ffsc_stack_ptr;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_start_dir	misc2.c	/^     char_u			*ffsc_start_dir;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_stopdirs_v	misc2.c	/^     char_u			**ffsc_stopdirs_v;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_visited_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_visited_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_visited_lists_list	misc2.c	/^     ff_visited_list_hdr_T	*ffsc_visited_lists_list;$/;"	m	struct:ff_search_ctx_T	file:
ffsc_wc_path	misc2.c	/^     char_u			*ffsc_wc_path;$/;"	m	struct:ff_search_ctx_T	file:
ffv_dev	misc2.c	/^    int			ffv_dev;	\/* device number (-1 if not set) *\/$/;"	m	struct:ff_visited	file:
ffv_fname	misc2.c	/^    char_u		ffv_fname[1];	\/* actually longer *\/$/;"	m	struct:ff_visited	file:
ffv_ino	misc2.c	/^    ino_t		ffv_ino;	\/* inode number *\/$/;"	m	struct:ff_visited	file:
ffv_next	misc2.c	/^    struct ff_visited	*ffv_next;$/;"	m	struct:ff_visited	typeref:struct:ff_visited::ff_visited	file:
ffv_wc_path	misc2.c	/^    char_u		*ffv_wc_path;$/;"	m	struct:ff_visited	file:
ffvl_filename	misc2.c	/^    char_u			*ffvl_filename;$/;"	m	struct:ff_visited_list_hdr	file:
ffvl_next	misc2.c	/^    struct ff_visited_list_hdr	*ffvl_next;$/;"	m	struct:ff_visited_list_hdr	typeref:struct:ff_visited_list_hdr::ff_visited_list_hdr	file:
ffvl_visited_list	misc2.c	/^    ff_visited_T		*ffvl_visited_list;$/;"	m	struct:ff_visited_list_hdr	file:
fg_color	structs.h	/^	    char_u	    fg_color;	\/* foreground color number *\/$/;"	m	struct:attr_entry::__anon34::__anon36
fg_color	structs.h	/^	    guicolor_T	    fg_color;	\/* foreground color handle *\/$/;"	m	struct:attr_entry::__anon34::__anon37
fg_color	structs.h	/^    long_u	fg_color;$/;"	m	struct:__anon44
fg_colour	gui.h	/^    int		fg_colour;		\/* in 0xBBGGRR format *\/$/;"	m	struct:Gui
fgcolor	gui.h	/^    GdkColor	*fgcolor;	    \/* GDK-styled foreground color *\/$/;"	m	struct:Gui
fgets_cr	ex_cmds2.c	/^fgets_cr(s, n, stream)$/;"	f
fi_level	structs.h	/^    int		fi_level;	\/* level of the fold; when this is zero the$/;"	m	struct:foldinfo
fi_lnum	structs.h	/^    int		fi_lnum;	\/* line number where fold starts *\/$/;"	m	struct:foldinfo
fi_low_level	structs.h	/^    int		fi_low_level;	\/* lowest fold level that starts in the same$/;"	m	struct:foldinfo
file	testdir/test49.vim	/^	let file = tempname()$/;"	v
file	testdir/test49.vim	/^    let file = tempname()$/;"	v
file_buffer	structs.h	/^struct file_buffer$/;"	s
file_ff_differs	option.c	/^file_ff_differs(buf)$/;"	f
file_line	ex_cmds2.c	/^    linenr_T	file_line;	    \/* line nr in the buffer *\/$/;"	m	struct:__anon10	file:
file_name_at_cursor	window.c	/^file_name_at_cursor(options, count)$/;"	f
file_name_in_line	window.c	/^file_name_in_line(line, col, options, count, rel_fname)$/;"	f
file_owned	main.c	/^file_owned(fname)$/;"	f	file:
file_pat_to_reg_pat	fileio.c	/^file_pat_to_reg_pat(pat, pat_end, allow_dirs, no_bslash)$/;"	f
filedlg	gui.h	/^    GtkWidget	*filedlg;	    \/* file selection dialog *\/$/;"	m	struct:Gui
fileformat	ex_cmds2.c	/^    int		fileformat;	\/* EOL_UNKNOWN, EOL_UNIX or EOL_DOS *\/$/;"	m	struct:source_cookie	file:
fileinfo	buffer.c	/^fileinfo(fullname, shorthelp, dont_truncate)$/;"	f
filemark	structs.h	/^typedef struct filemark$/;"	s
filemess	fileio.c	/^filemess(buf, name, s, attr)$/;"	f
filename	ex_cmds2.c	/^    char_u  filename[MAXPATHL + 1];$/;"	m	struct:prt_ps_resource_S	file:
fileno	xxd/xxd.c	89;"	d	file:
filetype_detect	ex_docmd.c	/^static int filetype_detect = FALSE;$/;"	v	file:
filetype_indent	ex_docmd.c	/^static int filetype_indent = FALSE;$/;"	v	file:
filetype_plugin	ex_docmd.c	/^static int filetype_plugin = FALSE;$/;"	v	file:
fill	move.c	/^    int		    fill;	\/* filler lines *\/$/;"	m	struct:__anon46	file:
fill_breakat_flags	option.c	/^fill_breakat_flags()$/;"	f	file:
fill_diff	globals.h	/^EXTERN int	fill_diff INIT(= '-');$/;"	v
fill_fold	globals.h	/^EXTERN int	fill_fold INIT(= '-');$/;"	v
fill_foldcolumn	screen.c	/^fill_foldcolumn(p, wp, closed, lnum)$/;"	f	file:
fill_input_buf	ui.c	/^fill_input_buf(exit_on_error)$/;"	f
fill_mouse_coord	gui.c	/^fill_mouse_coord(p, col, row)$/;"	f	file:
fill_stl	globals.h	/^EXTERN int	fill_stl INIT(= ' ');$/;"	v
fill_stlnc	globals.h	/^EXTERN int	fill_stlnc INIT(= ' ');$/;"	v
fill_vert	globals.h	/^EXTERN int	fill_vert INIT(= ' ');$/;"	v
fillchar_status	screen.c	/^fillchar_status(attr, is_curwin)$/;"	f	file:
fillchar_vsep	screen.c	/^fillchar_vsep(attr)$/;"	f	file:
find_buffer	eval.c	/^find_buffer(avar)$/;"	f	file:
find_builtin_term	term.c	/^find_builtin_term(term)$/;"	f	file:
find_command	ex_docmd.c	/^find_command(eap, full)$/;"	f	file:
find_command	normal.c	/^find_command(cmdchar)$/;"	f	file:
find_directory_in_path	misc2.c	/^find_directory_in_path(ptr, len, options, rel_fname)$/;"	f
find_end_event	fileio.c	/^find_end_event(arg, have_group)$/;"	f	file:
find_end_of_word	normal.c	/^find_end_of_word(pos)$/;"	f	file:
find_endpos	syntax.c	/^find_endpos(idx, startpos, m_endpos, hl_endpos, flagsp, end_endpos,$/;"	f	file:
find_extra	tag.c	/^find_extra(pp)$/;"	f	file:
find_file_in_path	misc2.c	/^find_file_in_path(ptr, len, options, first, rel_fname)$/;"	f
find_file_in_path_option	misc2.c	/^find_file_in_path_option(ptr, len, options, first, path_option, need_dir, rel_fname)$/;"	f	file:
find_file_name_in_path	window.c	/^find_file_name_in_path(ptr, len, options, count, rel_fname)$/;"	f
find_first_blank	search.c	/^find_first_blank(posp)$/;"	f	file:
find_func	eval.c	/^find_func(name)$/;"	f	file:
find_help_tags	ex_cmds.c	/^find_help_tags(arg, num_matches, matches, keep_lang)$/;"	f
find_ident_at_pos	normal.c	/^find_ident_at_pos(wp, lnum, startcol, string, find_type)$/;"	f
find_ident_under_cursor	normal.c	/^find_ident_under_cursor(string, find_type)$/;"	f
find_internal_func	eval.c	/^find_internal_func(name)$/;"	f	file:
find_is_eval_item	normal.c	/^find_is_eval_item(ptr, colp, bnp, dir)$/;"	f	file:
find_key_option	option.c	/^find_key_option(arg)$/;"	f	file:
find_last_paren	misc1.c	/^find_last_paren(l, start, end)$/;"	f	file:
find_line_comment	misc1.c	/^find_line_comment() \/* XXX *\/$/;"	f	file:
find_match	misc1.c	/^find_match(lookfor, ourscope, ind_maxparen, ind_maxcomment)$/;"	f	file:
find_match_paren	misc1.c	/^find_match_paren(ind_maxparen, ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_name_end	eval.c	/^find_name_end(arg, expr_start, expr_end)$/;"	f	file:
find_nextcmd	ex_docmd.c	/^find_nextcmd(p)$/;"	f
find_option_end	eval.c	/^find_option_end(arg, opt_flags)$/;"	f	file:
find_pattern_in_path	search.c	/^find_pattern_in_path(ptr, dir, len, whole, skip_comments,$/;"	f
find_some_match	eval.c	/^find_some_match(argvars, retvar, type)$/;"	f	file:
find_special_key	misc2.c	/^find_special_key(srcp, modp, keycode)$/;"	f
find_special_key_in_table	misc2.c	/^find_special_key_in_table(c)$/;"	f
find_start_brace	misc1.c	/^find_start_brace(ind_maxcomment)	    \/* XXX *\/$/;"	f	file:
find_start_comment	misc1.c	/^find_start_comment(ind_maxcomment)	    \/* XXX *\/$/;"	f
find_start_of_word	normal.c	/^find_start_of_word(pos)$/;"	f	file:
find_tags	tag.c	/^find_tags(pat, num_matches, matchesp, flags, mincount, buf_ffname)$/;"	f
find_term_bykeys	term.c	/^find_term_bykeys(src)$/;"	f
find_termcode	term.c	/^find_termcode(name)$/;"	f
find_var	eval.c	/^find_var(name, writing)$/;"	f	file:
find_var_ga	eval.c	/^find_var_ga(name, varname)$/;"	f	file:
find_var_in_ga	eval.c	/^find_var_in_ga(gap, varname)$/;"	f	file:
find_vim_var	eval.c	/^find_vim_var(name, len)$/;"	f	file:
find_viminfo_parameter	option.c	/^find_viminfo_parameter(type)$/;"	f
find_win_by_nr	eval.c	/^find_win_by_nr(vp)$/;"	f	file:
find_wininfo	buffer.c	/^find_wininfo(buf)$/;"	f	file:
find_wl_entry	fold.c	/^find_wl_entry(win, lnum)$/;"	f
find_word_end	edit.c	/^find_word_end(ptr)$/;"	f
find_word_start	edit.c	/^find_word_start(ptr)$/;"	f
findenv	misc2.c	/^findenv(name)$/;"	f	file:
findmatch	search.c	/^findmatch(oap, initc)$/;"	f
findmatchlimit	search.c	/^findmatchlimit(oap, initc, flags, maxtravel)$/;"	f
findoption	option.c	/^findoption(arg)$/;"	f	file:
findpar	search.c	/^findpar(oap, dir, count, what, both)$/;"	f
findsent	search.c	/^findsent(dir, count)$/;"	f
findsent_forward	search.c	/^findsent_forward(count, at_start_sent)$/;"	f	file:
findswapname	memline.c	/^findswapname(buf, dirp, old_fname)$/;"	f	file:
finish_exception	ex_eval.c	/^finish_exception(excp)$/;"	f	file:
finish_op	globals.h	/^EXTERN int	finish_op INIT(= FALSE);\/* TRUE while an operator is pending *\/$/;"	v
finish_viminfo_history	ex_getln.c	/^finish_viminfo_history()$/;"	f
finished	ex_cmds2.c	/^    int		finished;	\/* ":finish" used *\/$/;"	m	struct:source_cookie	file:
fireChanges	netbeans.c	/^    unsigned int	 fireChanges:1;$/;"	m	struct:nbbuf_struct	file:
first	mbyte.c	/^    unsigned short first;$/;"	m	struct:interval	file:
first_abbr	getchar.c	/^static mapblock_T	*first_abbr = NULL; \/* first entry in abbrlist *\/$/;"	v	file:
first_autopat	fileio.c	/^static AutoPat *first_autopat[NUM_EVENTS] =$/;"	v	file:
first_diff	diff.c	/^static diff_T	*first_diff = NULL;$/;"	v	file:
first_lnum	screen.c	/^    linenr_T	first_lnum;	\/* first lnum to search for multi-line pat *\/$/;"	m	struct:__anon1	file:
first_match	edit.c	/^static struct Completion    *first_match = NULL;$/;"	v	typeref:struct:Completion	file:
first_msg_hist	message.c	/^static struct msg_hist *first_msg_hist = NULL;$/;"	v	typeref:struct:msg_hist	file:
first_sign	ex_cmds.c	/^static sign_T	*first_sign = NULL;$/;"	v	file:
first_submatch	search.c	/^first_submatch(rp)$/;"	f	file:
firstbuf	globals.h	/^EXTERN buf_T	*firstbuf INIT(= NULL);	\/* first buffer *\/$/;"	v
firstfunc	eval.c	/^ufunc_T		*firstfunc = NULL;$/;"	v
firstline	eval.c	/^    var		firstline;	\/* "a:firstline" variable *\/$/;"	m	struct:funccall	file:
firstwin	globals.h	/^EXTERN win_T	*firstwin;		\/* first window *\/$/;"	v
firstwin	globals.h	465;"	d
fix_fname	buffer.c	/^fix_fname(fname)$/;"	f
fix_help_buffer	ex_cmds.c	/^fix_help_buffer()$/;"	f
fix_indent	edit.c	/^fix_indent()$/;"	f
fix_input_buffer	getchar.c	/^fix_input_buffer(buf, len, script)$/;"	f
fixthisline	edit.c	/^fixthisline(get_the_indent)$/;"	f
fkmap	farsi.c	/^fkmap(c)$/;"	f
flag	syntax.c	/^    int		flag;$/;"	m	struct:name_list	file:
flags	eval.c	/^    char	flags;		\/* VV_COMPAT and VV_RO *\/$/;"	m	struct:vimvar	file:
flags	eval.c	/^    int		flags;$/;"	m	struct:ufunc	file:
flags	option.c	/^    long_u	flags;		\/* see below *\/$/;"	m	struct:vimoption	file:
flags	quickfix.c	/^    char_u	    flags;	\/* additional flags given in prefix *\/$/;"	m	struct:eformat	file:
flags	structs.h	/^    short	flags;		\/* see syntax.c *\/$/;"	m	struct:keyentry
fline_T	fold.c	/^} fline_T;$/;"	t	typeref:struct:__anon15	file:
flush_buffers	getchar.c	/^flush_buffers(typeahead)$/;"	f
fm_getname	mark.c	/^fm_getname(fmark, lead_len)$/;"	f
fmark	structs.h	/^    fmark_T	fmark;		\/* cursor position BEFORE ":tag" *\/$/;"	m	struct:taggy
fmark	structs.h	/^    fmark_T	fmark;$/;"	m	struct:xfilemark
fmark_T	structs.h	/^} fmark_T;$/;"	t	typeref:struct:filemark
fmarks_check_names	mark.c	/^fmarks_check_names(buf)$/;"	f
fmarks_check_one	mark.c	/^fmarks_check_one(fm, name, buf)$/;"	f	file:
fmt_check_par	ops.c	/^fmt_check_par(lnum)$/;"	f	file:
fmt_check_par	ops.c	/^fmt_check_par(lnum, leader_len, leader_flags, do_comments)$/;"	f	file:
fname	edit.c	/^    char_u		*fname;	  \/* file containing the match *\/$/;"	m	struct:Completion	file:
fname	ex_cmds2.c	/^    char_u	*fname;		\/* name of sourced file *\/$/;"	m	struct:source_cookie	file:
fname	fileio.c	/^    char_u	*fname;		\/* fname to match with *\/$/;"	m	struct:AutoPatCmd	file:
fname	structs.h	/^    char_u	*fname;		\/* file name, used when fnum == 0 *\/$/;"	m	struct:xfilemark
fname	tag.c	/^    char_u	*fname;		\/* first char of file name *\/$/;"	m	struct:tag_pointers	file:
fname2fnum	mark.c	/^fname2fnum(fm)$/;"	f	file:
fname_case	os_amiga.c	/^fname_case(name, len)$/;"	f
fname_end	tag.c	/^    char_u	*fname_end;	\/* char after file name *\/$/;"	m	struct:tag_pointers	file:
fname_expand	buffer.c	/^fname_expand(buf, ffname, sfname)$/;"	f
fname_match	buffer.c	/^fname_match(prog, name)$/;"	f	file:
fnamecmp	vim.h	1320;"	d
fnamecmp	vim.h	1323;"	d
fnamecmp	vim.h	1327;"	d
fnamecmp_ino	memline.c	/^fnamecmp_ino(fname_c, fname_s, ino_block0)$/;"	f	file:
fnamencmp	vim.h	1321;"	d
fnamencmp	vim.h	1324;"	d
fnamencmp	vim.h	1328;"	d
fnum	structs.h	/^    int		fnum;		\/* file number *\/$/;"	m	struct:filemark
foldAddMarker	fold.c	/^foldAddMarker(lnum, marker, markerlen)$/;"	f	file:
foldAdjustCursor	fold.c	/^foldAdjustCursor()$/;"	f
foldAdjustVisual	fold.c	/^foldAdjustVisual()$/;"	f
foldCase	mbyte.c	/^convertStruct foldCase[] =$/;"	v
foldCheckClose	fold.c	/^foldCheckClose()$/;"	f
foldCreate	fold.c	/^foldCreate(start, end)$/;"	f
foldCreateMarkers	fold.c	/^foldCreateMarkers(start, end)$/;"	f	file:
foldDelMarker	fold.c	/^foldDelMarker(lnum, marker, markerlen)$/;"	f	file:
foldFind	fold.c	/^foldFind(gap, lnum, fpp)$/;"	f	file:
foldInitWin	fold.c	/^foldInitWin(newwin)$/;"	f
foldInsert	fold.c	/^foldInsert(gap, i)$/;"	f	file:
foldLevel	fold.c	/^foldLevel(lnum)$/;"	f
foldLevelWin	fold.c	/^foldLevelWin(wp, lnum)$/;"	f	file:
foldManualAllowed	fold.c	/^foldManualAllowed(create)$/;"	f
foldMarkAdjust	fold.c	/^foldMarkAdjust(wp, line1, line2, amount, amount_after)$/;"	f
foldMarkAdjustRecurse	fold.c	/^foldMarkAdjustRecurse(gap, line1, line2, amount, amount_after)$/;"	f	file:
foldMerge	fold.c	/^foldMerge(fp1, gap, fp2)$/;"	f	file:
foldMoveTo	fold.c	/^foldMoveTo(updown, dir, count)$/;"	f
foldOpenCursor	fold.c	/^foldOpenCursor()$/;"	f
foldOpenNested	fold.c	/^foldOpenNested(fpr)$/;"	f	file:
foldRemove	fold.c	/^foldRemove(gap, top, bot)$/;"	f	file:
foldSplit	fold.c	/^foldSplit(gap, i, top, bot)$/;"	f	file:
foldUpdate	fold.c	/^foldUpdate(wp, top, bot)$/;"	f
foldUpdateAll	fold.c	/^foldUpdateAll(win)$/;"	f
foldUpdateIEMS	fold.c	/^foldUpdateIEMS(wp, top, bot)$/;"	f	file:
foldUpdateIEMSRecurse	fold.c	/^foldUpdateIEMSRecurse(gap, level, startlnum, flp, getlevel, bot, topflags)$/;"	f	file:
fold_T	fold.c	/^} fold_T;$/;"	t	typeref:struct:__anon14	file:
fold_changed	fold.c	/^static int fold_changed;$/;"	v	file:
fold_line	screen.c	/^fold_line(wp, fold_count, foldinfo, lnum, row)$/;"	f	file:
foldclosed_both	eval.c	/^foldclosed_both(argvars, retvar, end)$/;"	f	file:
foldedCount	fold.c	/^foldedCount(win, lnum, infop)$/;"	f
foldendmarker	fold.c	/^static char_u *foldendmarker;$/;"	v	file:
foldendmarkerlen	fold.c	/^static int foldendmarkerlen;$/;"	v	file:
foldinfo	structs.h	/^typedef struct foldinfo$/;"	s
foldinfo_T	structs.h	/^} foldinfo_T;$/;"	t	typeref:struct:foldinfo
foldlevelDiff	fold.c	/^foldlevelDiff(flp)$/;"	f	file:
foldlevelExpr	fold.c	/^foldlevelExpr(flp)$/;"	f	file:
foldlevelIndent	fold.c	/^foldlevelIndent(flp)$/;"	f	file:
foldlevelMarker	fold.c	/^foldlevelMarker(flp)$/;"	f	file:
foldlevelSyntax	fold.c	/^foldlevelSyntax(flp)$/;"	f	file:
foldmethodIsDiff	fold.c	/^foldmethodIsDiff(wp)$/;"	f
foldmethodIsExpr	fold.c	/^foldmethodIsExpr(wp)$/;"	f
foldmethodIsIndent	fold.c	/^foldmethodIsIndent(wp)$/;"	f
foldmethodIsManual	fold.c	/^foldmethodIsManual(wp)$/;"	f
foldmethodIsMarker	fold.c	/^foldmethodIsMarker(wp)$/;"	f
foldmethodIsSyntax	fold.c	/^foldmethodIsSyntax(wp)$/;"	f
foldstartmarkerlen	fold.c	/^static int foldstartmarkerlen;$/;"	v	file:
foldtext_cleanup	fold.c	/^foldtext_cleanup(str)$/;"	f
font	structs.h	/^	    GuiFont	    font;	\/* font handle *\/$/;"	m	struct:attr_entry::__anon34::__anon37
font_argument	globals.h	/^EXTERN char	*font_argument INIT(= NULL);$/;"	v
font_can_bold	gui.h	/^    int		font_can_bold;	    \/* Whether norm_font supports bold weight.$/;"	m	struct:Gui
font_name2handle	syntax.c	/^font_name2handle(name)$/;"	f	file:
fontdlg	gui.h	/^    GtkWidget	*fontdlg;	    \/* font selection dialog window *\/$/;"	m	struct:Gui
fontname	gui.h	/^    char_u	*fontname;	    \/* font name from font selection dialog *\/$/;"	m	struct:Gui
fontset	gui.h	/^    GuiFontset	fontset;	    \/* set of fonts for multi-byte chars *\/$/;"	m	struct:Gui
fontset	structs.h	/^	    GuiFontset	    fontset;	\/* fontset handle *\/$/;"	m	struct:attr_entry::__anon34::__anon37
fontset_name2handle	syntax.c	/^fontset_name2handle(name, fixed_width)$/;"	f	file:
footer_height	gui.h	/^    int		footer_height;	    \/* height of the message footer *\/$/;"	m	struct:Gui
fopen_noinh_readbin	ex_cmds2.c	/^fopen_noinh_readbin(filename)$/;"	f	file:
force_abort	globals.h	/^EXTERN int force_abort INIT(= FALSE);$/;"	v
force_bin	ex_cmds.h	/^    int		force_bin;	\/* 0, FORCE_BIN or FORCE_NOBIN *\/$/;"	m	struct:exarg
force_enc	ex_cmds.h	/^    int		force_enc;	\/* forced 'encoding' (index in cmd[]) *\/$/;"	m	struct:exarg
force_ff	ex_cmds.h	/^    int		force_ff;	\/* forced 'fileformat' (index in cmd[]) *\/$/;"	m	struct:exarg
force_menu_update	globals.h	/^EXTERN int force_menu_update INIT(= FALSE);$/;"	v
forceit	ex_cmds.h	/^    int		forceit;	\/* TRUE if ! present *\/$/;"	m	struct:exarg
foreground_argument	globals.h	/^EXTERN char	*foreground_argument INIT(= NULL);$/;"	v
format	vim.h	/^    int_u	format;		\/* Vim's own special clipboard format *\/$/;"	m	struct:VimClipboard
format_lines	ops.c	/^format_lines(line_count)$/;"	f
format_raw	vim.h	/^    int_u	format_raw;	\/* Vim's raw text clipboard format *\/$/;"	m	struct:VimClipboard
formwin	gui.h	/^    GtkWidget	*formwin;	    \/* manages all the windows below *\/$/;"	m	struct:Gui
forward_slash	fileio.c	/^forward_slash(fname)$/;"	f
found_reverse_arg	globals.h	/^EXTERN int	found_reverse_arg INIT(= FALSE);$/;"	v
found_tagfile_cb	tag.c	/^found_tagfile_cb(fname)$/;"	f	file:
fp	ex_cmds2.c	/^    FILE	*fp;		\/* opened file for sourcing *\/$/;"	m	struct:source_cookie	file:
fp	search.c	/^    FILE	*fp;		\/* File pointer *\/$/;"	m	struct:SearchedFile	file:
fr_child	structs.h	/^    frame_T	*fr_child;	\/* first contained frame *\/$/;"	m	struct:frame
fr_height	structs.h	/^    int		fr_height;$/;"	m	struct:frame
fr_layout	structs.h	/^    char	fr_layout;	\/* FR_LEAF, FR_COL or FR_ROW *\/$/;"	m	struct:frame
fr_newheight	structs.h	/^    int		fr_newheight;	\/* new height used in win_equal_rec() *\/$/;"	m	struct:frame
fr_next	structs.h	/^    frame_T	*fr_next;	\/* frame right or below in same parent, NULL$/;"	m	struct:frame
fr_parent	structs.h	/^    frame_T	*fr_parent;	\/* containing frame or NULL *\/$/;"	m	struct:frame
fr_prev	structs.h	/^    frame_T	*fr_prev;	\/* frame left or above in same parent, NULL$/;"	m	struct:frame
fr_width	structs.h	/^    int		fr_width;$/;"	m	struct:frame
fr_win	structs.h	/^    win_T	*fr_win;	\/* window that fills this frame *\/$/;"	m	struct:frame
frame	structs.h	/^struct frame$/;"	s
frame2win	window.c	/^frame2win(frp)$/;"	f	file:
frame_T	structs.h	/^typedef struct frame	frame_T;$/;"	t	typeref:struct:frame
frame_add_height	window.c	/^frame_add_height(frp, n)$/;"	f	file:
frame_add_statusline	window.c	/^frame_add_statusline(frp)$/;"	f	file:
frame_add_vsep	window.c	/^frame_add_vsep(frp)$/;"	f	file:
frame_append	window.c	/^frame_append(after, frp)$/;"	f	file:
frame_comp_pos	window.c	/^frame_comp_pos(topfrp, row, col)$/;"	f	file:
frame_fix_height	window.c	/^frame_fix_height(wp)$/;"	f	file:
frame_fix_width	window.c	/^frame_fix_width(wp)$/;"	f	file:
frame_fixed_height	window.c	/^frame_fixed_height(frp)$/;"	f	file:
frame_has_win	window.c	/^frame_has_win(frp, wp)$/;"	f	file:
frame_insert	window.c	/^frame_insert(before, frp)$/;"	f	file:
frame_minheight	window.c	/^frame_minheight(topfrp, next_curwin)$/;"	f	file:
frame_minwidth	window.c	/^frame_minwidth(topfrp, next_curwin)$/;"	f	file:
frame_new_height	window.c	/^frame_new_height(topfrp, height, topfirst, wfh)$/;"	f	file:
frame_new_width	window.c	/^frame_new_width(topfrp, width, leftfirst)$/;"	f	file:
frame_remove	window.c	/^frame_remove(frp)$/;"	f	file:
frame_setheight	window.c	/^frame_setheight(curfrp, height)$/;"	f	file:
frame_setwidth	window.c	/^frame_setwidth(curfrp, width)$/;"	f	file:
free_buf_options	buffer.c	/^free_buf_options(buf, free_p_ff)$/;"	f
free_buff	getchar.c	/^free_buff(buf)$/;"	f
free_buffer	buffer.c	/^free_buffer(buf)$/;"	f	file:
free_buffer_stuff	buffer.c	/^free_buffer_stuff(buf, free_options)$/;"	f	file:
free_cmdlines	ex_docmd.c	/^free_cmdlines(gap)$/;"	f	file:
free_highlight_fonts	syntax.c	/^free_highlight_fonts()$/;"	f
free_jumplist	mark.c	/^free_jumplist(wp)$/;"	f
free_keywtab	syntax.c	/^free_keywtab(ktabp)$/;"	f	file:
free_menu	menu.c	/^free_menu(menup)$/;"	f	file:
free_menu_string	menu.c	/^free_menu_string(menu, idx)$/;"	f	file:
free_msglist	ex_eval.c	/^free_msglist(l)$/;"	f	file:
free_string_option	option.c	/^free_string_option(p)$/;"	f
free_typebuf	getchar.c	/^free_typebuf()$/;"	f
free_var	eval.c	/^free_var(varp)$/;"	f	file:
free_yank	ops.c	/^free_yank(n)$/;"	f	file:
free_yank_all	ops.c	/^free_yank_all()$/;"	f	file:
from	digraph.c	/^    char_u	*from;$/;"	m	struct:__anon20	file:
from	menu.c	/^    char_u	*from;		\/* English name *\/$/;"	m	struct:__anon47	file:
from_noamp	menu.c	/^    char_u	*from_noamp;	\/* same, without '&' *\/$/;"	m	struct:__anon47	file:
fst	eval.c	/^static struct fst$/;"	s	file:
fstatfs	memfile.c	51;"	d	file:
fstatfs	memfile.c	58;"	d	file:
ftell	tag.c	100;"	d	file:
full_screen	globals.h	/^EXTERN int	full_screen INIT(= FALSE);$/;"	v
fullname	option.c	/^    char	*fullname;	\/* full option name *\/$/;"	m	struct:vimoption	file:
fullpathcmp	misc1.c	/^fullpathcmp(s1, s2, checkname)$/;"	f
func	eval.c	/^    ufunc_T	*func;		\/* function being called *\/$/;"	m	struct:funccall	file:
func	syntax.c	/^    void    (*func)__ARGS((exarg_T *, int));	\/* function to call *\/$/;"	m	struct:subcommand	file:
func_breakpoint	eval.c	/^func_breakpoint(cookie)$/;"	f
func_dbg_tick	eval.c	/^func_dbg_tick(cookie)$/;"	f
func_has_abort	eval.c	/^func_has_abort(cookie)$/;"	f
func_has_ended	eval.c	/^func_has_ended(cookie)$/;"	f
func_level	eval.c	/^func_level(cookie)$/;"	f
func_name	eval.c	/^func_name(cookie)$/;"	f
funccall	eval.c	/^struct funccall$/;"	s	file:
functions	eval.c	/^} functions[] =$/;"	v	typeref:struct:fst	file:
fwd_word	search.c	/^fwd_word(count, bigword, eol)$/;"	f
g:arg	testdir/test49.vim	/^		let g:arg = "brrrr"$/;"	v
g:arg	testdir/test49.vim	/^	    let g:arg = "autsch"$/;"	v
g:jump	testdir/test49.vim	/^		    let g:jump = "finish"$/;"	v
g:jump	testdir/test49.vim	/^		let g:jump = "throw"$/;"	v
g:jump	testdir/test49.vim	/^	    let g:jump = "interrupt"$/;"	v
g:jump	testdir/test49.vim	/^	let g:jump = "error"$/;"	v
g:jump	testdir/test49.vim	/^    let g:jump = "break"$/;"	v
g:jump	testdir/test49.vim	/^    let g:jump = "continue"$/;"	v
g:jump	testdir/test49.vim	/^    let g:jump = "finish"$/;"	v
g:line	testdir/test49.vim	/^		let g:line = 8$/;"	v
g:line	testdir/test49.vim	/^	    let g:line = 6$/;"	v
g:taken	testdir/test49.vim	/^	    let g:taken = g:taken . "T" . t$/;"	v
g_do_tagpreview	globals.h	/^EXTERN int	g_do_tagpreview INIT(= 0);  \/* for tag preview commands:$/;"	v
ga_append	misc2.c	/^ga_append(gap, c)$/;"	f
ga_clear	misc2.c	/^ga_clear(gap)$/;"	f
ga_clear_strings	misc2.c	/^ga_clear_strings(gap)$/;"	f
ga_concat	misc2.c	/^ga_concat(gap, s)$/;"	f
ga_data	structs.h	/^    void    *ga_data;		    \/* pointer to the first item *\/$/;"	m	struct:growarray
ga_grow	misc2.c	/^ga_grow(gap, n)$/;"	f
ga_growsize	structs.h	/^    int	    ga_growsize;	    \/* number of items to grow each time *\/$/;"	m	struct:growarray
ga_init	misc2.c	/^ga_init(gap)$/;"	f
ga_init2	misc2.c	/^ga_init2(gap, itemsize, growsize)$/;"	f
ga_itemsize	structs.h	/^    int	    ga_itemsize;	    \/* sizeof one item *\/$/;"	m	struct:growarray
ga_len	structs.h	/^    int	    ga_len;		    \/* current number of items used *\/$/;"	m	struct:growarray
ga_room	structs.h	/^    int	    ga_room;		    \/* number of unused items at the end *\/$/;"	m	struct:growarray
ga_scripts	eval.c	/^static garray_T	    ga_scripts = {0, 0, sizeof(garray_T), 4, NULL};$/;"	v	file:
ga_userinput	eval.c	/^static garray_T	    ga_userinput = {0, 0, sizeof(tasave_T), 4, NULL};$/;"	v	file:
garray_T	structs.h	/^} garray_T;$/;"	t	typeref:struct:growarray
gather_termleader	term.c	/^gather_termleader()$/;"	f	file:
gboolean	mbyte.c	4009;"	d	file:
gboolean	mbyte.c	4021;"	d	file:
gchar_cursor	misc1.c	/^gchar_cursor()$/;"	f
gchar_pos	misc1.c	/^gchar_pos(pos)$/;"	f
gen_expand_wildcards	misc1.c	/^gen_expand_wildcards(num_pat, pat, num_file, file, flags)$/;"	f
gen_expand_wildcards	vim.h	653;"	d
geom	gui.h	/^    char_u	*geom;		    \/* Geometry, eg "80x24" *\/$/;"	m	struct:Gui
getConnInfo	netbeans.c	/^getConnInfo(char *file, char **host, char **port, char **auth)$/;"	f	file:
getDeepestNesting	fold.c	/^getDeepestNesting()$/;"	f
getDeepestNestingRecurse	fold.c	/^getDeepestNestingRecurse(gap)$/;"	f	file:
getMenu	gui_amiga.c	/^getMenu(struct RastPort *rast, int left, STRPTR name)$/;"	f	file:
get_address	ex_docmd.c	/^get_address(ptr, skip, to_other_file)$/;"	f	file:
get_attr_entry	syntax.c	/^get_attr_entry(table, aep)$/;"	f	file:
get_augroup_name	fileio.c	/^get_augroup_name(xp, idx)$/;"	f
get_buf_size	netbeans.c	/^get_buf_size(buf_T *bufp)$/;"	f	file:
get_buf_var	eval.c	/^get_buf_var(avar)$/;"	f	file:
get_buffcont	getchar.c	/^get_buffcont(buffer, dozero)$/;"	f	file:
get_bytes_from_buf	term.c	/^get_bytes_from_buf(buf, bytes, num_bytes)$/;"	f	file:
get_c_indent	misc1.c	/^get_c_indent()$/;"	f
get_ccline_ptr	ex_getln.c	/^get_ccline_ptr()$/;"	f	file:
get_cmd_output	misc1.c	/^get_cmd_output(cmd, flags)$/;"	f
get_cmdline_pos	ex_getln.c	/^get_cmdline_pos()$/;"	f
get_cmdline_str	ex_getln.c	/^get_cmdline_str()$/;"	f
get_command_name	ex_docmd.c	/^get_command_name(xp, idx)$/;"	f
get_crypt_key	misc2.c	/^get_crypt_key(store, twice)$/;"	f
get_digraph	digraph.c	/^get_digraph(cmdline)$/;"	f
get_emsg_lnum	message.c	/^get_emsg_lnum(other)$/;"	f	file:
get_emsg_source	message.c	/^get_emsg_source(other)$/;"	f	file:
get_env_len	eval.c	/^get_env_len(arg)$/;"	f	file:
get_env_name	misc1.c	/^get_env_name(xp, idx)$/;"	f
get_env_var	eval.c	/^get_env_var(arg, retvar, evaluate)$/;"	f	file:
get_equalprg	option.c	/^get_equalprg()$/;"	f
get_event_name	fileio.c	/^get_event_name(xp, idx)$/;"	f
get_expr_indent	misc1.c	/^get_expr_indent()$/;"	f
get_expr_line	ops.c	/^get_expr_line()$/;"	f
get_expr_name	eval.c	/^get_expr_name(xp, idx)$/;"	f
get_expr_register	ops.c	/^get_expr_register()$/;"	f
get_extra_op_char	ops.c	/^get_extra_op_char(optype)$/;"	f
get_fib	os_amiga.c	/^get_fib(fname)$/;"	f	file:
get_file_in_dir	memline.c	/^get_file_in_dir(fname, dname)$/;"	f
get_fileformat	misc2.c	/^get_fileformat(buf)$/;"	f
get_fileformat_force	misc2.c	/^get_fileformat_force(buf, eap)$/;"	f
get_find_dialog_text	gui.c	/^get_find_dialog_text(arg, wwordp, mcasep)$/;"	f
get_fio_flags	fileio.c	/^get_fio_flags(ptr)$/;"	f	file:
get_fpos_of_mouse	ui.c	/^get_fpos_of_mouse(mpos)$/;"	f
get_func_len	eval.c	/^get_func_len(arg, alias, evaluate)$/;"	f	file:
get_func_line	eval.c	/^get_func_line(c, cookie, indent)$/;"	f
get_func_var	eval.c	/^get_func_var(name, len, retvar, arg, firstline, lastline, doesrange, evaluate)$/;"	f	file:
get_function_name	eval.c	/^get_function_name(xp, idx)$/;"	f
get_group_name	syntax.c	/^get_group_name(arg, name_end)$/;"	f	file:
get_highlight_default	option.c	/^get_highlight_default()$/;"	f
get_highlight_name	syntax.c	/^get_highlight_name(xp, idx)$/;"	f
get_history_entry	ex_getln.c	/^get_history_entry(histype, idx)$/;"	f
get_history_idx	ex_getln.c	/^get_history_idx(histype)$/;"	f
get_histtype	ex_getln.c	/^get_histtype(name)$/;"	f
get_id_len	eval.c	/^get_id_len(arg)$/;"	f	file:
get_id_list	syntax.c	/^get_id_list(arg, keylen, list)$/;"	f	file:
get_indent	misc1.c	/^get_indent()$/;"	f
get_indent_buf	misc1.c	/^get_indent_buf(buf, lnum)$/;"	f
get_indent_lnum	misc1.c	/^get_indent_lnum(lnum)$/;"	f
get_indent_nolabel	misc1.c	/^get_indent_nolabel(lnum)		\/* XXX *\/$/;"	f	file:
get_indent_str	misc1.c	/^get_indent_str(ptr, ts)$/;"	f	file:
get_input_buf	ui.c	/^get_input_buf()$/;"	f
get_inserted	getchar.c	/^get_inserted()$/;"	f
get_key_name	misc2.c	/^get_key_name(i)$/;"	f
get_keymap_str	screen.c	/^get_keymap_str(wp, buf, len)$/;"	f
get_keystroke	misc1.c	/^get_keystroke()$/;"	f
get_lang_arg	ex_cmds2.c	/^get_lang_arg(xp, idx)$/;"	f
get_last_insert	edit.c	/^get_last_insert()$/;"	f
get_last_insert_save	edit.c	/^get_last_insert_save()$/;"	f
get_leader_len	misc1.c	/^get_leader_len(line, flags, backward)$/;"	f
get_lisp_indent	misc1.c	/^get_lisp_indent()$/;"	f
get_list_range	ex_getln.c	/^get_list_range(str, num1, num2)$/;"	f
get_lit_string_var	eval.c	/^get_lit_string_var(arg, retvar, evaluate)$/;"	f	file:
get_literal	edit.c	/^get_literal()$/;"	f
get_locale_val	ex_cmds2.c	/^get_locale_val(what)$/;"	f	file:
get_long_from_buf	term.c	/^get_long_from_buf(buf, val)$/;"	f	file:
get_mac_fio_flags	fileio.c	/^get_mac_fio_flags(ptr)$/;"	f	file:
get_map_mode	getchar.c	/^get_map_mode(cmdp, forceit)$/;"	f
get_maparg	eval.c	/^get_maparg(argvars, retvar, exact)$/;"	f	file:
get_mef_name	quickfix.c	/^get_mef_name()$/;"	f	file:
get_menu_cmd_modes	menu.c	/^get_menu_cmd_modes(cmd, forceit, noremap, unmenu)$/;"	f	file:
get_menu_index	menu.c	/^get_menu_index(menu, state)$/;"	f
get_menu_mode	menu.c	/^get_menu_mode()$/;"	f	file:
get_menu_name	menu.c	/^get_menu_name(xp, idx)$/;"	f
get_menu_names	menu.c	/^get_menu_names(xp, idx)$/;"	f
get_mess_env	ex_cmds2.c	/^get_mess_env()$/;"	f	file:
get_mess_lang	ex_cmds2.c	/^get_mess_lang()$/;"	f
get_mouse_button	misc2.c	/^get_mouse_button(code, is_click, is_drag)$/;"	f
get_mouse_class	normal.c	/^get_mouse_class(p)$/;"	f	file:
get_nolist_virtcol	edit.c	/^get_nolist_virtcol()$/;"	f	file:
get_number	misc1.c	/^get_number(colon)$/;"	f
get_number_arg	main.c	/^get_number_arg(p, idx, def)$/;"	f	file:
get_number_indent	misc1.c	/^get_number_indent(lnum)$/;"	f
get_off_or_lnum	netbeans.c	/^get_off_or_lnum(buf_T *buf, char_u **argp)$/;"	f	file:
get_one_sourceline	ex_cmds2.c	/^get_one_sourceline(sp)$/;"	f	file:
get_op_char	ops.c	/^get_op_char(optype)$/;"	f
get_op_type	ops.c	/^get_op_type(char1, char2)$/;"	f
get_option_value	option.c	/^get_option_value(name, numval, stringval, opt_flags)$/;"	f
get_option_var	eval.c	/^get_option_var(arg, retvar, evaluate)$/;"	f	file:
get_past_head	misc1.c	/^get_past_head(path)$/;"	f
get_printer_page_num	ex_cmds2.c	/^get_printer_page_num()$/;"	f
get_pseudo_mouse_code	misc2.c	/^get_pseudo_mouse_code(button, is_click, is_drag)$/;"	f
get_real_state	misc2.c	/^get_real_state()$/;"	f
get_recorded	getchar.c	/^get_recorded()$/;"	f
get_reg_contents	ops.c	/^get_reg_contents(regname, allowexpr)$/;"	f
get_reg_type	ops.c	/^get_reg_type(regname, reglen)$/;"	f
get_register	ops.c	/^get_register(name, copy)$/;"	f
get_register_name	ops.c	/^get_register_name(num)$/;"	f
get_rel_pos	buffer.c	/^get_rel_pos(wp, str)$/;"	f
get_return_cmd	eval.c	/^get_return_cmd(retvar)$/;"	f
get_scriptname	ex_cmds2.c	/^get_scriptname(id)$/;"	f
get_scroll_overlap	move.c	/^get_scroll_overlap(lp, dir)$/;"	f	file:
get_search_arg	eval.c	/^get_search_arg(varp, flagsp)$/;"	f	file:
get_search_pat	search.c	/^get_search_pat()$/;"	f
get_shape_idx	misc2.c	/^get_shape_idx(mouse)$/;"	f
get_short_pathname	eval.c	/^get_short_pathname(fnamep, bufp, fnamelen)$/;"	f	file:
get_spec_reg	ops.c	/^get_spec_reg(regname, argp, allocated, errmsg)$/;"	f
get_special_key_code	misc2.c	/^get_special_key_code(name)$/;"	f
get_special_key_name	misc2.c	/^get_special_key_name(c, modifiers)$/;"	f
get_string_var	eval.c	/^get_string_var(arg, retvar, evaluate)$/;"	f	file:
get_syn_options	syntax.c	/^get_syn_options(arg, flagsp, keyword, sync_idx, cont_list,$/;"	f	file:
get_syn_pattern	syntax.c	/^get_syn_pattern(arg, ci)$/;"	f	file:
get_syntax_attr	syntax.c	/^get_syntax_attr(col)$/;"	f
get_syntax_name	syntax.c	/^get_syntax_name(xp, idx)$/;"	f
get_tagfname	tag.c	/^get_tagfname(first, buf)$/;"	f	file:
get_term_code	option.c	/^get_term_code(tname)$/;"	f
get_termcode	term.c	/^get_termcode(i)$/;"	f
get_user_cmd_complete	ex_docmd.c	/^get_user_cmd_complete(xp, idx)$/;"	f
get_user_cmd_flags	ex_docmd.c	/^get_user_cmd_flags(xp, idx)$/;"	f
get_user_cmd_nargs	ex_docmd.c	/^get_user_cmd_nargs(xp, idx)$/;"	f
get_user_command_name	ex_docmd.c	/^get_user_command_name(idx)$/;"	f	file:
get_user_commands	ex_docmd.c	/^get_user_commands(xp, idx)$/;"	f
get_user_func_name	eval.c	/^get_user_func_name(xp, idx)$/;"	f
get_user_name	misc2.c	/^get_user_name(buf, len)$/;"	f
get_user_var_name	eval.c	/^get_user_var_name(xp, idx)$/;"	f
get_var_lnum	eval.c	/^get_var_lnum(argvars)$/;"	f	file:
get_var_number	eval.c	/^get_var_number(varp)$/;"	f	file:
get_var_string	eval.c	/^get_var_string(varp)$/;"	f	file:
get_var_string_buf	eval.c	/^get_var_string_buf(varp, buf)$/;"	f	file:
get_var_value	eval.c	/^get_var_value(name)$/;"	f
get_var_var	eval.c	/^get_var_var(name, len, retvar)$/;"	f	file:
get_varp	option.c	/^get_varp(p)$/;"	f	file:
get_varp_scope	option.c	/^get_varp_scope(p, opt_flags)$/;"	f	file:
get_view_file	ex_docmd.c	/^get_view_file(c)$/;"	f	file:
get_vim_var_nr	eval.c	/^get_vim_var_nr(idx)$/;"	f
get_viminfo_parameter	option.c	/^get_viminfo_parameter(type)$/;"	f
get_visual_text	normal.c	/^get_visual_text(cap, pp, lenp)$/;"	f	file:
get_while_line	ex_docmd.c	/^get_while_line(c, cookie, indent)$/;"	f	file:
get_win_fio_flags	fileio.c	/^get_win_fio_flags(ptr)$/;"	f	file:
get_winopts	buffer.c	/^get_winopts(buf)$/;"	f
get_yank_register	ops.c	/^get_yank_register(regname, writing)$/;"	f
getaltfname	buffer.c	/^getaltfname(errmsg)$/;"	f
getargcmd	ex_docmd.c	/^getargcmd(argp)$/;"	f	file:
getargopt	ex_docmd.c	/^getargopt(eap)$/;"	f	file:
getchr	regexp.c	/^getchr()$/;"	f	file:
getcmdline	ex_getln.c	/^getcmdline(firstc, count, indent)$/;"	f
getcmdline_prompt	ex_getln.c	/^getcmdline_prompt(firstc, prompt, attr)$/;"	f
getcwd	vim.h	220;"	d
getdigits	charset.c	/^getdigits(pp)$/;"	f
getdigraph	digraph.c	/^getdigraph(char1, char2, meta)$/;"	f
getent	termlib.c	/^getent(tbuf, term, termcap, buflen)$/;"	f	file:
getexactdigraph	digraph.c	/^getexactdigraph(char1, char2, meta)$/;"	f	file:
getexline	ex_getln.c	/^getexline(c, dummy, indent)$/;"	f
getexmodeline	ex_getln.c	/^getexmodeline(c, dummy, indent)$/;"	f
getfile	ex_cmds.c	/^getfile(fnum, ffname, sfname, setpm, lnum, forceit)$/;"	f
getline	ex_cmds.h	/^    char_u	*(*getline) __ARGS((int, void *, int));$/;"	m	struct:exarg
getline	ex_docmd.c	/^    char_u	*(*getline) __ARGS((int, void *, int));$/;"	m	struct:while_cookie	file:
getline_cookie	ex_docmd.c	/^getline_cookie(getline, cookie)$/;"	f
getline_equal	ex_docmd.c	/^getline_equal(getline, cookie, func)$/;"	f
getlinecol	term.c	/^getlinecol(cp, rp)$/;"	f
getmark	mark.c	/^getmark(c, changefile)$/;"	f
getnextac	fileio.c	/^getnextac(c, cookie, indent)$/;"	f	file:
getnextcomp	misc1.c	/^getnextcomp(fname)$/;"	f
getnextmark	mark.c	/^getnextmark(startpos, dir, begin_line)$/;"	f
getout	main.c	/^getout(exitval)$/;"	f
getout_preserve_modified	main.c	/^getout_preserve_modified(exitval)$/;"	f
getrealcolor	gui_amiga.c	/^static UBYTE getrealcolor(guicolor_T i)$/;"	f	file:
getsourceline	ex_cmds2.c	/^getsourceline(c, cookie, indent)$/;"	f
gettail	misc1.c	/^gettail(fname)$/;"	f
gettext_lang	ex_cmds2.c	/^gettext_lang(char_u *name)$/;"	f	file:
gettimeofday	main.c	/^gettimeofday(struct timeval *tv, char *dummy)$/;"	f
getvcol	charset.c	/^getvcol(wp, pos, start, cursor, end)$/;"	f
getvcol_nolist	charset.c	/^getvcol_nolist(posp)$/;"	f
getvcols	charset.c	/^getvcols(wp, pos1, pos2, left, right)$/;"	f
getviscol	misc2.c	/^getviscol()$/;"	f
getviscol2	misc2.c	/^getviscol2(col, coladd)$/;"	f
getvpos	misc2.c	/^getvpos(pos, wcol)$/;"	f
getvvcol	charset.c	/^getvvcol(wp, pos, start, cursor, end)$/;"	f
getvvcol	vim.h	1594;"	d
gfp_buffer	gui.c	/^static char_u	*gfp_buffer;$/;"	v	file:
gfp_setname	gui.c	/^gfp_setname(fname)$/;"	f	file:
gfxBase	gui_amiga.c	/^struct GFXBase		*gfxBase;$/;"	v	typeref:struct:GFXBase
gg	testdir/test49.vim	/^	normal! gg$/;"	m
give_warning	message.c	/^give_warning(message, hl)$/;"	f
global_alist	globals.h	/^EXTERN alist_T	global_alist;	\/* global argument list *\/$/;"	v
global_busy	globals.h	/^EXTERN int	global_busy INIT(= 0);	    \/* set when :global is executing *\/$/;"	v
global_changedtick	globals.h	/^EXTERN int	global_changedtick INIT(= 0);	\/* incremented for each$/;"	v
global_exe	ex_cmds.c	/^global_exe(cmd)$/;"	f
global_need_beginline	ex_cmds.c	/^static int	global_need_beginline;	\/* call beginline() after ":g" *\/$/;"	v	file:
globaldir	globals.h	/^EXTERN char_u	*globaldir INIT(= NULL);$/;"	v
globalsignmap	netbeans.c	/^static char **globalsignmap;$/;"	v	file:
globalsignmaplen	netbeans.c	/^static int globalsignmaplen;$/;"	v	file:
globalsignmapused	netbeans.c	/^static int globalsignmapused;$/;"	v	file:
globpath	ex_getln.c	/^globpath(path, file)$/;"	f
got_code_from_term	term.c	/^got_code_from_term(code, len)$/;"	f	file:
got_int	globals.h	/^EXTERN int	got_int INIT(= FALSE);	    \/* set to TRUE when interrupt$/;"	v
gotchars	getchar.c	/^gotchars(s, len)$/;"	f	file:
goto_buffer	buffer.c	/^goto_buffer(eap, start, dir, count)$/;"	f
goto_byte	memline.c	/^goto_byte(cnt)$/;"	f
goto_im	misc1.c	/^goto_im()$/;"	f
gotocmdline	ex_getln.c	/^gotocmdline(clr)$/;"	f
green	gui_amiga.c	/^	UBYTE		green;$/;"	m	struct:guicolor_tTable	file:
greyed_out	structs.h	/^    int		greyed_out;	    \/* Flag *\/$/;"	m	struct:VimMenu
group	fileio.c	/^    int		    group;		\/* group ID *\/$/;"	m	struct:AutoPat	file:
group	fileio.c	/^    int		group;		\/* group being used *\/$/;"	m	struct:AutoPatCmd	file:
growarray	structs.h	/^typedef struct growarray$/;"	s
gtk_sel_atom	vim.h	/^    GdkAtom     gtk_sel_atom;	\/* PRIMARY\/CLIPBOARD selection ID *\/$/;"	m	struct:VimClipboard
gtk_socket_id	globals.h	/^EXTERN guint32	gtk_socket_id INIT(= 0);$/;"	v
gui	gui.c	/^gui_T gui;$/;"	v
gui	structs.h	/^	} gui;$/;"	m	union:attr_entry::__anon34	typeref:struct:attr_entry::__anon34::__anon37
guiMenu	gui_amiga.h	/^    vimmenu_T	*guiMenu;$/;"	m	struct:MyMenuItem
gui_T	gui.h	/^} gui_T;$/;"	t	typeref:struct:Gui
gui_add_tearoff	menu.c	/^gui_add_tearoff(tearpath, pri_tab, pri_idx)$/;"	f	file:
gui_attr_table	syntax.c	/^garray_T	gui_attr_table = {0, 0, 0, 0, NULL};$/;"	v
gui_bg_default	option.c	/^gui_bg_default()$/;"	f	file:
gui_can_update_cursor	gui.c	/^gui_can_update_cursor()$/;"	f
gui_check_colors	gui.c	/^gui_check_colors()$/;"	f
gui_check_pos	gui.c	/^gui_check_pos()$/;"	f	file:
gui_clear_block	gui.c	/^gui_clear_block(row1, col1, row2, col2)$/;"	f
gui_create_initial_menus	menu.c	/^gui_create_initial_menus(menu)$/;"	f
gui_create_scrollbar	gui.c	/^gui_create_scrollbar(sb, type, wp)$/;"	f
gui_create_tearoffs_recurse	menu.c	/^gui_create_tearoffs_recurse(menu, pname, pri_tab, pri_idx)$/;"	f	file:
gui_delete_lines	gui.c	/^gui_delete_lines(row, count)$/;"	f	file:
gui_destroy_tearoffs_recurse	menu.c	/^gui_destroy_tearoffs_recurse(menu)$/;"	f	file:
gui_do_findrepl	gui.c	/^gui_do_findrepl(flags, find_text, repl_text, down)$/;"	f
gui_do_horiz_scroll	gui.c	/^gui_do_horiz_scroll()$/;"	f
gui_do_one_color	syntax.c	/^gui_do_one_color(idx, do_menu, do_tooltip)$/;"	f	file:
gui_do_scroll	gui.c	/^gui_do_scroll()$/;"	f
gui_do_scrollbar	gui.c	/^gui_do_scrollbar(wp, which, enable)$/;"	f	file:
gui_dont_update_cursor	gui.c	/^gui_dont_update_cursor()$/;"	f
gui_drag_scrollbar	gui.c	/^gui_drag_scrollbar(sb, value, still_dragging)$/;"	f
gui_exit	gui.c	/^gui_exit(rc)$/;"	f
gui_find_bitmap	gui.c	/^gui_find_bitmap(name, buffer, ext)$/;"	f
gui_find_iconfile	gui.c	/^gui_find_iconfile(name, buffer, ext)$/;"	f
gui_find_menu	menu.c	/^gui_find_menu(path_name)$/;"	f
gui_find_scrollbar	gui.c	/^gui_find_scrollbar(ident)$/;"	f
gui_focus_change	gui.c	/^gui_focus_change(in_focus)$/;"	f
gui_get_base_height	gui.c	/^gui_get_base_height()$/;"	f
gui_get_base_width	gui.c	/^gui_get_base_width()$/;"	f
gui_get_color	gui.c	/^gui_get_color(name)$/;"	f
gui_get_lightness	gui.c	/^gui_get_lightness(pixel)$/;"	f
gui_get_shellsize	gui.c	/^gui_get_shellsize()$/;"	f
gui_get_wide_font	gui.c	/^gui_get_wide_font()$/;"	f
gui_handle_drop	gui.c	/^gui_handle_drop(x, y, modifiers, fnames, count)$/;"	f
gui_init	gui.c	/^gui_init()$/;"	f
gui_init_check	gui.c	/^gui_init_check()$/;"	f
gui_init_font	gui.c	/^gui_init_font(font_list, fontset)$/;"	f
gui_init_which_components	gui.c	/^gui_init_which_components(oldval)$/;"	f
gui_insert_lines	gui.c	/^gui_insert_lines(row, count)$/;"	f	file:
gui_is_menu_shortcut	menu.c	/^gui_is_menu_shortcut(key)$/;"	f
gui_may_resize_shell	gui.c	/^gui_may_resize_shell()$/;"	f
gui_mch_add_menu	gui_amiga.c	/^gui_mch_add_menu(vimmenu_T *menu, int idx)$/;"	f
gui_mch_add_menu_item	gui_amiga.c	/^gui_mch_add_menu_item(vimmenu_T *menu, int idx)$/;"	f
gui_mch_adjust_charsize	gui_amiga.c	/^gui_mch_adjust_charsize()$/;"	f
gui_mch_beep	gui_amiga.c	/^gui_mch_beep(void)$/;"	f
gui_mch_clear_all	gui_amiga.c	/^gui_mch_clear_all(void)$/;"	f
gui_mch_clear_block	gui_amiga.c	/^gui_mch_clear_block(int row1, int col1, int row2, int col2)$/;"	f
gui_mch_create_beval_area	gui_beval.c	/^gui_mch_create_beval_area(target, mesg, mesgCB, clientData)$/;"	f
gui_mch_create_scrollbar	gui_amiga.c	/^gui_mch_create_scrollbar(scrollbar_T *sb, int orient)$/;"	f
gui_mch_currently_showing_beval	gui_beval.c	/^gui_mch_currently_showing_beval()$/;"	f
gui_mch_delete_lines	gui_amiga.c	/^gui_mch_delete_lines(int row, int num_lines)$/;"	f
gui_mch_destroy_beval_area	gui_beval.c	/^gui_mch_destroy_beval_area(beval)$/;"	f
gui_mch_destroy_menu	gui_amiga.c	/^gui_mch_destroy_menu(vimmenu_T *menu)$/;"	f
gui_mch_destroy_scrollbar	gui_amiga.c	/^gui_mch_destroy_scrollbar(scrollbar_T *sb)$/;"	f
gui_mch_disable_beval_area	gui_beval.c	/^gui_mch_disable_beval_area(beval)$/;"	f
gui_mch_draw_hollow_cursor	gui_amiga.c	/^gui_mch_draw_hollow_cursor(guicolor_T color)$/;"	f
gui_mch_draw_menubar	gui_amiga.c	/^gui_mch_draw_menubar(void)$/;"	f
gui_mch_draw_part_cursor	gui_amiga.c	/^gui_mch_draw_part_cursor( int w, int h, guicolor_T color)$/;"	f
gui_mch_draw_string	gui_amiga.c	/^gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)$/;"	f
gui_mch_enable_beval_area	gui_beval.c	/^gui_mch_enable_beval_area(beval)$/;"	f
gui_mch_enable_menu	gui_amiga.c	/^gui_mch_enable_menu(int flag)$/;"	f
gui_mch_enable_scrollbar	gui_amiga.c	/^gui_mch_enable_scrollbar(scrollbar_T *sb, int flag)$/;"	f
gui_mch_exit	gui_amiga.c	/^gui_mch_exit(int returnCode)$/;"	f
gui_mch_find_dialog	ex_docmd.c	209;"	d	file:
gui_mch_flash	gui_amiga.c	/^gui_mch_flash(int msec)$/;"	f
gui_mch_flush	gui_amiga.c	/^gui_mch_flush(void)$/;"	f
gui_mch_free_font	gui_amiga.c	/^gui_mch_free_font(GuiFont font)$/;"	f
gui_mch_get_beval_info	gui_beval.c	/^gui_mch_get_beval_info(beval, filename, line, text, idx)$/;"	f
gui_mch_get_color	gui_amiga.c	/^gui_mch_get_color(char_u *name)$/;"	f
gui_mch_get_font	gui_amiga.c	/^gui_mch_get_font( char_u *name, int giveErrorIfMissing)$/;"	f
gui_mch_get_mouse_x	gui_amiga.c	/^gui_mch_get_mouse_x()$/;"	f
gui_mch_get_mouse_y	gui_amiga.c	/^gui_mch_get_mouse_y()$/;"	f
gui_mch_get_rgb	gui_amiga.c	/^gui_mch_get_rgb(guicolor_T pixel)$/;"	f
gui_mch_get_screen_dimensions	gui_amiga.c	/^gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)$/;"	f
gui_mch_get_winpos	gui_amiga.c	/^gui_mch_get_winpos(int *x, int *y)$/;"	f
gui_mch_haskey	gui_amiga.c	/^gui_mch_haskey(char_u *name)$/;"	f
gui_mch_iconify	gui_amiga.c	/^gui_mch_iconify(void)$/;"	f
gui_mch_init	gui_amiga.c	/^gui_mch_init(void)$/;"	f
gui_mch_init_check	gui_amiga.c	/^gui_mch_init_check(void)$/;"	f
gui_mch_init_font	gui_amiga.c	/^int gui_mch_init_font(char_u *font_name, int fontset)$/;"	f
gui_mch_insert_lines	gui_amiga.c	/^gui_mch_insert_lines(int row, int num_lines)$/;"	f
gui_mch_invert_rectangle	gui_amiga.c	/^gui_mch_invert_rectangle( int r, int c, int nr, int nc)$/;"	f
gui_mch_menu_grey	gui_amiga.c	/^gui_mch_menu_grey(vimmenu_T *menu, int grey)$/;"	f
gui_mch_menu_hidden	gui_amiga.c	/^gui_mch_menu_hidden(vimmenu_T *menu, int hidden)$/;"	f
gui_mch_new_colors	gui_amiga.c	/^gui_mch_new_colors(void)$/;"	f
gui_mch_open	gui_amiga.c	/^gui_mch_open(void)$/;"	f
gui_mch_post_balloon	gui_beval.c	/^gui_mch_post_balloon(beval, mesg)$/;"	f
gui_mch_prepare	gui_amiga.c	/^gui_mch_prepare(int *argc, char **argv)$/;"	f
gui_mch_replace_dialog	ex_docmd.c	210;"	d	file:
gui_mch_set_bg_color	gui_amiga.c	/^gui_mch_set_bg_color(guicolor_T color)$/;"	f
gui_mch_set_blinking	gui_amiga.c	/^gui_mch_set_blinking(long wait, long on, long off)$/;"	f
gui_mch_set_colors	gui_amiga.c	/^gui_mch_set_colors(guicolor_T fg, guicolor_T bg)$/;"	f
gui_mch_set_fg_color	gui_amiga.c	/^gui_mch_set_fg_color(guicolor_T color)$/;"	f
gui_mch_set_font	gui_amiga.c	/^gui_mch_set_font(GuiFont font)$/;"	f
gui_mch_set_foreground	gui_amiga.c	/^gui_mch_set_foreground()$/;"	f
gui_mch_set_menu_pos	gui_amiga.c	/^gui_mch_set_menu_pos(int x, int y, int w, int h)$/;"	f
gui_mch_set_scrollbar_pos	gui_amiga.c	/^gui_mch_set_scrollbar_pos(scrollbar_T *sb, int x, int y, int w, int h)$/;"	f
gui_mch_set_scrollbar_thumb	gui_amiga.c	/^gui_mch_set_scrollbar_thumb(scrollbar_T *sb, long val, long size, long max)$/;"	f
gui_mch_set_shellsize	gui_amiga.c	/^gui_mch_set_shellsize(int width, int height,$/;"	f
gui_mch_set_text_area_pos	gui_amiga.c	/^gui_mch_set_text_area_pos(int x, int y, int w, int h)$/;"	f
gui_mch_set_winpos	gui_amiga.c	/^gui_mch_set_winpos(int x, int y)$/;"	f
gui_mch_setmouse	gui_amiga.c	/^gui_mch_setmouse(x, y)$/;"	f
gui_mch_settitle	gui_amiga.c	/^gui_mch_settitle(char_u  *title, char_u  *icon)$/;"	f
gui_mch_show_popupmenu	gui_amiga.c	/^gui_mch_show_popupmenu(vimmenu_T *menu)$/;"	f
gui_mch_start_blink	gui_amiga.c	/^gui_mch_start_blink(void)$/;"	f
gui_mch_stop_blink	gui_amiga.c	/^gui_mch_stop_blink(void)$/;"	f
gui_mch_toggle_tearoffs	gui_amiga.c	/^gui_mch_toggle_tearoffs(enable)$/;"	f
gui_mch_toggle_tearoffs	menu.c	/^gui_mch_toggle_tearoffs(int enable)$/;"	f
gui_mch_unpost_balloon	gui_beval.c	/^gui_mch_unpost_balloon(beval)$/;"	f
gui_mch_update	gui_amiga.c	/^gui_mch_update(void)$/;"	f
gui_mch_wait_for_chars	gui_amiga.c	/^gui_mch_wait_for_chars(int wtime)$/;"	f
gui_menu_cb	gui.c	/^gui_menu_cb(menu)$/;"	f
gui_mouse_correct	gui.c	/^gui_mouse_correct()$/;"	f
gui_mouse_moved	gui.c	/^gui_mouse_moved(x, y)$/;"	f
gui_new_scrollbar_colors	gui.c	/^gui_new_scrollbar_colors()$/;"	f
gui_new_shellsize	gui.c	/^gui_new_shellsize()$/;"	f
gui_outstr	gui.c	/^gui_outstr(s, len)$/;"	f	file:
gui_outstr_nowrap	gui.c	/^gui_outstr_nowrap(s, len, flags, fg, bg, back)$/;"	f
gui_position_components	gui.c	/^gui_position_components(total_width)$/;"	f	file:
gui_position_menu	gui.c	/^gui_position_menu()$/;"	f
gui_prepare	gui.c	/^gui_prepare(argc, argv)$/;"	f
gui_prev_topfill	globals.h	/^EXTERN int	gui_prev_topfill INIT(= 0);$/;"	v
gui_prev_topline	globals.h	/^EXTERN linenr_T gui_prev_topline INIT(= 0);$/;"	v
gui_redraw	gui.c	/^gui_redraw(x, y, w, h)$/;"	f
gui_redraw_block	gui.c	/^gui_redraw_block(row1, col1, row2, col2, flags)$/;"	f
gui_reset_scroll_region	gui.c	/^gui_reset_scroll_region()$/;"	f
gui_resize_shell	gui.c	/^gui_resize_shell(pixel_width, pixel_height)$/;"	f
gui_screenchar	gui.c	/^gui_screenchar(off, flags, fg, bg, back)$/;"	f	file:
gui_screenstr	gui.c	/^gui_screenstr(off, len, flags, fg, bg, back)$/;"	f	file:
gui_send_mouse_event	gui.c	/^gui_send_mouse_event(button, x, y, repeated_click, modifiers)$/;"	f
gui_set_bg_color	gui.c	/^gui_set_bg_color(name)$/;"	f
gui_set_cursor	gui.c	/^gui_set_cursor(row, col)$/;"	f
gui_set_fg_color	gui.c	/^gui_set_fg_color(name)$/;"	f
gui_set_shellsize	gui.c	/^gui_set_shellsize(mustset, fit_to_display)$/;"	f
gui_shell_closed	gui.c	/^gui_shell_closed()$/;"	f
gui_show_popupmenu	menu.c	/^gui_show_popupmenu()$/;"	f
gui_start	gui.c	/^gui_start()$/;"	f
gui_start_highlight	gui.c	/^gui_start_highlight(mask)$/;"	f
gui_stop_highlight	gui.c	/^gui_stop_highlight(mask)$/;"	f
gui_undraw_cursor	gui.c	/^gui_undraw_cursor()$/;"	f
gui_update_cursor	gui.c	/^gui_update_cursor(force, clear_selection)$/;"	f
gui_update_cursor_later	gui.c	/^gui_update_cursor_later()$/;"	f
gui_update_horiz_scrollbar	gui.c	/^gui_update_horiz_scrollbar(force)$/;"	f	file:
gui_update_menus	menu.c	/^gui_update_menus(modes)$/;"	f
gui_update_menus_recurse	menu.c	/^gui_update_menus_recurse(menu, mode)$/;"	f	file:
gui_update_screen	gui.c	/^gui_update_screen()$/;"	f
gui_update_scrollbars	gui.c	/^gui_update_scrollbars(force)$/;"	f
gui_wait_for_chars	gui.c	/^gui_wait_for_chars(wtime)$/;"	f
gui_win_pos_T	gui.h	/^gui_win_pos_T;$/;"	t	typeref:enum:__anon21
gui_win_x	globals.h	/^EXTERN int	gui_win_x INIT(= -1);$/;"	v
gui_win_y	globals.h	/^EXTERN int	gui_win_y INIT(= -1);$/;"	v
gui_wingoto_xy	gui.c	/^gui_wingoto_xy(x, y)$/;"	f	file:
gui_write	gui.c	/^gui_write(s, len)$/;"	f
gui_xy2colrow	gui.c	/^gui_xy2colrow(x, y, colp)$/;"	f
guicolor_T	gui.h	/^typedef long	    guicolor_T;	\/* handle for a GUI color; for X11 this should$/;"	t
guicolor_T	structs.h	86;"	d
guicolor_tTable	gui_amiga.c	/^    typedef struct guicolor_tTable$/;"	s	file:
guicolor_tTable	gui_amiga.c	/^    } guicolor_tTable;$/;"	t	typeref:struct:guicolor_tTable	file:
hIconvDLL	mbyte.c	/^HINSTANCE hIconvDLL = 0;$/;"	v
hMsvcrtDLL	mbyte.c	/^HINSTANCE hMsvcrtDLL = 0;$/;"	v
had_end	fold.c	/^    int		had_end;	\/* level of fold that is forced to end above$/;"	m	struct:__anon15	file:
had_endbrace	regexp.c	/^static char_u	had_endbrace[NSUBEXP];	\/* flags, TRUE if end of () found *\/$/;"	v	file:
had_eol	regexp.c	/^static int	had_eol;	\/* TRUE when EOL found by vim_regcomp() *\/$/;"	v	file:
half_shape	arabic.c	/^half_shape(c)$/;"	f	file:
halfpage	move.c	/^halfpage(flag, Prenum)$/;"	f
handle_drop	ex_docmd.c	/^handle_drop(filec, filev, split)$/;"	f
handle_key_queue	netbeans.c	/^handle_key_queue(void)$/;"	f	file:
handle_swap_exists	buffer.c	/^handle_swap_exists(old_curbuf)$/;"	f
handler_id	gui.h	/^    unsigned long handler_id;   \/* Id of "value_changed" signal handler *\/$/;"	m	struct:GuiScrollbar
hardcopy_line	ex_cmds2.c	/^hardcopy_line(psettings, page_line, ppos)$/;"	f	file:
hasAnyFolding	fold.c	/^hasAnyFolding(win)$/;"	f
hasFolding	fold.c	/^hasFolding(lnum, firstp, lastp)$/;"	f
hasFoldingWin	fold.c	/^hasFoldingWin(win, lnum, firstp, lastp, cache, infop)$/;"	f
has_autocmd	fileio.c	/^has_autocmd(event, sfname)$/;"	f
has_color	structs.h	/^    int		has_color;$/;"	m	struct:__anon45
has_cursorhold	fileio.c	/^has_cursorhold()$/;"	f
has_format_option	option.c	/^has_format_option(x)$/;"	f
has_mbyte	globals.h	/^EXTERN int	has_mbyte INIT(= 0);		\/* any multi-byte encoding *\/$/;"	v
has_mouse_termcode	term.c	/^static int has_mouse_termcode = 0;$/;"	v	file:
has_patch	version.c	/^has_patch(n)$/;"	f
has_while_cmd	ex_eval.c	/^has_while_cmd(p)$/;"	f
hasnum	structs.h	/^    int		hasnum;$/;"	m	struct:__anon43
haveConnection	netbeans.c	/^static int haveConnection = FALSE;	\/* socket is connected and$/;"	v	file:
head	netbeans.c	/^static queue_T head;  \/* dummy node, header for circular queue *\/$/;"	v	file:
head	tag.c	/^    char_u	*head;		\/* start of pattern head *\/$/;"	m	struct:__anon8	file:
headlen	tag.c	/^    int		headlen;	\/* length of head[] *\/$/;"	m	struct:__anon8	file:
height	ex_cmds2.c	/^    float	height;$/;"	m	struct:prt_mediasize_S	file:
height	gui.h	/^    int		height;		\/* Current height of scroll bar in rows *\/$/;"	m	struct:GuiScrollbar
height	move.c	/^    int		    height;	\/* height of added line *\/$/;"	m	struct:__anon46	file:
heightCharToPoint	gui_amiga.c	/^heightCharToPoint(int height)$/;"	f	file:
heightPointToChar	gui_amiga.c	/^heightPointToChar(int height)$/;"	f	file:
help_compare	ex_cmds.c	/^help_compare(s1, s2)$/;"	f	file:
help_heuristic	ex_cmds.c	/^help_heuristic(matched_string, offset, wrong_case)$/;"	f
helptags_one	ex_cmds.c	/^helptags_one(dir, ext, tagfname)$/;"	f	file:
hex2nr	charset.c	/^hex2nr(c)$/;"	f
hexhex2nr	charset.c	/^hexhex2nr(p)$/;"	f
hexx	xxd/xxd.c	/^char hexxa[] = "0123456789abcdef0123456789ABCDEF", *hexx = hexxa;$/;"	v
hexxa	xxd/xxd.c	/^char hexxa[] = "0123456789abcdef0123456789ABCDEF", *hexx = hexxa;$/;"	v
hidden	structs.h	/^    int		hidden;$/;"	m	struct:VimMenu
hide	structs.h	/^    int		hide;			\/* TRUE when ":hide" was used *\/$/;"	m	struct:__anon31
highest_patch	version.c	/^highest_patch()$/;"	f
highlight_attr	globals.h	/^EXTERN int	highlight_attr[HLF_COUNT];  \/* Highl. attr for each context. *\/$/;"	v
highlight_changed	syntax.c	/^highlight_changed()$/;"	f
highlight_clear	syntax.c	/^highlight_clear(idx)$/;"	f	file:
highlight_color	syntax.c	/^highlight_color(id, what, modec)$/;"	f
highlight_exists	syntax.c	/^highlight_exists(name)$/;"	f
highlight_ga	syntax.c	/^static garray_T highlight_ga;	\/* highlight groups for 'highlight' option *\/$/;"	v	file:
highlight_gui_color_rgb	syntax.c	/^highlight_gui_color_rgb(id, fg)$/;"	f
highlight_gui_started	syntax.c	/^highlight_gui_started()$/;"	f
highlight_has_attr	syntax.c	/^highlight_has_attr(id, flag, modec)$/;"	f
highlight_init_both	syntax.c	/^static char *(highlight_init_both[]) =$/;"	v	file:
highlight_init_dark	syntax.c	/^static char *(highlight_init_dark[]) =$/;"	v	file:
highlight_init_light	syntax.c	/^static char *(highlight_init_light[]) =$/;"	v	file:
highlight_list	syntax.c	/^highlight_list()$/;"	f	file:
highlight_list_arg	syntax.c	/^highlight_list_arg(id, didh, type, iarg, sarg, name)$/;"	f	file:
highlight_list_one	syntax.c	/^highlight_list_one(id)$/;"	f	file:
highlight_list_two	syntax.c	/^highlight_list_two(cnt, attr)$/;"	f	file:
highlight_mask	gui.h	/^    int		highlight_mask;	    \/* Highlight attribute mask *\/$/;"	m	struct:Gui
highlight_match	globals.h	/^EXTERN int	highlight_match INIT(= FALSE);	\/* show search match pos *\/$/;"	v
highlight_stlnc	globals.h	/^EXTERN int	highlight_stlnc[9];		\/* On top of user *\/$/;"	v
highlight_user	globals.h	/^EXTERN int	highlight_user[9];		\/* User[1-9] attributes *\/$/;"	v
hisidx	ex_getln.c	/^static int	hisidx[HIST_COUNT] = {-1, -1, -1, -1, -1};  \/* lastused entry *\/$/;"	v	file:
hislen	ex_getln.c	/^static int	hislen = 0;		\/* actual length of history tables *\/$/;"	v	file:
hisnum	ex_getln.c	/^    int		hisnum;		\/* identifying number *\/$/;"	m	struct:hist_entry	file:
hisnum	ex_getln.c	/^static int	hisnum[HIST_COUNT] = {0, 0, 0, 0, 0};$/;"	v	file:
hisstr	ex_getln.c	/^    char_u	*hisstr;	\/* actual entry, separator char after the NUL *\/$/;"	m	struct:hist_entry	file:
hist_char2type	ex_getln.c	/^hist_char2type(c)$/;"	f	file:
hist_entry	ex_getln.c	/^typedef struct hist_entry$/;"	s	file:
hist_type2char	ex_getln.c	/^hist_type2char(type, use_question)$/;"	f	file:
histentry_T	ex_getln.c	/^} histentry_T;$/;"	t	typeref:struct:hist_entry	file:
history	ex_getln.c	/^static histentry_T *(history[HIST_COUNT]) = {NULL, NULL, NULL, NULL, NULL};$/;"	v	file:
history_names	ex_getln.c	/^static char *(history_names[]) =$/;"	v	file:
hit_return_msg	message.c	/^hit_return_msg()$/;"	f	file:
hkmap	edit.c	/^hkmap(c)$/;"	f
hl_attr	vim.h	1366;"	d
hl_attr_table	syntax.c	/^static int hl_attr_table[] =$/;"	v	file:
hl_do_font	syntax.c	/^hl_do_font(idx, arg, do_normal, do_menu, do_tooltip)$/;"	f	file:
hl_get_font_name	syntax.c	/^hl_get_font_name()$/;"	f
hl_group	syntax.c	/^struct hl_group$/;"	s	file:
hl_has_settings	syntax.c	/^hl_has_settings(idx, check_link)$/;"	f	file:
hl_name_table	syntax.c	/^static char *(hl_name_table[]) =$/;"	v	file:
hl_set_bg_color_name	syntax.c	/^hl_set_bg_color_name(name)$/;"	f
hl_set_fg_color_name	syntax.c	/^hl_set_fg_color_name(name)$/;"	f
hl_set_font_name	syntax.c	/^hl_set_font_name(font_name)$/;"	f
hlf_value	vim.h	/^enum hlf_value$/;"	g
hold_gui_events	globals.h	/^EXTERN int	hold_gui_events INIT(= 0);$/;"	v
home_replace	misc1.c	/^home_replace(buf, src, dst, dstlen, one)$/;"	f
home_replace_save	misc1.c	/^home_replace_save(buf, src)$/;"	f
homedir	misc1.c	/^static char_u	*homedir = NULL;$/;"	v	file:
huntype	xxd/xxd.c	/^huntype(fpi, fpo, fperr, pname, cols, hextype, base_off)$/;"	f	file:
i	testdir/test49.vim	/^	let i = i + 1$/;"	v
i	testdir/test49.vim	/^    let i = 0$/;"	v
icon_builtin	structs.h	/^    int		icon_builtin;	    \/* icon names is BuiltIn{nr} *\/$/;"	m	struct:VimMenu
iconfile	structs.h	/^    char_u	*iconfile;	    \/* name of file for icon or NULL *\/$/;"	m	struct:VimMenu
iconidx	structs.h	/^    int		iconidx;	    \/* icon index (-1 if not set) *\/$/;"	m	struct:VimMenu
iconv	globals.h	/^EXTERN size_t (*iconv) (iconv_t cd, const char **inbuf, size_t *inbytesleft, char **outbuf, size_t *outbytesleft);$/;"	v
iconv_close	globals.h	/^EXTERN int (*iconv_close) (iconv_t cd);$/;"	v
iconv_enabled	mbyte.c	/^iconv_enabled(verbose)$/;"	f
iconv_end	mbyte.c	/^iconv_end()$/;"	f
iconv_errno	globals.h	/^EXTERN int* (*iconv_errno) (void);$/;"	v
iconv_open	globals.h	/^EXTERN iconv_t (*iconv_open) (const char *tocode, const char *fromcode);$/;"	v
iconv_string	mbyte.c	/^iconv_string(vcp, str, slen, unconvlenp)$/;"	f	file:
iconv_t	structs.h	/^typedef struct _iconv_t *iconv_t;$/;"	t	typeref:struct:_iconv_t
iconv_t	structs.h	/^typedef void *iconv_t;$/;"	t
iconvctl	globals.h	/^EXTERN int (*iconvctl) (iconv_t cd, int request, void *argument);$/;"	v
id	gui.h	/^    ControlHandle id;		\/* A handle to the scrollbar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    GtkWidget *id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    HWND	id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    PtWidget_t	*id;$/;"	m	struct:GuiScrollbar
id	gui.h	/^    VimScrollBar *id;		\/* Pointer to real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    Widget	id;		\/* Id of real scroll bar *\/$/;"	m	struct:GuiScrollbar
id	gui.h	/^    int		id;		\/* Window handle of scrollbar window *\/$/;"	m	struct:GuiScrollbar
id	structs.h	/^    BMenuItem	*id;		    \/* Id of menu item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    GtkWidget	*id;		    \/* Manage this to enable item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    PtWidget_t	*id;$/;"	m	struct:VimMenu
id	structs.h	/^    UINT	id;		    \/* Id of menu item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    Widget	id;		    \/* Manage this to enable item *\/$/;"	m	struct:VimMenu
id	structs.h	/^    int		    id;		    \/* unused by the amiga, but used in the$/;"	m	struct:VimMenu
id	structs.h	/^    int		*id;		    \/* Not used, but gui.c needs it *\/$/;"	m	struct:VimMenu
id	structs.h	/^    int		id;		\/* highlight group ID *\/$/;"	m	struct:cursor_entry
id	structs.h	/^    int		id;		\/* unique identifier for each placed sign *\/$/;"	m	struct:signlist
id	structs.h	/^    short	id;		\/* highlight group ID of item *\/$/;"	m	struct:sp_syn
id_lm	structs.h	/^    int		id_lm;		\/* highlight group ID for :lmap mode *\/$/;"	m	struct:cursor_entry
ident	gui.h	/^    long	ident;		\/* Unique identifier for each scrollbar *\/$/;"	m	struct:GuiScrollbar
idopt_T	option.c	/^} idopt_T;$/;"	t	typeref:enum:__anon9	file:
if_level	ex_docmd.c	/^static int	if_level = 0;		\/* depth in :if *\/$/;"	v	file:
ignorecase	search.c	/^ignorecase(pat)$/;"	f
illegal_char	option.c	/^illegal_char(errbuf, c)$/;"	f	file:
illegal_slash	misc2.c	/^illegal_slash(name)$/;"	f
im_activatekey_keyval	mbyte.c	/^static unsigned int  im_activatekey_keyval = GDK_VoidSymbol;$/;"	v	file:
im_activatekey_state	mbyte.c	/^static unsigned int  im_activatekey_state  = 0;$/;"	v	file:
im_add_to_input	mbyte.c	/^im_add_to_input(char_u *str, int len)$/;"	f	file:
im_commit_cb	mbyte.c	/^im_commit_cb(GtkIMContext *context, const gchar *str, gpointer data)$/;"	f	file:
im_commit_handler_id	mbyte.c	/^static unsigned long im_commit_handler_id  = 0;$/;"	v	file:
im_correct_cursor	mbyte.c	/^im_correct_cursor(int num_move_back)$/;"	f	file:
im_delete_preedit	mbyte.c	/^im_delete_preedit(void)$/;"	f	file:
im_get_feedback_attr	mbyte.c	/^im_get_feedback_attr(int col)$/;"	f
im_get_status	mbyte.c	/^im_get_status()$/;"	f
im_get_status	mbyte.c	/^im_get_status(void)$/;"	f
im_is_active	mbyte.c	/^static int im_is_active	       = FALSE;	\/* IM is enabled for current mode    *\/$/;"	v	file:
im_is_preediting	mbyte.c	/^im_is_preediting()$/;"	f
im_preedit_changed_cb	mbyte.c	/^im_preedit_changed_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_cursor	mbyte.c	/^static int im_preedit_cursor   = 0;	\/* cursor offset in characters       *\/$/;"	v	file:
im_preedit_end_cb	mbyte.c	/^im_preedit_end_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_start_cb	mbyte.c	/^im_preedit_start_cb(GtkIMContext *context, gpointer data)$/;"	f	file:
im_preedit_trailing	mbyte.c	/^static int im_preedit_trailing = 0;	\/* number of characters after cursor *\/$/;"	v	file:
im_save_status	ui.c	/^im_save_status(psave)$/;"	f
im_set_active	mbyte.c	/^im_set_active(active)$/;"	f
im_set_active	mbyte.c	/^im_set_active(int active)$/;"	f
im_set_position	mbyte.c	/^im_set_position(int row, int col)$/;"	f
im_set_position	mbyte.c	/^im_set_position(row, col)$/;"	f
im_show_info	mbyte.c	/^im_show_info(void)$/;"	f	file:
im_shutdown	mbyte.c	/^im_shutdown(void)$/;"	f
im_string_to_keyval	mbyte.c	/^im_string_to_keyval(const char *str, unsigned int *keyval, unsigned int *state)$/;"	f	file:
im_synthesize_keypress	mbyte.c	/^im_synthesize_keypress(unsigned int keyval, unsigned int state)$/;"	f	file:
im_xim_isvalid_imactivate	mbyte.c	/^im_xim_isvalid_imactivate()$/;"	f
im_xim_isvalid_imactivate	mbyte.c	/^im_xim_isvalid_imactivate(void)$/;"	f
im_xim_send_event_imactivate	mbyte.c	/^im_xim_send_event_imactivate()$/;"	f	file:
im_xim_str2keycode	mbyte.c	/^im_xim_str2keycode(code, state)$/;"	f	file:
image	structs.h	/^    Pixmap	image;		    \/* Toolbar image *\/$/;"	m	struct:VimMenu
image_ins	structs.h	/^    Pixmap	image_ins;	    \/* Toolbar image insensitive *\/$/;"	m	struct:VimMenu
inAtomic	netbeans.c	/^static int inAtomic = 0;$/;"	v	file:
in_cinkeys	edit.c	/^in_cinkeys(keytyped, when, line_is_empty)$/;"	f
in_focus	gui.h	/^    int		in_focus;	    \/* Vim has input focus *\/$/;"	m	struct:Gui
in_history	ex_getln.c	/^in_history(type, str, move_to_front)$/;"	f	file:
in_id_list	syntax.c	/^in_id_list(cur_si, list, ssp, contained)$/;"	f	file:
in_use	gui.h	/^    int		in_use;		    \/* Is the GUI being used? *\/$/;"	m	struct:Gui
in_win_border	charset.c	/^in_win_border(wp, vcol)$/;"	f
inbuf	ui.c	/^static char_u	inbuf[INBUFLEN + MAX_KEY_CODE_LEN];$/;"	v	file:
inbufcount	ui.c	/^static int	inbufcount = 0;	    \/* number of chars in inbuf[] *\/$/;"	v	file:
inc	misc2.c	/^inc(lp)$/;"	f
inc_cursor	misc2.c	/^inc_cursor()$/;"	f
inc_tag	structs.h	/^    int		inc_tag;	\/* ":syn include" unique tag *\/$/;"	m	struct:sp_syn
inchar	getchar.c	/^inchar(buf, maxlen, wait_time, tb_change_cnt)$/;"	f
incl	misc2.c	/^incl(lp)$/;"	f
include_default	syntax.c	/^static int include_default = FALSE;	\/* include "default" for expansion *\/$/;"	v	file:
include_groups	fileio.c	/^static int include_groups = FALSE;$/;"	v	file:
include_link	syntax.c	/^static int include_link = FALSE;	\/* include "link" for expansion *\/$/;"	v	file:
included_patches	version.c	/^static int included_patches[] =$/;"	v	file:
inclusive	structs.h	/^    int		inclusive;	\/* TRUE if char motion is inclusive (only$/;"	m	struct:oparg
indir	option.c	/^    idopt_T	indir;		\/* global option: PV_NONE;$/;"	m	struct:vimoption	file:
infile	testdir/test49.vim	/^	let infile = tempname()$/;"	v
info_message	globals.h	/^EXTERN int	info_message INIT(= FALSE); \/* printing informative message *\/$/;"	v
info_pointer	structs.h	/^typedef struct info_pointer$/;"	s
infoptr_T	structs.h	/^} infoptr_T;	\/* block\/index pair *\/$/;"	t	typeref:struct:info_pointer
inindent	misc1.c	/^inindent(extra)$/;"	f
initDone	netbeans.c	/^    unsigned int	 initDone:1;$/;"	m	struct:nbbuf_struct	file:
init_chartab	charset.c	/^init_chartab()$/;"	f
init_class_tab	regexp.c	/^init_class_tab()$/;"	f	file:
init_gui_options	option.c	/^init_gui_options()$/;"	f
init_highlight	syntax.c	/^init_highlight(both, reset)$/;"	f
init_history	ex_getln.c	/^init_history()$/;"	f	file:
init_homedir	misc1.c	/^init_homedir()$/;"	f
init_mappings	getchar.c	/^init_mappings()$/;"	f
init_normal_cmds	normal.c	/^init_normal_cmds()$/;"	f
init_preedit_start_col	mbyte.c	/^init_preedit_start_col(void)$/;"	f	file:
init_syn_patterns	syntax.c	/^init_syn_patterns()$/;"	f	file:
init_typebuf	getchar.c	/^init_typebuf()$/;"	f	file:
init_yank	ops.c	/^init_yank()$/;"	f
initchr	regexp.c	/^initchr(str)$/;"	f	file:
initial_pos	edit.c	/^static pos_T		    initial_pos;$/;"	v	file:
initmap	getchar.c	/^static struct initmap$/;"	s	file:
initmappings	getchar.c	/^} initmappings[] =$/;"	v	typeref:struct:initmap	file:
inmacro	search.c	/^inmacro(opt, s)$/;"	f	file:
ino	ex_cmds2.c	/^    ino_t	ino;$/;"	m	struct:scriptstuff	file:
inputHandler	netbeans.c	/^static XtInputId inputHandler;		\/* Cookie for input *\/$/;"	v	file:
inputHandler	netbeans.c	/^static gint inputHandler;		\/* Cookie for input *\/$/;"	v	file:
inputHandler	netbeans.c	/^static int  inputHandler = -1;		\/* simply ret.value of WSAAsyncSelect() *\/$/;"	v	file:
input_available	getchar.c	/^input_available()$/;"	f
input_conv	globals.h	/^EXTERN vimconv_T input_conv;			\/* type of input conversion *\/$/;"	v
input_style	mbyte.c	/^static XIMStyle	input_style;$/;"	v	file:
inputsecret_flag	eval.c	/^static int inputsecret_flag = 0;$/;"	v	file:
ins_bs	edit.c	/^ins_bs(c, mode, inserted_space_p)$/;"	f	file:
ins_bytes	misc1.c	/^ins_bytes(p)$/;"	f
ins_bytes_len	misc1.c	/^ins_bytes_len(p, len)$/;"	f
ins_char	misc1.c	/^ins_char(c)$/;"	f
ins_char_bytes	misc1.c	/^ins_char_bytes(buf, charlen)$/;"	f
ins_compl_add	edit.c	/^ins_compl_add(str, len, fname, dir, reuse)$/;"	f	file:
ins_compl_add_infercase	edit.c	/^ins_compl_add_infercase(str, len, fname, dir, reuse)$/;"	f
ins_compl_add_matches	edit.c	/^ins_compl_add_matches(num_matches, matches, dir)$/;"	f	file:
ins_compl_check_keys	edit.c	/^ins_compl_check_keys()$/;"	f
ins_compl_clear	edit.c	/^ins_compl_clear()$/;"	f	file:
ins_compl_delete	edit.c	/^ins_compl_delete()$/;"	f	file:
ins_compl_dictionaries	edit.c	/^ins_compl_dictionaries(dict, pat, dir, flags, thesaurus)$/;"	f	file:
ins_compl_free	edit.c	/^ins_compl_free()$/;"	f	file:
ins_compl_get_exp	edit.c	/^ins_compl_get_exp(ini, dir)$/;"	f	file:
ins_compl_insert	edit.c	/^ins_compl_insert()$/;"	f	file:
ins_compl_make_cyclic	edit.c	/^ins_compl_make_cyclic()$/;"	f	file:
ins_compl_next	edit.c	/^ins_compl_next(allow_get_expansion)$/;"	f	file:
ins_compl_next_buf	edit.c	/^ins_compl_next_buf(buf, flag)$/;"	f	file:
ins_compl_prep	edit.c	/^ins_compl_prep(c)$/;"	f	file:
ins_complete	edit.c	/^ins_complete(c)$/;"	f	file:
ins_copychar	edit.c	/^ins_copychar(lnum)$/;"	f	file:
ins_ctrl_	edit.c	/^ins_ctrl_()$/;"	f	file:
ins_ctrl_g	edit.c	/^ins_ctrl_g()$/;"	f	file:
ins_ctrl_v	edit.c	/^ins_ctrl_v()$/;"	f	file:
ins_del	edit.c	/^ins_del()$/;"	f	file:
ins_digraph	edit.c	/^ins_digraph()$/;"	f	file:
ins_down	edit.c	/^ins_down(startcol)$/;"	f	file:
ins_drop	edit.c	/^ins_drop()$/;"	f	file:
ins_end	edit.c	/^ins_end(c)$/;"	f	file:
ins_eol	edit.c	/^ins_eol(c)$/;"	f	file:
ins_esc	edit.c	/^ins_esc(count, cmdchar)$/;"	f	file:
ins_home	edit.c	/^ins_home(c)$/;"	f	file:
ins_horscroll	edit.c	/^ins_horscroll()$/;"	f
ins_left	edit.c	/^ins_left()$/;"	f	file:
ins_mouse	edit.c	/^ins_mouse(c)$/;"	f	file:
ins_mousescroll	edit.c	/^ins_mousescroll(up)$/;"	f	file:
ins_need_undo	edit.c	/^static int	ins_need_undo;		\/* call u_save() before inserting a$/;"	v	file:
ins_pagedown	edit.c	/^ins_pagedown()$/;"	f	file:
ins_pageup	edit.c	/^ins_pageup()$/;"	f	file:
ins_redraw	edit.c	/^ins_redraw()$/;"	f	file:
ins_reg	edit.c	/^ins_reg()$/;"	f	file:
ins_right	edit.c	/^ins_right()$/;"	f	file:
ins_s_left	edit.c	/^ins_s_left()$/;"	f	file:
ins_s_right	edit.c	/^ins_s_right()$/;"	f	file:
ins_scroll	edit.c	/^ins_scroll()$/;"	f
ins_shift	edit.c	/^ins_shift(c, lastc)$/;"	f	file:
ins_start_select	edit.c	/^ins_start_select(c)$/;"	f	file:
ins_str	misc1.c	/^ins_str(s)$/;"	f
ins_tab	edit.c	/^ins_tab()$/;"	f	file:
ins_try_si	edit.c	/^ins_try_si(c)$/;"	f	file:
ins_typebuf	getchar.c	/^ins_typebuf(str, noremap, offset, nottyped, silent)$/;"	f
ins_up	edit.c	/^ins_up(startcol)$/;"	f	file:
insert_reg	ops.c	/^insert_reg(regname, literally)$/;"	f
insert_sign	buffer.c	/^insert_sign(buf, prev, next, id, lnum, typenr)$/;"	f	file:
insert_special	edit.c	/^insert_special(c, allow_modmask, ctrlv)$/;"	f	file:
insertchar	edit.c	/^insertchar(c, flags, second_indent)$/;"	f
instr	vim.h	1776;"	d
int_u	vim.h	/^typedef unsigned int	int_u;$/;"	t
intable	mbyte.c	/^intable(table, size, c)$/;"	f	file:
intcaught	testdir/test49.vim	/^		let intcaught = 1$/;"	v
intcaught	testdir/test49.vim	/^	    let intcaught = 0$/;"	v
intcaught	testdir/test49.vim	/^	    let intcaught = 1$/;"	v
interval	mbyte.c	/^struct interval$/;"	s	file:
intr_char	globals.h	/^EXTERN int	intr_char INIT(= 0);	    \/* extra interrupt character *\/$/;"	v
intro_message	version.c	/^intro_message(colon)$/;"	f
invalid_bot	fold.c	/^static linenr_T invalid_bot = (linenr_T)0;$/;"	v	file:
invalid_range	ex_docmd.c	/^invalid_range(eap)$/;"	f	file:
invalid_top	fold.c	/^static linenr_T invalid_top = (linenr_T)0;$/;"	v	file:
invalidate_botline	move.c	/^invalidate_botline()$/;"	f
invalidate_botline_win	move.c	/^invalidate_botline_win(wp)$/;"	f
invalidate_current_state	syntax.c	/^invalidate_current_state()$/;"	f	file:
invert_gc	gui.h	/^    GC		invert_gc;$/;"	m	struct:Gui
invoke_edit	normal.c	/^invoke_edit(cap, repl, cmd, startln)$/;"	f	file:
ip_bnum	structs.h	/^    blocknr_T	ip_bnum;	\/* block number *\/$/;"	m	struct:info_pointer
ip_high	structs.h	/^    linenr_T	ip_high;	\/* highest lnum in this block *\/$/;"	m	struct:info_pointer
ip_index	structs.h	/^    int		ip_index;	\/* index for block with current lnum *\/$/;"	m	struct:info_pointer
ip_low	structs.h	/^    linenr_T	ip_low;		\/* lowest lnum in this block *\/$/;"	m	struct:info_pointer
ireg_ic	regexp.c	/^static int	ireg_ic;$/;"	v	file:
ireg_icombine	regexp.c	/^static int	ireg_icombine;$/;"	v	file:
isNetbeansBuffer	netbeans.c	/^isNetbeansBuffer(buf_T *bufp)$/;"	f
isNetbeansModified	netbeans.c	/^isNetbeansModified(buf_T *bufp)$/;"	f
is_MAX	ops.c	/^    int		is_MAX;		\/* TRUE if curswant==MAXCOL when starting *\/$/;"	m	struct:block_def	file:
is_Magic	regexp.c	230;"	d	file:
is_VIsual	structs.h	/^    int		is_VIsual;	\/* operator on Visual area *\/$/;"	m	struct:oparg
is_click	misc2.c	/^    int	    is_click;		\/* Is it a mouse button click event? *\/$/;"	m	struct:mousetable	file:
is_drag	misc2.c	/^    int	    is_drag;		\/* Is it a mouse drag event? *\/$/;"	m	struct:mousetable	file:
is_etag	tag.c	/^    int		is_etag;	\/* TRUE for emacs tag *\/$/;"	m	struct:tag_pointers	file:
is_oneChar	ops.c	/^    int		is_oneChar;	\/* TRUE if block within one character *\/$/;"	m	struct:block_def	file:
is_short	ops.c	/^    int		is_short;	\/* TRUE if line is too short to fit in block *\/$/;"	m	struct:block_def	file:
istermoption	option.c	/^istermoption(p)$/;"	f	file:
ital_font	gui.h	/^    GuiFont	ital_font;	    \/* Italic font *\/$/;"	m	struct:Gui
italic	structs.h	/^    int		italic;$/;"	m	struct:__anon44
jobname	structs.h	/^    char_u	*jobname;$/;"	m	struct:__anon45
jump_to_mouse	ui.c	/^jump_to_mouse(flags, inclusive, which_button)$/;"	f
jumpto_tag	tag.c	/^jumpto_tag(lbuf, forceit, keep_help)$/;"	f	file:
k_syn	structs.h	/^    struct sp_syn k_syn;	\/* struct passed to in_id_list() *\/$/;"	m	struct:keyentry	typeref:struct:keyentry::sp_syn
keep_filetype	globals.h	/^EXTERN int	keep_filetype INIT(= FALSE);	\/* value for did_filetype when$/;"	v
keep_help_flag	globals.h	/^EXTERN int	keep_help_flag INIT(= FALSE); \/* doing :ta from help file *\/$/;"	v
keep_msg	globals.h	/^EXTERN char_u	*keep_msg INIT(= NULL);	    \/* msg to be shown after redraw *\/$/;"	v
keep_msg_attr	globals.h	/^EXTERN int	keep_msg_attr INIT(= 0);    \/* highlight attr for keep_msg *\/$/;"	v
keepend_level	syntax.c	/^static int keepend_level = -1;$/;"	v	file:
keepjumps	structs.h	/^    int		keepjumps;		\/* TRUE when ":keepjumps" was used *\/$/;"	m	struct:__anon31
keepmarks	structs.h	/^    int		keepmarks;		\/* TRUE when ":keepmarks" was used *\/$/;"	m	struct:__anon31
key	misc2.c	/^    int	    key;	\/* Special key code or ascii value *\/$/;"	m	struct:key_name_entry	file:
key	netbeans.c	/^    int		     key;$/;"	m	struct:keyqueue	file:
keyHead	netbeans.c	/^static keyQ_T keyHead; \/* dummy node, header for circular queue *\/$/;"	v	file:
keyQ_T	netbeans.c	/^typedef struct keyqueue keyQ_T;$/;"	t	typeref:struct:keyqueue	file:
key_event	gui_beval.c	/^key_event(BalloonEval *beval, unsigned keyval, int is_keypress)$/;"	f	file:
key_extra	keymap.h	/^enum key_extra$/;"	g
key_name_entry	misc2.c	/^static struct key_name_entry$/;"	s	file:
key_names	term.c	/^static char *(key_names[]) =$/;"	v	file:
key_names_table	misc2.c	/^} key_names_table[] =$/;"	v	typeref:struct:key_name_entry	file:
key_press_event_queue	mbyte.c	/^static GSList *key_press_event_queue = NULL;$/;"	v	file:
key_sym	gui_amiga.c	/^    unsigned int  key_sym;$/;"	m	struct:__anon25	file:
keyentry	structs.h	/^struct keyentry$/;"	s
keyentry_T	structs.h	/^typedef struct keyentry keyentry_T;$/;"	t	typeref:struct:keyentry
keymap_init	digraph.c	/^keymap_init()$/;"	f
keymap_unload	digraph.c	/^keymap_unload()$/;"	f	file:
keyqueue	netbeans.c	/^struct keyqueue$/;"	s	file:
keys	misc2.c	/^static ulg keys[3]; \/* keys defining the pseudo-random sequence *\/$/;"	v	file:
keyword	structs.h	/^    char_u	keyword[1];	\/* actually longer *\/$/;"	m	struct:keyentry
km_startsel	globals.h	/^EXTERN int	km_startsel INIT(= FALSE);$/;"	v
km_stopsel	globals.h	/^EXTERN int	km_stopsel INIT(= FALSE);$/;"	v
kmap_T	digraph.c	/^} kmap_T;$/;"	t	typeref:struct:__anon20	file:
kprintf	gui_amiga.c	132;"	d	file:
ksmd_str	term.c	/^static char ksmd_str[20];$/;"	v	file:
ksme_str	term.c	/^static char ksme_str[20];$/;"	v	file:
ksmr_str	term.c	/^static char ksmr_str[20];$/;"	v	file:
l_vars	eval.c	/^    garray_T	l_vars;		\/* local function variables *\/$/;"	m	struct:funccall	file:
label	structs.h	/^    GtkWidget   *label;		    \/* Used by "set wak=" code. *\/$/;"	m	struct:VimMenu
lalloc	misc2.c	/^lalloc(size, message)$/;"	f
lalloc_clear	misc2.c	/^lalloc_clear(size, message)$/;"	f
langmap_init	option.c	/^langmap_init()$/;"	f	file:
langmap_mapchar	globals.h	/^EXTERN char_u	langmap_mapchar[256];	\/* mapping for language keys *\/$/;"	v
langmap_set	option.c	/^langmap_set()$/;"	f	file:
last	fileio.c	/^    char	    last;		\/* last command in list *\/$/;"	m	struct:AutoCmd	file:
last	fileio.c	/^    char	    last;		\/* last pattern for apply_autocmds() *\/$/;"	m	struct:AutoPat	file:
last	mbyte.c	/^    unsigned short last;$/;"	m	struct:interval	file:
last_breakp	ex_cmds2.c	/^static int last_breakp = 0;	\/* nr of last defined breakpoint *\/$/;"	v	file:
last_cmdline	globals.h	/^EXTERN char_u	*last_cmdline INIT(= NULL); \/* last command line (for ":) *\/$/;"	v
last_event	fileio.c	/^static EVENT_T	last_event;$/;"	v	file:
last_group	fileio.c	/^static int	last_group;$/;"	v	file:
last_idx	search.c	/^static int last_idx = 0;	\/* index in spats[] for RE_LAST *\/$/;"	v	file:
last_insert	edit.c	/^static char_u	*last_insert = NULL;	\/* the text of the previous insert,$/;"	v	file:
last_insert_skip	edit.c	/^static int	last_insert_skip; \/* nr of chars in front of previous insert *\/$/;"	v	file:
last_maptick	ex_getln.c	/^static int	last_maptick = -1;	\/* last seen maptick *\/$/;"	v	file:
last_matchgroup	syntax.c	/^static int  last_matchgroup;$/;"	v	file:
last_msg_hist	message.c	/^static struct msg_hist *last_msg_hist = NULL;$/;"	v	typeref:struct:msg_hist	file:
last_pat_prog	search.c	/^last_pat_prog(regmatch)$/;"	f
last_recorded_len	getchar.c	/^static int	last_recorded_len = 0;	\/* number of last recorded chars *\/$/;"	v	file:
last_search_pat	search.c	/^last_search_pat()$/;"	f
last_sign_typenr	ex_cmds.c	/^static int	last_sign_typenr = MAX_TYPENR;	\/* is decremented *\/$/;"	v	file:
last_sourcing_lnum	message.c	/^static int	last_sourcing_lnum = 0;$/;"	v	file:
last_sourcing_name	message.c	/^static char_u   *last_sourcing_name = NULL;$/;"	v	file:
last_status	window.c	/^last_status(morewin)$/;"	f
last_status_rec	window.c	/^last_status_rec(fr, statusline)$/;"	f	file:
lastbuf	globals.h	/^EXTERN buf_T	*lastbuf INIT(= NULL);	\/* last buffer *\/$/;"	v
lasticon	buffer.c	/^static char_u *lasticon = NULL;$/;"	v	file:
lastline	eval.c	/^    var		lastline;	\/* "a:lastline" variable *\/$/;"	m	struct:funccall	file:
lasttitle	buffer.c	/^static char_u *lasttitle = NULL;$/;"	v	file:
lastwin	globals.h	/^EXTERN win_T	*lastwin;		\/* last window *\/$/;"	v
lastwin	globals.h	466;"	d
latin_char2bytes	mbyte.c	/^latin_char2bytes(c, buf)$/;"	f
latin_char2cells	mbyte.c	/^latin_char2cells(c)$/;"	f
latin_char2len	mbyte.c	/^latin_char2len(c)$/;"	f
latin_head_off	mbyte.c	/^latin_head_off(base, p)$/;"	f
latin_off2cells	mbyte.c	/^latin_off2cells(off)$/;"	f
latin_ptr2cells	mbyte.c	/^latin_ptr2cells(p)$/;"	f
latin_ptr2char	mbyte.c	/^latin_ptr2char(p)$/;"	f
latin_ptr2len_check	mbyte.c	/^latin_ptr2len_check(p)$/;"	f
layersBase	gui_amiga.c	/^struct LayersBase	*layersBase;$/;"	v	typeref:struct:LayersBase
lbr_chartabsize	charset.c	/^lbr_chartabsize(s, col)$/;"	f
lbr_chartabsize_adv	charset.c	/^lbr_chartabsize_adv(s, col)$/;"	f
lc_active	globals.h	/^EXTERN int lc_active INIT(= FALSE); \/* TRUE when lc_jump_env is valid. *\/$/;"	v
lc_jump_env	globals.h	/^EXTERN JMP_BUF lc_jump_env;	\/* argument to SETJMP() *\/$/;"	v
lc_signal	globals.h	/^EXTERN int lc_signal;		\/* catched signal number, 0 when no was signal$/;"	v
lcs_eol	globals.h	/^EXTERN int	lcs_eol INIT(= '$');$/;"	v
lcs_ext	globals.h	/^EXTERN int	lcs_ext INIT(= NUL);$/;"	v
lcs_prec	globals.h	/^EXTERN int	lcs_prec INIT(= NUL);$/;"	v
lcs_tab1	globals.h	/^EXTERN int	lcs_tab1 INIT(= NUL);$/;"	v
lcs_tab2	globals.h	/^EXTERN int	lcs_tab2 INIT(= NUL);$/;"	v
lcs_trail	globals.h	/^EXTERN int	lcs_trail INIT(= NUL);$/;"	v
lead_spaces	ex_cmds2.c	/^    int		lead_spaces;	    \/* remaining spaces for a TAB *\/$/;"	m	struct:__anon10	file:
leave_cleanup	ex_eval.c	/^leave_cleanup(csp)$/;"	f
left_sbar_x	gui.h	/^    int		left_sbar_x;	    \/* Calculated x coord for left scrollbar *\/$/;"	m	struct:Gui
leftcol_changed	misc2.c	/^leftcol_changed()$/;"	f
len	eval.c	/^    int		len;		\/* length of name *\/$/;"	m	struct:vimvar	file:
len	tag.c	/^    int		len;		\/* length of pat[] *\/$/;"	m	struct:__anon8	file:
len	term.c	/^    int	    len;	    \/* STRLEN(code) *\/$/;"	m	struct:termcode	file:
level	eval.c	/^    int		level;		\/* top nesting level of executed function *\/$/;"	m	struct:funccall	file:
level	ex_cmds2.c	/^    int		level;		\/* top nesting level of sourced file *\/$/;"	m	struct:source_cookie	file:
libcall_common	eval.c	/^libcall_common(argvars, retvar, type)$/;"	f	file:
limit_pos	syntax.c	/^limit_pos(pos, limit)$/;"	f	file:
limit_pos_zero	syntax.c	/^limit_pos_zero(pos, limit)$/;"	f	file:
line	ex_docmd.c	/^    char_u	*line;		\/* command line *\/$/;"	m	struct:__anon22	file:
line	search.c	/^    int		line;		\/* search has line offset *\/$/;"	m	struct:soffset	file:
line1	ex_cmds.h	/^    linenr_T	line1;		\/* the first line number *\/$/;"	m	struct:exarg
line2	ex_cmds.h	/^    linenr_T	line2;		\/* the second line number or count *\/$/;"	m	struct:exarg
lineFolded	fold.c	/^lineFolded(win, lnum)$/;"	f
line_breakcheck	misc1.c	/^line_breakcheck()$/;"	f
line_count	structs.h	/^    long	line_count;	\/* number of lines from op_start to op_end$/;"	m	struct:oparg
line_count_info	ops.c	/^line_count_info(line, wc, limit, eol_size)$/;"	f	file:
lineclear	screen.c	/^lineclear(off, width)$/;"	f	file:
linecopy	screen.c	/^linecopy(to, from, wp)$/;"	f	file:
lineempty	macros.h	46;"	d
lineinvalid	screen.c	/^lineinvalid(off, width)$/;"	f	file:
linelen	ex_cmds.c	/^linelen(has_tab)$/;"	f	file:
linenr	eval.c	/^    int		linenr;		\/* next line to be executed *\/$/;"	m	struct:funccall	file:
linenr_T	structs.h	/^typedef long		linenr_T;$/;"	t
linenr_T	vim.h	/^typedef long	    linenr_T;		\/* line number type *\/$/;"	t
lineoff_T	move.c	/^} lineoff_T;$/;"	t	typeref:struct:__anon46	file:
lines	eval.c	/^    garray_T	lines;		\/* function lines *\/$/;"	m	struct:ufunc	file:
lines_gap	ex_docmd.c	/^    garray_T	*lines_gap;		\/* growarray with line info *\/$/;"	m	struct:while_cookie	file:
lines_left	globals.h	/^EXTERN int	lines_left INIT(= -1);	    \/* lines left for listing *\/$/;"	v
lines_per_page	structs.h	/^    int		lines_per_page;$/;"	m	struct:__anon45
linetabsize	charset.c	/^linetabsize(s)$/;"	f
linewhite	search.c	/^linewhite(lnum)$/;"	f
lisp_match	misc1.c	/^lisp_match(p)$/;"	f	file:
list_func_head	eval.c	/^list_func_head(fp, indent)$/;"	f	file:
list_one_var	eval.c	/^list_one_var(v, prefix)$/;"	f	file:
list_one_var_a	eval.c	/^list_one_var_a(prefix, name, type, string)$/;"	f	file:
list_version	version.c	/^list_version()$/;"	f
list_vim_var	eval.c	/^list_vim_var(i)$/;"	f	file:
listcmd_busy	globals.h	/^EXTERN int	listcmd_busy INIT(= FALSE); \/* set when :argdo, :windo or$/;"	v
listdigraphs	digraph.c	/^listdigraphs()$/;"	f
lnum	ex_docmd.c	/^    linenr_T	lnum;		\/* sourcing_lnum of the line *\/$/;"	m	struct:__anon22	file:
lnum	fold.c	/^    linenr_T	lnum;		\/* current line number *\/$/;"	m	struct:__anon15	file:
lnum	move.c	/^    linenr_T	    lnum;	\/* line number *\/$/;"	m	struct:__anon46	file:
lnum	screen.c	/^    linenr_T	lnum;	\/* the line to search for a match *\/$/;"	m	struct:__anon1	file:
lnum	search.c	/^    linenr_T	lnum;		\/* Line we were up to in file *\/$/;"	m	struct:SearchedFile	file:
lnum	structs.h	/^    linenr_T	lnum;		\/* line number which has this sign *\/$/;"	m	struct:signlist
lnum	structs.h	/^    linenr_T	lnum;	\/* line number *\/$/;"	m	struct:__anon28
lnum	structs.h	/^    linenr_T	lnum;	\/* line number *\/$/;"	m	struct:__anon29
lnum_save	fold.c	/^    linenr_T	lnum_save;	\/* line nr used by foldUpdateIEMSRecurse() *\/$/;"	m	struct:__anon15	file:
load_colors	syntax.c	/^load_colors(p)$/;"	f
load_current_state	syntax.c	/^load_current_state(from)$/;"	f	file:
lock2name	os_amiga.c	/^lock2name(lock, buf, len)$/;"	f	file:
lockmarks	structs.h	/^    int		lockmarks;		\/* TRUE when ":lockmarks" was used *\/$/;"	m	struct:__anon31
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG;$/;"	v
longVersion	version.c	/^char	*longVersion = VIM_VERSION_LONG_DATE __DATE__ " " __TIME__ ")";$/;"	v
longVersion	version.c	/^char	longVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)$/;"	v
long_to_char	memline.c	/^long_to_char(n, s)$/;"	f	file:
long_u	vim.h	/^typedef unsigned __int64 long_u;$/;"	t
long_u	vim.h	/^typedef unsigned long	long_u;$/;"	t
longest_lnum	gui.c	/^static linenr_T longest_lnum = 0;$/;"	v	file:
lookup	nbdebug.c	/^lookup($/;"	f	file:
loops	testdir/test49.vim	/^		    let loops = loops - 1$/;"	v
loops	testdir/test49.vim	/^		let loops = loops - 1$/;"	v
loops	testdir/test49.vim	/^	    let loops = -1$/;"	v
loops	testdir/test49.vim	/^	    let loops = loops - 1$/;"	v
loops	testdir/test49.vim	/^	let loops = loops - 1$/;"	v
loops	testdir/test49.vim	/^    let loops = 3$/;"	v
loops	testdir/test49.vim	/^    let loops = loops - 1$/;"	v
loops	testdir/test49.vim	/^let loops = 2$/;"	v
loops	testdir/test49.vim	/^let loops = 3$/;"	v
lowest_marked	memline.c	/^static linenr_T	lowest_marked = 0;$/;"	v	file:
lpos_T	structs.h	/^} lpos_T;$/;"	t	typeref:struct:__anon29
lrF_sub	farsi.c	/^lrF_sub(ibuf)$/;"	f
lrFswap	farsi.c	/^lrFswap(cmdbuf, len)$/;"	f
lrswap	farsi.c	/^lrswap(ibuf)$/;"	f
lrswapbuf	farsi.c	/^lrswapbuf(buf, len)$/;"	f	file:
lt	macros.h	22;"	d
lt	macros.h	34;"	d
ltoreq	macros.h	41;"	d
ltp	macros.h	27;"	d
ltp	macros.h	36;"	d
lvl	fold.c	/^    int		lvl;		\/* current level (-1 for undefined) *\/$/;"	m	struct:__anon15	file:
lvl_next	fold.c	/^    int		lvl_next;	\/* level used for next line *\/$/;"	m	struct:__anon15	file:
m_block	structs.h	/^struct m_block$/;"	s
m_info	structs.h	/^struct m_info$/;"	s
m_keylen	structs.h	/^    int		m_keylen;	\/* strlen(m_keys) *\/$/;"	m	struct:mapblock
m_keys	structs.h	/^    char_u	*m_keys;	\/* mapped from *\/$/;"	m	struct:mapblock
m_mode	structs.h	/^    int		m_mode;		\/* valid mode *\/$/;"	m	struct:mapblock
m_next	structs.h	/^    mapblock_T	*m_next;	\/* next mapblock in list *\/$/;"	m	struct:mapblock
m_next	structs.h	/^    minfo_T	*m_next;	\/* pointer to next free chunk in the list *\/$/;"	m	struct:m_info
m_noremap	structs.h	/^    int		m_noremap;	\/* if non-zero no re-mapping for m_str *\/$/;"	m	struct:mapblock
m_silent	structs.h	/^    char	m_silent;	\/* <silent> used, don't echo commands *\/$/;"	m	struct:mapblock
m_size	structs.h	/^    long_u	m_size;		\/* size of the chunk (including m_info) *\/$/;"	m	struct:m_info
m_str	structs.h	/^    char_u	*m_str;		\/* mapped to *\/$/;"	m	struct:mapblock
mac_string_convert	mbyte.c	/^mac_string_convert(ptr, len, lenp, fail_on_error, from, to, unconvlenp)$/;"	f	file:
magic	search.c	/^    int		    magic;	\/* magicness of the pattern *\/$/;"	m	struct:spat	file:
main	xxd/xxd.c	/^main(argc, argv)$/;"	f
main_errors	main.c	/^static char *(main_errors[]) =$/;"	v	file:
main_loop	main.c	/^main_loop(cmdwin)$/;"	f
main_msg	main.c	/^main_msg(s)$/;"	f	file:
main_start_gui	main.c	/^main_start_gui()$/;"	f	file:
mainerr	main.c	/^mainerr(n, str)$/;"	f	file:
mainerr_arg_missing	main.c	/^mainerr_arg_missing(str)$/;"	f
mainwin	gui.h	/^    GtkWidget	*mainwin;	    \/* top level GTK window *\/$/;"	m	struct:Gui
mainwin_event_cb	gui_beval.c	/^mainwin_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)$/;"	f	file:
make_bom	fileio.c	/^make_bom(buf, name)$/;"	f	file:
make_connection	eval.c	/^make_connection()$/;"	f	file:
make_crc_tab	misc2.c	/^make_crc_tab()$/;"	f	file:
make_expanded_name	eval.c	/^make_expanded_name(in_start, expr_start, expr_end, in_end)$/;"	f	file:
make_extmatch	regexp.c	/^make_extmatch()$/;"	f	file:
make_filter_cmd	ex_cmds.c	/^make_filter_cmd(cmd, itmp, otmp)$/;"	f
make_percent_swname	memline.c	/^make_percent_swname(dir, name)$/;"	f	file:
make_snapshot	window.c	/^make_snapshot()$/;"	f	file:
make_snapshot_rec	window.c	/^make_snapshot_rec(fr, frp)$/;"	f	file:
make_version	version.c	/^make_version()$/;"	f
make_windows	window.c	/^make_windows(count, vertical)$/;"	f
makefoldset	option.c	/^makefoldset(fd)$/;"	f
makemap	getchar.c	/^makemap(fd, buf)$/;"	f
makeopens	ex_docmd.c	/^makeopens(fd, dirnow)$/;"	f	file:
makeset	option.c	/^makeset(fd, opt_flags, local_only)$/;"	f
makeswapname	memline.c	/^makeswapname(buf, dir_name)$/;"	f	file:
maketitle	buffer.c	/^maketitle()$/;"	f
map_clear	getchar.c	/^map_clear(cmdp, arg, forceit, abbr)$/;"	f
map_clear_int	getchar.c	/^map_clear_int(buf, mode, local, abbr)$/;"	f
map_free	getchar.c	/^map_free(mpp)$/;"	f	file:
map_to_exists	getchar.c	/^map_to_exists(str, modechars)$/;"	f
map_to_exists_mode	getchar.c	/^map_to_exists_mode(rhs, mode)$/;"	f
mapblock	structs.h	/^struct mapblock$/;"	s
mapblock_T	structs.h	/^typedef struct mapblock mapblock_T;$/;"	t	typeref:struct:mapblock
maphash	getchar.c	/^static mapblock_T	*(maphash[256]);$/;"	v	file:
maphash_valid	getchar.c	/^static int		maphash_valid = FALSE;$/;"	v	file:
mapped_ctrl_c	globals.h	/^EXTERN int	mapped_ctrl_c INIT(= FALSE); \/* CTRL-C is mapped *\/$/;"	v
mapsigntype	netbeans.c	/^mapsigntype(nbbuf_T *buf, int localsigntype)$/;"	f	file:
maptick	globals.h	/^EXTERN int	maptick INIT(= 0);	\/* tick for each non-mapped char *\/$/;"	v
mark	structs.h	/^    pos_T	mark;		\/* cursor position *\/$/;"	m	struct:filemark
mark_adjust	mark.c	/^mark_adjust(line1, line2, amount, amount_after)$/;"	f
mark_col_adjust	mark.c	/^mark_col_adjust(lnum, mincol, lnum_amount, col_amount)$/;"	f
mark_line	mark.c	/^mark_line(mp, lead_len)$/;"	f	file:
match	testdir/test49.vim	/^		    let match = MATCH(0, thrmsg, 'E106', "Unknown variable")$/;"	v
match	testdir/test49.vim	/^		    let match = MATCH(0, thrmsg, 'E108', "No such variable")$/;"	v
match_T	screen.c	/^} match_T;$/;"	t	typeref:struct:__anon1	file:
match_file_list	fileio.c	/^match_file_list(list, sfname, ffname)$/;"	f
match_file_pat	fileio.c	/^match_file_pat(pattern, fname, sfname, tail, allow_dirs)$/;"	f
match_hl	screen.c	/^static match_T match_hl;	\/* used for ":match" highlight matching *\/$/;"	v	file:
match_suffix	misc1.c	/^match_suffix(fname)$/;"	f
matched	search.c	/^    int		matched;	\/* Found a match in this file *\/$/;"	m	struct:SearchedFile	file:
matches	regexp.h	/^    char_u		*matches[NSUBEXP];$/;"	m	struct:__anon6
max	gui.h	/^    long	max;		\/* Number of lines in buffer *\/$/;"	m	struct:GuiScrollbar
max_topfill	move.c	/^max_topfill()$/;"	f	file:
may_get_selection	ops.c	/^may_get_selection(regname)$/;"	f
may_req_termresponse	term.c	/^may_req_termresponse()$/;"	f	file:
may_set_selection	ops.c	/^may_set_selection()$/;"	f	file:
may_start_select	normal.c	/^may_start_select(c)$/;"	f
may_sync_undo	getchar.c	/^may_sync_undo()$/;"	f	file:
mb_adjust_cursor	mbyte.c	/^mb_adjust_cursor()$/;"	f
mb_adjust_opend	ops.c	/^mb_adjust_opend(oap)$/;"	f	file:
mb_adjustpos	mbyte.c	/^mb_adjustpos(lp)$/;"	f
mb_bytelen_tab	globals.h	/^EXTERN char	mb_bytelen_tab[256];$/;"	v
mb_charlen	mbyte.c	/^mb_charlen(str)$/;"	f
mb_decompose	regexp.c	/^mb_decompose(c, c1, c2, c3)$/;"	f	file:
mb_fix_col	mbyte.c	/^mb_fix_col(col, row)$/;"	f
mb_get_class	mbyte.c	/^mb_get_class(p)$/;"	f
mb_info	structs.h	/^    minfo_T	mb_info;	\/* head of free chuck list for this block *\/$/;"	m	struct:m_block
mb_init	mbyte.c	/^mb_init()$/;"	f
mb_lefthalve	mbyte.c	/^mb_lefthalve(row, col)$/;"	f
mb_next	structs.h	/^    mblock_T	*mb_next;	\/* pointer to next allocated block *\/$/;"	m	struct:m_block
mb_off_next	mbyte.c	/^mb_off_next(base, p)$/;"	f
mb_prevptr	mbyte.c	/^mb_prevptr(line, p)$/;"	f
mb_ptr2char_adv	mbyte.c	/^mb_ptr2char_adv(pp)$/;"	f
mb_replace_pop_ins	edit.c	/^mb_replace_pop_ins(cc)$/;"	f	file:
mb_size	structs.h	/^    size_t	mb_size;	\/* total size of all chunks in this block *\/$/;"	m	struct:m_block
mb_strnicmp	mbyte.c	/^mb_strnicmp(s1, s2, n)$/;"	f
mb_tail_off	mbyte.c	/^mb_tail_off(base, p)$/;"	f
mb_unescape	mbyte.c	/^mb_unescape(pp)$/;"	f
mblock_T	structs.h	/^typedef struct m_block mblock_T;$/;"	t	typeref:struct:m_block
mch_FullName	os_amiga.c	/^mch_FullName(fname, buf, len, force)$/;"	f
mch_access	macros.h	148;"	d
mch_access	macros.h	156;"	d
mch_avail_mem	os_amiga.c	/^mch_avail_mem(special)$/;"	f
mch_breakcheck	os_amiga.c	/^mch_breakcheck()$/;"	f
mch_call_shell	os_amiga.c	/^mch_call_shell(cmd, options)$/;"	f
mch_can_exe	os_amiga.c	/^mch_can_exe(name)$/;"	f
mch_can_restore_icon	os_amiga.c	/^mch_can_restore_icon()$/;"	f
mch_can_restore_title	os_amiga.c	/^mch_can_restore_title()$/;"	f
mch_char_avail	os_amiga.c	/^mch_char_avail()$/;"	f
mch_chdir	os_amiga.h	200;"	d
mch_check_win	os_amiga.c	/^mch_check_win(argc, argv)$/;"	f
mch_delay	os_amiga.c	/^mch_delay(msec, ignoreinput)$/;"	f
mch_dirname	os_amiga.c	/^mch_dirname(buf, len)$/;"	f
mch_early_init	os_amiga.c	/^mch_early_init()$/;"	f
mch_errmsg	message.c	/^mch_errmsg(str)$/;"	f
mch_errmsg	message.c	2199;"	d	file:
mch_errmsg	vim.h	1580;"	d
mch_exit	os_amiga.c	/^mch_exit(r)$/;"	f
mch_expandpath	misc1.c	/^mch_expandpath($/;"	f
mch_expandpath	os_amiga.c	/^mch_expandpath(gap, pat, flags)$/;"	f
mch_fopen	macros.h	150;"	d
mch_fopen	macros.h	159;"	d
mch_fstat	macros.h	151;"	d
mch_fstat	macros.h	161;"	d
mch_get_host_name	os_amiga.c	/^mch_get_host_name(s, len)$/;"	f
mch_get_pid	os_amiga.c	/^mch_get_pid()$/;"	f
mch_get_shellsize	os_amiga.c	/^mch_get_shellsize()$/;"	f
mch_get_user_name	os_amiga.c	/^mch_get_user_name(s, len)$/;"	f
mch_getenv	os_amiga.c	/^mch_getenv(var)$/;"	f
mch_getperm	os_amiga.c	/^mch_getperm(name)$/;"	f
mch_has_exp_wildcard	os_amiga.c	/^mch_has_exp_wildcard(p)$/;"	f
mch_has_wildcard	os_amiga.c	/^mch_has_wildcard(p)$/;"	f
mch_hide	os_amiga.c	/^mch_hide(name)$/;"	f
mch_inchar	os_amiga.c	/^mch_inchar(buf, maxlen, time, tb_change_cnt)$/;"	f
mch_init	os_amiga.c	/^mch_init()$/;"	f
mch_input_isatty	os_amiga.c	/^mch_input_isatty()$/;"	f
mch_isFullName	os_amiga.c	/^mch_isFullName(fname)$/;"	f
mch_isdir	os_amiga.c	/^mch_isdir(name)$/;"	f
mch_lstat	macros.h	162;"	d
mch_memmove	misc2.c	/^mch_memmove(dst_arg, src_arg, len)$/;"	f
mch_memmove	vim.h	1308;"	d
mch_mkdir	os_amiga.c	/^mch_mkdir(name)$/;"	f
mch_msg	message.c	/^mch_msg(str)$/;"	f
mch_msg	message.c	2202;"	d	file:
mch_msg	vim.h	1582;"	d
mch_new_shellsize	os_amiga.c	/^mch_new_shellsize()$/;"	f
mch_nodetype	os_amiga.c	/^mch_nodetype(name)$/;"	f
mch_open	macros.h	178;"	d
mch_open	macros.h	186;"	d
mch_open	macros.h	189;"	d
mch_open_rw	macros.h	196;"	d
mch_open_rw	macros.h	199;"	d
mch_open_rw	macros.h	201;"	d
mch_print_begin	ex_cmds2.c	/^mch_print_begin(psettings)$/;"	f
mch_print_begin_page	ex_cmds2.c	/^mch_print_begin_page(str)$/;"	f
mch_print_blank_page	ex_cmds2.c	/^mch_print_blank_page()$/;"	f
mch_print_cleanup	ex_cmds2.c	/^mch_print_cleanup()$/;"	f
mch_print_end	ex_cmds2.c	/^mch_print_end(psettings)$/;"	f
mch_print_end_page	ex_cmds2.c	/^mch_print_end_page()$/;"	f
mch_print_init	ex_cmds2.c	/^mch_print_init(psettings, jobname, forceit)$/;"	f
mch_print_set_bg	ex_cmds2.c	/^mch_print_set_bg(bgcol)$/;"	f
mch_print_set_fg	ex_cmds2.c	/^mch_print_set_fg(fgcol)$/;"	f
mch_print_set_font	ex_cmds2.c	/^mch_print_set_font(iBold, iItalic, iUnderline)$/;"	f
mch_print_start_line	ex_cmds2.c	/^mch_print_start_line(margin, page_line)$/;"	f
mch_print_text_out	ex_cmds2.c	/^mch_print_text_out(p, len)$/;"	f
mch_remove	os_amiga.h	198;"	d
mch_rename	os_amiga.h	199;"	d
mch_restore_title	os_amiga.c	/^mch_restore_title(which)$/;"	f
mch_screenmode	os_amiga.c	/^mch_screenmode(arg)$/;"	f
mch_set_shellsize	os_amiga.c	/^mch_set_shellsize()$/;"	f
mch_setenv	os_amiga.c	/^mch_setenv(var, value, x)$/;"	f
mch_setmouse	gui_amiga.c	/^mch_setmouse(int  on)$/;"	f
mch_setperm	os_amiga.c	/^mch_setperm(name, perm)$/;"	f
mch_settitle	os_amiga.c	/^mch_settitle(title, icon)$/;"	f
mch_settmode	os_amiga.c	/^mch_settmode(tmode)$/;"	f
mch_stat	macros.h	153;"	d
mch_stat	macros.h	164;"	d
mch_stat	macros.h	169;"	d
mch_stat	macros.h	171;"	d
mch_suspend	os_amiga.c	/^mch_suspend()$/;"	f
mch_write	os_amiga.c	/^mch_write(p, len)$/;"	f
mediumVersion	version.c	/^char	*mediumVersion = VIM_VERSION_MEDIUM;$/;"	v
mem_allocated	misc2.c	/^static long_u mem_allocated;$/;"	v	file:
mem_allocs	misc2.c	/^static long_u mem_allocs[MEM_SIZES];$/;"	v	file:
mem_freed	misc2.c	/^static long_u mem_freed;$/;"	v	file:
mem_frees	misc2.c	/^static long_u mem_frees[MEM_SIZES];$/;"	v	file:
mem_peak	misc2.c	/^static long_u mem_peak;$/;"	v	file:
mem_post_alloc	misc2.c	/^mem_post_alloc(pp, size)$/;"	f	file:
mem_pre_alloc_l	misc2.c	/^mem_pre_alloc_l(sizep)$/;"	f	file:
mem_pre_alloc_s	misc2.c	/^mem_pre_alloc_s(sizep)$/;"	f	file:
mem_pre_free	misc2.c	/^mem_pre_free(pp)$/;"	f	file:
mem_realloc	misc2.c	/^mem_realloc(ptr, size)$/;"	f
memfile	structs.h	/^struct memfile$/;"	s
memfile_T	structs.h	/^typedef struct memfile	    memfile_T;$/;"	t	typeref:struct:memfile
memline	structs.h	/^typedef struct memline$/;"	s
memline_T	structs.h	/^} memline_T;$/;"	t	typeref:struct:memline
menu	gui.h	/^    struct Menu	  *menu;		\/* a pointer to the first menu *\/$/;"	m	struct:Gui	typeref:struct:Gui::Menu
menuItem	gui_amiga.h	/^    struct MenuItem menuItem;$/;"	m	struct:MyMenuItem	typeref:struct:MyMenuItem::MenuItem
menuItem	gui_amiga.h	/^    struct MenuItem menuItem;$/;"	m	union:myMenuItemUnion	typeref:struct:myMenuItemUnion::MenuItem
menuItemPtr	structs.h	/^    struct MenuItem *menuItemPtr;$/;"	m	struct:VimMenu	typeref:struct:VimMenu::MenuItem
menuPtr	structs.h	/^    struct Menu	    *menuPtr;$/;"	m	struct:VimMenu	typeref:struct:VimMenu::Menu
menu_bg_pixel	gui.h	/^    guicolor_T	menu_bg_pixel;		\/* Same in Pixel format *\/$/;"	m	struct:Gui
menu_def_bg_pixel	gui.h	/^    guicolor_T	menu_def_bg_pixel;  \/* Default menu background *\/$/;"	m	struct:Gui
menu_def_fg_pixel	gui.h	/^    guicolor_T	menu_def_fg_pixel;  \/* Default menu foreground *\/$/;"	m	struct:Gui
menu_fg_pixel	gui.h	/^    guicolor_T	menu_fg_pixel;		\/* Same in Pixel format *\/$/;"	m	struct:Gui
menu_font	gui.h	/^    GuiFont	menu_font;	    \/* menu item font *\/$/;"	m	struct:Gui
menu_fontset	gui.h	/^    GuiFontset	menu_fontset;	    \/* set of fonts for multi-byte chars *\/$/;"	m	struct:Gui
menu_handle	structs.h	/^    MenuHandle	menu_handle;$/;"	m	struct:VimMenu
menu_height	gui.h	/^    int		menu_height;	    \/* Height of the menu bar *\/$/;"	m	struct:Gui
menu_height_fixed	gui.h	/^    char	menu_height_fixed;  \/* TRUE if menu height fixed *\/$/;"	m	struct:Gui
menu_id	structs.h	/^    short	menu_id;	    \/* the menu id to which this item belong *\/$/;"	m	struct:VimMenu
menu_is_active	gui.h	/^    char	menu_is_active;	    \/* TRUE if menu is present *\/$/;"	m	struct:Gui
menu_is_child_of_popup	menu.c	/^menu_is_child_of_popup(menu)$/;"	f
menu_is_hidden	menu.c	/^menu_is_hidden(name)$/;"	f	file:
menu_is_menubar	menu.c	/^menu_is_menubar(name)$/;"	f
menu_is_popup	menu.c	/^menu_is_popup(name)$/;"	f
menu_is_separator	menu.c	/^menu_is_separator(name)$/;"	f
menu_is_tearoff	menu.c	/^menu_is_tearoff(name)$/;"	f	file:
menu_is_toolbar	menu.c	/^menu_is_toolbar(name)$/;"	f
menu_mode_chars	menu.c	/^static char_u	menu_mode_chars[] = {'n', 'v', 'o', 'i', 'c', 't'};$/;"	v	file:
menu_nable_recurse	menu.c	/^menu_nable_recurse(menu, name, modes, enable)$/;"	f	file:
menu_name_equal	menu.c	/^menu_name_equal(name, menu)$/;"	f	file:
menu_name_skip	menu.c	/^menu_name_skip(name)$/;"	f
menu_namecmp	menu.c	/^menu_namecmp(name, mname)$/;"	f	file:
menu_skip_part	menu.c	/^menu_skip_part(p)$/;"	f	file:
menu_text	menu.c	/^menu_text(str, mnemonic, actext)$/;"	f	file:
menu_width	gui.h	/^    int		menu_width;	    \/* Width of the menu bar *\/$/;"	m	struct:Gui
menubar	gui.h	/^    GtkWidget	*menubar;	    \/* menubar *\/$/;"	m	struct:Gui
menubar_h	gui.h	/^    GtkWidget	*menubar_h;	    \/* menubar handle *\/$/;"	m	struct:Gui
menutrans_T	menu.c	/^} menutrans_T;$/;"	t	typeref:struct:__anon47	file:
menutrans_ga	menu.c	/^static garray_T menutrans_ga = {0, 0, 0, 0, NULL};$/;"	v	file:
menutrans_lookup	menu.c	/^menutrans_lookup(name, len)$/;"	f	file:
messageFromNetbeansW32	netbeans.c	/^messageFromNetbeansW32()$/;"	f
messages	structs.h	/^    struct msglist	*messages;	\/* message(s) causing error exception *\/$/;"	m	struct:vim_exception	typeref:struct:vim_exception::msglist
messages	testdir/test49.vim	/^    let messages = g:messages . "D"$/;"	v
messages	testdir/test49.vim	/^let messages = ""$/;"	v
messaging	screen.c	/^messaging()$/;"	f
mf_alloc_bhdr	memfile.c	/^mf_alloc_bhdr(mfp, page_count)$/;"	f	file:
mf_blocknr_max	structs.h	/^    blocknr_T	mf_blocknr_max;		\/* highest positive block number + 1*\/$/;"	m	struct:memfile
mf_blocknr_min	structs.h	/^    blocknr_T	mf_blocknr_min;		\/* lowest negative block number - 1 *\/$/;"	m	struct:memfile
mf_close	memfile.c	/^mf_close(mfp, del_file)$/;"	f
mf_close_file	memfile.c	/^mf_close_file(buf, getlines)$/;"	f
mf_dirty	structs.h	/^    int		mf_dirty;		\/* TRUE if there are dirty blocks *\/$/;"	m	struct:memfile
mf_do_open	memfile.c	/^mf_do_open(mfp, fname, flags)$/;"	f	file:
mf_fd	structs.h	/^    int		mf_fd;			\/* file descriptor *\/$/;"	m	struct:memfile
mf_ffname	structs.h	/^    char_u	*mf_ffname;		\/* idem, full path *\/$/;"	m	struct:memfile
mf_find_hash	memfile.c	/^mf_find_hash(mfp, nr)$/;"	f	file:
mf_fname	structs.h	/^    char_u	*mf_fname;		\/* name of the file *\/$/;"	m	struct:memfile
mf_free	memfile.c	/^mf_free(mfp, hp)$/;"	f
mf_free_bhdr	memfile.c	/^mf_free_bhdr(hp)$/;"	f	file:
mf_free_first	structs.h	/^    bhdr_T	*mf_free_first;		\/* first block_hdr in free list *\/$/;"	m	struct:memfile
mf_fullname	memfile.c	/^mf_fullname(mfp)$/;"	f
mf_get	memfile.c	/^mf_get(mfp, nr, page_count)$/;"	f
mf_hash	structs.h	/^    bhdr_T	*mf_hash[MEMHASHSIZE];	\/* array of hash lists *\/$/;"	m	struct:memfile
mf_infile_count	structs.h	/^    blocknr_T	mf_infile_count;	\/* number of pages in the file *\/$/;"	m	struct:memfile
mf_ins_free	memfile.c	/^mf_ins_free(mfp, hp)$/;"	f	file:
mf_ins_hash	memfile.c	/^mf_ins_hash(mfp, hp)$/;"	f	file:
mf_ins_used	memfile.c	/^mf_ins_used(mfp, hp)$/;"	f	file:
mf_need_trans	memfile.c	/^mf_need_trans(mfp)$/;"	f
mf_neg_count	structs.h	/^    blocknr_T	mf_neg_count;		\/* number of negative blocks numbers *\/$/;"	m	struct:memfile
mf_new	memfile.c	/^mf_new(mfp, negative, page_count)$/;"	f
mf_new_page_size	memfile.c	/^mf_new_page_size(mfp, new_size)$/;"	f
mf_open	memfile.c	/^mf_open(fname, flags)$/;"	f
mf_open_file	memfile.c	/^mf_open_file(mfp, fname)$/;"	f
mf_page_size	structs.h	/^    unsigned	mf_page_size;		\/* number of bytes in a page *\/$/;"	m	struct:memfile
mf_put	memfile.c	/^mf_put(mfp, hp, dirty, infile)$/;"	f
mf_read	memfile.c	/^mf_read(mfp, hp)$/;"	f	file:
mf_release	memfile.c	/^mf_release(mfp, page_count)$/;"	f	file:
mf_release_all	memfile.c	/^mf_release_all()$/;"	f
mf_rem_free	memfile.c	/^mf_rem_free(mfp)$/;"	f	file:
mf_rem_hash	memfile.c	/^mf_rem_hash(mfp, hp)$/;"	f	file:
mf_rem_used	memfile.c	/^mf_rem_used(mfp, hp)$/;"	f	file:
mf_set_ffname	memfile.c	/^mf_set_ffname(mfp)$/;"	f
mf_sync	memfile.c	/^mf_sync(mfp, flags)$/;"	f
mf_trans	structs.h	/^    NR_TRANS	*mf_trans[MEMHASHSIZE];	\/* array of trans lists *\/$/;"	m	struct:memfile
mf_trans_add	memfile.c	/^mf_trans_add(mfp, hp)$/;"	f	file:
mf_trans_del	memfile.c	/^mf_trans_del(mfp, old_nr)$/;"	f
mf_used_count	structs.h	/^    unsigned	mf_used_count;		\/* number of pages in used list *\/$/;"	m	struct:memfile
mf_used_count_max	structs.h	/^    unsigned	mf_used_count_max;	\/* maximum number of pages in memory *\/$/;"	m	struct:memfile
mf_used_first	structs.h	/^    bhdr_T	*mf_used_first;		\/* mru block_hdr in used list *\/$/;"	m	struct:memfile
mf_used_last	structs.h	/^    bhdr_T	*mf_used_last;		\/* lru block_hdr in used list *\/$/;"	m	struct:memfile
mf_write	memfile.c	/^mf_write(mfp, hp)$/;"	f	file:
mfd_save	testdir/test49.vim	/^	let mfd_save = &mfd$/;"	v
min_rows	window.c	/^min_rows()$/;"	f
minfo_T	structs.h	/^typedef struct m_info minfo_T;$/;"	t	typeref:struct:m_info
mksession_nl	ex_docmd.c	/^static int mksession_nl = FALSE;    \/* use NL only in put_eol() *\/$/;"	v	file:
ml_add_stack	memline.c	/^ml_add_stack(buf)$/;"	f	file:
ml_append	memline.c	/^ml_append(lnum, line, len, newfile)$/;"	f
ml_append_int	memline.c	/^ml_append_int(buf, lnum, line, len, newfile, mark)$/;"	f	file:
ml_chunksize	structs.h	/^    chunksize_T *ml_chunksize;$/;"	m	struct:memline
ml_chunksize	structs.h	/^typedef struct ml_chunksize$/;"	s
ml_clearmarked	memline.c	/^ml_clearmarked()$/;"	f
ml_close	memline.c	/^ml_close(buf, del_file)$/;"	f
ml_close_all	memline.c	/^ml_close_all(del_file)$/;"	f
ml_close_notmod	memline.c	/^ml_close_notmod()$/;"	f
ml_delete	memline.c	/^ml_delete(lnum, message)$/;"	f
ml_delete_int	memline.c	/^ml_delete_int(buf, lnum, message)$/;"	f	file:
ml_find_line	memline.c	/^ml_find_line(buf, lnum, action)$/;"	f	file:
ml_find_line_or_offset	memline.c	/^ml_find_line_or_offset(buf, line, offp)$/;"	f
ml_firstmarked	memline.c	/^ml_firstmarked()$/;"	f
ml_flags	structs.h	/^    int		ml_flags;$/;"	m	struct:memline
ml_flush_line	memline.c	/^ml_flush_line(buf)$/;"	f	file:
ml_get	memline.c	/^ml_get(lnum)$/;"	f
ml_get_buf	memline.c	/^ml_get_buf(buf, lnum, will_change)$/;"	f
ml_get_curline	memline.c	/^ml_get_curline()$/;"	f
ml_get_cursor	memline.c	/^ml_get_cursor()$/;"	f
ml_get_pos	memline.c	/^ml_get_pos(pos)$/;"	f
ml_line_alloced	memline.c	/^ml_line_alloced()$/;"	f
ml_line_count	structs.h	/^    linenr_T	ml_line_count;	\/* number of lines in the buffer *\/$/;"	m	struct:memline
ml_line_lnum	structs.h	/^    linenr_T	ml_line_lnum;	\/* line number of cached line, 0 if not valid *\/$/;"	m	struct:memline
ml_line_ptr	structs.h	/^    char_u	*ml_line_ptr;	\/* pointer to cached line *\/$/;"	m	struct:memline
ml_lineadd	memline.c	/^ml_lineadd(buf, count)$/;"	f	file:
ml_locked	structs.h	/^    bhdr_T	*ml_locked;	\/* block used by last ml_get *\/$/;"	m	struct:memline
ml_locked_high	structs.h	/^    linenr_T	ml_locked_high;	\/* last line in ml_locked *\/$/;"	m	struct:memline
ml_locked_lineadd	structs.h	/^    int		ml_locked_lineadd;  \/* number of lines inserted in ml_locked *\/$/;"	m	struct:memline
ml_locked_low	structs.h	/^    linenr_T	ml_locked_low;	\/* first line in ml_locked *\/$/;"	m	struct:memline
ml_mfp	structs.h	/^    memfile_T	*ml_mfp;	\/* pointer to associated memfile *\/$/;"	m	struct:memline
ml_new_data	memline.c	/^ml_new_data(mfp, negative, page_count)$/;"	f	file:
ml_new_ptr	memline.c	/^ml_new_ptr(mfp)$/;"	f	file:
ml_numchunks	structs.h	/^    int		ml_numchunks;$/;"	m	struct:memline
ml_open	memline.c	/^ml_open()$/;"	f
ml_open_file	memline.c	/^ml_open_file(buf)$/;"	f
ml_open_files	memline.c	/^ml_open_files()$/;"	f
ml_preserve	memline.c	/^ml_preserve(buf, message)$/;"	f
ml_recover	memline.c	/^ml_recover()$/;"	f
ml_replace	memline.c	/^ml_replace(lnum, line, copy)$/;"	f
ml_setdirty	memline.c	/^ml_setdirty(buf, flag)$/;"	f
ml_setmarked	memline.c	/^ml_setmarked(lnum)$/;"	f
ml_setname	memline.c	/^ml_setname(buf)$/;"	f
ml_stack	structs.h	/^    infoptr_T	*ml_stack;	\/* stack of pointer blocks (array of IPTRs) *\/$/;"	m	struct:memline
ml_stack_size	structs.h	/^    int		ml_stack_size;	\/* total number of entries in ml_stack *\/$/;"	m	struct:memline
ml_stack_top	structs.h	/^    int		ml_stack_top;	\/* current top if ml_stack *\/$/;"	m	struct:memline
ml_sync_all	memline.c	/^ml_sync_all(check_file, check_char)$/;"	f
ml_timestamp	memline.c	/^ml_timestamp(buf)$/;"	f
ml_updatechunk	memline.c	/^ml_updatechunk(buf, line, len, updtype)$/;"	f	file:
ml_usedchunks	structs.h	/^    int		ml_usedchunks;$/;"	m	struct:memline
mlcs_numlines	structs.h	/^    int		mlcs_numlines;$/;"	m	struct:ml_chunksize
mlcs_totalsize	structs.h	/^    long	mlcs_totalsize;$/;"	m	struct:ml_chunksize
mnemonic	structs.h	/^    int		mnemonic;	    \/* mnemonic key (after '&') *\/$/;"	m	struct:VimMenu
mod_flag	misc2.c	/^    short	mod_flag;	\/* Bit(s) for particular key modifier *\/$/;"	m	struct:modmasktable	file:
mod_mask	globals.h	/^EXTERN int	mod_mask INIT(= 0x0);		\/* current key modifiers *\/$/;"	v
mod_mask	misc2.c	/^    short	mod_mask;	\/* Bit-mask for particular key modifier *\/$/;"	m	struct:modmasktable	file:
mod_mask_table	misc2.c	/^} mod_mask_table[] =$/;"	v	typeref:struct:modmasktable	file:
mode	getchar.c	/^    int		mode;$/;"	m	struct:initmap	file:
mode	vim.h	/^    short_u	mode;		\/* Select by char, word, or line. *\/$/;"	m	struct:VimClipboard
modec	structs.h	/^    int		modec;$/;"	m	struct:__anon45
modes	structs.h	/^    int		modes;		    \/* Which modes is this menu visible for? *\/$/;"	m	struct:VimMenu
modified	netbeans.c	/^    unsigned int	 modified:1;$/;"	m	struct:nbbuf_struct	file:
modified_was_set	globals.h	/^EXTERN int	modified_was_set;		\/* did ":set modified" *\/$/;"	v
modifier_keys_table	misc2.c	/^static char_u modifier_keys_table[] =$/;"	v	file:
modify_fname	eval.c	/^modify_fname(src, usedlen, fnamep, bufp, fnamelen)$/;"	f
modmasktable	misc2.c	/^static struct modmasktable$/;"	s	file:
modname	fileio.c	/^modname(fname, ext, prepend_dot)$/;"	f
more_back	globals.h	/^EXTERN int	more_back INIT(= 0);	    \/* 'b' or 'u' at "--more--" msg *\/$/;"	v
more_back_used	globals.h	/^EXTERN int	more_back_used INIT(= FALSE); \/* using more_back *\/$/;"	v
moreenv	misc2.c	/^moreenv()$/;"	f	file:
motion_force	structs.h	/^    int		motion_force;	\/* force motion type: 'v', 'V' or CTRL-V *\/$/;"	m	struct:oparg
motion_type	structs.h	/^    int		motion_type;	\/* type of the current cursor motion *\/$/;"	m	struct:oparg
mouse_col	globals.h	/^EXTERN int	mouse_col;$/;"	v
mouse_comp_pos	ui.c	/^mouse_comp_pos(win, rowp, colp, lnump)$/;"	f
mouse_dragging	globals.h	/^EXTERN int	mouse_dragging INIT(= 0);	\/* extending Visual area with$/;"	v
mouse_find_win	ui.c	/^mouse_find_win(rowp, colp)$/;"	f
mouse_has	term.c	/^mouse_has(c)$/;"	f
mouse_model_popup	term.c	/^mouse_model_popup()$/;"	f
mouse_past_bottom	globals.h	/^EXTERN int	mouse_past_bottom INIT(= FALSE);\/* mouse below last line *\/$/;"	v
mouse_past_eol	globals.h	/^EXTERN int	mouse_past_eol INIT(= FALSE);	\/* mouse right of line *\/$/;"	v
mouse_row	globals.h	/^EXTERN int	mouse_row;$/;"	v
mouse_table	misc2.c	/^} mouse_table[] =$/;"	v	typeref:struct:mousetable	file:
mousetable	misc2.c	/^static struct mousetable$/;"	s	file:
move_lines	fileio.c	/^move_lines(frombuf, tobuf)$/;"	f	file:
movechangelist	mark.c	/^movechangelist(count)$/;"	f
movemark	mark.c	/^movemark(count)$/;"	f
movetail	tag.c	3192;"	d	file:
mr_pattern	search.c	/^static char_u	    *mr_pattern = NULL;	\/* pattern used by search_regcomp() *\/$/;"	v	file:
mr_pattern_alloced	search.c	/^static int	    mr_pattern_alloced = FALSE; \/* mr_pattern was allocated *\/$/;"	v	file:
msg	gui_beval.h	/^    char_u		*msg;$/;"	m	struct:BalloonEvalStruct
msg	message.c	/^    char_u		*msg;$/;"	m	struct:msg_hist	file:
msg	message.c	/^msg(s)$/;"	f
msg	structs.h	/^    char_u		*msg;		\/* original message *\/$/;"	m	struct:msglist
msgCB	gui_beval.h	/^    void		(*msgCB)__ARGS((struct BalloonEvalStruct *, int));$/;"	m	struct:BalloonEvalStruct
msg_add_eol	fileio.c	/^msg_add_eol()$/;"	f	file:
msg_add_fileformat	fileio.c	/^msg_add_fileformat(eol_type)$/;"	f	file:
msg_add_fname	fileio.c	/^msg_add_fname(buf, fname)$/;"	f	file:
msg_add_lines	fileio.c	/^msg_add_lines(insert_space, lnum, nchars)$/;"	f	file:
msg_advance	message.c	/^msg_advance(col)$/;"	f
msg_attr	message.c	/^msg_attr(s, attr)$/;"	f
msg_attr_keep	message.c	/^msg_attr_keep(s, attr, keep)$/;"	f
msg_buf	globals.h	/^EXTERN char_u	msg_buf[MSG_BUF_LEN];	\/* small buffer for messages *\/$/;"	v
msg_check	message.c	/^msg_check()$/;"	f
msg_check_screen	message.c	/^msg_check_screen()$/;"	f	file:
msg_clr_cmdline	message.c	/^msg_clr_cmdline()$/;"	f
msg_clr_eos	message.c	/^msg_clr_eos()$/;"	f
msg_clr_eos_force	message.c	/^msg_clr_eos_force()$/;"	f
msg_col	globals.h	/^EXTERN int	msg_col;$/;"	v
msg_didany	globals.h	/^EXTERN int	msg_didany INIT(= FALSE);   \/* msg_outstr() was used at all *\/$/;"	v
msg_didout	globals.h	/^EXTERN int	msg_didout INIT(= FALSE);   \/* msg_outstr() was used in line *\/$/;"	v
msg_end	message.c	/^msg_end()$/;"	f
msg_end_prompt	message.c	/^msg_end_prompt()$/;"	f	file:
msg_hist	message.c	/^struct msg_hist$/;"	s	file:
msg_hist_len	message.c	/^static int msg_hist_len = 0;$/;"	v	file:
msg_hist_off	message.c	/^static int msg_hist_off = FALSE;	\/* don't add messages to history *\/$/;"	v	file:
msg_home_replace	message.c	/^msg_home_replace(fname)$/;"	f
msg_home_replace_attr	message.c	/^msg_home_replace_attr(fname, attr)$/;"	f	file:
msg_home_replace_hl	message.c	/^msg_home_replace_hl(fname)$/;"	f
msg_list	globals.h	/^EXTERN struct msglist **msg_list INIT(= NULL);$/;"	v	typeref:struct:
msg_make	message.c	/^msg_make(arg)$/;"	f
msg_may_trunc	message.c	/^msg_may_trunc(force, s)$/;"	f
msg_moremsg	message.c	/^msg_moremsg(full)$/;"	f
msg_no_more	globals.h	/^EXTERN int	msg_no_more INIT(= FALSE);  \/* don't use more prompt, truncate$/;"	v
msg_nowait	globals.h	/^EXTERN int	msg_nowait INIT(= FALSE);   \/* don't wait for this msg *\/$/;"	v
msg_outnum	message.c	/^msg_outnum(n)$/;"	f
msg_outtrans	message.c	/^msg_outtrans(str)$/;"	f
msg_outtrans_attr	message.c	/^msg_outtrans_attr(str, attr)$/;"	f
msg_outtrans_len	message.c	/^msg_outtrans_len(str, len)$/;"	f
msg_outtrans_len_attr	message.c	/^msg_outtrans_len_attr(msgstr, len, attr)$/;"	f
msg_outtrans_one	message.c	/^msg_outtrans_one(p, attr)$/;"	f
msg_outtrans_special	message.c	/^msg_outtrans_special(strstart, from)$/;"	f
msg_pos_mode	screen.c	/^msg_pos_mode()$/;"	f	file:
msg_prt_line	message.c	/^msg_prt_line(s)$/;"	f
msg_putchar	message.c	/^msg_putchar(c)$/;"	f
msg_putchar_attr	message.c	/^msg_putchar_attr(c, attr)$/;"	f
msg_puts	message.c	/^msg_puts(s)$/;"	f
msg_puts_attr	message.c	/^msg_puts_attr(s, attr)$/;"	f
msg_puts_attr_len	message.c	/^msg_puts_attr_len(str, maxlen, attr)$/;"	f	file:
msg_puts_long	message.c	/^msg_puts_long(longstr)$/;"	f
msg_puts_long_attr	message.c	/^msg_puts_long_attr(longstr, attr)$/;"	f
msg_puts_long_len_attr	message.c	/^msg_puts_long_len_attr(longstr, len, attr)$/;"	f
msg_puts_title	message.c	/^msg_puts_title(s)$/;"	f
msg_row	globals.h	/^EXTERN int	msg_row;$/;"	v
msg_screen_putchar	message.c	/^msg_screen_putchar(c, attr)$/;"	f	file:
msg_scroll	globals.h	/^EXTERN int	msg_scroll INIT(= FALSE);   \/* msg_start() will scroll *\/$/;"	v
msg_scrolled	globals.h	/^EXTERN int	msg_scrolled;	\/* Number of screen lines that windows have$/;"	v
msg_scrolled_ign	globals.h	/^EXTERN int	msg_scrolled_ign INIT(= FALSE);$/;"	v
msg_show_console_dialog	message.c	/^msg_show_console_dialog(message, buttons, dfltbutton)$/;"	f	file:
msg_silent	globals.h	/^EXTERN int	msg_silent INIT(= 0);	\/* don't print messages *\/$/;"	v
msg_start	message.c	/^msg_start()$/;"	f
msg_starthere	message.c	/^msg_starthere()$/;"	f
msg_str	misc2.c	/^msg_str(s, arg)$/;"	f
msg_strtrunc	message.c	/^msg_strtrunc(s)$/;"	f
msg_trunc_attr	message.c	/^msg_trunc_attr(s, force, attr)$/;"	f
msg_use_printf	message.c	/^msg_use_printf()$/;"	f
msgfile	testdir/test49.vim	/^let msgfile = tempname()$/;"	v
msglist	structs.h	/^struct msglist$/;"	s
msgmore	misc1.c	/^msgmore(n)$/;"	f
mshape	structs.h	/^    int		mshape;		\/* one of the MSHAPE defines *\/$/;"	m	struct:cursor_entry
mshape_names	misc2.c	/^static char * mshape_names[] =$/;"	v	file:
mt_names	tag.c	/^static char	*mt_names[MT_COUNT\/2] =$/;"	v	file:
must_redraw	globals.h	/^EXTERN int	must_redraw INIT(= 0);	    \/* type of redraw necessary *\/$/;"	v
myMenuItem	gui_amiga.h	/^    struct MyMenuItem myMenuItem;$/;"	m	union:myMenuItemUnion	typeref:struct:myMenuItemUnion::MyMenuItem
myMenuItemUnion	gui_amiga.h	/^union myMenuItemUnion {$/;"	u
my_iconv_open	mbyte.c	/^my_iconv_open(to, from)$/;"	f
n_collated_copies	structs.h	/^    int		n_collated_copies;$/;"	m	struct:__anon45
n_opencmd	normal.c	/^n_opencmd(cap)$/;"	f	file:
n_start_visual_mode	normal.c	/^n_start_visual_mode(c)$/;"	f	file:
n_swapchar	normal.c	/^n_swapchar(cap)$/;"	f	file:
n_uncollated_copies	structs.h	/^    int		n_uncollated_copies;$/;"	m	struct:__anon45
name	eval.c	/^    char	*name;		\/* name of variable, without v: *\/$/;"	m	struct:vimvar	file:
name	eval.c	/^    char_u	*name;		\/* name of function; can start with <SNR>123_$/;"	m	struct:ufunc	file:
name	ex_cmds2.c	/^    char	*name;$/;"	m	struct:prt_mediasize_S	file:
name	ex_cmds2.c	/^    char_u	*name;$/;"	m	struct:scriptstuff	file:
name	ex_cmds2.c	/^    char_u  name[64];$/;"	m	struct:prt_ps_resource_S	file:
name	ex_docmd.c	/^    char    *name;$/;"	m	struct:__anon23	file:
name	fileio.c	/^    char	*name;	\/* event name *\/$/;"	m	struct:event_name	file:
name	gui_amiga.c	/^	char	    *name;$/;"	m	struct:guicolor_tTable	file:
name	mbyte.c	/^{   char *name;		int canon;}$/;"	m	struct:__anon12	file:
name	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon11	file:
name	misc2.c	/^    char_u	name;		\/* Single letter name of modifier *\/$/;"	m	struct:modmasktable	file:
name	misc2.c	/^    char_u  *name;	\/* Name of key *\/$/;"	m	struct:key_name_entry	file:
name	search.c	/^    char_u	*name;		\/* Full name of file *\/$/;"	m	struct:SearchedFile	file:
name	structs.h	/^    char	*name;		\/* mode name (fixed) *\/$/;"	m	struct:cursor_entry
name	structs.h	/^    char_u	*name;		    \/* Name of menu *\/$/;"	m	struct:VimMenu
name	structs.h	/^    const char	*name;$/;"	m	struct:__anon43
name	syntax.c	/^    char	*name;$/;"	m	struct:name_list	file:
name	syntax.c	/^    char    *name;				\/* subcommand name *\/$/;"	m	struct:subcommand	file:
name	term.c	/^    char_u  name[2];	    \/* termcap name of entry *\/$/;"	m	struct:termcode	file:
name_list	syntax.c	/^struct name_list$/;"	s	file:
name_to_mod_mask	misc2.c	/^name_to_mod_mask(c)$/;"	f
namedfm	mark.c	/^static xfmark_T namedfm[NMARKS + EXTRA_MARKS];		\/* marks with file nr *\/$/;"	v	file:
namelowcpy	misc1.c	/^namelowcpy($/;"	f	file:
nb_bufp2nbbuf_fire	netbeans.c	/^nb_bufp2nbbuf_fire(buf_T *bufp, int *bufnop)$/;"	f	file:
nb_debug	nbdebug.c	/^FILE		*nb_debug = NULL;$/;"	v
nb_dlevel	nbdebug.c	/^u_int		 nb_dlevel = 0;		\/* nb_debug verbosity level *\/$/;"	v
nb_do_cmd	netbeans.c	/^nb_do_cmd($/;"	f	file:
nb_get_buf	netbeans.c	/^nb_get_buf(int bufno)$/;"	f	file:
nb_getbufno	netbeans.c	/^nb_getbufno(buf_T *bufp)$/;"	f	file:
nb_init_graphics	netbeans.c	/^nb_init_graphics(void)$/;"	f	file:
nb_parse_cmd	netbeans.c	/^nb_parse_cmd(char_u *cmd)$/;"	f	file:
nb_parse_messages	netbeans.c	/^nb_parse_messages(void)$/;"	f	file:
nb_quote	netbeans.c	/^nb_quote(char_u *txt)$/;"	f	file:
nb_reply_nil	netbeans.c	/^nb_reply_nil(int cmdno)$/;"	f	file:
nb_reply_nr	netbeans.c	/^nb_reply_nr(int cmdno, long result)$/;"	f	file:
nb_reply_text	netbeans.c	/^nb_reply_text(int cmdno, char_u *result)$/;"	f	file:
nb_send	netbeans.c	/^nb_send(char *buf, char *fun)$/;"	f	file:
nb_unquote	netbeans.c	/^nb_unquote(char_u *p, char_u **endp)$/;"	f	file:
nbbuf_T	netbeans.c	/^typedef struct nbbuf_struct nbbuf_T;$/;"	t	typeref:struct:nbbuf_struct	file:
nbbuf_struct	netbeans.c	/^struct nbbuf_struct$/;"	s	file:
nbdbg	nbdebug.c	/^nbdbg($/;"	f
nbdbg	nbdebug.h	/^nbdbg($/;"	f
nbdebug	nbdebug.h	26;"	d
nbdebug	vim.h	1743;"	d
nbdebug_log_init	nbdebug.c	/^nbdebug_log_init($/;"	f
nbdebug_wait	nbdebug.c	/^void nbdebug_wait($/;"	f
nbtrace	nbdebug.c	/^nbtrace($/;"	f
nbtrace	nbdebug.h	/^nbtrace($/;"	f
nchar	structs.h	/^    int		nchar;		\/* next command character (optional) *\/$/;"	m	struct:cmdarg
ncharC1	structs.h	/^    int		ncharC1;	\/* first composing character (optional) *\/$/;"	m	struct:cmdarg
ncharC2	structs.h	/^    int		ncharC2;	\/* second composing character (optional) *\/$/;"	m	struct:cmdarg
need_check_timestamps	globals.h	/^EXTERN int	need_check_timestamps INIT(= FALSE); \/* need to check file$/;"	v
need_clear_subexpr	regexp.c	/^static int	need_clear_subexpr;	\/* subexpressions still need to be$/;"	v	file:
need_clear_zsubexpr	regexp.c	/^static int	need_clear_zsubexpr = FALSE;	\/* extmatch subexpressions$/;"	v	file:
need_fileinfo	globals.h	/^EXTERN int	need_fileinfo INIT(= FALSE);\/* do fileinfo() after redraw *\/$/;"	v
need_gather	term.c	/^static int	need_gather = FALSE;		\/* need to fill termleader[] *\/$/;"	v	file:
need_highlight_changed	globals.h	/^EXTERN int	need_highlight_changed INIT(= TRUE);$/;"	v
need_maketitle	globals.h	/^EXTERN int	need_maketitle INIT(= TRUE); \/* call maketitle() soon *\/$/;"	v
need_mouse_correct	globals.h	/^EXTERN int	need_mouse_correct INIT(= FALSE);$/;"	v
need_rethrow	globals.h	/^EXTERN int need_rethrow INIT(= FALSE);$/;"	v
need_start_insertmode	globals.h	/^EXTERN int	need_start_insertmode INIT(= FALSE);$/;"	v
need_wait_return	globals.h	/^EXTERN int	need_wait_return INIT(= 0); \/* need to wait for return later *\/$/;"	v
needupdate	netbeans.c	/^static int needupdate = 0;$/;"	v	file:
nested	fileio.c	/^    char	    nested;		\/* If autocommands nest here *\/$/;"	m	struct:AutoCmd	file:
netbeansArg	globals.h	/^EXTERN char *netbeansArg INIT(= NULL);	\/* the -nb[:host:port:passwd] arg *\/$/;"	v
netbeansCloseFile	globals.h	/^EXTERN int netbeansCloseFile INIT(= 0);	\/* send killed if != 0 *\/$/;"	v
netbeansFireChanges	globals.h	/^EXTERN int netbeansFireChanges INIT(= 1); \/* send buffer changes if != 0 *\/$/;"	v
netbeansForcedQuit	globals.h	/^EXTERN int netbeansForcedQuit INIT(= 0);\/* don't write modified files *\/$/;"	v
netbeansOpenFile	globals.h	/^EXTERN int netbeansOpenFile INIT(= 1);	\/* send fileOpened if != 0 *\/$/;"	v
netbeansReadFile	globals.h	/^EXTERN int netbeansReadFile INIT(= 1);	\/* OK to read from disk if != 0 *\/$/;"	v
netbeansSuppressNoLines	globals.h	/^EXTERN int netbeansSuppressNoLines INIT(= 0); \/* skip "No lines in buffer" *\/$/;"	v
netbeans_Xt_connect	netbeans.c	/^netbeans_Xt_connect(void *context)$/;"	f
netbeans_beval_cb	netbeans.c	/^netbeans_beval_cb($/;"	f	file:
netbeans_button_release	netbeans.c	/^netbeans_button_release(int button)$/;"	f
netbeans_connect	netbeans.c	/^netbeans_connect(void)$/;"	f	file:
netbeans_deleted_all_lines	netbeans.c	/^netbeans_deleted_all_lines(buf_T *bufp)$/;"	f
netbeans_disconnect	netbeans.c	/^netbeans_disconnect(void)$/;"	f	file:
netbeans_draw_multisign_indicator	netbeans.c	/^netbeans_draw_multisign_indicator(int row)$/;"	f
netbeans_end	netbeans.c	/^netbeans_end(void)$/;"	f
netbeans_file_closed	netbeans.c	/^netbeans_file_closed(buf_T *bufp)$/;"	f
netbeans_file_opened	netbeans.c	/^netbeans_file_opened(char *filename)$/;"	f
netbeans_frame_moved	netbeans.c	/^netbeans_frame_moved(int new_x, int new_y)$/;"	f
netbeans_gtk_connect	netbeans.c	/^netbeans_gtk_connect(void)$/;"	f
netbeans_gutter_click	netbeans.c	/^netbeans_gutter_click(linenr_T lnum)$/;"	f
netbeans_inserted	netbeans.c	/^netbeans_inserted($/;"	f
netbeans_is_guarded	netbeans.c	/^netbeans_is_guarded(linenr_T top, linenr_T bot)$/;"	f
netbeans_keycommand	netbeans.c	/^netbeans_keycommand(int key)$/;"	f
netbeans_keyname	netbeans.c	/^netbeans_keyname(int key, char *buf)$/;"	f	file:
netbeans_removed	netbeans.c	/^netbeans_removed($/;"	f
netbeans_save_buffer	netbeans.c	/^netbeans_save_buffer(buf_T *bufp)$/;"	f
netbeans_startup_done	netbeans.c	/^netbeans_startup_done(void)$/;"	f
netbeans_unmodified	netbeans.c	/^netbeans_unmodified(buf_T *bufp)$/;"	f
netbeans_w32_connect	netbeans.c	/^netbeans_w32_connect(void)$/;"	f
newFoldLevel	fold.c	/^newFoldLevel()$/;"	f
newFoldLevelWin	fold.c	/^newFoldLevelWin(wp)$/;"	f	file:
new_cmdpos	ex_getln.c	/^static int	new_cmdpos;	\/* position set by set_cmdline_pos() *\/$/;"	v	file:
new_curbuf	structs.h	/^    buf_T	*new_curbuf;	\/* buffer to be used *\/$/;"	m	struct:__anon42
new_curwin	structs.h	/^    win_T	*new_curwin;	\/* new curwin if save_curwin != NULL *\/$/;"	m	struct:__anon42
new_insert_skip	edit.c	/^static int	new_insert_skip;  \/* nr of chars in front of current insert *\/$/;"	v	file:
new_last_cmdline	globals.h	/^EXTERN char_u	*new_last_cmdline INIT(= NULL);	\/* new value for last_cmdline *\/$/;"	v
new_pixel_height	globals.h	/^EXTERN int	new_pixel_height INIT(= 0);$/;"	v
new_pixel_width	globals.h	/^EXTERN int	new_pixel_width INIT(= 0);$/;"	v
new_script_vars	eval.c	/^new_script_vars(id)$/;"	f
newenv	misc2.c	/^newenv()$/;"	f	file:
newline_on_exit	globals.h	/^EXTERN int	newline_on_exit INIT(= FALSE);	\/* did msg in altern. screen *\/$/;"	v
next	edit.c	/^    struct Completion	*next;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
next	eval.c	/^    ufunc_T	*next;		\/* next function in list *\/$/;"	m	struct:ufunc	file:
next	fileio.c	/^    struct AutoCmd  *next;		\/* Next AutoCmd in list *\/$/;"	m	struct:AutoCmd	typeref:struct:AutoCmd::AutoCmd	file:
next	fileio.c	/^    struct AutoPat  *next;		\/* next AutoPat in AutoPat list *\/$/;"	m	struct:AutoPat	typeref:struct:AutoPat::AutoPat	file:
next	message.c	/^    struct msg_hist	*next;$/;"	m	struct:msg_hist	typeref:struct:msg_hist::msg_hist	file:
next	netbeans.c	/^    struct cmdqueue *next;$/;"	m	struct:cmdqueue	typeref:struct:cmdqueue::cmdqueue	file:
next	netbeans.c	/^    struct keyqueue *next;$/;"	m	struct:keyqueue	typeref:struct:keyqueue::keyqueue	file:
next	quickfix.c	/^    struct dir_stack_T	*next;$/;"	m	struct:dir_stack_T	typeref:struct:dir_stack_T::dir_stack_T	file:
next	quickfix.c	/^    struct eformat  *next;	\/* pointer to next (NULL if last) *\/$/;"	m	struct:eformat	typeref:struct:eformat::eformat	file:
next	structs.h	/^    eslist_T	*next;			\/* next element on the list *\/$/;"	m	struct:eslist_elem
next	structs.h	/^    keyentry_T	*next;		\/* next keyword in the hash list *\/$/;"	m	struct:keyentry
next	structs.h	/^    signlist_T	*next;		\/* next signlist entry *\/$/;"	m	struct:signlist
next	structs.h	/^    struct msglist	*next;		\/* next of several messages in a row *\/$/;"	m	struct:msglist	typeref:struct:msglist::msglist
next	structs.h	/^    vimmenu_T	*next;		    \/* Next item in menu *\/$/;"	m	struct:VimMenu
next_fenc	fileio.c	/^next_fenc(pp)$/;"	f	file:
next_list	structs.h	/^    short	*next_list;	\/* ID list for next match (if non-zero) *\/$/;"	m	struct:keyentry
next_match_col	syntax.c	/^static int next_match_col;		\/* column for start of next match *\/$/;"	v	file:
next_match_end_idx	syntax.c	/^static int next_match_end_idx;		\/* ID of group for end pattn or zero *\/$/;"	v	file:
next_match_eoe_pos	syntax.c	/^static lpos_T next_match_eoe_pos;	\/* pos. for end of end pattern *\/$/;"	v	file:
next_match_eos_pos	syntax.c	/^static lpos_T next_match_eos_pos;	\/* end of start pattn (start region) *\/$/;"	v	file:
next_match_extmatch	syntax.c	/^static reg_extmatch_T *next_match_extmatch = NULL;$/;"	v	file:
next_match_flags	syntax.c	/^static long next_match_flags;		\/* flags for next match *\/$/;"	v	file:
next_match_h_endpos	syntax.c	/^static lpos_T next_match_h_endpos;	\/* pos. for highl. end of next match *\/$/;"	v	file:
next_match_h_startpos	syntax.c	/^static lpos_T next_match_h_startpos;  \/* pos. for highl. start of next match *\/$/;"	v	file:
next_match_idx	syntax.c	/^static int next_match_idx;		\/* index of matched item *\/$/;"	v	file:
next_match_m_endpos	syntax.c	/^static lpos_T next_match_m_endpos;	\/* position for end of next match *\/$/;"	v	file:
next_search_hl	screen.c	/^next_search_hl(win, shl, lnum, mincol)$/;"	f	file:
nextchr	regexp.c	/^static int	nextchr;    \/* used for ungetchr() *\/$/;"	v	file:
nextcmd	ex_cmds.h	/^    char_u	*nextcmd;	\/* next command (NULL if none) *\/$/;"	m	struct:exarg
nextcmd	fileio.c	/^    AutoCmd	*nextcmd;	\/* next AutoCmd to execute *\/$/;"	m	struct:AutoPatCmd	file:
nextent	termlib.c	/^nextent(tbuf, termcap, buflen)		\/* Read 1 entry from TERMCAP file *\/$/;"	f	file:
nextline	ex_cmds2.c	/^    char_u      *nextline;      \/* if not NULL: line that was read ahead *\/$/;"	m	struct:source_cookie	file:
nextwild	ex_getln.c	/^nextwild(xp, type, options)$/;"	f	file:
no_Magic	regexp.c	/^no_Magic(x)$/;"	f	file:
no_abbr	globals.h	/^EXTERN int	no_abbr INIT(= TRUE);	\/* TRUE when no abbreviations loaded *\/$/;"	v
no_check_timestamps	globals.h	/^EXTERN int	no_check_timestamps INIT(= 0);	\/* Don't check timestamps *\/$/;"	v
no_console_input	gui.c	/^no_console_input()$/;"	f
no_hlsearch	globals.h	/^EXTERN int	no_hlsearch INIT(= FALSE);$/;"	v
no_lines_msg	globals.h	/^EXTERN char_u no_lines_msg[]	INIT(= N_("--No lines in buffer--"));$/;"	v
no_mapping	globals.h	/^EXTERN int	no_mapping INIT(= FALSE);   \/* currently no mapping allowed *\/$/;"	v
no_scs	search.c	/^    int		    no_scs;	\/* no smarcase for this pattern *\/$/;"	m	struct:spat	file:
no_smartcase	globals.h	/^EXTERN int	no_smartcase INIT(= FALSE);	\/* don't use 'smartcase' once *\/$/;"	v
no_u_sync	globals.h	/^EXTERN int	no_u_sync INIT(= 0);	\/* Don't call u_sync() *\/$/;"	v
no_viminfo	ex_cmds.c	/^no_viminfo()$/;"	f	file:
no_wait_return	globals.h	/^EXTERN int	no_wait_return INIT(= 0);   \/* don't wait for return for now *\/$/;"	v
no_zero_mapping	globals.h	/^EXTERN int	no_zero_mapping INIT(= 0);  \/* mapping zero not allowed *\/$/;"	v
nofile_fname	tag.c	/^static char_u	*nofile_fname = NULL;	\/* fname for NOTAGFILE error *\/$/;"	v	file:
noremap	structs.h	/^    int		noremap[MENU_MODES]; \/* A REMAP_ flag for each mode *\/$/;"	m	struct:VimMenu
noremapbuf_init	getchar.c	/^static char_u	noremapbuf_init[TYPELEN_INIT];	\/* initial typebuf.tb_noremap *\/$/;"	v	file:
norm_font	gui.h	/^    GuiFont	norm_font;	    \/* Normal font *\/$/;"	m	struct:Gui
norm_pixel	gui.h	/^    guicolor_T	norm_pixel;	    \/* Color of normal text *\/$/;"	m	struct:Gui
normal_cmd	normal.c	/^normal_cmd(oap, toplevel)$/;"	f
normal_search	normal.c	/^normal_search(cap, dir, pat, opt)$/;"	f	file:
not_exiting	ex_docmd.c	/^not_exiting()$/;"	f
not_writing	ex_cmds.c	/^not_writing()$/;"	f
nr2hex	charset.c	/^nr2hex(c)$/;"	f	file:
nr_trans	structs.h	/^struct nr_trans$/;"	s
nt_new_bnum	structs.h	/^    blocknr_T	nt_new_bnum;		\/* new, positive, number *\/$/;"	m	struct:nr_trans
nt_next	structs.h	/^    NR_TRANS	*nt_next;		\/* next nr_trans in hash list *\/$/;"	m	struct:nr_trans
nt_old_bnum	structs.h	/^    blocknr_T	nt_old_bnum;		\/* old, negative, number *\/$/;"	m	struct:nr_trans
nt_prev	structs.h	/^    NR_TRANS	*nt_prev;		\/* previous nr_trans in hash list *\/$/;"	m	struct:nr_trans
num_alloc	misc2.c	/^static long_u num_alloc;$/;"	v	file:
num_cols	gui.h	/^    int		num_cols;	    \/* Number of columns *\/$/;"	m	struct:Gui
num_complex_braces	regexp.c	/^static int	num_complex_braces; \/* Complex \\{...} count *\/$/;"	v	file:
num_freed	misc2.c	/^static long_u num_freed;$/;"	v	file:
num_rows	gui.h	/^    int		num_rows;	    \/* Number of rows *\/$/;"	m	struct:Gui
number	edit.c	/^    int			number;	  \/* sequence number *\/$/;"	m	struct:Completion	file:
number	structs.h	/^    long	number;$/;"	m	struct:__anon43
number	structs.h	/^    prt_text_attr_T number;$/;"	m	struct:__anon45
nv_Replace	normal.c	/^nv_Replace(cap)$/;"	f	file:
nv_Undo	normal.c	/^nv_Undo(cap)$/;"	f	file:
nv_Zet	normal.c	/^nv_Zet(cap)$/;"	f	file:
nv_abbrev	normal.c	/^nv_abbrev(cap)$/;"	f	file:
nv_addsub	normal.c	/^nv_addsub(cap)$/;"	f	file:
nv_at	normal.c	/^nv_at(cap)$/;"	f	file:
nv_bck_word	normal.c	/^nv_bck_word(cap)$/;"	f	file:
nv_beginline	normal.c	/^nv_beginline(cap)$/;"	f	file:
nv_brace	normal.c	/^nv_brace(cap)$/;"	f	file:
nv_brackets	normal.c	/^nv_brackets(cap)$/;"	f	file:
nv_clear	normal.c	/^nv_clear(cap)$/;"	f	file:
nv_cmd	normal.c	/^static const struct nv_cmd$/;"	s	file:
nv_cmd_idx	normal.c	/^static short nv_cmd_idx[NV_CMDS_SIZE];$/;"	v	file:
nv_cmds	normal.c	/^} nv_cmds[] =$/;"	v	typeref:struct:nv_cmd	file:
nv_colon	normal.c	/^nv_colon(cap)$/;"	f	file:
nv_compare	normal.c	/^nv_compare(s1, s2)$/;"	f	file:
nv_csearch	normal.c	/^nv_csearch(cap)$/;"	f	file:
nv_ctrlg	normal.c	/^nv_ctrlg(cap)$/;"	f	file:
nv_ctrlh	normal.c	/^nv_ctrlh(cap)$/;"	f	file:
nv_ctrlo	normal.c	/^nv_ctrlo(cap)$/;"	f	file:
nv_cursormark	normal.c	/^nv_cursormark(cap, flag, pos)$/;"	f	file:
nv_diffgetput	diff.c	/^nv_diffgetput(put)$/;"	f
nv_dollar	normal.c	/^nv_dollar(cap)$/;"	f	file:
nv_dot	normal.c	/^nv_dot(cap)$/;"	f	file:
nv_down	normal.c	/^nv_down(cap)$/;"	f	file:
nv_drop	normal.c	/^nv_drop(cap)$/;"	f	file:
nv_edit	normal.c	/^nv_edit(cap)$/;"	f	file:
nv_end	normal.c	/^nv_end(cap)$/;"	f	file:
nv_error	normal.c	/^nv_error(cap)$/;"	f	file:
nv_esc	normal.c	/^nv_esc(cap)$/;"	f	file:
nv_exmode	normal.c	/^nv_exmode(cap)$/;"	f	file:
nv_findpar	normal.c	/^nv_findpar(cap)$/;"	f	file:
nv_func_T	normal.c	/^typedef void (*nv_func_T) __ARGS((cmdarg_T *cap));$/;"	t	file:
nv_g_cmd	normal.c	/^nv_g_cmd(cap)$/;"	f	file:
nv_gd	normal.c	/^nv_gd(oap, nchar)$/;"	f	file:
nv_gomark	normal.c	/^nv_gomark(cap)$/;"	f	file:
nv_goto	normal.c	/^nv_goto(cap)$/;"	f	file:
nv_gotofile	normal.c	/^nv_gotofile(cap)$/;"	f	file:
nv_halfpage	normal.c	/^nv_halfpage(cap)$/;"	f	file:
nv_hat	normal.c	/^nv_hat(cap)$/;"	f	file:
nv_help	normal.c	/^nv_help(cap)$/;"	f	file:
nv_home	normal.c	/^nv_home(cap)$/;"	f	file:
nv_hor_scrollbar	normal.c	/^nv_hor_scrollbar(cap)$/;"	f	file:
nv_ident	normal.c	/^nv_ident(cap)$/;"	f	file:
nv_ignore	normal.c	/^nv_ignore(cap)$/;"	f	file:
nv_join	normal.c	/^nv_join(cap)$/;"	f	file:
nv_kundo	normal.c	/^nv_kundo(cap)$/;"	f	file:
nv_left	normal.c	/^nv_left(cap)$/;"	f	file:
nv_lineop	normal.c	/^nv_lineop(cap)$/;"	f	file:
nv_mark	normal.c	/^nv_mark(cap)$/;"	f	file:
nv_max_linear	normal.c	/^static int nv_max_linear;$/;"	v	file:
nv_mouse	normal.c	/^nv_mouse(cap)$/;"	f	file:
nv_mousescroll	normal.c	/^nv_mousescroll(cap)$/;"	f	file:
nv_nbcmd	normal.c	/^nv_nbcmd(cap)$/;"	f	file:
nv_next	normal.c	/^nv_next(cap)$/;"	f	file:
nv_normal	normal.c	/^nv_normal(cap)$/;"	f	file:
nv_object	normal.c	/^nv_object(cap)$/;"	f	file:
nv_open	normal.c	/^nv_open(cap)$/;"	f	file:
nv_operator	normal.c	/^nv_operator(cap)$/;"	f	file:
nv_optrans	normal.c	/^nv_optrans(cap)$/;"	f	file:
nv_page	normal.c	/^nv_page(cap)$/;"	f	file:
nv_pcmark	normal.c	/^nv_pcmark(cap)$/;"	f	file:
nv_percent	normal.c	/^nv_percent(cap)$/;"	f	file:
nv_pipe	normal.c	/^nv_pipe(cap)$/;"	f	file:
nv_put	normal.c	/^nv_put(cap)$/;"	f	file:
nv_record	normal.c	/^nv_record(cap)$/;"	f	file:
nv_redo	normal.c	/^nv_redo(cap)$/;"	f	file:
nv_regname	normal.c	/^nv_regname(cap)$/;"	f	file:
nv_replace	normal.c	/^nv_replace(cap)$/;"	f	file:
nv_right	normal.c	/^nv_right(cap)$/;"	f	file:
nv_screengo	normal.c	/^nv_screengo(oap, dir, dist)$/;"	f	file:
nv_scroll	normal.c	/^nv_scroll(cap)$/;"	f	file:
nv_scroll_line	normal.c	/^nv_scroll_line(cap)$/;"	f	file:
nv_search	normal.c	/^nv_search(cap)$/;"	f	file:
nv_select	normal.c	/^nv_select(cap)$/;"	f	file:
nv_sniff	normal.c	/^nv_sniff(cap)$/;"	f	file:
nv_subst	normal.c	/^nv_subst(cap)$/;"	f	file:
nv_suspend	normal.c	/^nv_suspend(cap)$/;"	f	file:
nv_tagpop	normal.c	/^nv_tagpop(cap)$/;"	f	file:
nv_tilde	normal.c	/^nv_tilde(cap)$/;"	f	file:
nv_undo	normal.c	/^nv_undo(cap)$/;"	f	file:
nv_up	normal.c	/^nv_up(cap)$/;"	f	file:
nv_ver_scrollbar	normal.c	/^nv_ver_scrollbar(cap)$/;"	f	file:
nv_visual	normal.c	/^nv_visual(cap)$/;"	f	file:
nv_vreplace	normal.c	/^nv_vreplace(cap)$/;"	f	file:
nv_window	normal.c	/^nv_window(cap)$/;"	f	file:
nv_wordcmd	normal.c	/^nv_wordcmd(cap)$/;"	f	file:
nv_zet	normal.c	/^nv_zet(cap)$/;"	f	file:
oap	structs.h	/^    oparg_T	*oap;		\/* Operator arguments *\/$/;"	m	struct:cmdarg
off	fold.c	/^    linenr_T	off;		\/* offset between lnum and real line number *\/$/;"	m	struct:__anon15	file:
off	search.c	/^    long	off;		\/* line or char offset *\/$/;"	m	struct:soffset	file:
off	search.c	/^    struct soffset  off;$/;"	m	struct:spat	typeref:struct:spat::soffset	file:
off2pos	netbeans.c	/^off2pos(buf_T *buf, long offset)$/;"	f	file:
offTime	gui_amiga.c	/^    int		offTime;$/;"	m	struct:__anon26	file:
off_t	os_amiga.h	/^typedef long off_t;$/;"	t
offset	mbyte.c	/^    int offset;$/;"	m	struct:__anon13	file:
oldFire	netbeans.c	/^static int oldFire = 1;$/;"	v	file:
old_char	getchar.c	/^static int old_char = -1;	\/* character put back by vungetc() *\/$/;"	v	file:
old_indent	edit.c	/^static int	old_indent = 0;		\/* for ^^D command in insert mode *\/$/;"	v	file:
old_mod_mask	getchar.c	/^static int old_mod_mask;	\/* mod_mask for ungotten character *\/$/;"	v	file:
old_mouse_shape	misc2.c	/^static int old_mouse_shape = 0;$/;"	v	file:
old_redobuff	getchar.c	/^static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
old_showcmd_buf	normal.c	/^static char_u	old_showcmd_buf[SHOWCMD_BUFLEN];  \/* For push_showcmd() *\/$/;"	v	file:
old_sub	ex_cmds.c	/^static char_u	*old_sub = NULL;	\/* previous substitute pattern *\/$/;"	v	file:
oldwindowtitle	os_amiga.c	/^static char_u		*oldwindowtitle = NULL;$/;"	v	file:
onTime	gui_amiga.c	/^    int		onTime;$/;"	m	struct:__anon26	file:
one_adjust	mark.c	835;"	d	file:
one_adjust_nodel	mark.c	850;"	d	file:
one_exactly	regexp.c	/^static int	one_exactly = FALSE;	\/* only do one char for EXACTLY *\/$/;"	v	file:
oneleft	edit.c	/^oneleft()$/;"	f
onepage	move.c	/^onepage(dir, count)$/;"	f
oneright	edit.c	/^oneright()$/;"	f
only_one_window	window.c	/^only_one_window()$/;"	f
opFoldRange	fold.c	/^opFoldRange(first, last, opening, recurse, had_visual)$/;"	f
op_change	ops.c	/^op_change(oap)$/;"	f
op_colon	normal.c	/^op_colon(oap)$/;"	f	file:
op_delete	ops.c	/^op_delete(oap)$/;"	f
op_format	ops.c	/^op_format(oap, keep_cursor)$/;"	f
op_insert	ops.c	/^op_insert(oap, count1)$/;"	f
op_on_lines	ops.c	/^op_on_lines(op)$/;"	f
op_reindent	ops.c	/^op_reindent(oap, how)$/;"	f
op_replace	ops.c	/^op_replace(oap, c)$/;"	f
op_shift	ops.c	/^op_shift(oap, curs_top, amount)$/;"	f
op_tilde	ops.c	/^op_tilde(oap)$/;"	f
op_type	structs.h	/^    int		op_type;	\/* current pending operator type *\/$/;"	m	struct:oparg
op_yank	ops.c	/^op_yank(oap, deleting, mess)$/;"	f
oparg	structs.h	/^typedef struct oparg$/;"	s
oparg_T	structs.h	/^} oparg_T;$/;"	t	typeref:struct:oparg
opchars	ops.c	/^static char opchars[][3] =$/;"	v	file:
opcount	structs.h	/^    long	opcount;	\/* count before an operator *\/$/;"	m	struct:cmdarg
openFold	fold.c	/^openFold(lnum, count)$/;"	f
openFoldRecurse	fold.c	/^openFoldRecurse(lnum)$/;"	f
open_app_context	ui.c	/^open_app_context()$/;"	f
open_buffer	buffer.c	/^open_buffer(read_stdin, eap)$/;"	f
open_exfile	ex_docmd.c	/^open_exfile(fname, forceit, mode)$/;"	f
open_line	misc1.c	/^open_line(dir, flags, old_indent)$/;"	f
openscript	getchar.c	/^openscript(name, directly)$/;"	f
opt_strings_flags	option.c	/^opt_strings_flags(val, values, flagp, list)$/;"	f	file:
option_expand	option.c	/^option_expand(opt_idx, val)$/;"	f	file:
option_table_T	structs.h	/^} option_table_T;$/;"	t	typeref:struct:__anon43
option_value2string	option.c	/^option_value2string(opp, opt_flags)$/;"	f	file:
option_was_set	option.c	/^option_was_set(name)$/;"	f
options	option.c	/^	options[] =$/;"	v	typeref:struct:_far	file:
optval_default	option.c	/^optval_default(p, varp)$/;"	f	file:
orig_line_count	globals.h	/^EXTERN int	orig_line_count INIT(= 0);  \/* Line count when "gR" started *\/$/;"	v
orig_topfill	term.c	/^static int orig_topfill = 0;$/;"	v	file:
orig_topline	term.c	/^static linenr_T orig_topline = 0;$/;"	v	file:
origin_end_col	vim.h	/^    short_u	origin_end_col;$/;"	m	struct:VimClipboard
origin_row	vim.h	/^    short_u	origin_row;$/;"	m	struct:VimClipboard
origin_start_col	vim.h	/^    short_u	origin_start_col;$/;"	m	struct:VimClipboard
original	edit.c	/^    int			original; \/* ORIGINAL_TEXT, CONT_S_IPOS or FREE_FNAME *\/$/;"	m	struct:Completion	file:
original_text	edit.c	/^static char_u		    *original_text = NULL;  \/* text before completion *\/$/;"	v	file:
ospeed	term.c	/^short ospeed;$/;"	v
ospeed	termlib.c	/^short	ospeed;		      \/* Baud rate (1-16, 1=300, 16=19200), as in stty *\/$/;"	v
osver	xxd/xxd.c	/^char osver[] = " (Win32)";$/;"	v
osver	xxd/xxd.c	/^char osver[] = " (dos 16 bit)";$/;"	v
osver	xxd/xxd.c	/^char osver[] = " (dos 32 bit)";$/;"	v
osver	xxd/xxd.c	/^char osver[] = "";$/;"	v
otherfile	buffer.c	/^otherfile(ffname)$/;"	f
otherfile_buf	buffer.c	/^otherfile_buf(buf, ffname$/;"	f	file:
out_buf	term.c	/^static char_u		out_buf[OUT_SIZE + 1];$/;"	v	file:
out_char	term.c	/^out_char(c)$/;"	f
out_char_nf	term.c	/^out_char_nf(c)$/;"	f	file:
out_flush	term.c	/^out_flush()$/;"	f
out_flush_check	term.c	/^out_flush_check()$/;"	f
out_num	os_amiga.c	/^out_num(n)$/;"	f	file:
out_of_stack	regexp.c	/^static int	out_of_stack;	\/* TRUE when ran out of stack space *\/$/;"	v	file:
out_pos	term.c	/^static int		out_pos = 0;	\/* number of chars in out_buf *\/$/;"	v	file:
out_str	term.c	/^out_str(s)$/;"	f
out_str_nf	term.c	/^out_str_nf(s)$/;"	f
out_trash	term.c	/^out_trash()$/;"	f
outfile	structs.h	/^    char_u	*outfile;$/;"	m	struct:__anon45
output_conv	globals.h	/^EXTERN vimconv_T output_conv;			\/* type of output conversion *\/$/;"	v
overstrike	ex_getln.c	/^    int		overstrike;	\/* Typing mode on the command line.  Shared by$/;"	m	struct:cmdline_info	file:
owned	vim.h	/^    int		owned;		\/* Flag: do we own the selection? *\/$/;"	m	struct:VimClipboard
p	testdir/test49.vim	/^		let p = 0$/;"	v
p	testdir/test49.vim	/^	    let p = 1$/;"	v
p	testdir/test49.vim	/^	let p = 0$/;"	v
p	testdir/test49.vim	/^    let p = 1$/;"	v
p_acd	option.h	/^EXTERN int	p_acd;		\/* 'autochdir' *\/$/;"	v
p_ai	option.c	/^static int	p_ai;$/;"	v	file:
p_ai_nopaste	option.c	/^static int	p_ai_nopaste;$/;"	v	file:
p_aleph	option.h	/^EXTERN long	p_aleph;	\/* 'aleph' *\/$/;"	v
p_altkeymap	option.h	/^EXTERN int	p_altkeymap;	\/* 'altkeymap' *\/$/;"	v
p_ambw	option.h	/^EXTERN char_u	*p_ambw;	\/* 'ambiwidth' *\/$/;"	v
p_ambw_values	option.c	/^static char *(p_ambw_values[]) = {"single", "double", NULL};$/;"	v	file:
p_antialias	option.h	/^EXTERN int	*p_antialias;	\/* 'antialias' *\/$/;"	v
p_ar	option.h	/^EXTERN int	p_ar;		\/* 'autoread' *\/$/;"	v
p_ari	option.h	/^EXTERN int	p_ari;		\/* 'allowrevins' *\/$/;"	v
p_arshape	option.h	/^EXTERN int	p_arshape;	\/* 'arabicshape' *\/$/;"	v
p_aw	option.h	/^EXTERN int	p_aw;		\/* 'autowrite' *\/$/;"	v
p_awa	option.h	/^EXTERN int	p_awa;		\/* 'autowriteall' *\/$/;"	v
p_bdir	option.h	/^EXTERN char_u	*p_bdir;	\/* 'backupdir' *\/$/;"	v
p_bdlay	option.h	/^EXTERN long	p_bdlay;	\/* 'balloondelay' *\/$/;"	v
p_beval	option.h	/^EXTERN int	p_beval;	\/* 'ballooneval' *\/$/;"	v
p_bex	option.h	/^EXTERN char_u	*p_bex;		\/* 'backupext' *\/$/;"	v
p_bg	option.h	/^EXTERN char_u	*p_bg;		\/* 'background' *\/$/;"	v
p_bg_values	option.c	/^static char *(p_bg_values[]) = {"light", "dark", NULL};$/;"	v	file:
p_bh	option.c	/^static char_u	*p_bh;$/;"	v	file:
p_bin	option.c	/^static int	p_bin;$/;"	v	file:
p_biosk	option.h	/^EXTERN int	p_biosk;	\/* 'bioskey' *\/$/;"	v
p_bk	option.h	/^EXTERN int	p_bk;		\/* 'backup' *\/$/;"	v
p_bkc	option.h	/^EXTERN char_u	*p_bkc;		\/* 'backupcopy' *\/$/;"	v
p_bkc_values	option.h	/^static char *(p_bkc_values[]) = {"yes", "auto", "no", "breaksymlink", "breakhardlink", NULL};$/;"	v
p_bl	option.c	/^static int	p_bl;$/;"	v	file:
p_bomb	option.c	/^static int	p_bomb;$/;"	v	file:
p_breakat	option.h	/^EXTERN char_u	*p_breakat;	\/* 'breakat' *\/$/;"	v
p_bs	option.h	/^EXTERN char_u	*p_bs;		\/* 'backspace' *\/$/;"	v
p_bs_values	option.c	/^static char *(p_bs_values[]) = {"indent", "eol", "start", NULL};$/;"	v	file:
p_bsdir	option.h	/^EXTERN char_u	*p_bsdir;	\/* 'browsedir' *\/$/;"	v
p_bsdir_values	option.c	/^static char *(p_bsdir_values[]) = {"current", "last", "buffer", NULL};$/;"	v	file:
p_bsk	option.h	/^EXTERN char_u	*p_bsk;		\/* 'backupskip' *\/$/;"	v
p_bt	option.c	/^static char_u	*p_bt;$/;"	v	file:
p_bufhidden_values	option.c	/^static char *(p_bufhidden_values[]) = {"hide", "unload", "delete", "wipe", NULL};$/;"	v	file:
p_buftype_values	option.c	/^static char *(p_buftype_values[]) = {"nofile", "nowrite", "quickfix", "help", NULL};$/;"	v	file:
p_cb	option.h	/^EXTERN char_u	*p_cb;		\/* 'clipboard' *\/$/;"	v
p_ccv	option.h	/^EXTERN char_u	*p_ccv;		\/* 'charconvert' *\/$/;"	v
p_cdpath	option.h	/^EXTERN char_u	*p_cdpath;	\/* 'cdpath' *\/$/;"	v
p_cedit	option.h	/^EXTERN char_u	*p_cedit;	\/* 'cedit' *\/$/;"	v
p_ch	option.h	/^EXTERN long	p_ch;		\/* 'cmdheight' *\/$/;"	v
p_ch_used	window.c	/^static long p_ch_used = 1L;		\/* value of 'cmdheight' when frame$/;"	v	file:
p_ci	option.c	/^static int	p_ci;$/;"	v	file:
p_cin	option.c	/^static int	p_cin;$/;"	v	file:
p_cink	option.c	/^static char_u	*p_cink;$/;"	v	file:
p_cino	option.c	/^static char_u	*p_cino;$/;"	v	file:
p_cinw	option.c	/^static char_u	*p_cinw;$/;"	v	file:
p_cmp	option.h	/^EXTERN char_u	*p_cmp;		\/* 'casemap' *\/$/;"	v
p_cmp_values	option.h	/^static char *(p_cmp_values[]) = {"internal", "keepascii", NULL};$/;"	v
p_cms	option.c	/^static char_u	*p_cms;$/;"	v	file:
p_com	option.c	/^static char_u	*p_com;$/;"	v	file:
p_confirm	option.h	/^EXTERN int	p_confirm;	\/* 'confirm' *\/$/;"	v
p_consk	option.h	/^EXTERN int	p_consk;	\/* 'conskey' *\/$/;"	v
p_cp	option.h	/^EXTERN int	p_cp;		\/* 'compatible' *\/$/;"	v
p_cpo	option.h	/^EXTERN char_u	*p_cpo;		\/* 'cpoptions' *\/$/;"	v
p_cpt	option.c	/^static char_u	*p_cpt;$/;"	v	file:
p_cspc	option.h	/^EXTERN long	p_cspc;		\/* 'cscopepathcomp' *\/$/;"	v
p_csprg	option.h	/^EXTERN char_u	*p_csprg;	\/* 'cscopeprg' *\/$/;"	v
p_csqf	option.h	/^EXTERN char_u	*p_csqf;	\/* 'cscopequickfix' *\/$/;"	v
p_cst	option.h	/^EXTERN int	p_cst;		\/* 'cscopetag' *\/$/;"	v
p_csto	option.h	/^EXTERN long	p_csto;		\/* 'cscopetagorder' *\/$/;"	v
p_csverbose	option.h	/^EXTERN int	p_csverbose;	\/* 'cscopeverbose' *\/$/;"	v
p_cwh	option.h	/^EXTERN long	p_cwh;		\/* 'cmdwinheight' *\/$/;"	v
p_debug	option.h	/^EXTERN char_u	*p_debug;	\/* 'debug' *\/$/;"	v
p_debug_values	option.c	/^static char *(p_debug_values[]) = {"msg", NULL};$/;"	v	file:
p_deco	option.h	/^EXTERN int	p_deco;		\/* 'delcombine' *\/$/;"	v
p_def	option.h	/^EXTERN char_u	*p_def;		\/* 'define' *\/$/;"	v
p_dex	option.h	/^EXTERN char_u	*p_dex;		\/* 'diffexpr' *\/$/;"	v
p_dg	option.h	/^EXTERN int	p_dg;		\/* 'digraph' *\/$/;"	v
p_dict	option.h	/^EXTERN char_u	*p_dict;	\/* 'dictionary' *\/$/;"	v
p_dip	option.h	/^EXTERN char_u	*p_dip;		\/* 'diffopt' *\/$/;"	v
p_dir	option.h	/^EXTERN char_u	*p_dir;		\/* 'directory' *\/$/;"	v
p_dy	option.h	/^EXTERN char_u	*p_dy;		\/* 'display' *\/$/;"	v
p_dy_values	option.h	/^static char *(p_dy_values[]) = {"lastline", "uhex", NULL};$/;"	v
p_ea	option.h	/^EXTERN int	p_ea;		\/* 'equalalways' *\/$/;"	v
p_ead	option.h	/^EXTERN char_u	*p_ead;		\/* 'eadirection' *\/$/;"	v
p_ead_values	option.c	/^static char *(p_ead_values[]) = {"both", "ver", "hor", NULL};$/;"	v	file:
p_eb	option.h	/^EXTERN int	p_eb;		\/* 'errorbells' *\/$/;"	v
p_ed	option.h	/^EXTERN int	p_ed;		\/* 'edcompatible' *\/$/;"	v
p_ef	option.h	/^EXTERN char_u	*p_ef;		\/* 'errorfile' *\/$/;"	v
p_efm	option.h	/^EXTERN char_u	*p_efm;		\/* 'errorformat' *\/$/;"	v
p_ei	option.h	/^EXTERN char_u	*p_ei;		\/* 'eventignore' *\/$/;"	v
p_ek	option.h	/^EXTERN int	p_ek;		\/* 'esckeys' *\/$/;"	v
p_enc	option.h	/^EXTERN char_u	*p_enc;		\/* 'encoding' *\/$/;"	v
p_eol	option.c	/^static int	p_eol;$/;"	v	file:
p_ep	option.h	/^EXTERN char_u	*p_ep;		\/* 'equalprg' *\/$/;"	v
p_et	option.c	/^static int	p_et;$/;"	v	file:
p_et_nobin	option.c	/^static int	p_et_nobin;$/;"	v	file:
p_exrc	option.h	/^EXTERN int	p_exrc;		\/* 'exrc' *\/$/;"	v
p_fcl	option.h	/^EXTERN char_u	*p_fcl;		\/* 'foldclose' *\/$/;"	v
p_fcl_values	option.c	/^static char *(p_fcl_values[]) = {"all", NULL};$/;"	v	file:
p_fcs	option.h	/^EXTERN char_u	*p_fcs;		\/* 'fillchar' *\/$/;"	v
p_fdls	option.h	/^EXTERN long	p_fdls;		\/* 'foldlevelstart' *\/$/;"	v
p_fdm_values	option.c	/^static char *(p_fdm_values[]) = {"manual", "expr", "marker", "indent", "syntax",$/;"	v	file:
p_fdo	option.h	/^EXTERN char_u	*p_fdo;		\/* 'foldopen' *\/$/;"	v
p_fdo_values	option.h	/^static char *(p_fdo_values[]) = {"all", "block", "hor", "mark", "percent",$/;"	v
p_fenc	option.c	/^static char_u	*p_fenc;$/;"	v	file:
p_fencs	option.h	/^EXTERN char_u	*p_fencs;	\/* 'fileencodings' *\/$/;"	v
p_ff	option.c	/^static char_u	*p_ff;$/;"	v	file:
p_ff_values	option.c	/^static char *(p_ff_values[]) = {FF_UNIX, FF_DOS, FF_MAC, NULL};$/;"	v	file:
p_ffs	option.h	/^EXTERN char_u	*p_ffs;		\/* 'fileformats' *\/$/;"	v
p_fkmap	option.h	/^EXTERN int	p_fkmap;	\/* 'fkmap' *\/$/;"	v
p_fo	option.c	/^static char_u	*p_fo;$/;"	v	file:
p_fp	option.h	/^EXTERN char_u	*p_fp;		\/* 'formatprg' *\/$/;"	v
p_ft	option.c	/^static char_u	*p_ft;$/;"	v	file:
p_gd	option.h	/^EXTERN int	p_gd;		\/* 'gdefault' *\/$/;"	v
p_gefm	option.h	/^EXTERN char_u	*p_gefm;	\/* 'grepformat' *\/$/;"	v
p_ghr	option.h	/^EXTERN long	p_ghr;		\/* 'guiheadroom' *\/$/;"	v
p_go	option.h	/^EXTERN char_u	*p_go;		\/* 'guioptions' *\/$/;"	v
p_gp	option.h	/^EXTERN char_u	*p_gp;		\/* 'grepprg' *\/$/;"	v
p_guicursor	option.h	/^EXTERN char_u	*p_guicursor;	\/* 'guicursor' *\/$/;"	v
p_guifont	option.h	/^EXTERN char_u	*p_guifont;	\/* 'guifont' *\/$/;"	v
p_guifontset	option.h	/^EXTERN char_u	*p_guifontset;	\/* 'guifontset' *\/$/;"	v
p_guifontwide	option.h	/^EXTERN char_u	*p_guifontwide;	\/* 'guifontwide' *\/$/;"	v
p_guipty	option.h	/^EXTERN int	p_guipty;	\/* 'guipty' *\/$/;"	v
p_header	option.h	/^EXTERN char_u	*p_header;	\/* 'printheader' *\/$/;"	v
p_hf	option.h	/^EXTERN char_u	*p_hf;		\/* 'helpfile' *\/$/;"	v
p_hh	option.h	/^EXTERN long	p_hh;		\/* 'helpheight' *\/$/;"	v
p_hi	option.h	/^EXTERN long	p_hi;		\/* 'history' *\/$/;"	v
p_hid	option.h	/^EXTERN int	p_hid;		\/* 'hidden' *\/$/;"	v
p_hkmap	option.h	/^EXTERN int	p_hkmap;	\/* 'hkmap' *\/$/;"	v
p_hkmapp	option.h	/^EXTERN int	p_hkmapp;	\/* 'hkmapp' *\/$/;"	v
p_hl	option.h	/^EXTERN char_u	*p_hl;		\/* 'highlight' *\/$/;"	v
p_hlg	option.h	/^EXTERN char_u	*p_hlg;		\/* 'helplang' *\/$/;"	v
p_hls	option.h	/^EXTERN int	p_hls;		\/* 'hlsearch' *\/$/;"	v
p_ic	option.h	/^EXTERN int	p_ic;		\/* 'ignorecase' *\/$/;"	v
p_icon	option.h	/^EXTERN int	p_icon;		\/* 'icon' *\/$/;"	v
p_iconstring	option.h	/^EXTERN char_u	*p_iconstring;	\/* 'iconstring' *\/$/;"	v
p_im	option.h	/^EXTERN int	p_im;		\/* 'insertmode' *\/$/;"	v
p_imak	option.h	/^EXTERN char_u	*p_imak;	\/* 'imactivatekey' *\/$/;"	v
p_imcmdline	option.h	/^EXTERN int	p_imcmdline;	\/* 'imcmdline' *\/$/;"	v
p_imdisable	option.h	/^EXTERN int	p_imdisable;	\/* 'imdisable' *\/$/;"	v
p_iminsert	option.c	/^static long	p_iminsert;$/;"	v	file:
p_imsearch	option.c	/^static long	p_imsearch;$/;"	v	file:
p_inc	option.h	/^EXTERN char_u	*p_inc;$/;"	v
p_inde	option.c	/^static char_u	*p_inde;$/;"	v	file:
p_indk	option.c	/^static char_u	*p_indk;$/;"	v	file:
p_inex	option.c	/^static char_u	*p_inex;$/;"	v	file:
p_inf	option.c	/^static int	p_inf;$/;"	v	file:
p_is	option.h	/^EXTERN int	p_is;		\/* 'incsearch' *\/$/;"	v
p_isf	option.h	/^EXTERN char_u	*p_isf;		\/* 'isfname' *\/$/;"	v
p_isi	option.h	/^EXTERN char_u	*p_isi;		\/* 'isident' *\/$/;"	v
p_isk	option.c	/^static char_u	*p_isk;$/;"	v	file:
p_isp	option.h	/^EXTERN char_u	*p_isp;		\/* 'isprint' *\/$/;"	v
p_js	option.h	/^EXTERN int	p_js;		\/* 'joinspaces' *\/$/;"	v
p_key	option.c	/^static char_u	*p_key;$/;"	v	file:
p_keymap	option.c	/^static char_u	*p_keymap;$/;"	v	file:
p_km	option.h	/^EXTERN char_u	*p_km;		\/* 'keymodel' *\/$/;"	v
p_km_values	option.c	/^static char *(p_km_values[]) = {"startsel", "stopsel", NULL};$/;"	v	file:
p_kp	option.h	/^EXTERN char_u	*p_kp;		\/* 'keywordprg' *\/$/;"	v
p_langmap	option.h	/^EXTERN char_u	*p_langmap;	\/* 'langmap'*\/$/;"	v
p_lcs	option.h	/^EXTERN char_u	*p_lcs;		\/* 'listchars' *\/$/;"	v
p_linespace	option.h	/^EXTERN long	p_linespace;	\/* 'linespace' *\/$/;"	v
p_lisp	option.c	/^static int	p_lisp;$/;"	v	file:
p_lispwords	option.h	/^EXTERN char_u	*p_lispwords;	\/* 'lispwords' *\/$/;"	v
p_lm	option.h	/^EXTERN char_u	*p_lm;		\/* 'langmenu' *\/$/;"	v
p_lpl	option.h	/^EXTERN int	p_lpl;		\/* 'loadplugins' *\/$/;"	v
p_ls	option.h	/^EXTERN long	p_ls;		\/* 'laststatus' *\/$/;"	v
p_lz	option.h	/^EXTERN int	p_lz;		\/* 'lazyredraw' *\/$/;"	v
p_ma	option.c	/^static int	p_ma;$/;"	v	file:
p_magic	option.h	/^EXTERN int	p_magic;	\/* 'magic' *\/$/;"	v
p_mat	option.h	/^EXTERN long	p_mat;		\/* 'matchtime' *\/$/;"	v
p_mef	option.h	/^EXTERN char_u	*p_mef;		\/* 'makeef' *\/$/;"	v
p_mfd	option.h	/^EXTERN long	p_mfd;		\/* 'maxfuncdepth' *\/$/;"	v
p_mh	option.h	/^EXTERN int	p_mh;		\/* 'mousehide' *\/$/;"	v
p_mis	option.h	/^EXTERN long	p_mis;		\/* 'menuitems' *\/$/;"	v
p_ml	option.c	/^static int	p_ml;$/;"	v	file:
p_ml_nobin	option.c	/^static int	p_ml_nobin;$/;"	v	file:
p_mls	option.h	/^EXTERN long	p_mls;		\/* 'modelines' *\/$/;"	v
p_mm	option.h	/^EXTERN long	p_mm;		\/* 'maxmem' *\/$/;"	v
p_mmd	option.h	/^EXTERN long	p_mmd;		\/* 'maxmapdepth' *\/$/;"	v
p_mmt	option.h	/^EXTERN long	p_mmt;		\/* 'maxmemtot' *\/$/;"	v
p_mod	option.c	/^static int	p_mod;$/;"	v	file:
p_more	option.h	/^EXTERN int	p_more;		\/* 'more' *\/$/;"	v
p_mouse	option.h	/^EXTERN char_u	*p_mouse;	\/* 'mouse' *\/$/;"	v
p_mousef	option.h	/^EXTERN int	p_mousef;	\/* 'mousefocus' *\/$/;"	v
p_mousem	option.h	/^EXTERN char_u	*p_mousem;	\/* 'mousemodel' *\/$/;"	v
p_mousem_values	option.c	/^static char *(p_mousem_values[]) = {"extend", "popup", "popup_setpos", "mac", NULL};$/;"	v	file:
p_mouseshape	option.h	/^EXTERN char_u	*p_mouseshape;	\/* 'mouseshape' *\/$/;"	v
p_mouset	option.h	/^EXTERN long	p_mouset;	\/* 'mousetime' *\/$/;"	v
p_mp	option.h	/^EXTERN char_u	*p_mp;		\/* 'makeprg' *\/$/;"	v
p_mps	option.c	/^static char_u	*p_mps;$/;"	v	file:
p_nf	option.c	/^static char_u	*p_nf;$/;"	v	file:
p_nf_values	option.c	/^static char *(p_nf_values[]) = {"octal", "hex", "alpha", NULL};$/;"	v	file:
p_oft	option.c	/^static char_u	*p_oft;$/;"	v	file:
p_para	option.h	/^EXTERN char_u	*p_para;	\/* 'paragraphs' *\/$/;"	v
p_paste	option.h	/^EXTERN int	p_paste;	\/* 'paste' *\/$/;"	v
p_path	option.h	/^EXTERN char_u	*p_path;	\/* 'path' *\/$/;"	v
p_pdev	option.h	/^EXTERN char_u	*p_pdev;	\/* 'printdevice' *\/$/;"	v
p_penc	option.h	/^EXTERN char_u	*p_penc;	\/* 'printencoding' *\/$/;"	v
p_pex	option.h	/^EXTERN char_u	*p_pex;		\/* 'patchexpr' *\/$/;"	v
p_pexpr	option.h	/^EXTERN char_u	*p_pexpr;	\/* 'printexpr' *\/$/;"	v
p_pfn	option.h	/^EXTERN char_u	*p_pfn;		\/* 'printfont' *\/$/;"	v
p_pi	option.c	/^static int	p_pi;$/;"	v	file:
p_pm	option.h	/^EXTERN char_u	*p_pm;		\/* 'patchmode' *\/$/;"	v
p_popt	option.h	/^EXTERN char_u	*p_popt;	\/* 'printoptions' *\/$/;"	v
p_pt	option.h	/^EXTERN char_u	*p_pt;		\/* 'pastetoggle' *\/$/;"	v
p_pvh	option.h	/^EXTERN long	p_pvh;		\/* 'previewheight' *\/$/;"	v
p_remap	option.h	/^EXTERN int	p_remap;	\/* 'remap' *\/$/;"	v
p_report	option.h	/^EXTERN long	p_report;	\/* 'report' *\/$/;"	v
p_ri	option.h	/^EXTERN int	p_ri;		\/* 'revins' *\/$/;"	v
p_ro	option.c	/^static int	p_ro;$/;"	v	file:
p_rs	option.h	/^EXTERN int	p_rs;		\/* 'restorescreen' *\/$/;"	v
p_rtp	option.h	/^EXTERN char_u	*p_rtp;		\/* 'runtimepath' *\/$/;"	v
p_ru	option.h	/^EXTERN int	p_ru;		\/* 'ruler' *\/$/;"	v
p_ruf	option.h	/^EXTERN char_u	*p_ruf;		\/* 'rulerformat' *\/$/;"	v
p_sb	option.h	/^EXTERN int	p_sb;		\/* 'splitbelow' *\/$/;"	v
p_sbo	option.h	/^EXTERN char_u	*p_sbo;		\/* 'scrollopt' *\/$/;"	v
p_sbr	option.h	/^EXTERN char_u	*p_sbr;		\/* 'showbreak' *\/$/;"	v
p_sc	option.h	/^EXTERN int	p_sc;		\/* 'showcmd' *\/$/;"	v
p_scbopt_values	option.c	/^static char *(p_scbopt_values[]) = {"ver", "hor", "jump", NULL};$/;"	v	file:
p_scs	option.h	/^EXTERN int	p_scs;		\/* 'smartcase' *\/$/;"	v
p_sections	option.h	/^EXTERN char_u	*p_sections;	\/* 'sections' *\/$/;"	v
p_secure	option.h	/^EXTERN int	p_secure;	\/* 'secure' *\/$/;"	v
p_sel	option.h	/^EXTERN char_u	*p_sel;		\/* 'selection' *\/$/;"	v
p_sel_values	option.c	/^static char *(p_sel_values[]) = {"inclusive", "exclusive", "old", NULL};$/;"	v	file:
p_sft	option.h	/^EXTERN int	p_sft;		\/* 'showfulltag' *\/$/;"	v
p_sh	option.h	/^EXTERN char_u	*p_sh;		\/* 'shell' *\/$/;"	v
p_shcf	option.h	/^EXTERN char_u	*p_shcf;	\/* 'shellcmdflag' *\/$/;"	v
p_shm	option.h	/^EXTERN char_u	*p_shm;		\/* 'shortmess' *\/$/;"	v
p_shq	option.h	/^EXTERN char_u	*p_shq;		\/* 'shellquote' *\/$/;"	v
p_si	option.c	/^static int	p_si;$/;"	v	file:
p_siso	option.h	/^EXTERN long	p_siso;		\/* 'sidescrolloff' *\/$/;"	v
p_sj	option.h	/^EXTERN long	p_sj;		\/* 'scrolljump' *\/$/;"	v
p_slm	option.h	/^EXTERN char_u	*p_slm;		\/* 'selectmode' *\/$/;"	v
p_slm_values	option.c	/^static char *(p_slm_values[]) = {"mouse", "key", "cmd", NULL};$/;"	v	file:
p_sm	option.h	/^EXTERN int	p_sm;		\/* 'showmatch' *\/$/;"	v
p_smd	option.h	/^EXTERN int	p_smd;		\/* 'showmode' *\/$/;"	v
p_sn	option.c	/^static int	p_sn;$/;"	v	file:
p_so	option.h	/^EXTERN long	p_so;		\/* 'scrolloff' *\/$/;"	v
p_sol	option.h	/^EXTERN int	p_sol;		\/* 'startofline' *\/$/;"	v
p_sp	option.h	/^EXTERN char_u	*p_sp;		\/* 'shellpipe' *\/$/;"	v
p_spr	option.h	/^EXTERN int	p_spr;		\/* 'splitright' *\/$/;"	v
p_sr	option.h	/^EXTERN int	p_sr;		\/* 'shiftround' *\/$/;"	v
p_srr	option.h	/^EXTERN char_u	*p_srr;		\/* 'shellredir' *\/$/;"	v
p_ss	option.h	/^EXTERN long	p_ss;		\/* 'sidescroll' *\/$/;"	v
p_ssl	option.h	/^EXTERN int	p_ssl;		\/* 'shellslash' *\/$/;"	v
p_ssop	option.h	/^EXTERN char_u	*p_ssop;	\/* 'sessionoptions' *\/$/;"	v
p_ssop_values	option.h	/^static char *(p_ssop_values[]) = {"buffers", "winpos", "resize", "winsize",$/;"	v
p_st	option.h	/^EXTERN long	p_st;		\/* 'shelltype' *\/$/;"	v
p_sta	option.h	/^EXTERN int	p_sta;		\/* 'smarttab' *\/$/;"	v
p_stl	option.h	/^EXTERN char_u	*p_stl;		\/* 'statusline' *\/$/;"	v
p_sts	option.c	/^static long	p_sts;$/;"	v	file:
p_sts_nopaste	option.c	/^static long	p_sts_nopaste;$/;"	v	file:
p_su	option.h	/^EXTERN char_u	*p_su;		\/* 'suffixes' *\/$/;"	v
p_sua	option.c	/^static char_u	*p_sua;$/;"	v	file:
p_sw	option.c	/^static long	p_sw;$/;"	v	file:
p_swb	option.h	/^EXTERN char_u	*p_swb;		\/* 'switchbuf' *\/$/;"	v
p_swb_values	option.c	/^static char *(p_swb_values[]) = {"useopen", "split", NULL};$/;"	v	file:
p_swf	option.c	/^static int	p_swf;$/;"	v	file:
p_sws	option.h	/^EXTERN char_u	*p_sws;		\/* 'swapsync' *\/$/;"	v
p_sxq	option.h	/^EXTERN char_u	*p_sxq;		\/* 'shellxquote' *\/$/;"	v
p_syn	option.c	/^static char_u	*p_syn;$/;"	v	file:
p_ta	option.h	/^EXTERN int	p_ta;		\/* 'textauto' *\/$/;"	v
p_tags	option.h	/^EXTERN char_u	*p_tags;	\/* 'tags' *\/$/;"	v
p_tbi	option.h	/^EXTERN int	p_tbi;		\/* 'ttybuiltin' *\/$/;"	v
p_tbidi	option.h	/^EXTERN int	p_tbidi;	\/* 'termbidi' *\/$/;"	v
p_tbis	option.h	/^EXTERN char_u	*p_tbis;	\/* 'toolbariconsize' *\/$/;"	v
p_tbis_values	option.h	/^static char *(p_tbis_values[]) = {"tiny", "small", "medium", "large", NULL};$/;"	v
p_tbs	option.h	/^EXTERN int	p_tbs;		\/* 'tagbsearch' *\/$/;"	v
p_tenc	option.h	/^EXTERN char_u	*p_tenc;	\/* 'termencoding' *\/$/;"	v
p_term	option.c	2325;"	d	file:
p_terse	option.h	/^EXTERN int	p_terse;	\/* 'terse' *\/$/;"	v
p_tf	option.h	/^EXTERN int	p_tf;		\/* 'ttyfast' *\/$/;"	v
p_tgst	option.h	/^EXTERN int	p_tgst;		\/* 'tagstack' *\/$/;"	v
p_timeout	option.h	/^EXTERN int	p_timeout;	\/* 'timeout' *\/$/;"	v
p_title	option.h	/^EXTERN int	p_title;	\/* 'title' *\/$/;"	v
p_titlelen	option.h	/^EXTERN long	p_titlelen;	\/* 'titlelen' *\/$/;"	v
p_titleold	option.h	/^EXTERN char_u	*p_titleold;	\/* 'titleold' *\/$/;"	v
p_titlestring	option.h	/^EXTERN char_u	*p_titlestring;	\/* 'titlestring' *\/$/;"	v
p_tl	option.h	/^EXTERN long	p_tl;		\/* 'taglength' *\/$/;"	v
p_tm	option.h	/^EXTERN long	p_tm;		\/* 'timeoutlen' *\/$/;"	v
p_to	option.h	/^EXTERN int	p_to;		\/* 'tildeop' *\/$/;"	v
p_toolbar	option.h	/^EXTERN char_u	*p_toolbar;	\/* 'toolbar' *\/$/;"	v
p_toolbar_values	option.h	/^static char *(p_toolbar_values[]) = {"text", "icons", "tooltips", "horiz", NULL};$/;"	v
p_tr	option.h	/^EXTERN int	p_tr;		\/* 'tagrelative' *\/$/;"	v
p_ts	option.c	/^static long	p_ts;$/;"	v	file:
p_tsr	option.h	/^EXTERN char_u	*p_tsr;		\/* 'thesaurus' *\/$/;"	v
p_ttimeout	option.h	/^EXTERN int	p_ttimeout;	\/* 'ttimeout' *\/$/;"	v
p_ttm	option.h	/^EXTERN long	p_ttm;		\/* 'ttimeoutlen' *\/$/;"	v
p_ttym	option.h	/^EXTERN char_u	*p_ttym;	\/* 'ttymouse' *\/$/;"	v
p_ttym_values	option.h	/^static char *(p_ttym_values[]) = {"xterm", "xterm2", "dec", "netterm", "jsbterm", "pterm", NULL};$/;"	v
p_ttyscroll	option.h	/^EXTERN long	p_ttyscroll;	\/* 'ttyscroll' *\/$/;"	v
p_tw	option.c	/^static long	p_tw;$/;"	v	file:
p_tw_nobin	option.c	/^static long	p_tw_nobin;$/;"	v	file:
p_tw_nopaste	option.c	/^static long	p_tw_nopaste;$/;"	v	file:
p_tx	option.c	/^static int	p_tx;$/;"	v	file:
p_uc	option.h	/^EXTERN long	p_uc;		\/* 'updatecount' *\/$/;"	v
p_ul	option.h	/^EXTERN long	p_ul;		\/* 'undolevels' *\/$/;"	v
p_ut	option.h	/^EXTERN long	p_ut;		\/* 'updatetime' *\/$/;"	v
p_vb	option.h	/^EXTERN int	p_vb;		\/* 'visualbell' *\/$/;"	v
p_vdir	option.h	/^EXTERN char_u	*p_vdir;	\/* 'viewdir' *\/$/;"	v
p_ve	option.h	/^EXTERN char_u	*p_ve;		\/* 'virtualedit' *\/$/;"	v
p_ve_values	option.h	/^static char *(p_ve_values[]) = {"block", "insert", "all", NULL};$/;"	v
p_verbose	option.h	/^EXTERN long	p_verbose;	\/* 'verbose' *\/$/;"	v
p_viminfo	option.h	/^EXTERN char_u	*p_viminfo;	\/* 'viminfo' *\/$/;"	v
p_vop	option.h	/^EXTERN char_u	*p_vop;		\/* 'viewoptions' *\/$/;"	v
p_wa	option.h	/^EXTERN int	p_wa;		\/* 'writeany' *\/$/;"	v
p_wak	option.h	/^EXTERN char_u	*p_wak;		\/* 'winaltkeys' *\/$/;"	v
p_wak_values	option.c	/^static char *(p_wak_values[]) = {"yes", "menu", "no", NULL};$/;"	v	file:
p_warn	option.h	/^EXTERN int	p_warn;		\/* 'warn' *\/$/;"	v
p_wb	option.h	/^EXTERN int	p_wb;		\/* 'writebackup' *\/$/;"	v
p_wc	option.h	/^EXTERN long	p_wc;		\/* 'wildchar' *\/$/;"	v
p_wcm	option.h	/^EXTERN long	p_wcm;		\/* 'wildcharm' *\/$/;"	v
p_wd	option.h	/^EXTERN long	p_wd;		\/* 'writedelay' *\/$/;"	v
p_wh	option.h	/^EXTERN long	p_wh;		\/* 'winheight' *\/$/;"	v
p_wig	option.h	/^EXTERN char_u	*p_wig;		\/* 'wildignore' *\/$/;"	v
p_wim	option.h	/^EXTERN char_u	*p_wim;		\/* 'wildmode' *\/$/;"	v
p_wiv	option.h	/^EXTERN int	p_wiv;		\/* 'weirdinvert' *\/$/;"	v
p_wiw	option.h	/^EXTERN long	p_wiw;		\/* 'winwidth' *\/$/;"	v
p_wm	option.c	/^static long	p_wm;$/;"	v	file:
p_wm_nobin	option.c	/^static long	p_wm_nobin;$/;"	v	file:
p_wm_nopaste	option.c	/^static long	p_wm_nopaste;$/;"	v	file:
p_wmh	option.h	/^EXTERN long	p_wmh;		\/* 'winminheight' *\/$/;"	v
p_wmnu	option.h	/^EXTERN int	p_wmnu;		\/* 'wildmenu' *\/$/;"	v
p_wmw	option.h	/^EXTERN long	p_wmw;		\/* 'winminwidth' *\/$/;"	v
p_write	option.h	/^EXTERN int	p_write;	\/* 'write' *\/$/;"	v
p_ws	option.h	/^EXTERN int	p_ws;		\/* 'wrapscan' *\/$/;"	v
p_ww	option.h	/^EXTERN char_u	*p_ww;		\/* 'whichwrap' *\/$/;"	v
page_count	ex_cmds2.c	/^static int	page_count;$/;"	v	file:
paragraph_start	ops.c	/^paragraph_start(lnum)$/;"	f
parent	structs.h	/^    vimmenu_T	*parent;	    \/* Parent of menu *\/$/;"	m	struct:VimMenu
parseMarker	fold.c	/^parseMarker(wp)$/;"	f	file:
parse_builtin_tcap	term.c	/^parse_builtin_tcap(term)$/;"	f	file:
parse_list_options	misc2.c	/^parse_list_options(option_str, table, table_size)$/;"	f
parse_match	tag.c	/^parse_match(lbuf, tagp)$/;"	f	file:
parse_shape_opt	misc2.c	/^parse_shape_opt(what)$/;"	f
parse_tag_line	tag.c	/^parse_tag_line(lbuf,$/;"	f	file:
partial_line	netbeans.c	/^    char_u		*partial_line;$/;"	m	struct:nbbuf_struct	file:
paste_option_changed	option.c	/^paste_option_changed()$/;"	f	file:
pat	fileio.c	/^    char_u	    *pat;		\/* pattern as typed (NULL when pattern$/;"	m	struct:AutoPat	file:
pat	search.c	/^    char_u	    *pat;	\/* the pattern (in allocated memory) or NULL *\/$/;"	m	struct:spat	file:
pat	tag.c	/^    char_u	*pat;		\/* the pattern *\/$/;"	m	struct:__anon8	file:
pat_T	tag.c	/^} pat_T;$/;"	t	typeref:struct:__anon8	file:
path_is_url	window.c	/^path_is_url(p)$/;"	f	file:
path_with_url	window.c	/^path_with_url(fname)$/;"	f
pathcmp	misc2.c	/^pathcmp(p, q)$/;"	f
patlen	fileio.c	/^    int		    patlen;		\/* strlen() of pat *\/$/;"	m	struct:AutoPat	file:
pb_count	memline.c	/^    short_u	pb_count;	\/* number of pointer in this block *\/$/;"	m	struct:pointer_block	file:
pb_count_max	memline.c	/^    short_u	pb_count_max;	\/* maximum value for pb_count *\/$/;"	m	struct:pointer_block	file:
pb_id	memline.c	/^    short_u	pb_id;		\/* ID for pointer block: PTR_ID *\/$/;"	m	struct:pointer_block	file:
pb_pointer	memline.c	/^    PTR_EN	pb_pointer[1];	\/* list of pointers to blocks (actually longer)$/;"	m	struct:pointer_block	file:
pc_attr	edit.c	/^static int  pc_attr;$/;"	v	file:
pc_bytes	edit.c	/^static char_u pc_bytes[2];		\/* saved bytes *\/$/;"	v	file:
pc_bytes	edit.c	/^static char_u pc_bytes[MB_MAXBYTES + 1]; \/* saved bytes *\/$/;"	v	file:
pc_col	edit.c	/^static int  pc_col;$/;"	v	file:
pc_row	edit.c	/^static int  pc_row;$/;"	v	file:
pc_status	edit.c	/^static int  pc_status;$/;"	v	file:
pchar	macros.h	16;"	d
pchar_cursor	misc1.c	/^pchar_cursor(c)$/;"	f
pe_bnum	memline.c	/^    blocknr_T	pe_bnum;	\/* block number *\/$/;"	m	struct:pointer_entry	file:
pe_line_count	memline.c	/^    linenr_T	pe_line_count;	\/* number of lines in this branch *\/$/;"	m	struct:pointer_entry	file:
pe_old_lnum	memline.c	/^    linenr_T	pe_old_lnum;	\/* lnum for this block (for recovery) *\/$/;"	m	struct:pointer_entry	file:
pe_page_count	memline.c	/^    int		pe_page_count;	\/* number of pages in block pe_bnum *\/$/;"	m	struct:pointer_entry	file:
peekchr	regexp.c	/^peekchr()$/;"	f	file:
pen	gui_amiga.c	/^    WORD pen;$/;"	m	struct:MyColor	file:
pending	structs.h	/^    int pending;		\/* error\/interrupt\/exception state *\/$/;"	m	struct:cleanup_stuff
percentage	structs.h	/^    int		percentage;	\/* percentage of cell for bar *\/$/;"	m	struct:cursor_entry
perl_private	structs.h	/^    void	*perl_private;$/;"	m	struct:file_buffer
perl_private	structs.h	/^    void	*perl_private;$/;"	m	struct:window
pixval	gui.h	/^    int		pixval;		\/* pixel count of value *\/$/;"	m	struct:GuiScrollbar
plines	misc1.c	/^plines(lnum)$/;"	f
plines_m_win	misc1.c	/^plines_m_win(wp, first, last)$/;"	f
plines_nofill	misc1.c	/^plines_nofill(lnum)$/;"	f
plines_win	misc1.c	/^plines_win(wp, lnum, winheight)$/;"	f
plines_win_col	misc1.c	/^plines_win_col(wp, lnum, column)$/;"	f
plines_win_nofill	misc1.c	/^plines_win_nofill(wp, lnum, winheight)$/;"	f
plines_win_nofold	misc1.c	/^plines_win_nofold(wp, lnum)$/;"	f
pointerEvent	gui_beval.c	/^pointerEvent(beval, event)$/;"	f	file:
pointerEventEH	gui_beval.c	/^pointerEventEH(w, client_data, event, unused)$/;"	f	file:
pointer_block	memline.c	/^struct pointer_block$/;"	s	file:
pointer_entry	memline.c	/^struct pointer_entry$/;"	s	file:
pointer_event	gui_beval.c	/^pointer_event(BalloonEval *beval, int x, int y, unsigned state)$/;"	f	file:
pointer_hidden	gui.h	/^    int		pointer_hidden;	    \/* Is the mouse pointer hidden? *\/$/;"	m	struct:Gui
pop_current_state	syntax.c	/^pop_current_state()$/;"	f	file:
pop_showcmd	normal.c	/^pop_showcmd()$/;"	f
popup_mode_name	menu.c	/^popup_mode_name(name, idx)$/;"	f	file:
pos	regexp.c	/^	lpos_T	pos;	\/* reginput pos, for multi-line regexp *\/$/;"	m	union:__anon48::__anon49	file:
pos	regexp.c	/^	lpos_T	pos;$/;"	m	union:__anon50::__anon51	file:
pos2off	netbeans.c	/^pos2off(buf_T *buf, pos_T *pos)$/;"	f	file:
posHeightCharToPoint	gui_amiga.c	/^posHeightCharToPoint(int height)$/;"	f	file:
posHeightPointToChar	gui_amiga.c	/^posHeightPointToChar(int height)$/;"	f	file:
posWidthCharToPoint	gui_amiga.c	/^posWidthCharToPoint(int width)$/;"	f	file:
posWidthPointToChar	gui_amiga.c	/^posWidthPointToChar(int width)$/;"	f	file:
pos_T	structs.h	/^} pos_T;$/;"	t	typeref:struct:__anon28
post	testdir/test49.vim	/^		let post = 0$/;"	v
post	testdir/test49.vim	/^	    let post = 0$/;"	v
postpone_keycommand	netbeans.c	/^postpone_keycommand(int key)$/;"	f	file:
postponed_mouseshape	globals.h	/^EXTERN int	postponed_mouseshape INIT(= FALSE); \/* postponed updating the$/;"	v
postponed_split	globals.h	/^EXTERN int	postponed_split INIT(= 0);  \/* for CTRL-W CTRL-] command *\/$/;"	v
postponed_split_flags	globals.h	/^EXTERN int	postponed_split_flags INIT(= 0);  \/* args for win_split() *\/$/;"	v
pre_whitesp	ops.c	/^    int		pre_whitesp;	\/* screen cols of ws before block *\/$/;"	m	struct:block_def	file:
pre_whitesp_c	ops.c	/^    int		pre_whitesp_c;	\/* chars of ws before block *\/$/;"	m	struct:block_def	file:
prechar	structs.h	/^    int		prechar;	\/* prefix character (optional, always 'g') *\/$/;"	m	struct:cmdarg
preedit_buf_len	mbyte.c	/^static int	preedit_buf_len = 0;$/;"	v	file:
preedit_callback_setup	mbyte.c	/^preedit_callback_setup(GdkIC *ic)$/;"	f	file:
preedit_caret_cbproc	mbyte.c	/^preedit_caret_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_done_cbproc	mbyte.c	/^preedit_done_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_draw_cbproc	mbyte.c	/^preedit_draw_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_end_col	globals.h	/^EXTERN colnr_T		preedit_end_col INIT(= MAXCOL);$/;"	v
preedit_start_cbproc	mbyte.c	/^preedit_start_cbproc(XIC xic, XPointer client_data, XPointer call_data)$/;"	f	file:
preedit_start_col	globals.h	/^EXTERN colnr_T		preedit_start_col INIT(= MAXCOL);$/;"	v
prefix	quickfix.c	/^    char_u	    prefix;	\/* prefix of this format line: *\/$/;"	m	struct:eformat	file:
prep_exarg	fileio.c	/^prep_exarg(eap, buf)$/;"	f
prep_redo	normal.c	/^prep_redo(regname, num, cmd1, cmd2, cmd3, cmd4, cmd5)$/;"	f	file:
prep_redo_cmd	normal.c	/^prep_redo_cmd(cap)$/;"	f	file:
prepare_pats	tag.c	/^prepare_pats(pats, has_re)$/;"	f	file:
prepare_search_hl	screen.c	/^prepare_search_hl(wp, lnum)$/;"	f	file:
prepare_tagpreview	ex_cmds.c	/^prepare_tagpreview()$/;"	f
prepare_to_exit	misc1.c	/^prepare_to_exit()$/;"	f
prepare_viminfo_history	ex_getln.c	/^prepare_viminfo_history(asklen)$/;"	f
preprocs_left	ops.c	/^preprocs_left()$/;"	f
present	structs.h	/^    int		present;$/;"	m	struct:__anon43
preserve_exit	misc1.c	/^preserve_exit()$/;"	f
prev	edit.c	/^    struct Completion	*prev;$/;"	m	struct:Completion	typeref:struct:Completion::Completion	file:
prev	netbeans.c	/^    struct cmdqueue *prev;$/;"	m	struct:cmdqueue	typeref:struct:cmdqueue::cmdqueue	file:
prev	netbeans.c	/^    struct keyqueue *prev;$/;"	m	struct:keyqueue	typeref:struct:keyqueue::keyqueue	file:
prev	structs.h	/^    signlist_T  *prev;		\/* previous entry -- for easy reordering *\/$/;"	m	struct:signlist
prev	vim.h	/^    pos_T	prev;		\/* Previous position *\/$/;"	m	struct:VimClipboard
prev_at_start	regexp.c	/^static int	prev_at_start;  \/* True when on the second character *\/$/;"	v	file:
prev_ccline	ex_getln.c	/^static struct cmdline_info  prev_ccline;$/;"	v	typeref:struct:cmdline_info	file:
prev_ccline_used	ex_getln.c	/^static int		    prev_ccline_used = FALSE;$/;"	v	file:
prev_lnum	fold.c	/^static linenr_T prev_lnum = 0;$/;"	v	file:
prev_lnum_lvl	fold.c	/^static int prev_lnum_lvl = -1;$/;"	v	file:
prev_timeval	main.c	/^static struct timeval	prev_timeval;$/;"	v	typeref:struct:timeval	file:
prev_wrap	gui.h	/^    int		prev_wrap;	    \/* For updating the horizontal scrollbar *\/$/;"	m	struct:Gui
prevchr	regexp.c	/^static int	prevchr;$/;"	v	file:
prevchr_len	regexp.c	/^static int	prevchr_len;	\/* byte length of previous char *\/$/;"	v	file:
previous_script	edit.c	/^static short	previous_script = smRoman;$/;"	v	file:
prevprevchr	regexp.c	/^static int	prevprevchr;$/;"	v	file:
prevwin	globals.h	/^EXTERN win_T	*prevwin INIT(= NULL);	\/* previous window *\/$/;"	v
print_line	ex_cmds.c	/^print_line(lnum, use_number)$/;"	f
print_line_no_prefix	ex_cmds.c	/^print_line_no_prefix(lnum, use_number)$/;"	f
print_pos	ex_cmds2.c	/^    int		print_pos;	    \/* virtual column for computing TABs *\/$/;"	m	struct:__anon10	file:
printdigraph	digraph.c	/^printdigraph(dp)$/;"	f	file:
printer_opts	globals.h	/^EXTERN option_table_T printer_opts[OPT_PRINT_NUM_OPTIONS]$/;"	v
printer_page_num	ex_cmds2.c	/^static linenr_T printer_page_num;$/;"	v	file:
priority	structs.h	/^    int		priority;	    \/* Menu order priority *\/$/;"	m	struct:VimMenu
process_env	main.c	/^process_env(env, is_viminit)$/;"	f
process_still_running	memline.c	/^static int process_still_running;$/;"	v	file:
processing_queued_event	mbyte.c	/^static gboolean processing_queued_event = FALSE;$/;"	v	file:
prog	quickfix.c	/^    regprog_T	    *prog;	\/* pre-formatted part of 'errorformat' *\/$/;"	m	struct:eformat	file:
prog_magic_wrong	regexp.c	/^prog_magic_wrong()$/;"	f	file:
program	regexp.h	/^    char_u		program[1];		\/* actually longer.. *\/$/;"	m	struct:__anon3
prop	mbyte.c	/^{   char *name;		int prop;		int codepage;}$/;"	m	struct:__anon11	file:
propGadget	gui_amiga.c	/^static struct Gadget propGadget = { NULL, -12, 15, 10, -28,$/;"	v	typeref:struct:Gadget	file:
prt_add_resource	ex_cmds2.c	/^prt_add_resource(resource)$/;"	f	file:
prt_attribute_change	ex_cmds2.c	/^static int prt_attribute_change;$/;"	v	file:
prt_bgcol	ex_cmds2.c	/^static int prt_bgcol;$/;"	v	file:
prt_bgcol_offset	ex_cmds2.c	/^static float prt_bgcol_offset;$/;"	v	file:
prt_bottom_margin	ex_cmds2.c	/^static float prt_bottom_margin;$/;"	v	file:
prt_char_width	ex_cmds2.c	/^static float prt_char_width;$/;"	v	file:
prt_check_resource	ex_cmds2.c	/^prt_check_resource(resource, version)$/;"	f	file:
prt_collate	ex_cmds2.c	/^static int prt_collate;$/;"	v	file:
prt_conv	ex_cmds2.c	/^static vimconv_T prt_conv;$/;"	v	file:
prt_def_font	ex_cmds2.c	/^prt_def_font(new_name, encoding, height, font)$/;"	f	file:
prt_def_var	ex_cmds2.c	/^prt_def_var(name, value, prec)$/;"	f	file:
prt_do_bgcol	ex_cmds2.c	/^static int prt_do_bgcol;$/;"	v	file:
prt_do_conv	ex_cmds2.c	/^static int prt_do_conv;$/;"	v	file:
prt_do_moveto	ex_cmds2.c	/^static int prt_do_moveto;$/;"	v	file:
prt_do_underline	ex_cmds2.c	/^static int prt_do_underline;$/;"	v	file:
prt_dsc_atend	ex_cmds2.c	4361;"	d	file:
prt_dsc_docmedia	ex_cmds2.c	/^prt_dsc_docmedia(paper_name, width, height, weight, colour, type)$/;"	f	file:
prt_dsc_ints	ex_cmds2.c	/^prt_dsc_ints(comment, count, ints)$/;"	f	file:
prt_dsc_noarg	ex_cmds2.c	/^prt_dsc_noarg(comment)$/;"	f	file:
prt_dsc_requirements	ex_cmds2.c	/^prt_dsc_requirements(duplex, tumble, collate, color, num_copies)$/;"	f	file:
prt_dsc_resources	ex_cmds2.c	/^prt_dsc_resources(comment, type, count, strings)$/;"	f	file:
prt_dsc_start	ex_cmds2.c	/^prt_dsc_start()$/;"	f	file:
prt_dsc_text	ex_cmds2.c	/^prt_dsc_text(comment, text)$/;"	f	file:
prt_dsc_textline	ex_cmds2.c	/^prt_dsc_textline(comment, text)$/;"	f	file:
prt_duplex	ex_cmds2.c	/^static int prt_duplex;$/;"	v	file:
prt_fgcol	ex_cmds2.c	/^static int prt_fgcol;$/;"	v	file:
prt_file_error	ex_cmds2.c	/^static int prt_file_error;$/;"	v	file:
prt_find_resource	ex_cmds2.c	/^prt_find_resource(name, resource)$/;"	f	file:
prt_first_line_height	ex_cmds2.c	/^static float prt_first_line_height;$/;"	v	file:
prt_flush_buffer	ex_cmds2.c	/^prt_flush_buffer()$/;"	f	file:
prt_font	ex_cmds2.c	/^static int prt_font;$/;"	v	file:
prt_font_metrics	ex_cmds2.c	/^prt_font_metrics(font_scale)$/;"	f	file:
prt_get_attr	ex_cmds2.c	/^prt_get_attr(hl_id, pattr, modec)$/;"	f	file:
prt_get_cpl	ex_cmds2.c	/^prt_get_cpl()$/;"	f	file:
prt_get_lpp	ex_cmds2.c	/^prt_get_lpp()$/;"	f	file:
prt_get_term_color	ex_cmds2.c	/^prt_get_term_color(colorindex)$/;"	f	file:
prt_get_unit	ex_cmds2.c	/^prt_get_unit(idx)$/;"	f
prt_header	ex_cmds2.c	/^prt_header(psettings, pagenum, lnum)$/;"	f	file:
prt_header_height	ex_cmds2.c	/^prt_header_height()$/;"	f
prt_left_margin	ex_cmds2.c	/^static float prt_left_margin;$/;"	v	file:
prt_line_buffer	ex_cmds2.c	/^static char_u prt_line_buffer[257];$/;"	v	file:
prt_line_height	ex_cmds2.c	/^static float prt_line_height;$/;"	v	file:
prt_line_number	ex_cmds2.c	/^prt_line_number(psettings, page_line, lnum)$/;"	f	file:
prt_media	ex_cmds2.c	/^static int prt_media;$/;"	v	file:
prt_mediasize	ex_cmds2.c	/^static struct prt_mediasize_S prt_mediasize[] =$/;"	v	typeref:struct:prt_mediasize_S	file:
prt_mediasize_S	ex_cmds2.c	/^struct prt_mediasize_S$/;"	s	file:
prt_message	ex_cmds2.c	/^prt_message(s)$/;"	f	file:
prt_need_bgcol	ex_cmds2.c	/^static int prt_need_bgcol;$/;"	v	file:
prt_need_fgcol	ex_cmds2.c	/^static int prt_need_fgcol;$/;"	v	file:
prt_need_font	ex_cmds2.c	/^static int prt_need_font;$/;"	v	file:
prt_need_moveto	ex_cmds2.c	/^static int prt_need_moveto;$/;"	v	file:
prt_need_underline	ex_cmds2.c	/^static int prt_need_underline;$/;"	v	file:
prt_new_bgcol	ex_cmds2.c	/^static int prt_new_bgcol;$/;"	v	file:
prt_num_copies	ex_cmds2.c	/^static int prt_num_copies;$/;"	v	file:
prt_number_width	ex_cmds2.c	/^static float prt_number_width;$/;"	v	file:
prt_open_resource	ex_cmds2.c	/^prt_open_resource(resource)$/;"	f	file:
prt_page_height	ex_cmds2.c	/^static float prt_page_height;$/;"	v	file:
prt_page_margins	ex_cmds2.c	/^prt_page_margins(width, height, left, right, top, bottom)$/;"	f	file:
prt_page_num	ex_cmds2.c	/^static int prt_page_num;$/;"	v	file:
prt_page_width	ex_cmds2.c	/^static float prt_page_width;$/;"	v	file:
prt_portrait	ex_cmds2.c	/^static int prt_portrait;$/;"	v	file:
prt_pos_T	ex_cmds2.c	/^} prt_pos_T;$/;"	t	typeref:struct:__anon10	file:
prt_pos_x	ex_cmds2.c	/^static float prt_pos_x = 0;$/;"	v	file:
prt_pos_x_moveto	ex_cmds2.c	/^static float prt_pos_x_moveto = 0.0;$/;"	v	file:
prt_pos_y	ex_cmds2.c	/^static float prt_pos_y = 0;$/;"	v	file:
prt_pos_y_moveto	ex_cmds2.c	/^static float prt_pos_y_moveto = 0.0;$/;"	v	file:
prt_ps_buffer	ex_cmds2.c	/^static garray_T prt_ps_buffer;$/;"	v	file:
prt_ps_fd	ex_cmds2.c	/^static FILE *prt_ps_fd;$/;"	v	file:
prt_ps_file_name	ex_cmds2.c	/^static char_u *prt_ps_file_name = NULL;$/;"	v	file:
prt_ps_font	ex_cmds2.c	/^static struct prt_ps_font_S prt_ps_font =$/;"	v	typeref:struct:prt_ps_font_S	file:
prt_ps_font_S	ex_cmds2.c	/^struct prt_ps_font_S$/;"	s	file:
prt_ps_resource_S	ex_cmds2.c	/^struct prt_ps_resource_S$/;"	s	file:
prt_real_bits	ex_cmds2.c	/^prt_real_bits(real, precision, pinteger, pfraction)$/;"	f	file:
prt_resource_name	ex_cmds2.c	/^prt_resource_name(filename)$/;"	f	file:
prt_right_margin	ex_cmds2.c	/^static float prt_right_margin;$/;"	v	file:
prt_set_bg	ex_cmds2.c	/^prt_set_bg(bg)$/;"	f	file:
prt_set_fg	ex_cmds2.c	/^prt_set_fg(fg)$/;"	f	file:
prt_set_font	ex_cmds2.c	/^prt_set_font(bold, italic, underline)$/;"	f	file:
prt_settings_T	structs.h	/^} prt_settings_T;$/;"	t	typeref:struct:__anon45
prt_text_attr_T	structs.h	/^} prt_text_attr_T;$/;"	t	typeref:struct:__anon44
prt_text_count	ex_cmds2.c	/^static int prt_text_count;$/;"	v	file:
prt_top_margin	ex_cmds2.c	/^static float prt_top_margin;$/;"	v	file:
prt_tumble	ex_cmds2.c	/^static int prt_tumble;$/;"	v	file:
prt_underline	ex_cmds2.c	/^static int prt_underline;$/;"	v	file:
prt_use_number	ex_cmds2.c	/^prt_use_number()$/;"	f
prt_write_boolean	ex_cmds2.c	/^prt_write_boolean(b)$/;"	f	file:
prt_write_file	ex_cmds2.c	/^prt_write_file(buffer)$/;"	f	file:
prt_write_file_len	ex_cmds2.c	/^prt_write_file_len(buffer, bytes)$/;"	f	file:
prt_write_file_raw_len	ex_cmds2.c	/^prt_write_file_raw_len(buffer, bytes)$/;"	f	file:
prt_write_int	ex_cmds2.c	/^prt_write_int(i)$/;"	f	file:
prt_write_real	ex_cmds2.c	/^prt_write_real(val, prec)$/;"	f	file:
prt_write_string	ex_cmds2.c	/^prt_write_string(s)$/;"	f	file:
ps_fontname	ex_cmds2.c	/^    char	*(ps_fontname[4]);$/;"	m	struct:prt_ps_font_S	file:
psepc	globals.h	/^EXTERN char	psepc INIT(= '\\\\');	\/* normal path separator character *\/$/;"	v
psepcN	globals.h	/^EXTERN char	psepcN INIT(= '\/');	\/* abnormal path separator character *\/$/;"	v
pseps	globals.h	/^EXTERN char	pseps[2]		\/* normal path separator string *\/$/;"	v
psepsN	globals.h	/^EXTERN char	psepsN[2]		\/* abnormal path separator string *\/$/;"	v
pseudo_code	misc2.c	/^    int	    pseudo_code;	\/* Code for pseudo mouse event *\/$/;"	m	struct:mousetable	file:
pstrcmp	misc1.c	/^pstrcmp(const void *a, const void *b)$/;"	f	file:
ptag_entry	tag.c	/^static taggy_T ptag_entry = {NULL};$/;"	v	file:
ptr	regexp.c	/^	char_u	*ptr;	\/* reginput pointer, for single-line regexp *\/$/;"	m	union:__anon48::__anon49	file:
ptr	regexp.c	/^	char_u	*ptr;$/;"	m	union:__anon50::__anon51	file:
ptr2cells	charset.c	/^ptr2cells(p)$/;"	f
push_current_state	syntax.c	/^push_current_state(idx)$/;"	f	file:
push_next_match	syntax.c	/^push_next_match(cur_si)$/;"	f	file:
push_raw_key	ui.c	/^push_raw_key (s, len)$/;"	f
push_showcmd	normal.c	/^push_showcmd()$/;"	f
put_and_redo	farsi.c	/^put_and_redo(c)$/;"	f	file:
put_curr_and_l_to_X	farsi.c	/^put_curr_and_l_to_X(c)$/;"	f	file:
put_eol	ex_docmd.c	/^put_eol(fd)$/;"	f
put_escstr	getchar.c	/^put_escstr(fd, strstart, what)$/;"	f
put_foldopen_recurse	fold.c	/^put_foldopen_recurse(fd, gap, off)$/;"	f	file:
put_folds	fold.c	/^put_folds(fd, wp)$/;"	f
put_folds_recurse	fold.c	/^put_folds_recurse(fd, gap, off)$/;"	f	file:
put_id_list	syntax.c	/^put_id_list(name, list, attr)$/;"	f	file:
put_in_typebuf	ops.c	/^put_in_typebuf(s, colon)$/;"	f	file:
put_line	ex_docmd.c	/^put_line(fd, s)$/;"	f
put_on_cmdline	ex_getln.c	/^put_on_cmdline(str, len, redraw)$/;"	f
put_pattern	syntax.c	/^put_pattern(s, c, spp, attr)$/;"	f	file:
put_reedit_in_typebuf	ops.c	/^put_reedit_in_typebuf()$/;"	f	file:
put_register	ops.c	/^put_register(name, reg)$/;"	f
put_setbool	option.c	/^put_setbool(fd, cmd, name, value)$/;"	f	file:
put_setnum	option.c	/^put_setnum(fd, cmd, name, valuep)$/;"	f	file:
put_setstring	option.c	/^put_setstring(fd, cmd, name, valuep, expand)$/;"	f	file:
put_view	ex_docmd.c	/^put_view(fd, wp, add_edit, flagp)$/;"	f	file:
putcmdline	ex_getln.c	/^putcmdline(c, shift)$/;"	f
putdigraph	digraph.c	/^putdigraph(str)$/;"	f
putenv	misc2.c	/^putenv(string)$/;"	f
python_ref	structs.h	/^    void	*python_ref;	\/* The Python value referring to this buffer *\/$/;"	m	struct:file_buffer
python_ref	structs.h	/^    void	*python_ref;	\/* The Python value referring to this$/;"	m	struct:window
qf_add_entry	quickfix.c	/^qf_add_entry(prevp, dir, fname, mesg, lnum, col, virt_col, nr, type, valid)$/;"	f	file:
qf_age	ex_docmd.c	119;"	d	file:
qf_age	quickfix.c	/^qf_age(eap)$/;"	f
qf_clean_dir_stack	quickfix.c	/^qf_clean_dir_stack(stackptr)$/;"	f	file:
qf_cleared	quickfix.c	/^    char_u	     qf_cleared;\/* set to TRUE if line has been deleted *\/$/;"	m	struct:qf_line	file:
qf_col	quickfix.c	/^    int		     qf_col;	\/* column where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_count	quickfix.c	/^    int  qf_count;		\/* number of errors (0 means no error list) *\/$/;"	m	struct:qf_list	file:
qf_curlist	quickfix.c	/^static int	qf_curlist = 0;	\/* current error list *\/$/;"	v	file:
qf_current_entry	quickfix.c	/^qf_current_entry()$/;"	f
qf_fill_buffer	quickfix.c	/^qf_fill_buffer()$/;"	f	file:
qf_find_buf	quickfix.c	/^qf_find_buf()$/;"	f	file:
qf_fmt_text	quickfix.c	/^qf_fmt_text(text, buf, bufsize)$/;"	f	file:
qf_fnum	quickfix.c	/^    int		     qf_fnum;	\/* file number for the line *\/$/;"	m	struct:qf_line	file:
qf_free	quickfix.c	/^qf_free(idx)$/;"	f	file:
qf_get_fnum	quickfix.c	/^qf_get_fnum(directory, fname)$/;"	f	file:
qf_guess_filepath	quickfix.c	/^qf_guess_filepath(filename)$/;"	f	file:
qf_index	quickfix.c	/^    int  qf_index;		\/* current index in the error list *\/$/;"	m	struct:qf_list	file:
qf_init	quickfix.c	/^qf_init(efile, errorformat, newlist)$/;"	f
qf_jump	quickfix.c	/^qf_jump(dir, errornr, forceit)$/;"	f
qf_line	quickfix.c	/^struct qf_line$/;"	s	file:
qf_list	ex_docmd.c	118;"	d	file:
qf_list	quickfix.c	/^qf_list(eap)$/;"	f
qf_list	quickfix.c	/^struct qf_list$/;"	s	file:
qf_listcount	quickfix.c	/^static int	qf_listcount = 0;   \/* current number of lists *\/$/;"	v	file:
qf_lists	quickfix.c	/^} qf_lists[LISTCOUNT];$/;"	v	typeref:struct:qf_list
qf_lnum	quickfix.c	/^    linenr_T	     qf_lnum;	\/* line number where the error occurred *\/$/;"	m	struct:qf_line	file:
qf_mark_adjust	quickfix.c	/^qf_mark_adjust(line1, line2, amount, amount_after)$/;"	f
qf_msg	quickfix.c	/^qf_msg()$/;"	f	file:
qf_new_list	quickfix.c	/^qf_new_list()$/;"	f	file:
qf_next	quickfix.c	/^    struct qf_line  *qf_next;	\/* pointer to next error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_nonevalid	quickfix.c	/^    int  qf_nonevalid;		\/* TRUE if not a single valid entry found *\/$/;"	m	struct:qf_list	file:
qf_nr	quickfix.c	/^    int		     qf_nr;	\/* error number *\/$/;"	m	struct:qf_line	file:
qf_pop_dir	quickfix.c	/^qf_pop_dir(stackptr)$/;"	f	file:
qf_prev	quickfix.c	/^    struct qf_line  *qf_prev;	\/* pointer to previous error in the list *\/$/;"	m	struct:qf_line	typeref:struct:qf_line::qf_line	file:
qf_ptr	quickfix.c	/^    struct qf_line *qf_ptr;	\/* pointer to the current error *\/$/;"	m	struct:qf_list	typeref:struct:qf_list::qf_line	file:
qf_push_dir	quickfix.c	/^qf_push_dir(dirbuf, stackptr)$/;"	f	file:
qf_start	quickfix.c	/^    struct qf_line *qf_start;	\/* pointer to the first error *\/$/;"	m	struct:qf_list	typeref:struct:qf_list::qf_line	file:
qf_text	quickfix.c	/^    char_u	    *qf_text;	\/* description of the error *\/$/;"	m	struct:qf_line	file:
qf_type	quickfix.c	/^    char_u	     qf_type;	\/* type of the error (mostly 'E'); 1 for$/;"	m	struct:qf_line	file:
qf_types	quickfix.c	/^qf_types(c, nr)$/;"	f	file:
qf_update_buffer	quickfix.c	/^qf_update_buffer()$/;"	f	file:
qf_valid	quickfix.c	/^    char_u	     qf_valid;	\/* valid error message detected *\/$/;"	m	struct:qf_line	file:
qf_virt_col	quickfix.c	/^    char_u	     qf_virt_col; \/* set to TRUE if qf_col is screen column *\/$/;"	m	struct:qf_line	file:
qf_win_pos_update	quickfix.c	/^qf_win_pos_update(old_qf_index)$/;"	f	file:
qsort	misc2.c	/^qsort(base, elm_count, elm_size, cmp)$/;"	f
queue_T	netbeans.c	/^typedef struct cmdqueue queue_T;$/;"	t	typeref:struct:cmdqueue	file:
quit_more	globals.h	/^EXTERN int	quit_more INIT(= FALSE);    \/* 'q' hit at "--more--" msg *\/$/;"	v
quitmore	ex_docmd.c	/^static int	quitmore = 0;$/;"	v	file:
quits_skipped	testdir/test49.vim	/^    let quits_skipped = 0$/;"	v
quote_meta	edit.c	/^quote_meta(dest, src, len)$/;"	f	file:
rangeEnd	mbyte.c	/^    int rangeEnd;$/;"	m	struct:__anon13	file:
rangeStart	mbyte.c	/^    int rangeStart;$/;"	m	struct:__anon13	file:
raw_in	os_amiga.c	/^static BPTR		raw_in = (BPTR)NULL;$/;"	v	file:
raw_out	os_amiga.c	/^static BPTR		raw_out = (BPTR)NULL;$/;"	v	file:
rc_did_emsg	globals.h	/^EXTERN int	rc_did_emsg INIT(= FALSE);  \/* vim_regcomp() called emsg() *\/$/;"	v
re_extmatch_in	globals.h	/^EXTERN reg_extmatch_T *re_extmatch_in INIT(= NULL); \/* Used by vim_regexec():$/;"	v
re_extmatch_out	globals.h	/^EXTERN reg_extmatch_T *re_extmatch_out INIT(= NULL); \/* Set by vim_regexec()$/;"	v
re_has_z	regexp.c	/^static int	re_has_z;	\/* \\z item detected *\/$/;"	v	file:
re_lookbehind	regexp.c	/^re_lookbehind(prog)$/;"	f
re_multi_type	regexp.c	/^re_multi_type(c)$/;"	f	file:
re_multiline	regexp.c	/^re_multiline(prog)$/;"	f
re_num_cmp	regexp.c	/^re_num_cmp(val, scan)$/;"	f	file:
re_put_long	regexp.c	/^re_put_long(p, val)$/;"	f	file:
read_cmd_fd	globals.h	/^EXTERN int	read_cmd_fd INIT(= 0);	    \/* fd to read commands from *\/$/;"	v
read_error_exit	ui.c	/^read_error_exit()$/;"	f
read_from_input_buf	ui.c	/^read_from_input_buf(buf, maxlen)$/;"	f
read_limits	regexp.c	/^read_limits(minval, maxval)$/;"	f	file:
read_redo	getchar.c	/^read_redo(init, old_redo)$/;"	f	file:
read_stuff	getchar.c	/^read_stuff(advance)$/;"	f	file:
read_viminfo	ex_cmds.c	/^read_viminfo(file, want_info, want_marks, forceit)$/;"	f
read_viminfo_bufferlist	buffer.c	/^read_viminfo_bufferlist(virp, writing)$/;"	f
read_viminfo_filemark	mark.c	/^read_viminfo_filemark(virp, force)$/;"	f
read_viminfo_history	ex_getln.c	/^read_viminfo_history(virp)$/;"	f
read_viminfo_register	ops.c	/^read_viminfo_register(virp, force)$/;"	f
read_viminfo_search_pattern	search.c	/^read_viminfo_search_pattern(virp, force)$/;"	f
read_viminfo_sub_string	ex_cmds.c	/^read_viminfo_sub_string(virp, force)$/;"	f
read_viminfo_up_to_marks	ex_cmds.c	/^read_viminfo_up_to_marks(virp, forceit, writing)$/;"	f	file:
read_viminfo_varlist	eval.c	/^read_viminfo_varlist(virp, writing)$/;"	f
readfile	fileio.c	/^readfile(fname, sfname, from, lines_to_skip, lines_to_read, eap, flags)$/;"	f
readfile_charconvert	fileio.c	/^readfile_charconvert(fname, fenc, fdp)$/;"	f	file:
readonlymode	globals.h	/^EXTERN int	readonlymode INIT(= FALSE); \/* Set to TRUE for "view" *\/$/;"	v
realloc_cmdbuff	ex_getln.c	/^realloc_cmdbuff(len)$/;"	f	file:
received_from_client	globals.h	/^EXTERN int	received_from_client INIT(= FALSE);	\/* received text from$/;"	v
recordbuff	getchar.c	/^static struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
recov_file_names	memline.c	/^recov_file_names(names, path, prepend_dot)$/;"	f	file:
recover_names	memline.c	/^recover_names(fname, list, nr)$/;"	f
recoverymode	globals.h	/^EXTERN int	recoverymode INIT(= FALSE); \/* Set to TRUE for "-r" option *\/$/;"	v
red	gui_amiga.c	/^	UBYTE		red;$/;"	m	struct:guicolor_tTable	file:
redir_fd	globals.h	/^EXTERN FILE *redir_fd INIT(= NULL);	\/* message redirection file *\/$/;"	v
redir_off	globals.h	/^EXTERN int  redir_off INIT(= FALSE);	\/* no redirection for a moment *\/$/;"	v
redir_reg	globals.h	/^EXTERN int  redir_reg INIT(= 0);	\/* message redirection register *\/$/;"	v
redir_write	message.c	/^redir_write(str, maxlen)$/;"	f	file:
redo_VIsual_busy	globals.h	/^EXTERN int	redo_VIsual_busy INIT(= FALSE);$/;"	v
redo_literal	edit.c	/^redo_literal(c)$/;"	f	file:
redobuff	getchar.c	/^static struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
redrawWinline	screen.c	/^redrawWinline(lnum, invalid)$/;"	f
redraw_all_later	screen.c	/^redraw_all_later(type)$/;"	f
redraw_block	screen.c	/^redraw_block(row, end, wp)$/;"	f	file:
redraw_buf_later	screen.c	/^redraw_buf_later(buf, type)$/;"	f
redraw_cmdline	globals.h	/^EXTERN int	redraw_cmdline INIT(= FALSE);	\/* cmdline must be redrawn *\/$/;"	v
redraw_curbuf_later	screen.c	/^redraw_curbuf_later(type)$/;"	f
redraw_later	screen.c	/^redraw_later(type)$/;"	f
redraw_later_clear	screen.c	/^redraw_later_clear()$/;"	f
redraw_statuslines	screen.c	/^redraw_statuslines()$/;"	f
redraw_win_later	screen.c	/^redraw_win_later(wp, type)$/;"	f
redrawcmd	ex_getln.c	/^redrawcmd()$/;"	f
redrawcmd_preedit	ex_getln.c	/^redrawcmd_preedit()$/;"	f	file:
redrawcmdline	ex_getln.c	/^redrawcmdline()$/;"	f
redrawcmdprompt	ex_getln.c	/^redrawcmdprompt()$/;"	f	file:
redrawing	screen.c	/^redrawing()$/;"	f
ref_extmatch	regexp.c	/^ref_extmatch(em)$/;"	f
refcnt	regexp.h	/^    short		refcnt;$/;"	m	struct:__anon6
refreshBorder	gui_amiga.c	/^refreshBorder(void)$/;"	f	file:
reg	regexp.c	/^reg(paren, flagp)$/;"	f	file:
reg_buf	regexp.c	/^static buf_T		*reg_buf;$/;"	v	file:
reg_do_extmatch	globals.h	/^EXTERN int	reg_do_extmatch INIT(= 0);  \/* Used when compiling regexp:$/;"	v
reg_endp	regexp.c	/^static char_u		**reg_endp = NULL;$/;"	v	file:
reg_endpos	regexp.c	/^static lpos_T		*reg_endpos = NULL;$/;"	v	file:
reg_endzp	regexp.c	/^static char_u	*reg_endzp[NSUBEXP];	\/*   and end of \\z(...\\) matches *\/$/;"	v	file:
reg_endzpos	regexp.c	/^static lpos_T	reg_endzpos[NSUBEXP];	\/* idem, end pos *\/$/;"	v	file:
reg_extmatch_T	regexp.h	/^} reg_extmatch_T;$/;"	t	typeref:struct:__anon6
reg_firstlnum	regexp.c	/^static linenr_T		reg_firstlnum;$/;"	v	file:
reg_getline	regexp.c	/^reg_getline(lnum)$/;"	f	file:
reg_line_lbr	regexp.c	/^static int		reg_line_lbr;	    \/* "\\n" in string is line break *\/$/;"	v	file:
reg_magic	regexp.c	/^static int	reg_magic;	\/* magicness of the pattern: *\/$/;"	v	file:
reg_match	regexp.c	/^static regmatch_T	*reg_match;$/;"	v	file:
reg_maxline	regexp.c	/^static linenr_T		reg_maxline;$/;"	v	file:
reg_mmatch	regexp.c	/^static regmmatch_T	*reg_mmatch;$/;"	v	file:
reg_nextline	regexp.c	/^reg_nextline()$/;"	f	file:
reg_pat	fileio.c	/^    char_u	    *reg_pat;		\/* pattern converted to regexp *\/$/;"	m	struct:AutoPat	file:
reg_prev_class	regexp.c	/^reg_prev_class()$/;"	f	file:
reg_prev_sub	regexp.c	/^static char_u		*reg_prev_sub;$/;"	v	file:
reg_restore	regexp.c	/^reg_restore(save)$/;"	f	file:
reg_save	regexp.c	/^reg_save(save)$/;"	f	file:
reg_save_equal	regexp.c	/^reg_save_equal(save)$/;"	f	file:
reg_startp	regexp.c	/^static char_u		**reg_startp = NULL;$/;"	v	file:
reg_startpos	regexp.c	/^static lpos_T		*reg_startpos = NULL;$/;"	v	file:
reg_startzp	regexp.c	/^static char_u	*reg_startzp[NSUBEXP];	\/* Workspace to mark beginning *\/$/;"	v	file:
reg_startzpos	regexp.c	/^static lpos_T	reg_startzpos[NSUBEXP];	\/* idem, beginning pos *\/$/;"	v	file:
reg_string	regexp.c	/^static int	reg_string;	\/* matching with a string instead of a buffer$/;"	v	file:
reg_submatch	regexp.c	/^reg_submatch(no)$/;"	f
reg_syn	globals.h	/^EXTERN int	reg_syn INIT(= 0);	    \/* vim_regexec() used for syntax *\/$/;"	v
reg_tofree	regexp.c	/^static char_u	*reg_tofree;$/;"	v	file:
reg_tofreelen	regexp.c	/^static unsigned	reg_tofreelen;$/;"	v	file:
reg_win	regexp.c	/^static win_T		*reg_win;$/;"	v	file:
reganch	regexp.h	/^    char_u		reganch;$/;"	m	struct:__anon3
regatom	regexp.c	/^regatom(flagp)$/;"	f	file:
regbranch	regexp.c	/^regbranch(flagp)$/;"	f	file:
regc	regexp.c	/^regc(b)$/;"	f	file:
regcode	regexp.c	/^static char_u	*regcode;	\/* Code-emit pointer, or JUST_CALC_SIZE *\/$/;"	v	file:
regcomp_start	regexp.c	/^regcomp_start(expr, re_flags)$/;"	f	file:
regconcat	regexp.c	/^regconcat(flagp)$/;"	f	file:
regdump	regexp.c	/^regdump(pattern, r)$/;"	f	file:
regflags	regexp.c	/^static unsigned	regflags;	\/* RF_ flags for prog *\/$/;"	v	file:
regflags	regexp.h	/^    unsigned		regflags;$/;"	m	struct:__anon3
reghasz	regexp.h	/^    char_u		reghasz;$/;"	m	struct:__anon3
reginput	regexp.c	/^static char_u	*reginput;	\/* current input, points into "regline" *\/$/;"	v	file:
reginsert	regexp.c	/^reginsert(op, opnd)$/;"	f	file:
reginsert_limits	regexp.c	/^reginsert_limits(op, minval, maxval, opnd)$/;"	f	file:
regline	regexp.c	/^static char_u	*regline;	\/* start of current line *\/$/;"	v	file:
reglnum	regexp.c	/^static linenr_T	reglnum;	\/* line number, relative to first line *\/$/;"	v	file:
regmatch	regexp.c	/^regmatch(scan)$/;"	f	file:
regmatch	tag.c	/^    regmatch_T	regmatch;	\/* regexp program, may be NULL *\/$/;"	m	struct:__anon8	file:
regmatch_T	regexp.h	/^} regmatch_T;$/;"	t	typeref:struct:__anon4
regmbc	regexp.c	/^regmbc(c)$/;"	f	file:
regmlen	regexp.h	/^    int			regmlen;$/;"	m	struct:__anon3
regmmatch_T	regexp.h	/^} regmmatch_T;$/;"	t	typeref:struct:__anon5
regmust	regexp.h	/^    char_u		*regmust;$/;"	m	struct:__anon3
regname	ex_cmds.h	/^    int		regname;	\/* register name (NUL if none) *\/$/;"	m	struct:exarg
regname	structs.h	/^    int		regname;	\/* register to use for the operator *\/$/;"	m	struct:oparg
regnarrate	regexp.c	/^int		regnarrate = 0;$/;"	v
regnext	regexp.c	/^regnext(p)$/;"	f	file:
regnode	regexp.c	/^regnode(op)$/;"	f	file:
regnpar	regexp.c	/^static int	regnpar;	\/* () count. *\/$/;"	v	file:
regnzpar	regexp.c	/^static int	regnzpar;	\/* \\z() count. *\/$/;"	v	file:
regoptail	regexp.c	/^regoptail(p, val)$/;"	f	file:
regparse	regexp.c	/^static char_u	*regparse;	\/* Input-scan pointer. *\/$/;"	v	file:
regpiece	regexp.c	/^regpiece(flagp)$/;"	f	file:
regprog	regexp.h	/^    regprog_T		*regprog;$/;"	m	struct:__anon4
regprog	regexp.h	/^    regprog_T		*regprog;$/;"	m	struct:__anon5
regprog_T	regexp.h	/^} regprog_T;$/;"	t	typeref:struct:__anon3
regprop	regexp.c	/^regprop(op)$/;"	f	file:
regrepeat	regexp.c	/^regrepeat(p, maxcount)$/;"	f	file:
regsave_T	regexp.c	/^} regsave_T;$/;"	t	typeref:struct:__anon48	file:
regsize	regexp.c	/^static long	regsize;	\/* Code size. *\/$/;"	v	file:
regstart	regexp.h	/^    int			regstart;$/;"	m	struct:__anon3
regtail	regexp.c	/^regtail(p, val)$/;"	f	file:
regtilde	regexp.c	/^regtilde(source, magic)$/;"	f
regtry	regexp.c	/^regtry(prog, col)$/;"	f	file:
rem_backslash	charset.c	/^rem_backslash(str)$/;"	f
remote_common	eval.c	/^remote_common(argvars, retvar, expr)$/;"	f	file:
removable	mark.c	/^removable(name)$/;"	f
removeEventHandler	gui_beval.c	/^removeEventHandler(BalloonEval *beval)$/;"	f	file:
removeEventHandler	gui_beval.c	/^removeEventHandler(beval)$/;"	f	file:
remove_key_from_history	ex_getln.c	/^remove_key_from_history()$/;"	f
remove_menu	menu.c	/^remove_menu(menup, name, modes, silent)$/;"	f	file:
remove_tail	misc1.c	/^remove_tail(p, pend, name)$/;"	f	file:
remove_tail_with_ext	misc1.c	/^remove_tail_with_ext(p, pend, ext)$/;"	f	file:
repeat_cmdline	globals.h	/^EXTERN char_u	*repeat_cmdline INIT(= NULL); \/* command line for "." *\/$/;"	v
repeat_message	message.c	/^repeat_message()$/;"	f
repeating	ex_docmd.c	/^    int		repeating;		\/* TRUE when looping a second time *\/$/;"	m	struct:while_cookie	file:
repl_cmdline	ex_docmd.c	/^repl_cmdline(eap, src, srclen, repl, cmdlinep)$/;"	f	file:
replace_do_bs	edit.c	/^replace_do_bs()$/;"	f	file:
replace_flush	edit.c	/^replace_flush()$/;"	f	file:
replace_join	edit.c	/^replace_join(off)$/;"	f	file:
replace_offset	globals.h	/^EXTERN int	replace_offset INIT(= 0);   \/* offset for replace_push() *\/$/;"	v
replace_pop	edit.c	/^replace_pop()$/;"	f	file:
replace_pop_ins	edit.c	/^replace_pop_ins()$/;"	f	file:
replace_push	edit.c	/^replace_push(c)$/;"	f
replace_push_off	edit.c	/^replace_push_off(c)$/;"	f	file:
replace_stack	edit.c	/^char_u	*replace_stack = NULL;$/;"	v
replace_stack_len	edit.c	/^long	replace_stack_len = 0;	    \/* max. number of entries *\/$/;"	v
replace_stack_nr	edit.c	/^long	replace_stack_nr = 0;	    \/* next entry in replace stack *\/$/;"	v
replace_termcodes	term.c	/^replace_termcodes(from, bufp, from_part, do_lt)$/;"	f
report_discard_pending	ex_eval.c	/^report_discard_pending(pending, value)$/;"	f
report_make_pending	ex_eval.c	/^report_make_pending(pending, value)$/;"	f
report_pending	ex_eval.c	/^report_pending(action, pending, value)$/;"	f	file:
report_resume_pending	ex_eval.c	/^report_resume_pending(pending, value)$/;"	f
req_codes_from_term	term.c	/^req_codes_from_term()$/;"	f	file:
req_more_codes_from_term	term.c	/^req_more_codes_from_term()$/;"	f	file:
requestBalloon	gui_beval.c	/^requestBalloon(beval)$/;"	f	file:
resel_VIsual_col	normal.c	/^static colnr_T	resel_VIsual_col;		\/* nr of cols or end col *\/$/;"	v	file:
resel_VIsual_line_count	normal.c	/^static linenr_T	resel_VIsual_line_count;	\/* number of lines *\/$/;"	v	file:
resel_VIsual_mode	normal.c	/^static int	resel_VIsual_mode = NUL;	\/* 'v', 'V', or Ctrl-V *\/$/;"	v	file:
reset_VIsual	normal.c	/^reset_VIsual()$/;"	f
reset_VIsual_and_resel	normal.c	/^reset_VIsual_and_resel()$/;"	f
reset_cterm_colors	screen.c	/^reset_cterm_colors()$/;"	f
reset_last_sourcing	message.c	/^reset_last_sourcing()$/;"	f	file:
reset_modifiable	option.c	/^reset_modifiable()$/;"	f
reset_search_dir	search.c	/^reset_search_dir()$/;"	f
reset_state_setup	mbyte.c	/^reset_state_setup(GdkIC *ic)$/;"	f	file:
resettitle	buffer.c	/^resettitle()$/;"	f
resource_filename	ex_cmds2.c	/^static char_u *resource_filename;$/;"	v	file:
resource_types	ex_cmds2.c	/^static char *resource_types[] =$/;"	v	file:
restart_VIsual_select	normal.c	/^static int	restart_VIsual_select = 0;$/;"	v	file:
restart_edit	globals.h	/^EXTERN int	restart_edit INIT(= 0);	\/* call edit when next cmd finished *\/$/;"	v
restoreRedobuff	getchar.c	/^restoreRedobuff()$/;"	f
restore_cmdline	ex_getln.c	/^restore_cmdline(ccp)$/;"	f	file:
restore_cterm_colors	syntax.c	/^restore_cterm_colors()$/;"	f
restore_funccal	eval.c	/^restore_funccal(fc)$/;"	f
restore_se	regexp.c	2640;"	d	file:
restore_search_patterns	search.c	/^restore_search_patterns()$/;"	f
restore_snapshot	window.c	/^restore_snapshot(close_curwin)$/;"	f	file:
restore_snapshot_rec	window.c	/^restore_snapshot_rec(sn, fr)$/;"	f	file:
restore_typeahead	getchar.c	/^restore_typeahead(tp)$/;"	f
restricted	globals.h	/^EXTERN int	restricted INIT(= FALSE);$/;"	v
result	digraph.c	/^    result_T	result;$/;"	m	struct:digraph	file:
result	testdir/test49.vim	/^	    let result = exists('{EXPR("exists", 2)}')$/;"	v
result	testdir/test49.vim	/^	let result = exists('*{EXPR("exists", 1)}')$/;"	v
result	testdir/test49.vim	/^	let result =$/;"	v
result_T	digraph.c	/^typedef char_u result_T;$/;"	t	file:
result_T	digraph.c	/^typedef int result_T;$/;"	t	file:
retcode	testdir/test49.vim	/^let retcode = I()$/;"	v
returned	eval.c	/^    int		returned;	\/* ":return" used *\/$/;"	m	struct:funccall	file:
retval	structs.h	/^    int		retval;		\/* return: CA_* values *\/$/;"	m	struct:cmdarg
retvar	eval.c	/^    VAR		retvar;		\/* return value variable *\/$/;"	m	struct:funccall	file:
reverse_line	ops.c	/^reverse_line(s)$/;"	f	file:
reverse_text	search.c	/^reverse_text(s)$/;"	f	file:
revins_chars	edit.c	/^int		revins_chars;		\/* how much to skip after edit *\/$/;"	v
revins_legal	edit.c	/^int		revins_legal;		\/* was the last char 'legal'? *\/$/;"	v
revins_on	edit.c	/^int		revins_on;		\/* reverse insert mode on *\/$/;"	v
revins_scol	edit.c	/^int		revins_scol;		\/* start column of revins session *\/$/;"	v
rewind_conditionals	ex_eval.c	/^rewind_conditionals(cstack, idx, cond_type, cond_level)$/;"	f	file:
ri_alpha	regexp.c	585;"	d	file:
ri_alpha	regexp.c	595;"	d	file:
ri_digit	regexp.c	580;"	d	file:
ri_digit	regexp.c	590;"	d	file:
ri_head	regexp.c	584;"	d	file:
ri_head	regexp.c	594;"	d	file:
ri_hex	regexp.c	581;"	d	file:
ri_hex	regexp.c	591;"	d	file:
ri_lower	regexp.c	586;"	d	file:
ri_lower	regexp.c	596;"	d	file:
ri_octal	regexp.c	582;"	d	file:
ri_octal	regexp.c	592;"	d	file:
ri_upper	regexp.c	587;"	d	file:
ri_upper	regexp.c	597;"	d	file:
ri_white	regexp.c	588;"	d	file:
ri_white	regexp.c	598;"	d	file:
ri_word	regexp.c	583;"	d	file:
ri_word	regexp.c	593;"	d	file:
right_sbar_x	gui.h	/^    int		right_sbar_x;	    \/* Calculated x coord for right scrollbar *\/$/;"	m	struct:Gui
rl_mirror	screen.c	/^rl_mirror(str)$/;"	f	file:
rm	screen.c	/^    regmmatch_T	rm;	\/* points to the regexp program; contains last found$/;"	m	struct:__anon1	file:
rm_ic	regexp.h	/^    int			rm_ic;$/;"	m	struct:__anon4
rmm_ic	regexp.h	/^    int			rmm_ic;$/;"	m	struct:__anon5
root_menu	globals.h	/^EXTERN vimmenu_T	*root_menu INIT(= NULL);$/;"	v
row	gui.h	/^    int		row;		    \/* Current cursor row in GUI display *\/$/;"	m	struct:Gui
rs_u	regexp.c	/^    } rs_u;$/;"	m	struct:__anon48	typeref:union:__anon48::__anon49	file:
rsrc_bold_font_name	gui.h	/^    char_u	*rsrc_bold_font_name; \/* Resource bold font name *\/$/;"	m	struct:Gui
rsrc_boldital_font_name	gui.h	/^    char_u	*rsrc_boldital_font_name;  \/* Resource bold-italic font name *\/$/;"	m	struct:Gui
rsrc_font_name	gui.h	/^    char_u	*rsrc_font_name;    \/* Resource font name, used if 'guifont'$/;"	m	struct:Gui
rsrc_input_method	gui.h	/^    char	*rsrc_input_method;$/;"	m	struct:Gui
rsrc_ital_font_name	gui.h	/^    char_u	*rsrc_ital_font_name; \/* Resource italic font name *\/$/;"	m	struct:Gui
rsrc_menu_bg_name	gui.h	/^    char	*rsrc_menu_bg_name;	\/* Color of menu and dialog backgound *\/$/;"	m	struct:Gui
rsrc_menu_fg_name	gui.h	/^    char	*rsrc_menu_fg_name;	\/* Color of menu and dialog foregound *\/$/;"	m	struct:Gui
rsrc_menu_font_name	gui.h	/^    char_u	*rsrc_menu_font_name;    \/* Resource menu Font name *\/$/;"	m	struct:Gui
rsrc_preedit_type_name	gui.h	/^    char	*rsrc_preedit_type_name;$/;"	m	struct:Gui
rsrc_rev_video	gui.h	/^    Bool	rsrc_rev_video;	    \/* Use reverse video? *\/$/;"	m	struct:Gui
rsrc_scroll_bg_name	gui.h	/^    char	*rsrc_scroll_bg_name;	\/* Color of scrollbar background *\/$/;"	m	struct:Gui
rsrc_scroll_fg_name	gui.h	/^    char	*rsrc_scroll_fg_name;	\/* Color of scrollbar foreground *\/$/;"	m	struct:Gui
rsrc_tooltip_bg_name	gui.h	/^    char	*rsrc_tooltip_bg_name;	\/* tooltip background color name *\/$/;"	m	struct:Gui
rsrc_tooltip_fg_name	gui.h	/^    char	*rsrc_tooltip_fg_name;	\/* tooltip foreground color name *\/$/;"	m	struct:Gui
rsrc_tooltip_font_name	gui.h	/^    char_u	*rsrc_tooltip_font_name; \/* tooltip font name *\/$/;"	m	struct:Gui
ru_col	globals.h	/^EXTERN int	ru_col;		\/* column for ruler *\/$/;"	v
ru_wid	globals.h	/^EXTERN int	ru_wid;		\/* 'rulerfmt' width of ruler when non-zero *\/$/;"	v
ruby_ref	structs.h	/^    void	*ruby_ref;$/;"	m	struct:file_buffer
ruby_ref	structs.h	/^    void	*ruby_ref;$/;"	m	struct:window
running_syn_inc_tag	syntax.c	/^static int running_syn_inc_tag = 0;$/;"	v	file:
s_tearoffs	menu.c	/^static int s_tearoffs = FALSE;$/;"	v	file:
safe_vgetc	getchar.c	/^safe_vgetc()$/;"	f
same_encoding	fileio.c	/^same_encoding(a, b)$/;"	f	file:
same_leader	ops.c	/^same_leader(lnum, leader1_len, leader1_flags, leader2_len, leader2_flags)$/;"	f	file:
sandbox	globals.h	/^EXTERN int	sandbox INIT(= 0);$/;"	v
sattr_T	vim.h	315;"	d
save	netbeans.c	/^save(char_u *buf, int len)$/;"	f	file:
saveRedobuff	getchar.c	/^saveRedobuff()$/;"	f
save_buf	structs.h	/^    buf_T	*save_buf;	\/* saved curbuf *\/$/;"	m	struct:__anon42
save_cmdline	ex_getln.c	/^save_cmdline(ccp)$/;"	f	file:
save_cursor	structs.h	/^    pos_T	save_cursor;	\/* saved cursor pos of save_curwin *\/$/;"	m	struct:__anon42
save_curwin	structs.h	/^    win_T	*save_curwin;	\/* saved curwin, NULL if it didn't change *\/$/;"	m	struct:__anon42
save_file_ff	option.c	/^save_file_ff(buf)$/;"	f
save_funccal	eval.c	/^save_funccal()$/;"	f
save_inputbuf	structs.h	/^    char_u		*save_inputbuf;$/;"	m	struct:__anon39
save_level	getchar.c	/^static int save_level = 0;$/;"	v	file:
save_level	search.c	/^static int save_level = 0;$/;"	v	file:
save_old_redobuff	getchar.c	/^static struct buffheader save_old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_p_ls	globals.h	/^EXTERN int  save_p_ls INIT(= -1);	\/* Save 'laststatus' setting *\/$/;"	v
save_p_wmh	globals.h	/^EXTERN int  save_p_wmh INIT(= -1);	\/* Save 'winminheight' setting *\/$/;"	v
save_re_pat	search.c	/^save_re_pat(idx, pat, magic)$/;"	f	file:
save_redobuff	getchar.c	/^static struct buffheader save_redobuff = {{NULL, {NUL}}, NULL, 0, 0};$/;"	v	typeref:struct:buffheader	file:
save_se	regexp.c	2636;"	d	file:
save_se_T	regexp.c	/^} save_se_T;$/;"	t	typeref:struct:__anon50	file:
save_se_multi	regexp.c	/^save_se_multi(savep, posp)$/;"	f	file:
save_se_one	regexp.c	/^save_se_one(savep, pp)$/;"	f	file:
save_search_patterns	search.c	/^save_search_patterns()$/;"	f
save_sm	edit.c	/^static int		    save_sm;$/;"	v	file:
save_stuffbuff	structs.h	/^    struct buffheader	save_stuffbuff;$/;"	m	struct:__anon39	typeref:struct:__anon39::buffheader
save_topfill	structs.h	/^    int		save_topfill;	\/* saved topfill of save_curwin *\/$/;"	m	struct:__anon42
save_topline	structs.h	/^    linenr_T	save_topline;	\/* saved topline of save_curwin *\/$/;"	m	struct:__anon42
save_typeahead	getchar.c	/^save_typeahead(tp)$/;"	f
save_typebuf	getchar.c	/^save_typebuf()$/;"	f
save_typebuf	structs.h	/^    typebuf_T		save_typebuf;$/;"	m	struct:__anon39
saved_cursor	globals.h	/^EXTERN pos_T	saved_cursor		\/* w_cursor before formatting text. *\/$/;"	v
saved_emsg_silent	structs.h	/^    int		saved_emsg_silent;	\/* saved value of "emsg_silent" *\/$/;"	m	struct:eslist_elem
saved_gpath	testdir/test49.vim	/^	let saved_gpath = &g:path$/;"	v
saved_last_idx	search.c	/^static int	    saved_last_idx = 0;$/;"	v	file:
saved_lpath	testdir/test49.vim	/^	let saved_lpath = &l:path$/;"	v
saved_no_hlsearch	search.c	/^static int	    saved_no_hlsearch = 0;$/;"	v	file:
saved_spats	search.c	/^static struct spat  saved_spats[2];$/;"	v	typeref:struct:spat	file:
saved_typebuf	getchar.c	/^static typebuf_T saved_typebuf[NSCRIPT];$/;"	v	file:
sc_col	globals.h	/^EXTERN int	sc_col;		\/* column for shown command *\/$/;"	v
schar_T	vim.h	314;"	d
scid_T	structs.h	/^typedef int		scid_T;		\/* script ID *\/$/;"	t
scl_list	syntax.c	/^    short	    *scl_list;	    \/* IDs in this syntax cluster *\/$/;"	m	struct:syn_cluster	file:
scl_name	syntax.c	/^    char_u	    *scl_name;	    \/* syntax cluster name *\/$/;"	m	struct:syn_cluster	file:
scl_name_u	syntax.c	/^    char_u	    *scl_name_u;    \/* uppercase of scl_name *\/$/;"	m	struct:syn_cluster	file:
screen_Columns	globals.h	/^EXTERN int	screen_Columns INIT(= 0);   \/* actual size of ScreenLines[] *\/$/;"	v
screen_Rows	globals.h	/^EXTERN int	screen_Rows INIT(= 0);	    \/* actual size of ScreenLines[] *\/$/;"	v
screen_attr	screen.c	/^static int	screen_attr = 0;$/;"	v	file:
screen_char	screen.c	/^screen_char(off, row, col)$/;"	f	file:
screen_char_2	screen.c	/^screen_char_2(off, row, col)$/;"	f	file:
screen_char_attr	screen.c	/^static int screen_char_attr = 0;$/;"	v	file:
screen_cleared	globals.h	/^EXTERN int	screen_cleared INIT(= FALSE);	\/* screen has been cleared *\/$/;"	v
screen_cur_col	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_cur_row	screen.c	/^static int	screen_cur_row, screen_cur_col;	\/* last known cursor position *\/$/;"	v	file:
screen_del_lines	screen.c	/^screen_del_lines(off, row, line_count, end, force, wp)$/;"	f
screen_down	screen.c	/^screen_down()$/;"	f
screen_draw_rectangle	screen.c	/^screen_draw_rectangle(row, col, height, width, invert)$/;"	f
screen_fill	screen.c	/^screen_fill(start_row, end_row, start_col, end_col, c1, c2, attr)$/;"	f
screen_getbytes	screen.c	/^screen_getbytes(row, col, bytes, attrp)$/;"	f
screen_height	gui_beval.h	/^    Dimension		screen_height;	\/* screen height in pixels *\/$/;"	m	struct:BalloonEvalStruct
screen_ins_lines	screen.c	/^screen_ins_lines(off, row, line_count, end, wp)$/;"	f	file:
screen_line	screen.c	/^screen_line(row, coloff, endcol, clear_width$/;"	f	file:
screen_putchar	screen.c	/^screen_putchar(c, row, col, attr)$/;"	f
screen_puts	screen.c	/^screen_puts(text, row, col, attr)$/;"	f
screen_puts_len	screen.c	/^screen_puts_len(text, len, row, col, attr)$/;"	f
screen_puts_mbyte	message.c	/^screen_puts_mbyte(s, l, attr)$/;"	f	file:
screen_start	screen.c	/^screen_start()$/;"	f
screen_start_highlight	screen.c	/^screen_start_highlight(attr)$/;"	f	file:
screen_stop_highlight	screen.c	/^screen_stop_highlight()$/;"	f
screen_valid	screen.c	/^screen_valid(clear)$/;"	f
screen_width	gui_beval.h	/^    Dimension		screen_width;	\/* screen width in pixels *\/$/;"	m	struct:BalloonEvalStruct
screenalloc	screen.c	/^screenalloc(clear)$/;"	f
screenclear	screen.c	/^screenclear()$/;"	f
screenclear2	screen.c	/^screenclear2()$/;"	f	file:
scriptC	testdir/test49.vim	/^let scriptC = MakeScript("C")			" X: 1 + 4 + 8$/;"	v
scriptException	testdir/test49.vim	/^let scriptException  = MakeScript("FuncException")$/;"	v
scriptF	testdir/test49.vim	/^    let scriptF = MakeScript("F")$/;"	v
scriptF	testdir/test49.vim	/^let scriptF = MakeScript("F")			" X: 1 + 2 + 8 + 32$/;"	v
scriptF	testdir/test49.vim	/^let scriptF = MakeScript("F", scriptG)$/;"	v
scriptG	testdir/test49.vim	/^let scriptG = MakeScript("G", scriptF)		" X: 128 + 512 + 1024$/;"	v
scriptG	testdir/test49.vim	/^let scriptG = MakeScript("G", scriptT)$/;"	v
scriptH	testdir/test49.vim	/^let scriptH = MakeScript("H", scriptG)		" X: 4096 + 8192 + 16384$/;"	v
scriptID	fileio.c	/^    scid_T	    scriptID;		\/* script ID where defined *\/$/;"	m	struct:AutoCmd	file:
scriptID	option.c	/^    scid_T	scriptID;	\/* script in which the option was last set *\/$/;"	m	struct:vimoption	file:
scriptT	testdir/test49.vim	/^let scriptT = MakeScript("T")$/;"	v
scriptT1	testdir/test49.vim	/^let scriptT1 = MakeScript("T1")			" X: 16 + 64 + 16*16 + 64*16$/;"	v
scriptT2	testdir/test49.vim	/^let scriptT2 = MakeScript("T2", scriptT1)	" X: 4096 + 16384$/;"	v
scriptThrowPoint	testdir/test49.vim	/^let scriptThrowPoint = MakeScript("FuncThrowpoint")$/;"	v
script_ID	eval.c	/^    scid_T	script_ID;	\/* ID of script where function was defined,$/;"	m	struct:ufunc	file:
script_get	ex_getln.c	/^script_get(eap, cmd)$/;"	f
script_names	ex_cmds2.c	/^static garray_T script_names = {0, 0, sizeof(struct scriptstuff), 4, NULL};$/;"	v	file:
scriptin	globals.h	/^EXTERN FILE	*scriptin[NSCRIPT];	    \/* streams to read script from *\/$/;"	v
scriptnames_slash_adjust	ex_cmds2.c	/^scriptnames_slash_adjust()$/;"	f
scriptout	globals.h	/^EXTERN FILE	*scriptout  INIT(= NULL);   \/* stream to write script to *\/$/;"	v
scriptstuff	ex_cmds2.c	/^struct scriptstuff$/;"	s	file:
scroll_bg_pixel	gui.h	/^    guicolor_T	scroll_bg_pixel;	\/* Same in Pixel format *\/$/;"	m	struct:Gui
scroll_cursor_bot	move.c	/^scroll_cursor_bot(min_scroll, set_topbot)$/;"	f
scroll_cursor_halfway	move.c	/^scroll_cursor_halfway(atend)$/;"	f
scroll_cursor_top	move.c	/^scroll_cursor_top(min_scroll, always)$/;"	f
scroll_def_bg_pixel	gui.h	/^    guicolor_T	scroll_def_bg_pixel;  \/* Default scrollbar background *\/$/;"	m	struct:Gui
scroll_def_fg_pixel	gui.h	/^    guicolor_T	scroll_def_fg_pixel;  \/* Default scrollbar foreground *\/$/;"	m	struct:Gui
scroll_fg_pixel	gui.h	/^    guicolor_T	scroll_fg_pixel;	\/* Same in Pixel format *\/$/;"	m	struct:Gui
scroll_line_len	gui.c	/^scroll_line_len(lnum)$/;"	f	file:
scroll_redraw	normal.c	/^scroll_redraw(up, count)$/;"	f
scroll_region	globals.h	/^EXTERN int	scroll_region INIT(= FALSE); \/* term supports scroll region *\/$/;"	v
scroll_region_bot	gui.h	/^    int		scroll_region_bot;  \/* Bottom (last) line of scroll region *\/$/;"	m	struct:Gui
scroll_region_left	gui.h	/^    int		scroll_region_left;  \/* Left (first) column of scroll region *\/$/;"	m	struct:Gui
scroll_region_reset	term.c	/^scroll_region_reset()$/;"	f
scroll_region_right	gui.h	/^    int		scroll_region_right;  \/* Right (last) col. of scroll region *\/$/;"	m	struct:Gui
scroll_region_set	term.c	/^scroll_region_set(wp, off)$/;"	f
scroll_region_top	gui.h	/^    int		scroll_region_top;  \/* Top (first) line of scroll region *\/$/;"	m	struct:Gui
scroll_shift	gui.h	/^    int		scroll_shift;	\/* The scrollbar stuff can handle only up to$/;"	m	struct:GuiScrollbar
scroll_start	term.c	/^scroll_start()$/;"	f
scrollbar_T	gui.h	/^} scrollbar_T;$/;"	t	typeref:struct:GuiScrollbar
scrollbar_height	gui.h	/^    int		scrollbar_height;   \/* Height of horizontal scrollbar *\/$/;"	m	struct:Gui
scrollbar_value	globals.h	/^EXTERN long_u	scrollbar_value;$/;"	v
scrollbar_width	gui.h	/^    int		scrollbar_width;    \/* Width of vertical scrollbars *\/$/;"	m	struct:Gui
scrolldown	move.c	/^scrolldown(line_count, byfold)$/;"	f
scrolldown_clamp	move.c	/^scrolldown_clamp()$/;"	f
scrollup	move.c	/^scrollup(line_count, byfold)$/;"	f
scrollup_clamp	move.c	/^scrollup_clamp()$/;"	f
sd	netbeans.c	/^static int sd = -1;			\/* socket fd for Netbeans connection *\/$/;"	v	file:
se_u	regexp.c	/^    } se_u;$/;"	m	struct:__anon50	typeref:union:__anon50::__anon51	file:
search_for_exact_line	search.c	/^search_for_exact_line(buf, pos, dir, pat)$/;"	f
search_hl	screen.c	/^static match_T search_hl;	\/* used for 'hlsearch' highlight matching *\/$/;"	v	file:
search_match_endcol	globals.h	/^EXTERN colnr_T	search_match_endcol;		\/* col nr of match end *\/$/;"	v
search_match_lines	globals.h	/^EXTERN linenr_T	search_match_lines;		\/* lines of of matched string *\/$/;"	v
search_regcomp	search.c	/^search_regcomp(pat, pat_save, pat_use, options, regmatch)$/;"	f
searchbuf	structs.h	/^    char_u	*searchbuf;	\/* return: pointer to search pattern or NULL *\/$/;"	m	struct:cmdarg
searchc	search.c	/^searchc(cap, t_cmd)$/;"	f
searchcmdlen	globals.h	/^EXTERN int	searchcmdlen;		    \/* length of previous search cmd *\/$/;"	v
searchit	search.c	/^searchit(win, buf, pos, dir, pat, count, options, pat_use)$/;"	f
secure	globals.h	/^EXTERN int	secure INIT(= FALSE);$/;"	v
sel_atom	vim.h	/^    Atom	sel_atom;	\/* PRIMARY\/CLIPBOARD selection ID *\/$/;"	m	struct:VimClipboard
sensitive	structs.h	/^    int		sensitive;	    \/* turn button on\/off *\/$/;"	m	struct:VimMenu
separate_nextcmd	ex_docmd.c	/^separate_nextcmd(eap)$/;"	f
serverDelayedStartName	globals.h	/^EXTERN char_u	*serverDelayedStartName INIT(= NULL);$/;"	v
serverMakeName	main.c	/^serverMakeName(arg, cmd)$/;"	f	file:
serverName	globals.h	/^EXTERN char_u	*serverName INIT(= NULL);	\/* name of the server *\/$/;"	v
server_to_input_buf	main.c	/^server_to_input_buf(str)$/;"	f
ses_arglist	ex_docmd.c	/^ses_arglist(fd, cmd, gap, fullname, flagp)$/;"	f	file:
ses_do_frame	ex_docmd.c	/^ses_do_frame(fr)$/;"	f	file:
ses_do_win	ex_docmd.c	/^ses_do_win(wp)$/;"	f	file:
ses_fname	ex_docmd.c	/^ses_fname(fd, buf, flagp)$/;"	f	file:
ses_put_fname	ex_docmd.c	/^ses_put_fname(fd, name, flagp)$/;"	f	file:
ses_skipframe	ex_docmd.c	/^ses_skipframe(fr)$/;"	f	file:
ses_win_rec	ex_docmd.c	/^ses_win_rec(fd, fr)$/;"	f	file:
ses_winsizes	ex_docmd.c	/^ses_winsizes(fd, restore_size)$/;"	f	file:
setFoldRepeat	fold.c	/^setFoldRepeat(lnum, count, open)$/;"	f	file:
setManualFold	fold.c	/^setManualFold(lnum, opening, recurse, donep)$/;"	f	file:
setManualFoldWin	fold.c	/^setManualFoldWin(wp, lnum, opening, recurse, donep)$/;"	f	file:
setSmallMaybe	fold.c	/^setSmallMaybe(gap)$/;"	f	file:
set_arglist	ex_cmds2.c	/^set_arglist(str)$/;"	f
set_b0_fname	memline.c	/^set_b0_fname(b0p, buf)$/;"	f	file:
set_bool_option	option.c	/^set_bool_option(opt_idx, varp, value, opt_flags)$/;"	f	file:
set_buflisted	buffer.c	/^set_buflisted(on)$/;"	f
set_chars_option	option.c	/^set_chars_option(varp)$/;"	f	file:
set_cmd_context	ex_getln.c	/^set_cmd_context(xp, str, len, col)$/;"	f
set_cmdarg	eval.c	/^set_cmdarg(eap, oldarg)$/;"	f
set_cmdline_pos	ex_getln.c	/^set_cmdline_pos(pos)$/;"	f
set_cmdspos	ex_getln.c	/^set_cmdspos()$/;"	f	file:
set_cmdspos_cursor	ex_getln.c	/^set_cmdspos_cursor()$/;"	f	file:
set_color_count	term.c	/^set_color_count(nr)$/;"	f	file:
set_context_for_expression	eval.c	/^set_context_for_expression(xp, arg, cmdidx)$/;"	f
set_context_in_autocmd	fileio.c	/^set_context_in_autocmd(xp, arg, doautocmd)$/;"	f
set_context_in_highlight_cmd	syntax.c	/^set_context_in_highlight_cmd(xp, arg)$/;"	f
set_context_in_map_cmd	getchar.c	/^set_context_in_map_cmd(xp, cmd, arg, forceit, isabbrev, isunmap, cmdidx)$/;"	f
set_context_in_menu_cmd	menu.c	/^set_context_in_menu_cmd(xp, cmd, arg, forceit)$/;"	f
set_context_in_set_cmd	option.c	/^set_context_in_set_cmd(xp, arg, opt_flags)$/;"	f
set_context_in_syntax_cmd	syntax.c	/^set_context_in_syntax_cmd(xp, arg)$/;"	f
set_curbuf	buffer.c	/^set_curbuf(buf, action)$/;"	f
set_empty_rows	move.c	/^set_empty_rows(wp, used)$/;"	f
set_expand_context	ex_getln.c	/^set_expand_context(xp)$/;"	f	file:
set_expr_line	ops.c	/^set_expr_line(new_line)$/;"	f
set_file_time	fileio.c	/^set_file_time(fname, atime, mtime)$/;"	f	file:
set_fileformat	misc2.c	/^set_fileformat(t, opt_flags)$/;"	f
set_group_colors	syntax.c	/^set_group_colors(name, fgp, bgp, do_menu, use_norm, do_tooltip)$/;"	f	file:
set_guifontwide	gui.c	/^set_guifontwide(name)$/;"	f	file:
set_helplang_default	option.c	/^set_helplang_default(lang)$/;"	f
set_hl_attr	syntax.c	/^set_hl_attr(idx)$/;"	f	file:
set_iminsert_global	option.c	/^set_iminsert_global()$/;"	f
set_imsearch_global	option.c	/^set_imsearch_global()$/;"	f
set_indent	misc1.c	/^set_indent(size, flags)$/;"	f
set_init_1	option.c	/^set_init_1()$/;"	f
set_init_2	option.c	/^set_init_2()$/;"	f
set_init_3	option.c	/^set_init_3()$/;"	f
set_input_buf	ui.c	/^set_input_buf(p)$/;"	f
set_internal_string_var	eval.c	/^set_internal_string_var(name, value)$/;"	f
set_keep_msg	message.c	/^set_keep_msg(s)$/;"	f
set_lang_var	ex_cmds2.c	/^set_lang_var()$/;"	f
set_last_cursor	mark.c	/^set_last_cursor(win)$/;"	f
set_last_insert	edit.c	/^set_last_insert(c)$/;"	f
set_last_search_pat	search.c	/^set_last_search_pat(s, idx, magic, setlast)$/;"	f
set_mouse_termcode	term.c	/^set_mouse_termcode(n, s)$/;"	f
set_mouse_topline	term.c	/^set_mouse_topline(wp)$/;"	f
set_normal_colors	syntax.c	/^set_normal_colors()$/;"	f
set_num_option	option.c	/^set_num_option(opt_idx, varp, value, errbuf, opt_flags)$/;"	f	file:
set_number_default	option.c	/^set_number_default(name, val)$/;"	f
set_one_cmd_context	ex_docmd.c	/^set_one_cmd_context(xp, buff)$/;"	f
set_option_default	option.c	/^set_option_default(opt_idx, opt_flags, compatible)$/;"	f	file:
set_option_value	option.c	/^set_option_value(name, number, string, opt_flags)$/;"	f
set_options_bin	option.c	/^set_options_bin(oldval, newval, opt_flags)$/;"	f
set_options_default	option.c	/^set_options_default(opt_flags)$/;"	f	file:
set_printable_label_text	gui_beval.c	/^set_printable_label_text(GtkLabel *label, char_u *msg)$/;"	f	file:
set_reg_var	eval.c	/^set_reg_var(c)$/;"	f
set_shellsize	term.c	/^set_shellsize(width, height, mustset)$/;"	f
set_string_default	option.c	/^set_string_default(name, val)$/;"	f
set_string_option	option.c	/^set_string_option(opt_idx, value, opt_flags)$/;"	f	file:
set_string_option_direct	option.c	/^set_string_option_direct(name, opt_idx, val, opt_flags)$/;"	f
set_string_option_global	option.c	/^set_string_option_global(opt_idx, varp)$/;"	f	file:
set_term_defaults	option.c	/^set_term_defaults()$/;"	f
set_term_option_alloced	option.c	/^set_term_option_alloced(p)$/;"	f
set_termname	term.c	/^set_termname(term)$/;"	f
set_title_defaults	option.c	/^set_title_defaults()$/;"	f
set_topline	move.c	/^set_topline(wp, lnum)$/;"	f
set_var	eval.c	/^set_var(name, varp)$/;"	f	file:
set_vcount	eval.c	/^set_vcount(count, count1)$/;"	f
set_vim_var_nr	eval.c	/^set_vim_var_nr(idx, val)$/;"	f
set_vim_var_string	eval.c	/^set_vim_var_string(idx, val, len)$/;"	f
setaltfname	buffer.c	/^setaltfname(ffname, sfname, lnum)$/;"	f
setcursor	screen.c	/^setcursor()$/;"	f
setfname	buffer.c	/^setfname(buf, ffname, sfname, message)$/;"	f
setmark	mark.c	/^setmark(c)$/;"	f
setmouse	term.c	/^setmouse()$/;"	f
setpcmark	mark.c	/^setpcmark()$/;"	f
settmode	term.c	/^settmode(tmode)$/;"	f
sfile	testdir/test49.vim	/^    let sfile = expand("<sfile>")$/;"	v
sfname	fileio.c	/^    char_u	*sfname;	\/* sfname to match with *\/$/;"	m	struct:AutoPatCmd	file:
sg_cterm	syntax.c	/^    int		sg_cterm;	\/* "cterm=" highlighting attr *\/$/;"	m	struct:hl_group	file:
sg_cterm_attr	syntax.c	/^    int		sg_cterm_attr;	\/* Screen attr for color term mode *\/$/;"	m	struct:hl_group	file:
sg_cterm_bg	syntax.c	/^    int		sg_cterm_bg;	\/* terminal bg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_cterm_bold	syntax.c	/^    int		sg_cterm_bold;	\/* bold attr was set for light color *\/$/;"	m	struct:hl_group	file:
sg_cterm_fg	syntax.c	/^    int		sg_cterm_fg;	\/* terminal fg color number + 1 *\/$/;"	m	struct:hl_group	file:
sg_font	syntax.c	/^    GuiFont	sg_font;	\/* GUI font handle *\/$/;"	m	struct:hl_group	file:
sg_font_name	syntax.c	/^    char_u	*sg_font_name;  \/* GUI font or fontset name *\/$/;"	m	struct:hl_group	file:
sg_fontset	syntax.c	/^    GuiFontset	sg_fontset;	\/* GUI fontset handle *\/$/;"	m	struct:hl_group	file:
sg_gui	syntax.c	/^    int		sg_gui;		\/* "gui=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_gui_attr	syntax.c	/^    int		sg_gui_attr;    \/* Screen attr for GUI mode *\/$/;"	m	struct:hl_group	file:
sg_gui_bg	syntax.c	/^    guicolor_T	sg_gui_bg;	\/* GUI background color handle *\/$/;"	m	struct:hl_group	file:
sg_gui_bg_name	syntax.c	/^    char_u	*sg_gui_bg_name;\/* GUI background color name *\/$/;"	m	struct:hl_group	file:
sg_gui_fg	syntax.c	/^    guicolor_T	sg_gui_fg;	\/* GUI foreground color handle *\/$/;"	m	struct:hl_group	file:
sg_gui_fg_name	syntax.c	/^    char_u	*sg_gui_fg_name;\/* GUI foreground color name *\/$/;"	m	struct:hl_group	file:
sg_link	syntax.c	/^    int		sg_link;	\/* link to this highlight group ID *\/$/;"	m	struct:hl_group	file:
sg_name	syntax.c	/^    char_u	*sg_name;	\/* highlight group name *\/$/;"	m	struct:hl_group	file:
sg_name_u	syntax.c	/^    char_u	*sg_name_u;	\/* uppercase of sg_name *\/$/;"	m	struct:hl_group	file:
sg_set	syntax.c	/^    int		sg_set;		\/* combination of SG_* flags *\/$/;"	m	struct:hl_group	file:
sg_start	syntax.c	/^    char_u	*sg_start;	\/* terminal string for start highl *\/$/;"	m	struct:hl_group	file:
sg_stop	syntax.c	/^    char_u	*sg_stop;	\/* terminal string for stop highl *\/$/;"	m	struct:hl_group	file:
sg_term	syntax.c	/^    int		sg_term;	\/* "term=" highlighting attributes *\/$/;"	m	struct:hl_group	file:
sg_term_attr	syntax.c	/^    int		sg_term_attr;	\/* Screen attr for term mode *\/$/;"	m	struct:hl_group	file:
shape	structs.h	/^    int		shape;		\/* one of the SHAPE_ defines *\/$/;"	m	struct:cursor_entry
shape_table	misc2.c	/^cursorentry_T shape_table[SHAPE_IDX_COUNT] =$/;"	v
shell_created	gui.h	/^    int		shell_created;	    \/* Has the shell been created yet? *\/$/;"	m	struct:Gui
shell_new_columns	window.c	/^shell_new_columns()$/;"	f
shell_new_rows	window.c	/^shell_new_rows()$/;"	f
shell_resized	term.c	/^shell_resized()$/;"	f
shell_resized_check	term.c	/^shell_resized_check()$/;"	f
shift_block	ops.c	/^shift_block(oap, amount)$/;"	f	file:
shift_line	ops.c	/^shift_line(left, round, amount)$/;"	f
short_u	structs.h	/^typedef unsigned short	short_u;$/;"	t
short_u	vim.h	/^typedef unsigned short	short_u;$/;"	t
shorten_filenames	fileio.c	/^shorten_filenames(fnames, count)$/;"	f
shorten_fname	fileio.c	/^shorten_fname(full_path, dir_name)$/;"	f
shorten_fnames	fileio.c	/^shorten_fnames(force)$/;"	f
shortmess	option.c	/^shortmess(x)$/;"	f
shortname	option.c	/^    char	*shortname;	\/* permissible abbreviation *\/$/;"	m	struct:vimoption	file:
shortpath_for_invalid_fname	eval.c	/^shortpath_for_invalid_fname(fname, bufp, fnamelen)$/;"	f	file:
shortpath_for_partial	eval.c	/^shortpath_for_partial(fnamep, bufp, fnamelen)$/;"	f	file:
should_abort	ex_eval.c	/^should_abort(retcode)$/;"	f
showState	gui_beval.h	/^    BeState		showState;	\/* tells us whats currently going on *\/$/;"	m	struct:BalloonEvalStruct
show_autocmd	fileio.c	/^show_autocmd(ap, event)$/;"	f	file:
show_menus	menu.c	/^show_menus(path_name, modes)$/;"	f	file:
show_menus_recursive	menu.c	/^show_menus_recursive(menu, modes, depth)$/;"	f	file:
show_one_mark	mark.c	/^show_one_mark(c, arg, p, name, current)$/;"	f	file:
show_one_termcode	term.c	/^show_one_termcode(name, code, printit)$/;"	f
show_pat_in_path	search.c	/^show_pat_in_path(line, type, did_show, action, fp, lnum, count)$/;"	f	file:
show_termcodes	term.c	/^show_termcodes()$/;"	f
show_utf8	mbyte.c	/^show_utf8()$/;"	f
showcmd_buf	normal.c	/^static char_u	showcmd_buf[SHOWCMD_BUFLEN];$/;"	v	file:
showcmd_is_clear	normal.c	/^static int	showcmd_is_clear = TRUE;$/;"	v	file:
showcmd_visual	normal.c	/^static int	showcmd_visual = FALSE;$/;"	v	file:
showmap	getchar.c	/^showmap(mp, local)$/;"	f	file:
showmatch	search.c	/^showmatch(c)$/;"	f
showmatches	ex_getln.c	/^showmatches(xp, wildmenu)$/;"	f	file:
showmode	screen.c	/^showmode()$/;"	f
shown_direction	edit.c	/^static int		    shown_direction = FORWARD;$/;"	v	file:
shown_match	edit.c	/^static struct Completion    *shown_match = NULL;$/;"	v	typeref:struct:Completion	file:
showoneopt	option.c	/^showoneopt(p, opt_flags)$/;"	f	file:
showoptions	option.c	/^showoptions(all, opt_flags)$/;"	f	file:
showruler	screen.c	/^showruler(always)$/;"	f
si_attr	syntax.c	/^    int		si_attr;		\/* attributes in this state *\/$/;"	m	struct:state_item	file:
si_cont_list	syntax.c	/^    short	*si_cont_list;		\/* list of contained groups *\/$/;"	m	struct:state_item	file:
si_end_idx	syntax.c	/^    int		si_end_idx;		\/* group ID for end pattern or zero *\/$/;"	m	struct:state_item	file:
si_ends	syntax.c	/^    int		si_ends;		\/* if match ends before si_m_endpos *\/$/;"	m	struct:state_item	file:
si_eoe_pos	syntax.c	/^    lpos_T	si_eoe_pos;		\/* end position of end pattern *\/$/;"	m	struct:state_item	file:
si_extmatch	syntax.c	/^    reg_extmatch_T *si_extmatch;	\/* \\z(...\\) matches from start$/;"	m	struct:state_item	file:
si_flags	syntax.c	/^    long	si_flags;		\/* HL_HAS_EOL flag in this state, and$/;"	m	struct:state_item	file:
si_h_endpos	syntax.c	/^    lpos_T	si_h_endpos;		\/* end position of the highlighting *\/$/;"	m	struct:state_item	file:
si_h_startpos	syntax.c	/^    lpos_T	si_h_startpos;		\/* start position of the highlighting *\/$/;"	m	struct:state_item	file:
si_id	syntax.c	/^    int		si_id;			\/* highlight group ID for keywords *\/$/;"	m	struct:state_item	file:
si_idx	syntax.c	/^    int		si_idx;			\/* index of syntax pattern *\/$/;"	m	struct:state_item	file:
si_m_endpos	syntax.c	/^    lpos_T	si_m_endpos;		\/* just after end posn of the match *\/$/;"	m	struct:state_item	file:
si_m_lnum	syntax.c	/^    int		si_m_lnum;		\/* lnum of the match *\/$/;"	m	struct:state_item	file:
si_m_startcol	syntax.c	/^    int		si_m_startcol;		\/* starting column of the match *\/$/;"	m	struct:state_item	file:
si_next_list	syntax.c	/^    short	*si_next_list;		\/* nextgroup IDs after this item ends *\/$/;"	m	struct:state_item	file:
si_trans_id	syntax.c	/^    int		si_trans_id;		\/* idem, transparancy removed *\/$/;"	m	struct:state_item	file:
sign	ex_cmds.c	/^struct sign$/;"	s	file:
sign_T	ex_cmds.c	/^typedef struct sign sign_T;$/;"	t	typeref:struct:sign	file:
sign_get_attr	ex_cmds.c	/^sign_get_attr(typenr, line)$/;"	f
sign_get_image	ex_cmds.c	/^sign_get_image(typenr)$/;"	f
sign_get_text	ex_cmds.c	/^sign_get_text(typenr)$/;"	f
sign_gui_started	ex_cmds.c	/^sign_gui_started()$/;"	f
sign_list_defined	ex_cmds.c	/^sign_list_defined(sp)$/;"	f	file:
sign_list_placed	buffer.c	/^sign_list_placed(rbuf)$/;"	f
sign_mark_adjust	buffer.c	/^sign_mark_adjust(line1, line2, amount, amount_after)$/;"	f
sign_typenr2name	ex_cmds.c	/^sign_typenr2name(typenr)$/;"	f
signlist	structs.h	/^struct signlist$/;"	s
signlist_T	structs.h	/^typedef struct signlist signlist_T;$/;"	t	typeref:struct:signlist
signmap	netbeans.c	/^    int			*signmap;$/;"	m	struct:nbbuf_struct	file:
signmaplen	netbeans.c	/^    short_u		 signmaplen;$/;"	m	struct:nbbuf_struct	file:
signmapused	netbeans.c	/^    short_u		 signmapused;$/;"	m	struct:nbbuf_struct	file:
silent	structs.h	/^    char	silent[MENU_MODES]; \/* A silent flag for each mode *\/$/;"	m	struct:VimMenu
silent_mode	globals.h	/^EXTERN int	silent_mode INIT(= FALSE);$/;"	v
simplify_filename	tag.c	/^simplify_filename(filename)$/;"	f
simplify_key	misc2.c	/^simplify_key(key, modifiers)$/;"	f
size	gui.h	/^    long	size;		\/* Size of scrollbar thumb *\/$/;"	m	struct:GuiScrollbar
size_set	os_amiga.c	/^int			size_set = FALSE;   \/* set to TRUE if window size was set *\/$/;"	v
skip	ex_cmds.h	/^    int		skip;		\/* don't execute the command, only parse it *\/$/;"	m	struct:exarg
skip_anyof	regexp.c	/^skip_anyof(p)$/;"	f	file:
skip_chars	search.c	/^skip_chars(cclass, dir)$/;"	f	file:
skip_class_name	regexp.c	/^skip_class_name(pp)$/;"	f	file:
skip_cmd_arg	ex_docmd.c	/^skip_cmd_arg(p, rembs)$/;"	f	file:
skip_label	misc1.c	/^skip_label(lnum, pp, ind_maxcomment)$/;"	f	file:
skip_range	ex_docmd.c	/^skip_range(cmd, ctx)$/;"	f
skip_redraw	globals.h	/^EXTERN int	skip_redraw INIT(= FALSE);  \/* skip redraw once *\/$/;"	v
skip_regexp	regexp.c	/^skip_regexp(startp, dirc, magic, newp)$/;"	f
skip_string	misc1.c	/^skip_string(p)$/;"	f	file:
skip_to_option_part	misc1.c	/^skip_to_option_part(p)$/;"	f
skipchr	regexp.c	/^skipchr()$/;"	f	file:
skipchr_keepstart	regexp.c	/^skipchr_keepstart()$/;"	f	file:
skipdigits	charset.c	/^skipdigits(p)$/;"	f
skiptowhite	charset.c	/^skiptowhite(p)$/;"	f
skiptowhite_esc	charset.c	/^skiptowhite_esc(p)$/;"	f
skipwhite	charset.c	/^skipwhite(p)$/;"	f
sleep	netbeans.c	42;"	d	file:
sm_gettail	ex_getln.c	/^sm_gettail(s)$/;"	f
smsg	message.c	/^smsg(char_u *s, ...)$/;"	f
smsg	message.c	/^smsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
smsg_attr	message.c	/^smsg_attr(attr, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	f
smsg_attr	message.c	/^smsg_attr(int attr, char_u *s, ...)$/;"	f
sn_icon	ex_cmds.c	/^    char_u	*sn_icon;	\/* name of pixmap *\/$/;"	m	struct:sign	file:
sn_image	ex_cmds.c	/^    void	*sn_image;	\/* icon image *\/$/;"	m	struct:sign	file:
sn_line_hl	ex_cmds.c	/^    int		sn_line_hl;	\/* highlight ID for line *\/$/;"	m	struct:sign	file:
sn_name	ex_cmds.c	/^    char_u	*sn_name;	\/* name of sign *\/$/;"	m	struct:sign	file:
sn_next	ex_cmds.c	/^    sign_T	*sn_next;	\/* next sign in list *\/$/;"	m	struct:sign	file:
sn_text	ex_cmds.c	/^    char_u	*sn_text;	\/* text used instead of pixmap *\/$/;"	m	struct:sign	file:
sn_text_hl	ex_cmds.c	/^    int		sn_text_hl;	\/* highlight ID for text *\/$/;"	m	struct:sign	file:
sn_typenr	ex_cmds.c	/^    int		sn_typenr;	\/* type number of sign (negative if not equal$/;"	m	struct:sign	file:
snapshot	window.c	/^static frame_T *snapshot = NULL;$/;"	v	file:
sock_close	netbeans.c	41;"	d	file:
sock_close	netbeans.c	53;"	d	file:
sock_errno	netbeans.c	33;"	d	file:
sock_errno	netbeans.c	50;"	d	file:
sock_read	netbeans.c	40;"	d	file:
sock_read	netbeans.c	52;"	d	file:
sock_write	netbeans.c	39;"	d	file:
sock_write	netbeans.c	51;"	d	file:
soffset	search.c	/^struct soffset$/;"	s	file:
sort_compare	misc2.c	/^sort_compare(s1, s2)$/;"	f	file:
sort_strings	misc2.c	/^sort_strings(files, count)$/;"	f
sortcmp	os_amiga.c	/^sortcmp(a, b)$/;"	f	file:
source_breakpoint	ex_cmds2.c	/^source_breakpoint(cookie)$/;"	f
source_callback	ex_cmds2.c	/^source_callback(fname)$/;"	f	file:
source_cookie	ex_cmds2.c	/^struct source_cookie$/;"	s	file:
source_dbg_tick	ex_cmds2.c	/^source_dbg_tick(cookie)$/;"	f
source_finished	ex_cmds2.c	/^source_finished(getline, cookie)$/;"	f
source_level	ex_cmds2.c	/^source_level(cookie)$/;"	f
sourcing_lnum	globals.h	/^EXTERN linenr_T	sourcing_lnum INIT(= 0);    \/* line number of the source file *\/$/;"	v
sourcing_name	globals.h	/^EXTERN char_u	*sourcing_name INIT( = NULL);\/* name of error message source *\/$/;"	v
sp_cont_list	syntax.c	/^    short	*sp_cont_list;		\/* cont. group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_flags	syntax.c	/^    short	 sp_flags;		\/* see HL_ defines below *\/$/;"	m	struct:syn_pattern	file:
sp_ic	syntax.c	/^    int		 sp_ic;			\/* ignore-case flag for sp_prog *\/$/;"	m	struct:syn_pattern	file:
sp_line_id	syntax.c	/^    int		 sp_line_id;		\/* ID of last line where tried *\/$/;"	m	struct:syn_pattern	file:
sp_next_list	syntax.c	/^    short	*sp_next_list;		\/* next group IDs, if non-zero *\/$/;"	m	struct:syn_pattern	file:
sp_off_flags	syntax.c	/^    short	 sp_off_flags;		\/* see below *\/$/;"	m	struct:syn_pattern	file:
sp_offsets	syntax.c	/^    int		 sp_offsets[SPO_COUNT];	\/* offsets *\/$/;"	m	struct:syn_pattern	file:
sp_pattern	syntax.c	/^    char_u	*sp_pattern;		\/* regexp to match, pattern *\/$/;"	m	struct:syn_pattern	file:
sp_prog	syntax.c	/^    regprog_T	*sp_prog;		\/* regexp to match, program *\/$/;"	m	struct:syn_pattern	file:
sp_startcol	syntax.c	/^    int		 sp_startcol;		\/* next match in sp_line_id line *\/$/;"	m	struct:syn_pattern	file:
sp_syn	structs.h	/^struct sp_syn$/;"	s
sp_syn	syntax.c	/^    struct sp_syn sp_syn;		\/* struct passed to in_id_list() *\/$/;"	m	struct:syn_pattern	typeref:struct:syn_pattern::sp_syn	file:
sp_syn_match_id	syntax.c	/^    short	 sp_syn_match_id;	\/* highlight group ID of pattern *\/$/;"	m	struct:syn_pattern	file:
sp_sync_idx	syntax.c	/^    int		 sp_sync_idx;		\/* sync item index (syncing only) *\/$/;"	m	struct:syn_pattern	file:
sp_syncing	syntax.c	/^    char	 sp_syncing;		\/* this item used for syncing *\/$/;"	m	struct:syn_pattern	file:
sp_type	syntax.c	/^    char	 sp_type;		\/* see SPTYPE_ defines below *\/$/;"	m	struct:syn_pattern	file:
spat	search.c	/^struct spat$/;"	s	file:
spats	search.c	/^static struct spat spats[2] =$/;"	v	typeref:struct:spat	file:
special_keys	gui_amiga.c	/^} special_keys[] =$/;"	v	typeref:struct:__anon25	file:
split	structs.h	/^    int		split;			\/* flags for win_split() *\/$/;"	m	struct:__anon31
spo_name_tab	syntax.c	/^static char *(spo_name_tab[SPO_COUNT]) =$/;"	v	file:
ssop_flags	option.h	/^EXTERN unsigned	ssop_flags;$/;"	v
sst_change_lnum	structs.h	/^    linenr_T	sst_change_lnum;\/* when non-zero, change in this line$/;"	m	struct:syn_state
sst_ga	structs.h	/^	garray_T	sst_ga;	\/* growarray for long state stack *\/$/;"	m	union:syn_state::__anon33
sst_lnum	structs.h	/^    linenr_T	sst_lnum;	\/* line number for this state *\/$/;"	m	struct:syn_state
sst_next	structs.h	/^    synstate_T	*sst_next;	\/* next entry in used or free list *\/$/;"	m	struct:syn_state
sst_next_flags	structs.h	/^    int		sst_next_flags;	\/* flags for sst_next_list *\/$/;"	m	struct:syn_state
sst_next_list	structs.h	/^    short	*sst_next_list;	\/* "nextgroup" list in this state$/;"	m	struct:syn_state
sst_stack	structs.h	/^	bufstate_T	sst_stack[SST_FIX_STATES]; \/* short state stack *\/$/;"	m	union:syn_state::__anon33
sst_stacksize	structs.h	/^    short	sst_stacksize;	\/* number of states on the stack *\/$/;"	m	struct:syn_state
sst_tick	structs.h	/^    disptick_T	sst_tick;	\/* tick when last displayed *\/$/;"	m	struct:syn_state
sst_union	structs.h	/^    } sst_union;$/;"	m	struct:syn_state	typeref:union:syn_state::__anon33
start	fold.c	/^    int		start;		\/* number of folds that are forced to start at$/;"	m	struct:__anon15	file:
start	structs.h	/^	    char_u	    *start;	\/* start escape sequence *\/$/;"	m	struct:attr_entry::__anon34::__anon35
start	structs.h	/^    char_u	*start;$/;"	m	struct:stl_hlrec
start	structs.h	/^    pos_T	start;		\/* start of the operator *\/$/;"	m	struct:oparg
start	vim.h	/^    pos_T	start;		\/* Start of selected area *\/$/;"	m	struct:VimClipboard
startPS	search.c	/^startPS(lnum, para, both)$/;"	f
start_arrow	edit.c	/^start_arrow(end_insert_pos)$/;"	f	file:
start_char_vcols	ops.c	/^    colnr_T	start_char_vcols; \/* number of vcols of pre-block char *\/$/;"	m	struct:block_def	file:
start_redo	getchar.c	/^start_redo(count, old_redo)$/;"	f
start_redo_ins	getchar.c	/^start_redo_ins()$/;"	f
start_search_hl	screen.c	/^start_search_hl()$/;"	f	file:
start_selection	normal.c	/^start_selection()$/;"	f
start_stuff	getchar.c	/^start_stuff()$/;"	f	file:
start_vcol	ops.c	/^    colnr_T	start_vcol;	\/* start col of 1st char wholly inside block *\/$/;"	m	struct:block_def	file:
start_vcol	structs.h	/^    colnr_T	start_vcol;	\/* start col for block mode operator *\/$/;"	m	struct:oparg
startcol	screen.c	/^    colnr_T	startcol; \/* in win_line() points to char where HL starts *\/$/;"	m	struct:__anon1	file:
started_completion	edit.c	/^static int		    started_completion = FALSE;$/;"	v	file:
starting	globals.h	/^EXTERN int	starting INIT(= NO_SCREEN);$/;"	v
starting	gui.h	/^    int		starting;	    \/* GUI will start in a little while *\/$/;"	m	struct:Gui
startp	regexp.h	/^    char_u		*startp[NSUBEXP];$/;"	m	struct:__anon4
startpos	regexp.h	/^    lpos_T		startpos[NSUBEXP];$/;"	m	struct:__anon5
startspaces	ops.c	/^    int		startspaces;	\/* 'extra' cols of first char *\/$/;"	m	struct:block_def	file:
starttermcap	term.c	/^starttermcap()$/;"	f
stat	vim.h	1553;"	d
state	gui_amiga.c	/^    }		state;$/;"	m	struct:__anon26	typeref:enum:__anon26::__anon27	file:
state	gui_beval.h	/^    unsigned int	state;		\/* Button\/Modifier key state *\/$/;"	m	struct:BalloonEvalStruct
state	vim.h	/^    short_u	state;		\/* Current selection state *\/$/;"	m	struct:VimClipboard
state_item	syntax.c	/^typedef struct state_item$/;"	s	file:
stateitem_T	syntax.c	/^} stateitem_T;$/;"	t	typeref:struct:state_item	file:
status_area_enabled	mbyte.c	/^static int	status_area_enabled = TRUE;$/;"	v	file:
status_height	gui.h	/^    int		status_height;	\/* Height of status line *\/$/;"	m	struct:GuiScrollbar
status_match_len	screen.c	/^status_match_len(xp, s)$/;"	f	file:
status_redraw_all	screen.c	/^status_redraw_all()$/;"	f
status_redraw_curbuf	screen.c	/^status_redraw_curbuf()$/;"	f
step	mbyte.c	/^    int step;$/;"	m	struct:__anon13	file:
stl_connected	screen.c	/^stl_connected(wp)$/;"	f
stl_hlrec	structs.h	/^struct stl_hlrec$/;"	s
stl_syntax	globals.h	/^EXTERN int      stl_syntax INIT(= 0);$/;"	v
stop	structs.h	/^	    char_u	    *stop;	\/* stop escape sequence *\/$/;"	m	struct:attr_entry::__anon34::__anon35
stop_arrow	edit.c	/^stop_arrow()$/;"	f
stop_insert	edit.c	/^stop_insert(end_insert_pos, esc)$/;"	f	file:
stop_insert_mode	globals.h	/^EXTERN int	stop_insert_mode;	\/* for ":stopinsert" and 'insertmode' *\/$/;"	v
stop_redo_ins	getchar.c	/^stop_redo_ins()$/;"	f
stoptermcap	term.c	/^stoptermcap()$/;"	f
store_current_state	syntax.c	/^store_current_state(sp)$/;"	f	file:
store_session_globals	eval.c	/^store_session_globals(fd)$/;"	f
store_while_line	ex_docmd.c	/^store_while_line(gap, line)$/;"	f	file:
str	edit.c	/^    char_u		*str;	  \/* matched text *\/$/;"	m	struct:Completion	file:
str2special	message.c	/^str2special(sp, from)$/;"	f
str2specialbuf	message.c	/^str2specialbuf(sp, buf, len)$/;"	f
str_foldcase	charset.c	/^str_foldcase(str, len)$/;"	f
str_to_reg	ops.c	/^str_to_reg(y_ptr, type, str, len, blocklen)$/;"	f	file:
streq	netbeans.c	1201;"	d	file:
string	structs.h	/^    char_u	*string;	\/* points into option string *\/$/;"	m	struct:__anon43
string_convert	mbyte.c	/^string_convert(vcp, ptr, lenp)$/;"	f
string_convert_ext	mbyte.c	/^string_convert_ext(vcp, ptr, lenp, unconvlenp)$/;"	f
string_to_key	option.c	/^string_to_key(arg)$/;"	f	file:
strings	structs.h	/^    char_u	*strings[MENU_MODES]; \/* Mapped string for each mode *\/$/;"	m	struct:VimMenu
strlen	structs.h	/^    int		strlen;$/;"	m	struct:__anon43
stuffReadbuff	getchar.c	/^stuffReadbuff(s)$/;"	f
stuffReadbuffLen	getchar.c	/^stuffReadbuffLen(s, len)$/;"	f
stuffReadbuffSpec	getchar.c	/^stuffReadbuffSpec(s)$/;"	f
stuff_empty	getchar.c	/^stuff_empty()$/;"	f
stuff_inserted	edit.c	/^stuff_inserted(c, count, no_esc)$/;"	f
stuff_yank	ops.c	/^stuff_yank(regname, p)$/;"	f	file:
stuffbuff	globals.h	/^EXTERN struct buffheader stuffbuff	\/* stuff buffer *\/$/;"	v	typeref:struct:buffheader
stuffcharReadbuff	getchar.c	/^stuffcharReadbuff(c)$/;"	f
stuffescaped	ops.c	/^stuffescaped(arg, literally)$/;"	f	file:
stuffnumReadbuff	getchar.c	/^stuffnumReadbuff(n)$/;"	f
sub_nlines	ex_cmds.c	/^static linenr_T	sub_nlines;	\/* total number of lines changed *\/$/;"	v	file:
sub_nsubs	ex_cmds.c	/^static long	sub_nsubs;	\/* total number of substitutions *\/$/;"	v	file:
subcommand	syntax.c	/^struct subcommand$/;"	s	file:
subcommands	syntax.c	/^static struct subcommand subcommands[] =$/;"	v	typeref:struct:subcommand	file:
submatch_match	regexp.c	/^static regmatch_T	*submatch_match;$/;"	v	file:
submatch_mmatch	regexp.c	/^static regmmatch_T	*submatch_mmatch;$/;"	v	file:
submenu_handle	structs.h	/^    MenuHandle	submenu_handle;$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    BMenu	*submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    GtkWidget	*submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    HMENU	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    PtWidget_t	*submenu_id;$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    Widget	submenu_id;	    \/* If this is submenu, add children here *\/$/;"	m	struct:VimMenu
submenu_id	structs.h	/^    short	submenu_id;	    \/* the menu id of the children (could be$/;"	m	struct:VimMenu
sum	testdir/test49.vim	/^		let sum = sum + 1$/;"	v
sum	testdir/test49.vim	/^	    let sum = sum + 2$/;"	v
sum	testdir/test49.vim	/^	    let sum = sum - R("interrupt", -128)$/;"	v
sum	testdir/test49.vim	/^	    let sum = sum - R("throw", -256)$/;"	v
sum	testdir/test49.vim	/^	let sum = sum + 4$/;"	v
sum	testdir/test49.vim	/^	let sum = sum - R("error", -64)$/;"	v
sum	testdir/test49.vim	/^    let sum =  -R("continue", -8)$/;"	v
sum	testdir/test49.vim	/^    let sum = sum + 16$/;"	v
sum	testdir/test49.vim	/^    let sum = sum + 8$/;"	v
sum	testdir/test49.vim	/^    let sum = sum - R("break", -16)$/;"	v
sum	testdir/test49.vim	/^    let sum = sum - R("return", -32)$/;"	v
sum	testdir/test49.vim	/^let sum	     = F() + G() + H()  + I()   + J() + K() + L()     + M()$/;"	v
sum	testdir/test49.vim	/^let sum	     = sum      + N()      + O()$/;"	v
sum	testdir/test49.vim	/^let sum = (F() + 1) - 4*G() - 8*H()$/;"	v
sum	testdir/test49.vim	/^let sum = 0$/;"	v
suppress_alternate_input	globals.h	/^EXTERN int	suppress_alternate_input INIT(= FALSE);$/;"	v
suppress_errthrow	globals.h	/^EXTERN int suppress_errthrow INIT(= FALSE);$/;"	v
suspend_shell	ui.c	/^suspend_shell()$/;"	f
swap_exists_action	globals.h	/^EXTERN int	swap_exists_action INIT(= 0);	\/* use dialog when swap file$/;"	v
swapchar	ops.c	/^swapchar(op_type, pos)$/;"	f
swapfile_info	memline.c	/^swapfile_info(fname)$/;"	f	file:
swapping_screen	term.c	/^swapping_screen()$/;"	f
switch_to_8bit	term.c	/^switch_to_8bit()$/;"	f	file:
syn_add_cluster	syntax.c	/^syn_add_cluster(name)$/;"	f	file:
syn_add_end_off	syntax.c	/^syn_add_end_off(result, regmatch, spp, idx, extra)$/;"	f	file:
syn_add_group	syntax.c	/^syn_add_group(name)$/;"	f	file:
syn_add_start_off	syntax.c	/^syn_add_start_off(result, regmatch, spp, idx, extra)$/;"	f	file:
syn_buf	syntax.c	/^static buf_T	*syn_buf;		\/* current buffer for highlighting *\/$/;"	v	file:
syn_check_cluster	syntax.c	/^syn_check_cluster(pp, len)$/;"	f	file:
syn_check_group	syntax.c	/^syn_check_group(pp, len)$/;"	f
syn_clear_cluster	syntax.c	/^syn_clear_cluster(buf, i)$/;"	f	file:
syn_clear_keyword	syntax.c	/^syn_clear_keyword(id, ktabp)$/;"	f	file:
syn_clear_one	syntax.c	/^syn_clear_one(id, syncing)$/;"	f	file:
syn_clear_pattern	syntax.c	/^syn_clear_pattern(buf, i)$/;"	f	file:
syn_cluster	syntax.c	/^struct syn_cluster$/;"	s	file:
syn_cmd_case	syntax.c	/^syn_cmd_case(eap, syncing)$/;"	f	file:
syn_cmd_clear	syntax.c	/^syn_cmd_clear(eap, syncing)$/;"	f	file:
syn_cmd_cluster	syntax.c	/^syn_cmd_cluster(eap, syncing)$/;"	f	file:
syn_cmd_enable	syntax.c	/^syn_cmd_enable(eap, syncing)$/;"	f	file:
syn_cmd_include	syntax.c	/^syn_cmd_include(eap, syncing)$/;"	f	file:
syn_cmd_keyword	syntax.c	/^syn_cmd_keyword(eap, syncing)$/;"	f	file:
syn_cmd_list	syntax.c	/^syn_cmd_list(eap, syncing)$/;"	f	file:
syn_cmd_manual	syntax.c	/^syn_cmd_manual(eap, syncing)$/;"	f	file:
syn_cmd_match	syntax.c	/^syn_cmd_match(eap, syncing)$/;"	f	file:
syn_cmd_off	syntax.c	/^syn_cmd_off(eap, syncing)$/;"	f	file:
syn_cmd_on	syntax.c	/^syn_cmd_on(eap, syncing)$/;"	f	file:
syn_cmd_onoff	syntax.c	/^syn_cmd_onoff(eap, name)$/;"	f	file:
syn_cmd_region	syntax.c	/^syn_cmd_region(eap, syncing)$/;"	f	file:
syn_cmd_reset	syntax.c	/^syn_cmd_reset(eap, syncing)$/;"	f	file:
syn_cmd_sync	syntax.c	/^syn_cmd_sync(eap, syncing)$/;"	f	file:
syn_cmdlinep	syntax.c	/^static char_u **syn_cmdlinep;$/;"	v	file:
syn_combine_list	syntax.c	/^syn_combine_list(clstr1, clstr2, list_op)$/;"	f	file:
syn_compare_stub	syntax.c	/^syn_compare_stub(v1, v2)$/;"	f	file:
syn_cterm_attr2entry	syntax.c	/^syn_cterm_attr2entry(attr)$/;"	f
syn_current_attr	syntax.c	/^syn_current_attr(syncing, displaying)$/;"	f	file:
syn_finish_line	syntax.c	/^syn_finish_line(syncing)$/;"	f	file:
syn_get_final_id	syntax.c	/^syn_get_final_id(hl_id)$/;"	f
syn_get_foldlevel	syntax.c	/^syn_get_foldlevel(wp, lnum)$/;"	f
syn_get_id	syntax.c	/^syn_get_id(lnum, col, trans)$/;"	f
syn_getcurline	syntax.c	/^syn_getcurline()$/;"	f	file:
syn_gui_attr2entry	syntax.c	/^syn_gui_attr2entry(attr)$/;"	f
syn_id2attr	syntax.c	/^syn_id2attr(hl_id)$/;"	f
syn_id2colors	syntax.c	/^syn_id2colors(hl_id, fgp, bgp)$/;"	f
syn_incl_toplevel	syntax.c	/^syn_incl_toplevel(id, flagsp)$/;"	f	file:
syn_khash	syntax.c	/^syn_khash(p)$/;"	f	file:
syn_lines_msg	syntax.c	/^syn_lines_msg()$/;"	f	file:
syn_list_cluster	syntax.c	/^syn_list_cluster(id)$/;"	f	file:
syn_list_flags	syntax.c	/^syn_list_flags(nl, flags, attr)$/;"	f	file:
syn_list_header	syntax.c	/^syn_list_header(did_header, outlen, id)$/;"	f	file:
syn_list_keywords	syntax.c	/^syn_list_keywords(id, ktabp, did_header, attr)$/;"	f	file:
syn_list_one	syntax.c	/^syn_list_one(id, syncing, link_only)$/;"	f	file:
syn_match_linecont	syntax.c	/^syn_match_linecont(lnum)$/;"	f	file:
syn_match_msg	syntax.c	/^syn_match_msg()$/;"	f	file:
syn_name2id	syntax.c	/^syn_name2id(name)$/;"	f
syn_namen2id	syntax.c	/^syn_namen2id(linep, len)$/;"	f
syn_pattern	syntax.c	/^typedef struct syn_pattern$/;"	s	file:
syn_regexec	syntax.c	/^syn_regexec(rmp, lnum, col)$/;"	f	file:
syn_remove_pattern	syntax.c	/^syn_remove_pattern(buf, idx)$/;"	f	file:
syn_scl_name2id	syntax.c	/^syn_scl_name2id(name)$/;"	f	file:
syn_scl_namen2id	syntax.c	/^syn_scl_namen2id(linep, len)$/;"	f	file:
syn_stack_alloc	syntax.c	/^syn_stack_alloc()$/;"	f	file:
syn_stack_apply_changes	syntax.c	/^syn_stack_apply_changes(buf)$/;"	f
syn_stack_cleanup	syntax.c	/^syn_stack_cleanup()$/;"	f	file:
syn_stack_equal	syntax.c	/^syn_stack_equal(sp)$/;"	f	file:
syn_stack_find_entry	syntax.c	/^syn_stack_find_entry(lnum)$/;"	f	file:
syn_stack_free_all	syntax.c	/^syn_stack_free_all(buf)$/;"	f
syn_stack_free_entry	syntax.c	/^syn_stack_free_entry(buf, p)$/;"	f	file:
syn_start_line	syntax.c	/^syn_start_line()$/;"	f	file:
syn_state	structs.h	/^struct syn_state$/;"	s
syn_sync	syntax.c	/^syn_sync(wp, start_lnum, last_valid)$/;"	f	file:
syn_term_attr2entry	syntax.c	/^syn_term_attr2entry(attr)$/;"	f
syn_unadd_group	syntax.c	/^syn_unadd_group()$/;"	f	file:
syn_update_ends	syntax.c	/^syn_update_ends(startofline)$/;"	f	file:
syn_win	syntax.c	/^static win_T	*syn_win;		\/* current window for highlighting *\/$/;"	v	file:
synpat_T	syntax.c	/^} synpat_T;$/;"	t	typeref:struct:syn_pattern	file:
synstate_T	structs.h	/^typedef struct syn_state synstate_T;$/;"	t	typeref:struct:syn_state
syntax_check_changed	syntax.c	/^syntax_check_changed(lnum)$/;"	f
syntax_clear	syntax.c	/^syntax_clear(buf)$/;"	f
syntax_end_parsing	syntax.c	/^syntax_end_parsing(lnum)$/;"	f
syntax_present	syntax.c	/^syntax_present(buf)$/;"	f
syntax_start	syntax.c	/^syntax_start(wp, lnum)$/;"	f
syntax_sync_clear	syntax.c	/^syntax_sync_clear()$/;"	f	file:
sys_menu	globals.h	/^EXTERN int	sys_menu INIT(= FALSE);$/;"	v
t	testdir/test49.vim	/^	let t = 1$/;"	v
t_colors	globals.h	/^EXTERN int	t_colors INIT(= 0);	    \/* int value of T_CCO *\/$/;"	v
t_puts	message.c	/^t_puts(t_col, t_s, s, attr)$/;"	f	file:
ta_len	ui.c	/^static int ta_len;	\/* length of ta_str when it's not NULL*\/$/;"	v	file:
ta_off	ui.c	/^static int ta_off;	\/* offset for next char to use when ta_str != NULL *\/$/;"	v	file:
ta_str	ui.c	/^static char_u *ta_str = NULL;$/;"	v	file:
table	gui_amiga.c	/^    static guicolor_tTable table[] =$/;"	v	file:
tag_fgets	diff.c	83;"	d	file:
tag_fgets	fileio.c	/^tag_fgets(buf, size, fp)$/;"	f
tag_fgets	tag.c	973;"	d	file:
tag_fname	tag.c	/^    char_u	*tag_fname;	\/* file name of the tags file *\/$/;"	m	struct:tag_pointers	file:
tag_fnames	tag.c	/^static garray_T tag_fnames = GA_EMPTY;$/;"	v	file:
tag_freematch	tag.c	/^tag_freematch()$/;"	f
tag_full_fname	tag.c	/^tag_full_fname(tagp)$/;"	f	file:
tag_pointers	tag.c	/^typedef struct tag_pointers$/;"	s	file:
tag_strnicmp	tag.c	/^tag_strnicmp(s1, s2, len)$/;"	f	file:
taggy	structs.h	/^typedef struct taggy$/;"	s
taggy_T	structs.h	/^} taggy_T;$/;"	t	typeref:struct:taggy
tagkind	tag.c	/^    char_u	*tagkind;	\/* "kind:" value *\/$/;"	m	struct:tag_pointers	file:
tagkind_end	tag.c	/^    char_u	*tagkind_end;	\/* end of tagkind *\/$/;"	m	struct:tag_pointers	file:
taglen_advance	tag.c	/^taglen_advance(l)$/;"	f	file:
tagmatchname	tag.c	/^static char_u	*tagmatchname = NULL;	\/* name of last used tag *\/$/;"	v	file:
tagname	structs.h	/^    char_u	*tagname;	\/* tag name *\/$/;"	m	struct:taggy
tagname	tag.c	/^    char_u	*tagname;	\/* start of tag name (skip "file:") *\/$/;"	m	struct:tag_pointers	file:
tagname_end	tag.c	/^    char_u	*tagname_end;	\/* char after tag name *\/$/;"	m	struct:tag_pointers	file:
tagptrs_T	tag.c	/^} tagptrs_T;$/;"	t	typeref:struct:tag_pointers	file:
tags	gui_amiga.c	/^struct TagItem tags[] =$/;"	v	typeref:struct:TagItem
tail	fileio.c	/^    char_u	*tail;		\/* tail of fname *\/$/;"	m	struct:AutoPatCmd	file:
taken	testdir/test49.vim	/^    let taken = ""$/;"	v
taken	testdir/test49.vim	/^let taken = ""$/;"	v
target	gui_beval.h	/^    GtkWidget		*target;	\/* widget we are monitoring *\/$/;"	m	struct:BalloonEvalStruct
target_event_cb	gui_beval.c	/^target_event_cb(GtkWidget *widget, GdkEvent *event, gpointer data)$/;"	f	file:
targets_atom	ui.c	/^static Atom	targets_atom;$/;"	v	file:
tasave_T	structs.h	/^} tasave_T;$/;"	t	typeref:struct:__anon39
tb_buf	structs.h	/^    char_u	*tb_buf;	\/* buffer for typed characters *\/$/;"	m	struct:__anon38
tb_buflen	structs.h	/^    int		tb_buflen;	\/* size of tb_buf[] *\/$/;"	m	struct:__anon38
tb_change_cnt	structs.h	/^    int		tb_change_cnt;	\/* nr of time tb_buf was changed; never zero *\/$/;"	m	struct:__anon38
tb_len	structs.h	/^    int		tb_len;		\/* number of valid bytes in tb_buf[] *\/$/;"	m	struct:__anon38
tb_maplen	structs.h	/^    int		tb_maplen;	\/* nr of mapped bytes in tb_buf[] *\/$/;"	m	struct:__anon38
tb_no_abbr_cnt	structs.h	/^    int		tb_no_abbr_cnt; \/* nr of bytes without abbrev. in tb_buf[] *\/$/;"	m	struct:__anon38
tb_noremap	structs.h	/^    char_u	*tb_noremap;	\/* mapping flags for characters in tb_buf[] *\/$/;"	m	struct:__anon38
tb_off	structs.h	/^    int		tb_off;		\/* current position in tb_buf[] *\/$/;"	m	struct:__anon38
tb_silent	structs.h	/^    int		tb_silent;	\/* nr of silently mapped bytes in tb_buf[] *\/$/;"	m	struct:__anon38
tbis_flags	option.h	/^EXTERN unsigned tbis_flags;$/;"	v
tc_len	term.c	/^static int  tc_len = 0;	    \/* current number of entries in termcodes[] *\/$/;"	v	file:
tc_max_len	term.c	/^static int  tc_max_len = 0; \/* number of entries that termcodes[] can hold *\/$/;"	v	file:
tcl_ref	structs.h	/^    void	*tcl_ref;$/;"	m	struct:file_buffer
tcl_ref	structs.h	/^    void	*tcl_ref;$/;"	m	struct:window
tearoff_handle	structs.h	/^    GtkWidget	*tearoff_handle;$/;"	m	struct:VimMenu
tearoff_handle	structs.h	/^    HWND	tearoff_handle;	    \/* hWnd of tearoff if created *\/$/;"	m	struct:VimMenu
temp_count	fileio.c	/^static long	temp_count = 0;		\/* Temp filename counter. *\/$/;"	v	file:
tent	termlib.c	/^char	*tent;		      \/* Pointer to terminal entry, set by tgetent *\/$/;"	v
term	structs.h	/^	} term;$/;"	m	union:attr_entry::__anon34	typeref:struct:attr_entry::__anon34::__anon35
term_7to8bit	term.c	/^term_7to8bit(p)$/;"	f	file:
term_append_lines	term.c	/^term_append_lines(line_count)$/;"	f
term_attr_table	syntax.c	/^garray_T	term_attr_table = {0, 0, 0, 0, NULL};$/;"	v
term_bg_color	term.c	/^term_bg_color(n)$/;"	f
term_color	term.c	/^term_color(s, n)$/;"	f	file:
term_console	globals.h	/^EXTERN int	term_console INIT(= FALSE); \/* set to TRUE when console used *\/$/;"	v
term_cursor_right	term.c	/^term_cursor_right(i)$/;"	f
term_delete_lines	term.c	/^term_delete_lines(line_count)$/;"	f
term_fg_color	term.c	/^term_fg_color(n)$/;"	f
term_is_8bit	term.c	/^term_is_8bit(name)$/;"	f
term_is_builtin	term.c	/^term_is_builtin(name)$/;"	f	file:
term_is_gui	term.c	/^term_is_gui(name)$/;"	f
term_is_xterm	globals.h	/^EXTERN int	term_is_xterm INIT(= FALSE);	\/* xterm-like 'term' *\/$/;"	v
term_set_winpos	term.c	/^term_set_winpos(x, y)$/;"	f
term_set_winsize	term.c	/^term_set_winsize(width, height)$/;"	f
term_settitle	term.c	/^term_settitle(title)$/;"	f
term_str	vim.h	1367;"	d
term_strings	term.c	/^char_u *(term_strings[(int)KS_LAST + 1]);$/;"	v
term_windgoto	term.c	/^term_windgoto(row, col)$/;"	f
termcap_active	globals.h	/^EXTERN int	termcap_active INIT(= FALSE);	\/* set by starttermcap() *\/$/;"	v
termcapinit	term.c	/^termcapinit(name)$/;"	f
termcode	term.c	/^struct termcode$/;"	s	file:
termcodes	term.c	/^} *termcodes = NULL;$/;"	v	typeref:struct:termcode
termleader	term.c	/^static char_u	termleader[256 + 1];		\/* for check_termcode() *\/$/;"	v	file:
test_for_current	tag.c	/^test_for_current(is_etag, fname, fname_end, tag_fname, buf_ffname)$/;"	f	file:
test_for_static	tag.c	/^test_for_static(tagp)$/;"	f	file:
text_atom	ui.c	/^static Atom	text_atom;$/;"	v	file:
text_context	gui.h	/^    PangoContext     *text_context; \/* the context used for all text *\/$/;"	m	struct:Gui
text_gc	gui.h	/^    GC		text_gc;$/;"	m	struct:Gui
text_gc	gui.h	/^    GdkGC	*text_gc;	    \/* cached GC for normal text *\/$/;"	m	struct:Gui
textcol	ops.c	/^    colnr_T	textcol;	\/* cols of chars (at least part.) in block *\/$/;"	m	struct:block_def	file:
textdomain	vim.h	413;"	d
textdomain	vim.h	431;"	d
textdomain	vim.h	433;"	d
textfont	gui.h	/^    struct TextFont *textfont;		\/* a pointer to the font structure *\/$/;"	m	struct:Gui	typeref:struct:Gui::TextFont
textlen	ops.c	/^    int		textlen;	\/* chars in block *\/$/;"	m	struct:block_def	file:
textstart	ops.c	/^    char_u	*textstart;	\/* pointer to 1st char in block *\/$/;"	m	struct:block_def	file:
tgetent	termlib.c	/^tgetent(tbuf, term)$/;"	f
tgetent_error	term.c	/^tgetent_error(tbuf, term)$/;"	f	file:
tgetflag	termlib.c	/^tgetflag(id)$/;"	f
tgetnum	termlib.c	/^tgetnum(id)$/;"	f
tgetstr	term.c	25;"	d	file:
tgetstr	term.c	51;"	d	file:
tgetstr	termlib.c	/^tgetstr(id, buf)$/;"	f
tgoto	term.c	/^tgoto(cm, x, y)$/;"	f
tgoto	termlib.c	/^tgoto(cm, col, line)$/;"	f
thrmsg	testdir/test49.vim	/^	    let thrmsg = ""$/;"	v
thrmsg	testdir/test49.vim	/^	    let thrmsg = substitute(v:exception, '^Vim\\((\\a\\+)\\)\\=:', '', "")$/;"	v
throw_exception	ex_eval.c	/^throw_exception(value, type, cmdname)$/;"	f	file:
throw_lnum	structs.h	/^    linenr_T		throw_lnum;	\/* line number of the throw point *\/$/;"	m	struct:vim_exception
throw_msg	structs.h	/^    char_u		*throw_msg;	\/* msg to throw: usually original one *\/$/;"	m	struct:msglist
throw_name	structs.h	/^    char_u		*throw_name;	\/* name of the throw point *\/$/;"	m	struct:vim_exception
throwcount	testdir/test49.vim	/^let throwcount = 0$/;"	v
throwpoint	testdir/test49.vim	/^		let throwpoint = v:throwpoint$/;"	v
throwpoint	testdir/test49.vim	/^	    let throwpoint = v:throwpoint$/;"	v
throwpoint	testdir/test49.vim	/^	let throwpoint = v:throwpoint$/;"	v
throwpoint	testdir/test49.vim	/^    let throwpoint = v:throwpoint$/;"	v
ti_change	buffer.c	/^ti_change(str, last)$/;"	f	file:
tilde_replace	ex_getln.c	/^tilde_replace(orig_pat, num_files, files)$/;"	f
time_diff	main.c	/^time_diff(then, now)$/;"	f	file:
time_differs	fileio.c	/^time_differs(t1, t2)$/;"	f	file:
time_fd	main.c	/^static FILE *time_fd = NULL;$/;"	v	file:
time_msg	main.c	/^time_msg(msg, tv_start)$/;"	f
time_pop	main.c	/^time_pop(tp)$/;"	f
time_push	main.c	/^time_push(tv_rel, tv_start)$/;"	f
timeout_cb	gui_beval.c	/^timeout_cb(gpointer data)$/;"	f	file:
timerID	gui_beval.h	/^    unsigned int	timerID;	\/* timer for run *\/$/;"	m	struct:BalloonEvalStruct
timerRoutine	gui_beval.c	/^timerRoutine(dx, id)$/;"	f	file:
tip	structs.h	/^    BalloonEval *tip;		    \/* tooltip for this menu item *\/$/;"	m	struct:VimMenu
title	ex_cmds2.c	/^    char_u  title[256];$/;"	m	struct:prt_ps_resource_S	file:
tltoa	term.c	/^tltoa(i)$/;"	f
tmpfile	testdir/test49.vim	/^	    let tmpfile = tempname()$/;"	v
tmpfile	testdir/test49.vim	/^	let tmpfile = tempname()$/;"	v
to	digraph.c	/^    char_u	*to;$/;"	m	struct:__anon20	file:
to	menu.c	/^    char_u	*to;		\/* translated name *\/$/;"	m	struct:__anon47	file:
toF_Rjoin	farsi.c	/^toF_Rjoin(c)$/;"	f	file:
toF_TyA	farsi.c	/^toF_TyA(c)$/;"	f
toF_TyB	farsi.c	/^toF_TyB(c)$/;"	f	file:
toF_Xor_X_	farsi.c	/^toF_Xor_X_(c)$/;"	f	file:
toF_ending	farsi.c	/^toF_ending(c)$/;"	f	file:
toF_leading	farsi.c	/^toF_leading(c)$/;"	f	file:
toLower	mbyte.c	/^convertStruct toLower[] =$/;"	v
toUpper	mbyte.c	/^convertStruct toUpper[] =$/;"	v
to_device_units	ex_cmds2.c	/^to_device_units(idx, physsize, def_number)$/;"	f	file:
toggle_Magic	regexp.c	/^toggle_Magic(x)$/;"	f	file:
tolower_tab	globals.h	/^EXTERN char_u	tolower_tab[256];	\/* table for tolower() *\/$/;"	v
toolbar	gui.h	/^    GtkWidget	*toolbar;	    \/* toolbar *\/$/;"	m	struct:Gui
toolbar_flags	option.h	/^EXTERN unsigned toolbar_flags;$/;"	v
toolbar_h	gui.h	/^    GtkWidget	*toolbar_h;	    \/* toolbar handle *\/$/;"	m	struct:Gui
toolbar_height	gui.h	/^    int		toolbar_height;	    \/* height of the toolbar *\/$/;"	m	struct:Gui
toolbar_height	gui.h	/^    int		toolbar_height;$/;"	m	struct:Gui
toolbar_names	menu.c	/^static const char *toolbar_names[] =$/;"	v	file:
tooltip_bg_pixel	gui.h	/^    guicolor_T	tooltip_bg_pixel;	\/* tooltip background color *\/$/;"	m	struct:Gui
tooltip_fg_pixel	gui.h	/^    guicolor_T	tooltip_fg_pixel;	\/* tooltip foreground color *\/$/;"	m	struct:Gui
tooltip_fontset	gui.h	/^    XFontSet	tooltip_fontset;	\/* tooltip fontset *\/$/;"	m	struct:Gui
top	gui.h	/^    int		top;		\/* Top of scroll bar (chars from row 0) *\/$/;"	m	struct:GuiScrollbar
top_bot_msg	search.c	/^static char_u *top_bot_msg = (char_u *)N_("search hit TOP, continuing at BOTTOM");$/;"	v	file:
top_file_num	buffer.c	/^static int  top_file_num = 1;		\/* highest file number *\/$/;"	v	file:
topframe	globals.h	/^EXTERN frame_T	*topframe;	\/* top of the window frame tree *\/$/;"	v
topline_back	move.c	/^topline_back(lp)$/;"	f	file:
topline_botline	move.c	/^topline_botline(lp)$/;"	f	file:
topmsg	tag.c	/^static char_u *topmsg = (char_u *)N_("E556: at top of tag stack");$/;"	v	file:
total_mem_used	memfile.c	/^static long_u	total_mem_used = 0;	\/* total memory used for memfiles *\/$/;"	v	file:
toupper_tab	globals.h	/^EXTERN char_u	toupper_tab[256];	\/* table for toupper() *\/$/;"	v
tputs	termlib.c	/^tputs(cp, affcnt, outc)$/;"	f
trans_characters	charset.c	/^trans_characters(buf, bufsize)$/;"	f
trans_function_name	eval.c	/^trans_function_name(pp, skip, internal)$/;"	f	file:
trans_special	misc2.c	/^trans_special(srcp, dst, keycode)$/;"	f
transchar	charset.c	/^transchar(c)$/;"	f
transchar_buf	charset.c	/^static char_u	transchar_buf[7];$/;"	v	file:
transchar_byte	charset.c	/^transchar_byte(c)$/;"	f
transchar_byte	vim.h	1239;"	d
transchar_hex	charset.c	/^transchar_hex(buf, c)$/;"	f
transchar_nonprint	charset.c	/^transchar_nonprint(buf, c)$/;"	f
translate_mapping	term.c	/^translate_mapping(str, expmap)$/;"	f
translate_pango_attributes	mbyte.c	/^translate_pango_attributes(PangoAttrIterator *iter)$/;"	f	file:
transstr	charset.c	/^transstr(s)$/;"	f
trash_input_buf	ui.c	/^trash_input_buf()$/;"	f
trunc_string	message.c	/^trunc_string(s, buf, room)$/;"	f
truncate_line	misc1.c	/^truncate_line(fixpos)$/;"	f
truncate_spaces	edit.c	/^truncate_spaces(line)$/;"	f
trylevel	globals.h	/^EXTERN int trylevel INIT(= 0);$/;"	v
ts	gui_beval.h	/^    int			ts;		\/* tabstop setting for this buffer *\/$/;"	m	struct:BalloonEvalStruct
ttest	term.c	/^ttest(pairs)$/;"	f
ttym_flags	option.h	/^EXTERN unsigned ttym_flags;$/;"	v
type	eval.c	/^    char	type;		\/* VAR_NUMBER or VAR_STRING *\/$/;"	m	struct:vimvar	file:
type	ex_cmds2.c	/^    int     type;$/;"	m	struct:prt_ps_resource_S	file:
type	gui.h	/^    int		type;		\/* one of SBAR_{LEFT,RIGHT,BOTTOM} *\/$/;"	m	struct:GuiScrollbar
type	structs.h	/^    int			type;		\/* exception type *\/$/;"	m	struct:vim_exception
typeahead_char	getchar.c	/^static int typeahead_char = 0;		\/* typeahead char that's not flushed *\/$/;"	v	file:
typeahead_noflush	getchar.c	/^typeahead_noflush(c)$/;"	f
typebuf	globals.h	/^EXTERN typebuf_T typebuf		\/* typeahead buffer *\/$/;"	v
typebuf_T	structs.h	/^} typebuf_T;$/;"	t	typeref:struct:__anon38
typebuf_changed	getchar.c	/^typebuf_changed(tb_change_cnt)$/;"	f
typebuf_init	getchar.c	/^static char_u	typebuf_init[TYPELEN_INIT];	\/* initial typebuf.tb_buf *\/$/;"	v	file:
typebuf_maplen	getchar.c	/^typebuf_maplen()$/;"	f
typebuf_typed	getchar.c	/^typebuf_typed()$/;"	f
typebuf_valid	structs.h	/^    int			typebuf_valid;	    \/* TRUE when save_typebuf valid *\/$/;"	m	struct:__anon39
typenr	structs.h	/^    int		typenr;		\/* typenr of sign *\/$/;"	m	struct:signlist
u8char_T	vim.h	/^typedef unsigned short u8char_T;$/;"	t
u_alloc_line	undo.c	/^u_alloc_line(size)$/;"	f	file:
u_blockalloc	undo.c	/^u_blockalloc(size)$/;"	f	file:
u_blockfree	undo.c	/^u_blockfree(buf)$/;"	f
u_clearall	undo.c	/^u_clearall(buf)$/;"	f
u_clearline	undo.c	/^u_clearline()$/;"	f
u_doit	undo.c	/^u_doit(count)$/;"	f	file:
u_entry	structs.h	/^struct u_entry$/;"	s
u_entry_T	structs.h	/^typedef struct u_entry u_entry_T;$/;"	t	typeref:struct:u_entry
u_free_line	undo.c	/^u_free_line(ptr, keep)$/;"	f	file:
u_freeentry	undo.c	/^u_freeentry(uep, n)$/;"	f	file:
u_freelist	undo.c	/^u_freelist(uhp)$/;"	f	file:
u_get_headentry	undo.c	/^u_get_headentry()$/;"	f	file:
u_getbot	undo.c	/^u_getbot()$/;"	f	file:
u_header	structs.h	/^struct u_header$/;"	s
u_header_T	structs.h	/^typedef struct u_header u_header_T;$/;"	t	typeref:struct:u_header
u_inssub	undo.c	/^u_inssub(lnum)$/;"	f
u_newcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_oldcount	undo.c	/^static long	u_newcount, u_oldcount;$/;"	v	file:
u_redo	undo.c	/^u_redo(count)$/;"	f
u_save	undo.c	/^u_save(top, bot)$/;"	f
u_save_cursor	undo.c	/^u_save_cursor()$/;"	f
u_save_line	undo.c	/^u_save_line(lnum)$/;"	f	file:
u_savecommon	undo.c	/^u_savecommon(top, bot, newbot)$/;"	f	file:
u_savedel	undo.c	/^u_savedel(lnum, nlines)$/;"	f
u_saveline	undo.c	/^u_saveline(lnum)$/;"	f
u_savesub	undo.c	/^u_savesub(lnum)$/;"	f
u_sync	undo.c	/^u_sync()$/;"	f
u_unchanged	undo.c	/^u_unchanged(buf)$/;"	f
u_undo	undo.c	/^u_undo(count)$/;"	f
u_undo_end	undo.c	/^u_undo_end()$/;"	f	file:
u_undoline	undo.c	/^u_undoline()$/;"	f
u_undoredo	undo.c	/^u_undoredo()$/;"	f	file:
uc_add_command	ex_docmd.c	/^uc_add_command(name, name_len, rep, argt, def, flags, compl, compl_arg, force)$/;"	f	file:
uc_argt	ex_docmd.c	/^    long_u	uc_argt;	\/* The argument type *\/$/;"	m	struct:ucmd	file:
uc_check_code	ex_docmd.c	/^uc_check_code(code, len, buf, cmd, eap, split_buf, split_len)$/;"	f	file:
uc_clear	ex_docmd.c	/^uc_clear(gap)$/;"	f
uc_compl	ex_docmd.c	/^    int		uc_compl;	\/* completion type *\/$/;"	m	struct:ucmd	file:
uc_compl_arg	ex_docmd.c	/^    char_u	*uc_compl_arg;	\/* completion argument if any *\/$/;"	m	struct:ucmd	file:
uc_def	ex_docmd.c	/^    long	uc_def;		\/* The default value for a range\/count *\/$/;"	m	struct:ucmd	file:
uc_fun_cmd	ex_docmd.c	/^uc_fun_cmd()$/;"	f	file:
uc_list	ex_docmd.c	/^uc_list(name, name_len)$/;"	f	file:
uc_name	ex_docmd.c	/^    char_u	*uc_name;	\/* The command name *\/$/;"	m	struct:ucmd	file:
uc_rep	ex_docmd.c	/^    char_u	*uc_rep;	\/* The command's replacement string *\/$/;"	m	struct:ucmd	file:
uc_scan_attr	ex_docmd.c	/^uc_scan_attr(attr, len, argt, def, flags, compl, compl_arg)$/;"	f	file:
uc_scriptID	ex_docmd.c	/^    scid_T	uc_scriptID;	\/* SID where the command was defined *\/$/;"	m	struct:ucmd	file:
uc_split_args	ex_docmd.c	/^uc_split_args(arg, lenp)$/;"	f	file:
ucmd	ex_docmd.c	/^typedef struct ucmd$/;"	s	file:
ucmd_T	ex_docmd.c	/^} ucmd_T;$/;"	t	typeref:struct:ucmd	file:
ucmds	ex_docmd.c	/^garray_T ucmds = {0, 0, sizeof(ucmd_T), 4, NULL};$/;"	v
ucs2bytes	fileio.c	/^ucs2bytes(c, pp, flags)$/;"	f	file:
ue_array	structs.h	/^    char_u	**ue_array;	\/* array of lines in undo block *\/$/;"	m	struct:u_entry
ue_bot	structs.h	/^    linenr_T	ue_bot;		\/* number of line below undo block *\/$/;"	m	struct:u_entry
ue_lcount	structs.h	/^    linenr_T	ue_lcount;	\/* linecount when u_save called *\/$/;"	m	struct:u_entry
ue_next	structs.h	/^    u_entry_T	*ue_next;	\/* pointer to next entry in list *\/$/;"	m	struct:u_entry
ue_size	structs.h	/^    long	ue_size;	\/* number of lines in ue_array *\/$/;"	m	struct:u_entry
ue_top	structs.h	/^    linenr_T	ue_top;		\/* number of line above undo block *\/$/;"	m	struct:u_entry
ufunc	eval.c	/^struct ufunc$/;"	s	file:
ufunc_T	eval.c	/^typedef struct ufunc ufunc_T;$/;"	t	typeref:struct:ufunc	file:
uh_cursor	structs.h	/^    pos_T	uh_cursor;	\/* cursor position before saving *\/$/;"	m	struct:u_header
uh_cursor_vcol	structs.h	/^    long	uh_cursor_vcol;$/;"	m	struct:u_header
uh_entry	structs.h	/^    u_entry_T	*uh_entry;	\/* pointer to first entry *\/$/;"	m	struct:u_header
uh_flags	structs.h	/^    int		uh_flags;	\/* see below *\/$/;"	m	struct:u_header
uh_getbot_entry	structs.h	/^    u_entry_T	*uh_getbot_entry; \/* pointer to where ue_bot must be set *\/$/;"	m	struct:u_header
uh_namedm	structs.h	/^    pos_T	uh_namedm[NMARKS];	\/* marks before undo\/after redo *\/$/;"	m	struct:u_header
uh_next	structs.h	/^    u_header_T	*uh_next;	\/* pointer to next header in list *\/$/;"	m	struct:u_header
uh_prev	structs.h	/^    u_header_T	*uh_prev;	\/* pointer to previous header in list *\/$/;"	m	struct:u_header
ui_breakcheck	ui.c	/^ui_breakcheck()$/;"	f
ui_char_avail	ui.c	/^ui_char_avail()$/;"	f
ui_cursor_shape	ui.c	/^ui_cursor_shape()$/;"	f
ui_delay	ui.c	/^ui_delay(msec, ignoreinput)$/;"	f
ui_focus_change	ui.c	/^ui_focus_change(in_focus)$/;"	f
ui_get_shellsize	ui.c	/^ui_get_shellsize()$/;"	f
ui_inchar	ui.c	/^ui_inchar(buf, maxlen, wtime, tb_change_cnt)$/;"	f
ui_inchar_undo	ui.c	/^ui_inchar_undo(s, len)$/;"	f
ui_new_shellsize	ui.c	/^ui_new_shellsize()$/;"	f
ui_set_shellsize	ui.c	/^ui_set_shellsize(mustset)$/;"	f
ui_suspend	ui.c	/^ui_suspend()$/;"	f
ui_write	ui.c	/^ui_write(s, len)$/;"	f
ulg	misc2.c	/^typedef unsigned long  ulg;	\/* unsigned 32-bit value *\/$/;"	t	file:
uline_offset	ex_cmds2.c	/^    int		uline_offset;$/;"	m	struct:prt_ps_font_S	file:
uline_width	ex_cmds2.c	/^    int		uline_width;$/;"	m	struct:prt_ps_font_S	file:
un_Magic	regexp.c	229;"	d	file:
unadjust_for_sel	normal.c	/^unadjust_for_sel()$/;"	f	file:
unchanged	misc1.c	/^unchanged(buf, ff)$/;"	f
underline	structs.h	/^    int		underline;$/;"	m	struct:__anon44
undisplay_dollar	edit.c	/^undisplay_dollar()$/;"	f	file:
undo_off	globals.h	/^EXTERN int	undo_off INIT(= FALSE);	    \/* undo switched off for now *\/$/;"	v
undo_undoes	undo.c	/^static int	undo_undoes = FALSE;$/;"	v	file:
undrawBalloon	gui_beval.c	/^undrawBalloon(BalloonEval *beval)$/;"	f	file:
undrawBalloon	gui_beval.c	/^undrawBalloon(beval)$/;"	f	file:
ungetchr	regexp.c	/^ungetchr()$/;"	f	file:
unputcmdline	ex_getln.c	/^unputcmdline()$/;"	f
unref_extmatch	regexp.c	/^unref_extmatch(em)$/;"	f
unshift_special	normal.c	/^unshift_special(cap)$/;"	f	file:
unshowmode	screen.c	/^unshowmode(force)$/;"	f
updateWindow	screen.c	/^updateWindow(wp)$/;"	f
update_curbuf	screen.c	/^update_curbuf(type)$/;"	f
update_curswant	move.c	/^update_curswant()$/;"	f
update_debug_sign	screen.c	/^update_debug_sign(buf, lnum)$/;"	f
update_finish	screen.c	/^update_finish()$/;"	f	file:
update_force_abort	ex_eval.c	/^update_force_abort()$/;"	f
update_keys	misc2.c	/^update_keys(c)$/;"	f
update_mouseshape	misc2.c	/^update_mouseshape(shape_idx)$/;"	f
update_prepare	screen.c	/^update_prepare()$/;"	f	file:
update_screen	screen.c	/^update_screen(type)$/;"	f
update_si_attr	syntax.c	/^update_si_attr(idx)$/;"	f	file:
update_si_end	syntax.c	/^update_si_end(sip, startcol, force)$/;"	f	file:
update_tcap	term.c	/^update_tcap(attr)$/;"	f
update_topline	move.c	/^update_topline()$/;"	f
update_topline_cursor	ex_docmd.c	/^update_topline_cursor()$/;"	f
update_topline_redraw	move.c	/^update_topline_redraw()$/;"	f
updatescript	getchar.c	/^updatescript(c)$/;"	f
updating_screen	globals.h	/^EXTERN int	updating_screen INIT(= FALSE);$/;"	v
usage	main.c	/^usage()$/;"	f	file:
use_gvimrc	globals.h	/^EXTERN char_u	*use_gvimrc INIT(= NULL);	\/* "-U" cmdline argument *\/$/;"	v
use_reg_one	structs.h	/^    int		use_reg_one;	\/* TRUE if delete uses reg 1 even when not$/;"	m	struct:oparg
use_status_area	mbyte.c	/^static gboolean	use_status_area = 0;$/;"	v	file:
use_viminfo	globals.h	/^EXTERN char_u	*use_viminfo INIT(= NULL);  \/* name of viminfo file to use *\/$/;"	v
used_for	structs.h	/^    char	used_for;	\/* SHAPE_MOUSE and\/or SHAPE_CURSOR *\/$/;"	m	struct:cursor_entry
usefilter	ex_cmds.h	/^    int		usefilter;	\/* TRUE with ":w !command" and ":r!command" *\/$/;"	m	struct:exarg
user_abort	structs.h	/^    int		user_abort;$/;"	m	struct:__anon45
user_digraphs	digraph.c	/^static garray_T	user_digraphs = {0, 0, sizeof(digr_T), 10, NULL};$/;"	v	file:
userhl	structs.h	/^    int		userhl;$/;"	m	struct:stl_hlrec
useridx	ex_cmds.h	/^    int		useridx;	\/* user command index *\/$/;"	m	struct:exarg
ush	misc2.c	/^typedef unsigned short ush;	\/* unsigned 16-bit value *\/$/;"	t	file:
usingNetbeans	globals.h	/^EXTERN int usingNetbeans INIT(= 0);	\/* set if -nb flag is used *\/$/;"	v
using_script	getchar.c	/^using_script()$/;"	f
utf8len_tab	mbyte.c	/^static char utf8len_tab[256] =$/;"	v	file:
utf_byte2len	mbyte.c	/^utf_byte2len(b)$/;"	f
utf_char2bytes	mbyte.c	/^utf_char2bytes(c, buf)$/;"	f
utf_char2cells	mbyte.c	/^utf_char2cells(c)$/;"	f
utf_char2len	mbyte.c	/^utf_char2len(c)$/;"	f
utf_class	mbyte.c	/^utf_class(c)$/;"	f
utf_composinglike	mbyte.c	/^utf_composinglike(p1, p2)$/;"	f
utf_convert	mbyte.c	/^utf_convert(a, table, tableSize)$/;"	f	file:
utf_fold	mbyte.c	/^utf_fold(a)$/;"	f
utf_head_off	mbyte.c	/^utf_head_off(base, p)$/;"	f
utf_iscomposing	mbyte.c	/^utf_iscomposing(c)$/;"	f
utf_islower	mbyte.c	/^utf_islower(a)$/;"	f
utf_isupper	mbyte.c	/^utf_isupper(a)$/;"	f
utf_off2cells	mbyte.c	/^utf_off2cells(off)$/;"	f
utf_printable	mbyte.c	/^utf_printable(c)$/;"	f
utf_ptr2cells	mbyte.c	/^utf_ptr2cells(p)$/;"	f
utf_ptr2char	mbyte.c	/^utf_ptr2char(p)$/;"	f
utf_ptr2len_check	mbyte.c	/^utf_ptr2len_check(p)$/;"	f
utf_ptr2len_check_len	mbyte.c	/^utf_ptr2len_check_len(p, size)$/;"	f
utf_tolower	mbyte.c	/^utf_tolower(a)$/;"	f
utf_toupper	mbyte.c	/^utf_toupper(a)$/;"	f
utf_valid_string	mbyte.c	/^utf_valid_string(s, end)$/;"	f
utfc_char2bytes	mbyte.c	/^utfc_char2bytes(off, buf)$/;"	f
utfc_ptr2char	mbyte.c	/^utfc_ptr2char(p, p1, p2)$/;"	f
utfc_ptr2char_len	mbyte.c	/^utfc_ptr2char_len(p, p1, p2, maxlen)$/;"	f
utfc_ptr2len_check	mbyte.c	/^utfc_ptr2len_check(p)$/;"	f
utfc_ptr2len_check_len	mbyte.c	/^utfc_ptr2len_check_len(p, size)$/;"	f
v	testdir/test49.vim	/^		    let v{ERR(t) + CONT(t)} = 0$/;"	v
v	testdir/test49.vim	/^		    let v{ERR(t) + CONT(t)}$/;"	v
v	testdir/test49.vim	/^		    let v{novar + CONT(t)} = 0$/;"	v
v	testdir/test49.vim	/^		    let v{novar + CONT(t)}$/;"	v
v_exception	eval.c	/^v_exception(oldval)$/;"	f
v_swap_corners	normal.c	/^v_swap_corners(cmdchar)$/;"	f	file:
v_throwpoint	eval.c	/^v_throwpoint(oldval)$/;"	f
v_visop	normal.c	/^v_visop(cap)$/;"	f	file:
val	eval.c	/^    char_u	*val;		\/* current value (can also be a number!) *\/$/;"	m	struct:vimvar	file:
valid_yank_reg	ops.c	/^valid_yank_reg(regname, writing)$/;"	f
validate_botline	move.c	/^validate_botline()$/;"	f
validate_botline_win	move.c	/^validate_botline_win(wp)$/;"	f	file:
validate_cheight	move.c	/^validate_cheight()$/;"	f	file:
validate_cline_row	move.c	/^validate_cline_row()$/;"	f
validate_current_state	syntax.c	/^validate_current_state()$/;"	f	file:
validate_cursor	move.c	/^validate_cursor()$/;"	f
validate_cursor_col	move.c	/^validate_cursor_col()$/;"	f
validate_maphash	getchar.c	/^validate_maphash()$/;"	f	file:
validate_virtcol	move.c	/^validate_virtcol()$/;"	f
validate_virtcol_win	move.c	/^validate_virtcol_win(wp)$/;"	f
value	gui.h	/^    long	value;		\/* Represents top line number visible *\/$/;"	m	struct:GuiScrollbar
value	structs.h	/^    char_u		*value;		\/* exception value *\/$/;"	m	struct:vim_exception
var	eval.c	/^} var;$/;"	t	typeref:struct:__anon16	file:
var	option.c	/^    char_u	*var;		\/* global option: pointer to variable;$/;"	m	struct:vimoption	file:
var	testdir/test49.vim	/^		    let var = exists('v{ERR(t) + CONT(t)}')$/;"	v
var	testdir/test49.vim	/^		    let var = exists('v{novar + CONT(t)}')$/;"	v
var	testdir/test49.vim	/^	let var = F(4712, "return-var", 2)$/;"	v
var	testdir/test49.vim	/^	let var = G("except3", "throw3", 5)$/;"	v
var	testdir/test49.vim	/^	let var = substitute("not", "sub", '\\=THROW("substitute()n", 11)', '')$/;"	v
var	testdir/test49.vim	/^	let var = substitute("sub", "sub", '\\=THROW("substitute()y", 10)', '')$/;"	v
var	testdir/test49.vim	/^	let var{THROW("var3")} = 4711$/;"	v
var	testdir/test49.vim	/^	let var{THROW("var4")} var{ADDPATH("T2")} | call ADDPATH("T3")$/;"	v
var1	testdir/test49.vim	/^	let var1 = "let(" . THROW("var1") . ")"$/;"	v
var1	testdir/test49.vim	/^	let var1 = {NAME(THROW("name", 1), 1)}(ARG(4711, 1), 1)$/;"	v
var2	testdir/test49.vim	/^	let var2 = "let(" . THROW("var2"). ")"$/;"	v
var2	testdir/test49.vim	/^	let var2 = "old_value"$/;"	v
var2	testdir/test49.vim	/^	let var2 = {NAME("F", 2)}(ARG(THROW("arg", 2), 2), 2)$/;"	v
var2fpos	eval.c	/^var2fpos(varp, lnum)$/;"	f	file:
var3	testdir/test49.vim	/^	let var3 = {NAME("THROW", 3)}(ARG("call", 3), 3)$/;"	v
var4	testdir/test49.vim	/^	let var4 = {NAME("F", 4)}(ARG(4711, 4), 4)$/;"	v
var_clear	eval.c	/^var_clear(gap)$/;"	f
var_flavour	eval.c	/^var_flavour(varname)$/;"	f	file:
var_flavour_T	eval.c	/^} var_flavour_T;$/;"	t	typeref:enum:__anon19	file:
var_free_one	eval.c	/^var_free_one(v)$/;"	f	file:
var_init	eval.c	/^var_init(gap)$/;"	f
var_name	eval.c	/^    char_u	*var_name;	\/* name of variable *\/$/;"	m	struct:__anon16	file:
var_number	eval.c	/^	varnumber_T	var_number;   \/* number value *\/$/;"	m	union:__anon16::__anon17	file:
var_string	eval.c	/^	char_u		*var_string;  \/* string value (Careful: can be NULL!) *\/$/;"	m	union:__anon16::__anon17	file:
var_type	eval.c	/^    char	var_type;	\/* VAR_NUMBER or VAR_STRING *\/$/;"	m	struct:__anon16	file:
var_val	eval.c	/^    } var_val;$/;"	m	struct:__anon16	typeref:union:__anon16::__anon17	file:
varargs	eval.c	/^    int		varargs;	\/* variable nr of arguments *\/$/;"	m	struct:ufunc	file:
variables	eval.c	/^garray_T	variables = {0, 0, sizeof(var), 4, NULL};$/;"	v
varnamebuf	eval.c	/^static char_u	*varnamebuf = NULL;$/;"	v	file:
varnamebuflen	eval.c	/^static int	varnamebuflen = 0;$/;"	v	file:
varnumber_T	eval.c	/^typedef int	varnumber_T;$/;"	t	file:
varnumber_T	eval.c	/^typedef long	varnumber_T;$/;"	t	file:
vc_cpfrom	structs.h	/^    int		vc_cpfrom;	\/* codepage to convert from (CONV_CODEPAGE) *\/$/;"	m	struct:__anon40
vc_cpto	structs.h	/^    int		vc_cpto;	\/* codepage to convert to (CONV_CODEPAGE) *\/$/;"	m	struct:__anon40
vc_factor	structs.h	/^    int		vc_factor;	\/* max. expansion factor *\/$/;"	m	struct:__anon40
vc_fail	structs.h	/^    int		vc_fail;	\/* fail for invalid char, don't use '?' *\/$/;"	m	struct:__anon40
vc_fd	structs.h	/^    iconv_t	vc_fd;		\/* for CONV_ICONV *\/$/;"	m	struct:__anon40
vc_type	structs.h	/^    int		vc_type;	\/* zero or one of the CONV_ values *\/$/;"	m	struct:__anon40
vcol2col	ui.c	/^vcol2col(wp, lnum, vcol)$/;"	f
vdcmp	gui.h	/^    int		vdcmp;		    \/* Vim Direct Communication Message Port *\/$/;"	m	struct:Gui
ve_flags	option.h	/^EXTERN unsigned ve_flags;$/;"	v
version	ex_cmds2.c	/^    char_u  version[256];$/;"	m	struct:prt_ps_resource_S	file:
version	xxd/xxd.c	/^char version[] = "xxd V1.10 27oct98 by Juergen Weigert";$/;"	v
version_msg	version.c	/^version_msg(s)$/;"	f	file:
vgetc	getchar.c	/^vgetc()$/;"	f
vgetc_busy	globals.h	/^EXTERN int	vgetc_busy INIT(= FALSE);   \/* inside vgetc() now *\/$/;"	v
vgetc_im_active	globals.h	/^EXTERN int	vgetc_im_active;	\/* Input Method was active for last$/;"	v
vgetorpeek	getchar.c	/^vgetorpeek(advance)$/;"	f	file:
vimApp	gui.h	/^    VimApp     *vimApp;$/;"	m	struct:Gui
vimContainer	gui.h	/^    PtWidget_t	*vimContainer;		\/* PtPanel *\/$/;"	m	struct:Gui
vimForm	gui.h	/^    VimFormView *vimForm;$/;"	m	struct:Gui
vimMenuBar	gui.h	/^    PtWidget_t	*vimMenuBar;$/;"	m	struct:Gui
vimNewWindow	gui_amiga.c	/^static struct NewWindow vimNewWindow =$/;"	v	typeref:struct:NewWindow	file:
vimTextArea	gui.h	/^    PtWidget_t	*vimTextArea;		\/* PtRaw *\/$/;"	m	struct:Gui
vimTextArea	gui.h	/^    VimTextAreaView *vimTextArea;$/;"	m	struct:Gui
vimToolBar	gui.h	/^    PtWidget_t	*vimToolBar;$/;"	m	struct:Gui
vimToolBarGroup	gui.h	/^    PtWidget_t	*vimToolBarGroup;$/;"	m	struct:Gui
vimWindow	gui.h	/^    PtWidget_t	*vimWindow;		\/* PtWindow *\/$/;"	m	struct:Gui
vimWindow	gui.h	/^    VimWindow  *vimWindow;$/;"	m	struct:Gui
vim_FullName	window.c	/^vim_FullName(fname, buf, len, force)$/;"	f
vim_acl_T	vim.h	/^typedef void	    *vim_acl_T;		\/* dummy to pass an ACL to a function *\/$/;"	t
vim_atom	ui.c	/^static Atom	vim_atom;	\/* Vim's own special selection format *\/$/;"	v	file:
vim_backtick	misc1.c	/^vim_backtick(p)$/;"	f	file:
vim_beep	misc1.c	/^vim_beep()$/;"	f
vim_chdir	misc2.c	/^vim_chdir(new_dir)$/;"	f
vim_chdirfile	misc2.c	/^vim_chdirfile(fname)$/;"	f
vim_code0	gui_amiga.c	/^    char_u  vim_code0;$/;"	m	struct:__anon25	file:
vim_code1	gui_amiga.c	/^    char_u  vim_code1;$/;"	m	struct:__anon25	file:
vim_deltempdir	fileio.c	/^vim_deltempdir()$/;"	f
vim_dialog_yesno	message.c	/^vim_dialog_yesno(type, title, message, dflt)$/;"	f
vim_dialog_yesnoallcancel	message.c	/^vim_dialog_yesnoallcancel(type, title, message, dflt)$/;"	f
vim_dialog_yesnocancel	message.c	/^vim_dialog_yesnocancel(type, title, message, dflt)$/;"	f
vim_exception	structs.h	/^struct vim_exception$/;"	s
vim_fexists	misc1.c	/^vim_fexists(fname)$/;"	f
vim_fgets	fileio.c	/^vim_fgets(buf, size, fp)$/;"	f
vim_findfile	misc2.c	/^vim_findfile(search_ctx)$/;"	f
vim_findfile_cleanup	misc2.c	/^vim_findfile_cleanup(ctx)$/;"	f
vim_findfile_free_visited	misc2.c	/^vim_findfile_free_visited(search_ctx)$/;"	f
vim_findfile_free_visited_list	misc2.c	/^vim_findfile_free_visited_list(list_headp)$/;"	f	file:
vim_findfile_init	misc2.c	/^vim_findfile_init(path, filename, stopdirs, level, free_visited, need_dir,$/;"	f
vim_findfile_stopdir	misc2.c	/^vim_findfile_stopdir(buf)$/;"	f
vim_fnamecmp	misc1.c	/^vim_fnamecmp(x, y)$/;"	f
vim_fnamencmp	misc1.c	/^vim_fnamencmp(x, y, len)$/;"	f
vim_free	misc2.c	/^vim_free(x)$/;"	f
vim_free_in_input_buf	ui.c	/^vim_free_in_input_buf()$/;"	f
vim_getenv	misc1.c	/^vim_getenv(name, mustfree)$/;"	f
vim_isAbsName	window.c	/^vim_isAbsName(name)$/;"	f
vim_isIDc	charset.c	/^vim_isIDc(c)$/;"	f
vim_is_ctrl_x_key	edit.c	/^vim_is_ctrl_x_key(c)$/;"	f
vim_is_input_buf_empty	ui.c	/^vim_is_input_buf_empty()$/;"	f
vim_is_input_buf_full	ui.c	/^vim_is_input_buf_full()$/;"	f
vim_isblankline	charset.c	/^vim_isblankline(lbuf)$/;"	f
vim_isbreak	macros.h	141;"	d
vim_isdigit	charset.c	/^vim_isdigit(c)$/;"	f
vim_isfilec	charset.c	/^vim_isfilec(c)$/;"	f
vim_ispathlistsep	misc1.c	/^vim_ispathlistsep(c)$/;"	f
vim_ispathsep	misc1.c	/^vim_ispathsep(c)$/;"	f
vim_isprintc	charset.c	/^vim_isprintc(c)$/;"	f
vim_isprintc_strict	charset.c	/^vim_isprintc_strict(c)$/;"	f
vim_isspace	misc2.c	/^vim_isspace(x)$/;"	f
vim_iswhite	vim.h	1373;"	d
vim_iswordc	charset.c	/^vim_iswordc(c)$/;"	f
vim_iswordc_buf	charset.c	/^vim_iswordc_buf(p, buf)$/;"	f
vim_iswordp	charset.c	/^vim_iswordp(p)$/;"	f
vim_isxdigit	charset.c	/^vim_isxdigit(c)$/;"	f
vim_mem_profile_dump	misc2.c	/^vim_mem_profile_dump()$/;"	f
vim_memcmp	misc2.c	/^vim_memcmp(b1, b2, len)$/;"	f
vim_memcmp	vim.h	1338;"	d
vim_memcmp	vim.h	1341;"	d
vim_memset	misc2.c	/^vim_memset(ptr, c, size)$/;"	f
vim_memset	vim.h	1332;"	d
vim_mkdir	os_amiga.h	201;"	d
vim_read	vim.h	1356;"	d
vim_read	vim.h	1359;"	d
vim_realloc	vim.h	1635;"	d
vim_realloc	vim.h	1637;"	d
vim_regcomp	regexp.c	/^vim_regcomp(expr, re_flags)$/;"	f
vim_regcomp_had_eol	regexp.c	/^vim_regcomp_had_eol()$/;"	f
vim_regexec	regexp.c	/^vim_regexec(rmp, line, col)$/;"	f
vim_regexec_both	regexp.c	/^vim_regexec_both(line_arg, col_arg)$/;"	f	file:
vim_regexec_multi	regexp.c	/^vim_regexec_multi(rmp, win, buf, lnum, col)$/;"	f
vim_regexec_nl	regexp.c	/^vim_regexec_nl(rmp, line, col)$/;"	f
vim_regsub	regexp.c	/^vim_regsub(rmp, source, dest, copy, magic, backslash)$/;"	f
vim_regsub_both	regexp.c	/^vim_regsub_both(source, dest, copy, magic, backslash)$/;"	f	file:
vim_regsub_multi	regexp.c	/^vim_regsub_multi(rmp, lnum, source, dest, copy, magic, backslash)$/;"	f
vim_rename	fileio.c	/^vim_rename(from, to)$/;"	f
vim_setenv	misc1.c	/^vim_setenv(name, val)$/;"	f
vim_str2nr	charset.c	/^vim_str2nr(start, hexp, len, dooct, dohex, nptr, unptr)$/;"	f
vim_strchr	misc2.c	/^vim_strchr(string, c)$/;"	f
vim_stricmp	misc2.c	/^vim_stricmp(s1, s2)$/;"	f
vim_strncpy	misc2.c	/^vim_strncpy(to, from, len)$/;"	f
vim_strnicmp	misc2.c	/^vim_strnicmp(s1, s2, len)$/;"	f
vim_strnsave	misc2.c	/^vim_strnsave(string, len)$/;"	f
vim_strnsave_up	misc2.c	/^vim_strnsave_up(string, len)$/;"	f
vim_strnsize	charset.c	/^vim_strnsize(s, len)$/;"	f
vim_strpbrk	misc2.c	/^vim_strpbrk(s, charset)$/;"	f
vim_strpbrk	misc2.c	1493;"	d	file:
vim_strpbrk	vim.h	1246;"	d
vim_strrchr	misc2.c	/^vim_strrchr(string, c)$/;"	f
vim_strsave	misc2.c	/^vim_strsave(string)$/;"	f
vim_strsave_escaped	misc2.c	/^vim_strsave_escaped(string, esc_chars)$/;"	f
vim_strsave_escaped_ext	misc2.c	/^vim_strsave_escaped_ext(string, esc_chars, bsl)$/;"	f
vim_strsave_up	misc2.c	/^vim_strsave_up(string)$/;"	f
vim_strsize	charset.c	/^vim_strsize(s)$/;"	f
vim_strup	misc2.c	/^vim_strup(p)$/;"	f
vim_tempdir	globals.h	/^EXTERN char_u	*vim_tempdir INIT(= NULL); \/* Name of Vim's own temp dir.$/;"	v
vim_tempname	fileio.c	/^vim_tempname(extra_char)$/;"	f
vim_tgetstr	term.c	/^vim_tgetstr(s, pp)$/;"	f	file:
vim_used_in_input_buf	ui.c	/^vim_used_in_input_buf()$/;"	f
vim_version_dir	misc1.c	/^vim_version_dir(vimdir)$/;"	f	file:
vim_write	vim.h	1357;"	d
vim_write	vim.h	1360;"	d
vimconv_T	structs.h	/^} vimconv_T;$/;"	t	typeref:struct:__anon40
vimenc_atom	ui.c	/^static Atom	vimenc_atom;	\/* Vim's extended selection format *\/$/;"	v	file:
viminfo_add_at_front	ex_getln.c	/^static int	viminfo_add_at_front = FALSE;$/;"	v	file:
viminfo_encoding	ex_cmds.c	/^viminfo_encoding(virp)$/;"	f	file:
viminfo_errcnt	ex_cmds.c	/^static int  viminfo_errcnt;$/;"	v	file:
viminfo_error	ex_cmds.c	/^viminfo_error(errnum, message, line)$/;"	f
viminfo_filename	ex_cmds.c	/^viminfo_filename(file)$/;"	f	file:
viminfo_hisidx	ex_getln.c	/^static int	viminfo_hisidx[HIST_COUNT] = {0, 0, 0, 0};$/;"	v	file:
viminfo_hislen	ex_getln.c	/^static int	viminfo_hislen[HIST_COUNT] = {0, 0, 0, 0};$/;"	v	file:
viminfo_history	ex_getln.c	/^static char_u **viminfo_history[HIST_COUNT] = {NULL, NULL, NULL, NULL};$/;"	v	file:
viminfo_readline	ex_cmds.c	/^viminfo_readline(virp)$/;"	f
viminfo_readstring	ex_cmds.c	/^viminfo_readstring(virp, off, convert)$/;"	f
viminfo_writestring	ex_cmds.c	/^viminfo_writestring(fd, p)$/;"	f
vimmenu_T	structs.h	/^typedef int vimmenu_T;$/;"	t
vimmenu_T	structs.h	/^typedef struct VimMenu vimmenu_T;$/;"	t	typeref:struct:VimMenu
vimoption	option.c	/^struct vimoption$/;"	s	file:
vimpty_getenv	misc2.c	/^vimpty_getenv(string)$/;"	f
vimrc_found	option.c	/^vimrc_found()$/;"	f
vimvar	eval.c	/^struct vimvar$/;"	s	file:
vimvars	eval.c	/^} vimvars[VV_LEN] =$/;"	v	typeref:struct:vimvar
vir_T	structs.h	/^} vir_T;$/;"	t	typeref:struct:__anon41
vir_conv	structs.h	/^    vimconv_T	vir_conv;	\/* encoding conversion *\/$/;"	m	struct:__anon41
vir_fd	structs.h	/^    FILE	*vir_fd;	\/* file descriptor *\/$/;"	m	struct:__anon41
vir_line	structs.h	/^    char_u	*vir_line;	\/* text of the current line *\/$/;"	m	struct:__anon41
virtual_active	misc2.c	/^virtual_active()$/;"	f
virtual_active	vim.h	1595;"	d
virtual_op	globals.h	/^EXTERN int	virtual_op INIT(= MAYBE);$/;"	v
virtual_op	vim.h	1596;"	d
visibility	gui.h	/^    int		visibility;	    \/* Is shell partially\/fully obscured? *\/$/;"	m	struct:Gui
visibility	gui.h	/^    int		visibility;	    \/* Is window partially\/fully obscured? *\/$/;"	m	struct:Gui
vmode	vim.h	/^    int		vmode;		\/* Visual mode character *\/$/;"	m	struct:VimClipboard
vop_flags	option.h	/^EXTERN unsigned	vop_flags;	\/* uses SSOP_ flags *\/$/;"	v
vpeekc	getchar.c	/^vpeekc()$/;"	f
vpeekc_any	getchar.c	/^vpeekc_any()$/;"	f
vpeekc_nomap	getchar.c	/^vpeekc_nomap()$/;"	f
vr_lines_changed	globals.h	/^EXTERN int	vr_lines_changed INIT(= 0); \/* #Lines changed by "gR" so far *\/$/;"	v
vungetc	getchar.c	/^vungetc(c)	\/* unget one character (can only be done once!) *\/$/;"	f
w_alist	structs.h	/^    alist_T	*w_alist;	    \/* pointer to arglist for this window *\/$/;"	m	struct:window
w_allbuf_opt	structs.h	/^    winopt_T	w_allbuf_opt;$/;"	m	struct:window
w_alt_fnum	structs.h	/^    int		w_alt_fnum;	    \/* alternate file (for # and CTRL-^) *\/$/;"	m	struct:window
w_arg_idx	structs.h	/^    int		w_arg_idx;	    \/* current index in argument list (can be$/;"	m	struct:window
w_arg_idx_invalid	structs.h	/^    int		w_arg_idx_invalid;  \/* editing another file than w_arg_idx *\/$/;"	m	struct:window
w_botfill	structs.h	/^    int		w_botfill;	    \/* TRUE when filler lines are actually$/;"	m	struct:window
w_botline	structs.h	/^    linenr_T	w_botline;	    \/* number of the line below the bottom of$/;"	m	struct:window
w_buffer	structs.h	/^    buf_T	*w_buffer;	    \/* buffer we are a window into (used$/;"	m	struct:window
w_changelistidx	structs.h	/^    int		w_changelistidx;	\/* current position in b_changelist *\/$/;"	m	struct:window
w_cline_folded	structs.h	/^    int		w_cline_folded;	    \/* cursor line is folded *\/$/;"	m	struct:window
w_cline_height	structs.h	/^    int		w_cline_height;	    \/* current size of cursor line *\/$/;"	m	struct:window
w_cline_row	structs.h	/^    int		w_cline_row;	    \/* starting row of the cursor line *\/$/;"	m	struct:window
w_cursor	structs.h	/^    pos_T	w_cursor;	    \/* cursor position in buffer *\/$/;"	m	struct:window
w_curswant	structs.h	/^    colnr_T	w_curswant;	    \/* The column we'd like to be at.  This is$/;"	m	struct:window
w_empty_rows	structs.h	/^    int		w_empty_rows;	    \/* number of ~ rows in window *\/$/;"	m	struct:window
w_farsi	structs.h	/^    int		w_farsi;	\/* for the window dependent Farsi functions *\/$/;"	m	struct:window
w_filler_rows	structs.h	/^    int		w_filler_rows;	    \/* number of filler rows at the end of the$/;"	m	struct:window
w_fold_manual	structs.h	/^    char	w_fold_manual;	    \/* when TRUE: some folds are opened\/closed$/;"	m	struct:window
w_foldinvalid	structs.h	/^    char	w_foldinvalid;	    \/* when TRUE: folding needs to be$/;"	m	struct:window
w_folds	structs.h	/^    garray_T	w_folds;	    \/* array of nested folds *\/$/;"	m	struct:window
w_fraction	structs.h	/^    int		w_fraction;$/;"	m	struct:window
w_frame	structs.h	/^    frame_T	*w_frame;	    \/* frame containing this window *\/$/;"	m	struct:window
w_height	structs.h	/^    int		w_height;	    \/* number of rows in window, excluding$/;"	m	struct:window
w_jumplist	structs.h	/^    xfmark_T	w_jumplist[JUMPLISTSIZE];$/;"	m	struct:window
w_jumplistidx	structs.h	/^    int		w_jumplistidx;		\/* current position *\/$/;"	m	struct:window
w_jumplistlen	structs.h	/^    int		w_jumplistlen;		\/* number of active entries *\/$/;"	m	struct:window
w_leftcol	structs.h	/^    colnr_T	w_leftcol;	    \/* window column number of the left most$/;"	m	struct:window
w_line	structs.h	/^typedef struct w_line$/;"	s
w_lines	structs.h	/^    wline_T	*w_lines;$/;"	m	struct:window
w_lines_valid	structs.h	/^    int		w_lines_valid;	    \/* number of valid entries *\/$/;"	m	struct:window
w_localdir	structs.h	/^    char_u	*w_localdir;	    \/* absolute path of local directory or$/;"	m	struct:window
w_match	structs.h	/^    regmmatch_T	w_match;	\/* regexp program for ":match" *\/$/;"	m	struct:window
w_match_id	structs.h	/^    int		w_match_id;	\/* highlight ID for ":match" *\/$/;"	m	struct:window
w_next	structs.h	/^    win_T	*w_next;	    \/* link to next window *\/$/;"	m	struct:window
w_old_botfill	structs.h	/^    int		w_old_botfill;	    \/* w_botfill at last redraw *\/$/;"	m	struct:window
w_old_cursor_fcol	structs.h	/^    colnr_T	w_old_cursor_fcol;  \/* first column for block visual part *\/$/;"	m	struct:window
w_old_cursor_lcol	structs.h	/^    colnr_T	w_old_cursor_lcol;  \/* last column for block visual part *\/$/;"	m	struct:window
w_old_cursor_lnum	structs.h	/^    linenr_T	w_old_cursor_lnum;  \/* last known end of visual part *\/$/;"	m	struct:window
w_old_curswant	structs.h	/^    colnr_T	w_old_curswant;	    \/* last known value of Curswant *\/$/;"	m	struct:window
w_old_topfill	structs.h	/^    int		w_old_topfill;	    \/* w_topfill at last redraw *\/$/;"	m	struct:window
w_old_visual_lnum	structs.h	/^    linenr_T	w_old_visual_lnum;  \/* last known start of visual part *\/$/;"	m	struct:window
w_old_visual_mode	structs.h	/^    char	w_old_visual_mode;  \/* last known VIsual_mode *\/$/;"	m	struct:window
w_onebuf_opt	structs.h	/^    winopt_T	w_onebuf_opt;$/;"	m	struct:window
w_p_arab	structs.h	134;"	d
w_p_diff	structs.h	138;"	d
w_p_fdc	structs.h	142;"	d
w_p_fde	structs.h	157;"	d
w_p_fdi	structs.h	146;"	d
w_p_fdl	structs.h	148;"	d
w_p_fdm	structs.h	150;"	d
w_p_fdn	structs.h	154;"	d
w_p_fdt	structs.h	159;"	d
w_p_fen	structs.h	144;"	d
w_p_fml	structs.h	152;"	d
w_p_fmr	structs.h	162;"	d
w_p_lbr	structs.h	166;"	d
w_p_list	structs.h	169;"	d
w_p_nu	structs.h	171;"	d
w_p_pvw	structs.h	178;"	d
w_p_rl	structs.h	182;"	d
w_p_rlc	structs.h	184;"	d
w_p_scb	structs.h	190;"	d
w_p_scr	structs.h	187;"	d
w_p_wfh	structs.h	174;"	d
w_p_wrap	structs.h	193;"	d
w_pcmark	structs.h	/^    pos_T	w_pcmark;	\/* previous context mark *\/$/;"	m	struct:window
w_prev	structs.h	/^    win_T	*w_prev;	    \/* link to previous window *\/$/;"	m	struct:window
w_prev_fraction_row	structs.h	/^    int		w_prev_fraction_row;$/;"	m	struct:window
w_prev_pcmark	structs.h	/^    pos_T	w_prev_pcmark;	\/* previous w_pcmark *\/$/;"	m	struct:window
w_redr_status	structs.h	/^    int		w_redr_status;	    \/* if TRUE status line must be redrawn *\/$/;"	m	struct:window
w_redr_type	structs.h	/^    int		w_redr_type;	    \/* type of redraw to be performed on win *\/$/;"	m	struct:window
w_redraw_bot	structs.h	/^    linenr_T	w_redraw_bot;	    \/* when != 0: last line needing redraw *\/$/;"	m	struct:window
w_redraw_top	structs.h	/^    linenr_T	w_redraw_top;	    \/* when != 0: first line needing redraw *\/$/;"	m	struct:window
w_ru_cursor	structs.h	/^    pos_T	w_ru_cursor;	    \/* cursor position shown in ruler *\/$/;"	m	struct:window
w_ru_empty	structs.h	/^    char	w_ru_empty;	    \/* TRUE if ruler shows 0-1 (empty line) *\/$/;"	m	struct:window
w_ru_line_count	structs.h	/^    linenr_T	w_ru_line_count;    \/* line count used for ruler *\/$/;"	m	struct:window
w_ru_topfill	structs.h	/^    int		w_ru_topfill;	    \/* topfill shown in ruler *\/$/;"	m	struct:window
w_ru_topline	structs.h	/^    linenr_T	w_ru_topline;	    \/* topline shown in ruler *\/$/;"	m	struct:window
w_ru_virtcol	structs.h	/^    colnr_T	w_ru_virtcol;	    \/* virtcol shown in ruler *\/$/;"	m	struct:window
w_scbind_pos	structs.h	/^    long	w_scbind_pos;$/;"	m	struct:window
w_scrollbars	structs.h	/^    scrollbar_T	w_scrollbars[2];	\/* vert. Scrollbars for this window *\/$/;"	m	struct:window
w_set_curswant	structs.h	/^    int		w_set_curswant;	    \/* If set, then update w_curswant the next$/;"	m	struct:window
w_skipcol	structs.h	/^    colnr_T	w_skipcol;	    \/* starting column when a single line$/;"	m	struct:window
w_status_height	structs.h	/^    int		w_status_height;    \/* number of status lines (0 or 1) *\/$/;"	m	struct:window
w_tagstack	structs.h	/^    taggy_T	w_tagstack[TAGSTACKSIZE];	\/* the tag stack *\/$/;"	m	struct:window
w_tagstackidx	structs.h	/^    int		w_tagstackidx;		\/* idx just below activ entry *\/$/;"	m	struct:window
w_tagstacklen	structs.h	/^    int		w_tagstacklen;		\/* number of tags on stack *\/$/;"	m	struct:window
w_topfill	structs.h	/^    int		w_topfill;	    \/* number of filler lines above w_topline *\/$/;"	m	struct:window
w_topline	structs.h	/^    linenr_T	w_topline;	    \/* buffer line number of the line at the$/;"	m	struct:window
w_upd_rows	structs.h	/^    int		w_upd_rows;	    \/* number of window lines to update when$/;"	m	struct:window
w_valid	structs.h	/^    int		w_valid;$/;"	m	struct:window
w_valid_cursor	structs.h	/^    pos_T	w_valid_cursor;	    \/* last known position of w_cursor, used$/;"	m	struct:window
w_valid_leftcol	structs.h	/^    colnr_T	w_valid_leftcol;    \/* last known w_leftcol *\/$/;"	m	struct:window
w_vars	structs.h	/^    garray_T	w_vars;		\/* internal variables, local to window *\/$/;"	m	struct:window
w_virtcol	structs.h	/^    colnr_T	w_virtcol;	    \/* column number of the cursor in the$/;"	m	struct:window
w_vsep_width	structs.h	/^    int		w_vsep_width;	    \/* Number of separator columns (0 or 1).$/;"	m	struct:window
w_wcol	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor position in window *\/$/;"	m	struct:window
w_width	structs.h	/^    int		w_width;	    \/* Width of window, excluding separation.$/;"	m	struct:window
w_wincol	structs.h	/^    int		w_wincol;	    \/* Leftmost column of window in screen.$/;"	m	struct:window
w_winrow	structs.h	/^    int		w_winrow;	    \/* first row of window in screen *\/$/;"	m	struct:window
w_wrow	structs.h	/^    int		w_wrow, w_wcol;	    \/* cursor position in window *\/$/;"	m	struct:window
waitTime	gui_amiga.c	/^    int		waitTime;$/;"	m	struct:__anon26	file:
wait_return	message.c	/^wait_return(redraw)$/;"	f
wb_window	os_amiga.c	/^static struct Window	*wb_window;$/;"	v	typeref:struct:Window	file:
wc_use_keyname	option.c	/^wc_use_keyname(varp, wcp)$/;"	f	file:
wcmd_T	ex_docmd.c	/^} wcmd_T;$/;"	t	typeref:struct:__anon22	file:
where_paste_started	globals.h	/^EXTERN pos_T	where_paste_started;$/;"	v
which_scrollbars	gui.h	/^    int		which_scrollbars[3];\/* Which scrollbar boxes are active? *\/$/;"	m	struct:Gui
while_cookie	ex_docmd.c	/^struct while_cookie$/;"	s	file:
wi_fold_manual	structs.h	/^    int		wi_fold_manual;	\/* copy of w_fold_manual *\/$/;"	m	struct:wininfo
wi_folds	structs.h	/^    garray_T	wi_folds;	\/* clone of w_folds *\/$/;"	m	struct:wininfo
wi_fpos	structs.h	/^    pos_T	wi_fpos;	\/* last cursor position in the file *\/$/;"	m	struct:wininfo
wi_next	structs.h	/^    wininfo_T	*wi_next;	\/* next entry or NULL for last entry *\/$/;"	m	struct:wininfo
wi_opt	structs.h	/^    winopt_T	wi_opt;		\/* local window options *\/$/;"	m	struct:wininfo
wi_optset	structs.h	/^    int		wi_optset;	\/* TRUE when wi_opt has useful values *\/$/;"	m	struct:wininfo
wi_prev	structs.h	/^    wininfo_T	*wi_prev;	\/* previous entry or NULL for first entry *\/$/;"	m	struct:wininfo
wi_win	structs.h	/^    win_T	*wi_win;	\/* pointer to window that did set wi_lnum *\/$/;"	m	struct:wininfo
wid	gui.h	/^    Window	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
wid	gui.h	/^    WindowPtr	wid;		    \/* Window id of text area *\/$/;"	m	struct:Gui
wide_WindowProc	globals.h	/^EXTERN int	wide_WindowProc INIT(= FALSE);	\/* use wide WindowProc() *\/$/;"	v
wide_font	gui.h	/^    GuiFont	wide_font;	    \/* 'guifontwide' font *\/$/;"	m	struct:Gui
width	ex_cmds2.c	/^    float	width;		\/* width and height in points for portrait *\/$/;"	m	struct:prt_mediasize_S	file:
width	gui.h	/^    int		width;		\/* Current width of scroll bar in cols *\/$/;"	m	struct:GuiScrollbar
widthCharToPoint	gui_amiga.c	/^widthCharToPoint(int width)$/;"	f	file:
widthPointToChar	gui_amiga.c	/^widthPointToChar(int width)$/;"	f	file:
wild_menu_showing	globals.h	/^EXTERN int  wild_menu_showing INIT(= 0);$/;"	v
wim_flags	globals.h	/^EXTERN char_u	wim_flags[4];$/;"	v
win_T	structs.h	/^typedef struct window	win_T;$/;"	t	typeref:struct:window
win_alloc	window.c	/^win_alloc(after)$/;"	f	file:
win_alloc_first	window.c	/^win_alloc_first()$/;"	f
win_alloc_lines	window.c	/^win_alloc_lines(wp)$/;"	f
win_altframe	window.c	/^win_altframe(win)$/;"	f	file:
win_append	window.c	/^win_append(after, wp)$/;"	f	file:
win_chartabsize	charset.c	/^win_chartabsize(wp, p, col)$/;"	f	file:
win_close	window.c	/^win_close(win, free_buf)$/;"	f
win_col_off	move.c	/^win_col_off(wp)$/;"	f
win_col_off2	move.c	/^win_col_off2(wp)$/;"	f
win_comp_pos	window.c	/^win_comp_pos()$/;"	f	file:
win_comp_scroll	window.c	/^win_comp_scroll(wp)$/;"	f
win_copy_options	option.c	/^win_copy_options(wp_from, wp_to)$/;"	f
win_count	window.c	/^win_count()$/;"	f
win_del_lines	screen.c	/^win_del_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_do_lines	screen.c	/^win_do_lines(wp, row, line_count, mayclear, del)$/;"	f	file:
win_drag_status_line	window.c	/^win_drag_status_line(dragwin, offset)$/;"	f
win_drag_vsep_line	window.c	/^win_drag_vsep_line(dragwin, offset)$/;"	f
win_draw_end	screen.c	/^win_draw_end(wp, c1, c2, row, endrow, hl)$/;"	f	file:
win_enter	window.c	/^win_enter(wp, undo_sync)$/;"	f
win_enter_ext	window.c	/^win_enter_ext(wp, undo_sync, curwin_invalid)$/;"	f	file:
win_equal	window.c	/^win_equal(next_curwin, current, dir)$/;"	f
win_equal_rec	window.c	/^win_equal_rec(next_curwin, current, topfr, dir, col, row, width, height)$/;"	f	file:
win_exchange	window.c	/^win_exchange(Prenum)$/;"	f	file:
win_find_nr	window.c	/^win_find_nr(winnr)$/;"	f
win_foldinfo	screen.c	/^static foldinfo_T win_foldinfo;	\/* info for 'foldcolumn' *\/$/;"	v	file:
win_free	window.c	/^win_free(wp)$/;"	f	file:
win_free_lsize	window.c	/^win_free_lsize(wp)$/;"	f
win_goto	window.c	/^win_goto(wp)$/;"	f
win_goto_hor	window.c	/^win_goto_hor(left, count)$/;"	f	file:
win_goto_ver	window.c	/^win_goto_ver(up, count)$/;"	f	file:
win_hasvertsplit	window.c	/^win_hasvertsplit()$/;"	f
win_init	window.c	/^win_init(wp)$/;"	f
win_ins_lines	screen.c	/^win_ins_lines(wp, row, line_count, invalid, mayclear)$/;"	f
win_lbr_chartabsize	charset.c	/^win_lbr_chartabsize(wp, s, col, headp)$/;"	f
win_line	screen.c	/^win_line(wp, lnum, startrow, endrow)$/;"	f	file:
win_linetabsize	charset.c	/^win_linetabsize(wp, p, len)$/;"	f
win_minheight	window.c	/^win_minheight(wp)$/;"	f	file:
win_move_after	window.c	/^win_move_after(win1, win2)$/;"	f
win_new_height	window.c	/^win_new_height(wp, height)$/;"	f	file:
win_new_shellsize	term.c	/^win_new_shellsize()$/;"	f
win_new_width	window.c	/^win_new_width(wp, width)$/;"	f	file:
win_nolbr_chartabsize	charset.c	/^win_nolbr_chartabsize(wp, s, col, headp)$/;"	f	file:
win_redr_custom	screen.c	/^win_redr_custom(wp, Ruler)$/;"	f	file:
win_redr_ruler	screen.c	/^win_redr_ruler(wp, always)$/;"	f	file:
win_redr_status	screen.c	/^win_redr_status(wp)$/;"	f
win_redr_status_matches	screen.c	/^win_redr_status_matches(xp, num_matches, matches, match, showtail)$/;"	f
win_redraw_last_status	screen.c	/^win_redraw_last_status(frp)$/;"	f
win_remove	window.c	/^win_remove(wp)$/;"	f	file:
win_resize_off	os_amiga.c	/^win_resize_off()$/;"	f
win_resize_on	os_amiga.c	/^win_resize_on()$/;"	f
win_rest_invalid	screen.c	/^win_rest_invalid(wp)$/;"	f	file:
win_rotate	window.c	/^win_rotate(upwards, count)$/;"	f	file:
win_setheight	window.c	/^win_setheight(height)$/;"	f
win_setheight_win	window.c	/^win_setheight_win(height, win)$/;"	f
win_setminheight	window.c	/^win_setminheight()$/;"	f
win_setwidth	window.c	/^win_setwidth(width)$/;"	f
win_setwidth_win	window.c	/^win_setwidth_win(width, wp)$/;"	f
win_size_restore	window.c	/^win_size_restore(gap)$/;"	f
win_size_save	window.c	/^win_size_save(gap)$/;"	f
win_split	window.c	/^win_split(size, flags)$/;"	f
win_split_ins	window.c	/^win_split_ins(size, flags, newwin, dir)$/;"	f	file:
win_totop	window.c	/^win_totop(size, flags)$/;"	f	file:
win_update	screen.c	/^win_update(wp)$/;"	f	file:
win_valid	window.c	/^win_valid(win)$/;"	f
windgoto	screen.c	/^windgoto(row, col)$/;"	f
window	gui.h	/^    struct Window *window;		\/* a handle to the amiga window *\/$/;"	m	struct:Gui	typeref:struct:Gui::Window
window	structs.h	/^struct window$/;"	s
window_handle	gui.h	/^    int		window_handle;$/;"	m	struct:Gui
window_title	gui.h	/^    char_u	*window_title;$/;"	m	struct:Gui
window_title_size	gui.h	/^    int		window_title_size;$/;"	m	struct:Gui
winframe_remove	window.c	/^winframe_remove(win, dirp)$/;"	f	file:
wininfo	structs.h	/^struct wininfo$/;"	s
wininfo_T	structs.h	/^typedef struct wininfo	wininfo_T;$/;"	t	typeref:struct:wininfo
winopt_T	structs.h	/^} winopt_T;$/;"	t	typeref:struct:__anon30
wipe_buffer	buffer.c	/^wipe_buffer(buf, aucmd)$/;"	f
wl_folded	structs.h	/^    char	wl_folded;	\/* TRUE when this is a range of folded lines *\/$/;"	m	struct:w_line
wl_lastlnum	structs.h	/^    linenr_T	wl_lastlnum;	\/* last buffer line number for logical line *\/$/;"	m	struct:w_line
wl_lnum	structs.h	/^    linenr_T	wl_lnum;	\/* buffer line number for logical line *\/$/;"	m	struct:w_line
wl_size	structs.h	/^    short_u	wl_size;	\/* height in screen lines *\/$/;"	m	struct:w_line
wl_valid	structs.h	/^    char	wl_valid;	\/* TRUE values are valid for text in buffer *\/$/;"	m	struct:w_line
wline_T	structs.h	/^} wline_T;$/;"	t	typeref:struct:w_line
wo_arab	structs.h	/^    int		wo_arab;$/;"	m	struct:__anon30
wo_diff	structs.h	/^    int		wo_diff;$/;"	m	struct:__anon30
wo_fdc	structs.h	/^    long	wo_fdc;$/;"	m	struct:__anon30
wo_fde	structs.h	/^    char_u	*wo_fde;$/;"	m	struct:__anon30
wo_fdi	structs.h	/^    char_u	*wo_fdi;$/;"	m	struct:__anon30
wo_fdl	structs.h	/^    long	wo_fdl;$/;"	m	struct:__anon30
wo_fdm	structs.h	/^    char_u	*wo_fdm;$/;"	m	struct:__anon30
wo_fdn	structs.h	/^    long	wo_fdn;$/;"	m	struct:__anon30
wo_fdt	structs.h	/^    char_u	*wo_fdt;$/;"	m	struct:__anon30
wo_fen	structs.h	/^    int		wo_fen;$/;"	m	struct:__anon30
wo_fml	structs.h	/^    long	wo_fml;$/;"	m	struct:__anon30
wo_fmr	structs.h	/^    char_u	*wo_fmr;$/;"	m	struct:__anon30
wo_lbr	structs.h	/^    int		wo_lbr;$/;"	m	struct:__anon30
wo_list	structs.h	/^    int		wo_list;$/;"	m	struct:__anon30
wo_nu	structs.h	/^    int		wo_nu;$/;"	m	struct:__anon30
wo_pvw	structs.h	/^    int		wo_pvw;$/;"	m	struct:__anon30
wo_rl	structs.h	/^    int		wo_rl;$/;"	m	struct:__anon30
wo_rlc	structs.h	/^    char_u	*wo_rlc;$/;"	m	struct:__anon30
wo_scb	structs.h	/^    int		wo_scb;$/;"	m	struct:__anon30
wo_scr	structs.h	/^    long	wo_scr;$/;"	m	struct:__anon30
wo_wfh	structs.h	/^    int		wo_wfh;$/;"	m	struct:__anon30
wo_wrap	structs.h	/^    int		wo_wrap;$/;"	m	struct:__anon30
word_end_col	vim.h	/^    short_u	word_end_col;$/;"	m	struct:VimClipboard
word_start_col	vim.h	/^    short_u	word_start_col;$/;"	m	struct:VimClipboard
wp	fold.c	/^    win_T	*wp;		\/* window *\/$/;"	m	struct:__anon15	file:
wp	gui.h	/^    struct window *wp;		\/* Scrollbar's window, NULL for bottom *\/$/;"	m	struct:GuiScrollbar	typeref:struct:GuiScrollbar::window
write_lnum_adjust	fileio.c	/^write_lnum_adjust(offset)$/;"	f
write_no_eol_lnum	fileio.c	/^static linenr_T	write_no_eol_lnum = 0;	\/* non-zero lnum when last line of$/;"	v	file:
write_one_filemark	mark.c	/^write_one_filemark(fp, fm, c1, c2)$/;"	f	file:
write_one_mark	mark.c	/^write_one_mark(fp_out, c, pos)$/;"	f	file:
write_reg_contents	ops.c	/^write_reg_contents(name, str, maxlen, must_append)$/;"	f
write_reg_contents_ex	ops.c	/^write_reg_contents_ex(name, str, maxlen, must_append, yank_type, block_len)$/;"	f
write_viminfo	ex_cmds.c	/^write_viminfo(file, forceit)$/;"	f
write_viminfo_bufferlist	buffer.c	/^write_viminfo_bufferlist(fp)$/;"	f
write_viminfo_filemarks	mark.c	/^write_viminfo_filemarks(fp)$/;"	f
write_viminfo_history	ex_getln.c	/^write_viminfo_history(fp)$/;"	f
write_viminfo_marks	mark.c	/^write_viminfo_marks(fp_out)$/;"	f
write_viminfo_registers	ops.c	/^write_viminfo_registers(fp)$/;"	f
write_viminfo_search_pattern	search.c	/^write_viminfo_search_pattern(fp)$/;"	f
write_viminfo_sub_string	ex_cmds.c	/^write_viminfo_sub_string(fp)$/;"	f
write_viminfo_varlist	eval.c	/^write_viminfo_varlist(fp)$/;"	f
wvsp_one	search.c	/^wvsp_one(fp, idx, s, sc)$/;"	f	file:
wx	ex_cmds2.c	/^    int		wx;$/;"	m	struct:prt_ps_font_S	file:
x	gui_beval.h	/^    int			x;$/;"	m	struct:BalloonEvalStruct
x	testdir/test49.vim	/^	    let x = "a"$/;"	v
x	testdir/test49.vim	/^	    let x = x . "b" . append(1, "s") . H()$/;"	v
x	testdir/test49.vim	/^	let x = novar	" error E121\/E15; exception: E121$/;"	v
x11_export_final_selection	ops.c	/^x11_export_final_selection()$/;"	f
x11_setup_atoms	ui.c	/^x11_setup_atoms(dpy)$/;"	f
x_force_connect	globals.h	/^EXTERN int	x_force_connect INIT(= FALSE); \/* Do connect to X server.$/;"	v
x_jump_env	globals.h	/^EXTERN JMP_BUF x_jump_env;$/;"	v
x_no_connect	globals.h	/^EXTERN int	x_no_connect INIT(= FALSE); \/* don't connect to X server *\/$/;"	v
xfilemark	structs.h	/^typedef struct xfilemark$/;"	s
xfmark_T	structs.h	/^} xfmark_T;$/;"	t	typeref:struct:xfilemark
xic	globals.h	/^EXTERN GdkIC		*xic INIT(= NULL);$/;"	v
xic	globals.h	/^EXTERN GtkIMContext	*xic INIT(= NULL);$/;"	v
xic	globals.h	/^EXTERN XIC		xic INIT(= NULL);$/;"	v
xic_attr	globals.h	/^EXTERN GdkICAttr	*xic_attr INIT(= NULL);$/;"	v
xim_back_delete	mbyte.c	/^xim_back_delete(int n)$/;"	f	file:
xim_bg_color	globals.h	/^EXTERN guicolor_T	xim_bg_color INIT(= INVALCOLOR);$/;"	v
xim_can_preediting	mbyte.c	/^static int	xim_can_preediting INIT(= FALSE);	\/* XIM in showmode() *\/$/;"	v	file:
xim_changed_while_preediting	globals.h	/^EXTERN int		xim_changed_while_preediting INIT(= FALSE);$/;"	v
xim_decide_input_style	mbyte.c	/^xim_decide_input_style()$/;"	f
xim_destroy_cb	mbyte.c	/^xim_destroy_cb(im, client_data, call_data)$/;"	f	file:
xim_expected_char	mbyte.c	/^static int xim_expected_char = NUL;$/;"	v	file:
xim_fg_color	globals.h	/^EXTERN guicolor_T	xim_fg_color INIT(= INVALCOLOR);$/;"	v
xim_get_status_area_height	mbyte.c	/^xim_get_status_area_height()$/;"	f
xim_has_focus	mbyte.c	/^static int	xim_has_focus = FALSE;	\/* XIM is really being used for Vim *\/$/;"	v	file:
xim_has_preediting	mbyte.c	/^static int xim_has_preediting INIT(= FALSE);  \/* IM current status *\/$/;"	v	file:
xim_ignored_char	mbyte.c	/^static int xim_ignored_char = FALSE;$/;"	v	file:
xim_init	mbyte.c	/^xim_init()$/;"	f
xim_init	mbyte.c	/^xim_init(void)$/;"	f
xim_input_style	mbyte.c	/^static int	xim_input_style;$/;"	v	file:
xim_instantiate_cb	mbyte.c	/^xim_instantiate_cb(display, client_data, call_data)$/;"	f	file:
xim_is_active	mbyte.c	/^static int	xim_is_active = FALSE;  \/* XIM should be active in the current$/;"	v	file:
xim_log	mbyte.c	/^xim_log(char *s, ...)$/;"	f	file:
xim_queue_key_press_event	mbyte.c	/^xim_queue_key_press_event(GdkEventKey *event, int down)$/;"	f
xim_real_init	mbyte.c	/^xim_real_init(x11_window, x11_display)$/;"	f	file:
xim_reset	mbyte.c	/^xim_reset(void)$/;"	f
xim_set_focus	mbyte.c	/^xim_set_focus(focus)$/;"	f
xim_set_focus	mbyte.c	/^xim_set_focus(int focus)$/;"	f
xim_set_preedit	mbyte.c	/^xim_set_preedit()$/;"	f
xim_set_status_area	mbyte.c	/^xim_set_status_area()$/;"	f
xp_arg	structs.h	/^    char_u	*xp_arg;		\/* completion function *\/$/;"	m	struct:expand
xp_backslash	structs.h	/^    int		xp_backslash;		\/* one of the XP_BS_ values *\/$/;"	m	struct:expand
xp_context	structs.h	/^    int		xp_context;		\/* type of expansion *\/$/;"	m	struct:expand
xp_files	structs.h	/^    char_u	**xp_files;		\/* list of files *\/$/;"	m	struct:expand
xp_numfiles	structs.h	/^    int		xp_numfiles;		\/* number of files found by$/;"	m	struct:expand
xp_pattern	structs.h	/^    char_u	*xp_pattern;		\/* start of item to expand *\/$/;"	m	struct:expand
xp_scriptID	structs.h	/^    int		xp_scriptID;		\/* SID for completion function *\/$/;"	m	struct:expand
xsmp_icefd	globals.h	/^EXTERN int xsmp_icefd INIT(= -1);   \/* The actual connection *\/$/;"	v
xt_index_in	term.c	/^static int xt_index_in = 0;$/;"	v	file:
xt_index_out	term.c	/^static int xt_index_out = 0;$/;"	v	file:
xterm_display	globals.h	/^EXTERN char	*xterm_display INIT(= NULL);	\/* xterm display name *\/$/;"	v
xterm_dpy	globals.h	/^EXTERN Display	*xterm_dpy INIT(= NULL);	\/* xterm display pointer *\/$/;"	v
xxdline	xxd/xxd.c	/^xxdline(fp, l, nz)$/;"	f	file:
xy2win	gui.c	/^xy2win(x, y)$/;"	f	file:
y	gui_beval.h	/^    int			y;$/;"	m	struct:BalloonEvalStruct
y_append	ops.c	/^static int		y_append;	    \/* TRUE when appending *\/$/;"	v	file:
y_array	ops.c	/^    char_u	**y_array;	\/* pointer to array of line pointers *\/$/;"	m	struct:yankreg	file:
y_current	ops.c	/^static struct yankreg	*y_current;	    \/* ptr to current yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_previous	ops.c	/^static struct yankreg	*y_previous = NULL; \/* ptr to last written yankreg *\/$/;"	v	typeref:struct:yankreg	file:
y_regs	ops.c	/^} y_regs[NUM_REGISTERS];$/;"	v	typeref:struct:yankreg	file:
y_size	ops.c	/^    linenr_T	y_size;		\/* number of lines in y_array *\/$/;"	m	struct:yankreg	file:
y_type	ops.c	/^    char_u	y_type;		\/* MLINE, MCHAR or MBLOCK *\/$/;"	m	struct:yankreg	file:
y_width	ops.c	/^    colnr_T	y_width;	\/* only set if y_type == MBLOCK *\/$/;"	m	struct:yankreg	file:
yank_copy_line	ops.c	/^yank_copy_line(bd, y_idx)$/;"	f	file:
yank_register_mline	ops.c	/^yank_register_mline(regname)$/;"	f
yankreg	ops.c	/^static struct yankreg$/;"	s	file:
