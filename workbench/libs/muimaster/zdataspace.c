/* Zune -- a free Magic User Interface implementation
 * Copyright (C) 1999 David Le Corfec
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <exec/types.h>

#ifdef _AROS
#include <proto/intuition.h>
#include <proto/muimaster.h>
#include <proto/utility.h>
#endif

#include <zunepriv.h>
#include <builtin.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Dataspace.h>
#include <dataspacedata.h>


static ULONG
mNew (struct IClass *cl, Object *obj, struct opSet *msg)
{
    struct MUI_DataspaceData *data;
    struct TagItem *tags,*tag;

    obj = (Object *)DoSuperMethodA(cl, obj, (Msg)msg);
    if (!obj)
	return FALSE;

    data = INST_DATA(cl, obj);

    for (tags = msg->ops_AttrList; (tag = NextTagItem(&tags)); )
    {
	switch (tag->ti_Tag)
	{
	    case MUIA_Dataspace_Comments:
		data->comments = (ZStringSet *)tag->ti_Data;
	}
    }

    data->uprop = uprop_new(data->comments);

    return (ULONG)obj;
}


static ULONG 
mDispose(struct IClass *cl, Object *obj, Msg msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);

    uprop_destroy(data->uprop);
    return DoSuperMethodA(cl, obj, msg);
}


static ULONG 
mAddString(struct IClass *cl, Object *obj, struct MUIP_Dataspace_AddString *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    uprop_set_property(data->uprop, fullKey, msg->value ? msg->value : "");
	
    g_free(fullKey);
    return TRUE;
}

static ULONG
mAddInt(struct IClass *cl, Object *obj, struct MUIP_Dataspace_AddInt *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    uprop_set_property_int(data->uprop, fullKey, msg->value);
    g_free(fullKey);
    return TRUE;
}

static ULONG 
mAddFloat(struct IClass *cl, Object *obj, struct MUIP_Dataspace_AddFloat *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    uprop_set_property_float(data->uprop, fullKey, msg->value);
    g_free(fullKey);
    return TRUE;
}

static ULONG
mFindString(struct IClass *cl, Object *obj, struct MUIP_Dataspace_FindString *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    return (ULONG)uprop_get_property (data->uprop, fullKey);
}

static ULONG
mFindInt(struct IClass *cl, Object *obj, struct MUIP_Dataspace_FindInt *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;
    LONG tmp;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    uprop_get_property_int (data->uprop, fullKey, &tmp);
    return tmp;
}

static ULONG
mFindFloat(struct IClass *cl, Object *obj, struct MUIP_Dataspace_FindFloat *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);
    STRPTR fullKey;

    fullKey = g_strconcat(msg->objID, ".", msg->key, NULL);
    return (ULONG)uprop_get_property_float (data->uprop, fullKey, msg->value);
}

static ULONG 
mReadASCII(struct IClass *cl, Object *obj, struct MUIP_Dataspace_ReadASCII *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);

    uprop_load(data->uprop, msg->infile);
    return TRUE;
}

static ULONG 
mWriteASCII(struct IClass *cl, Object *obj, struct MUIP_Dataspace_WriteASCII *msg)
{
    struct MUI_DataspaceData *data = INST_DATA(cl, obj);

    uprop_save(data->uprop, msg->outfile, "Automatically generated by Zune");
    return TRUE;
}



/*
 * The class dispatcher
 */
static ULONG 
MyDispatcher (struct IClass *cl, Object *obj, Msg msg)
{
    switch (msg->MethodID)
    {
	/* Whenever an object shall be created using NewObject(), it will be
	** sent a OM_NEW method.
	*/
	case OM_NEW:
	    return(mNew(cl, obj, (struct opSet *) msg));
	case OM_DISPOSE:
	    return(mDispose(cl, obj, msg));
	
	case MUIM_Dataspace_ReadASCII :
	    return(mReadASCII(cl, obj, (APTR)msg));
	case MUIM_Dataspace_WriteASCII :
	    return(mWriteASCII(cl, obj, (APTR)msg));

	case MUIM_Dataspace_AddString :
	    return(mAddString(cl, obj, (APTR)msg));
	case MUIM_Dataspace_AddInt :
	    return(mAddInt(cl, obj, (APTR)msg));
	case MUIM_Dataspace_AddFloat :
	    return(mAddFloat(cl, obj, (APTR)msg));
	case MUIM_Dataspace_FindString :
	    return(mFindString(cl, obj, (APTR)msg));
	case MUIM_Dataspace_FindInt :
	    return(mFindInt(cl, obj, (APTR)msg));
	case MUIM_Dataspace_FindFloat :
	    return(mFindFloat(cl, obj, (APTR)msg));
    }

    return(DoSuperMethodA(cl, obj, msg));
}


/*
 * Class descriptor.
 */
const struct __MUIBuiltinClass _MUI_Dataspace_desc = {
    MUIC_Dataspace,                     /* Class name */
    ROOTCLASS,                          /* super class name */
    sizeof(struct MUI_DataspaceData),   /* size of class own datas */
    MyDispatcher                        /* class dispatcher */
};

