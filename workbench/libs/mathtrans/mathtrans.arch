/*
    Copyright © 1995-2001, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Function Archive for MathTrans.library
    Lang: english
*/
#Archive
#Header
#include <libraries/mathffp.h>
#include <aros/libcall.h>
#include <proto/mathffp.h>
#include <proto/mathtrans.h>
#include <proto/exec.h>
#include <exec/types.h>
#include "mathtrans_intern.h"
#/Header


#Function float SPAtan
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 5
#AutoDoc
    FUNCTION
      Calculates the angle of a given number representing the tangent
      of that angle. The angle will be in radians.

    RESULT
      Motorola fast floating point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG fnumabs = fnum1 & (FFPMantisse_Mask | FFPExponent_Mask);
  LONG fnumsquared, fnumcubed;

  /* check for +- infinity -> output: +-pi/2 */
  if (FFP_Pinfty == fnumabs )
    return (pio2 | (fnum1 & FFPSign_Mask));

  /* atan(0) = 0 */
  if (0 == fnumabs)
  {
     SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
     return 0;
  }

  /* atan(x>= 128) = pi/2 - 1/x */
  if ((BYTE) fnumabs >= 0x48)
  {
    if (fnumabs == fnum1) /* arg has ppositive sign */
    {
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);
      return SPSub(SPDiv(fnumabs,one),pio2);
    }
    else
    {
      LONG res;
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

      /* workaround a bug in egcs 1.0.3: complains about illegal operands to | */
      res = SPSub(SPDiv(fnumabs,one),pio2);
      return res | FFPSign_Mask;
    }
  }

  /* atan(x >= 64) = pi/2 - 1/x +1/(3*x^3) */

  fnumsquared = SPMul(fnumabs, fnumabs);

  if((BYTE) fnumabs >= 0x47)
  {
    fnumcubed   = SPMul(fnumabs, fnumsquared);

    /* pi/2 - 1/x + 1/(3*x^3) = pi/2 + (1-3*x^2)/(3*x^3)*/
    if (fnumabs == fnum1) /* arg has positive sign */
    {
      LONG res;
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);

      /* workaround a bug in egcs 1.0.3: complains about illegal operands to | */
      res = SPMul(three, fnumsquared);
      return SPAdd(pio2,
              SPDiv(
               SPMul(three, fnumcubed),
              SPAdd(
               res | FFPSign_Mask,
                    one )
                   ));
    }
    else
    {
      LONG res;
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

      /* workaround a bug in egcs 1.0.3: complains about illegal operands to | */
      res = SPMul(three, fnumsquared);
      res = SPAdd(pio2,
              SPDiv(
               SPMul(three, fnumcubed),
              SPAdd(
               res | FFPSign_Mask,
                    one )
                   ));
      return res | FFPSign_Mask;
    }
  }

  /* atan(x <= 64) */
  return SPAsin(SPDiv(SPSqrt(SPAdd(one,fnumsquared)),fnum1));
#/Code
#/Function


#Function float SPSin
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 6
#AutoDoc
    FUNCTION
      Calculate the sine of a given FFP number in radians

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
     Algorithm for Calculation of sin(y):
     <code>
         z    = floor ( |y| / pi );
         y_1  = |y| - z * pi;        => 0 <= y_1 < pi

         if (y_1 > pi/2 ) then y_1 = pi - y_1;

         => 0 <= y_1 < pi/2

         Res = y - y^3/3! + y^5/5! - y^7/7! + y^9/9! - y^11/11! =
             = y(1+y^2(-1/3!+y^2(1/5!+y^2(-1/7!+y^2(1/9!-1/11!y^2)))));

         if (y < 0)
           Res = -Res;

         if (z was an odd number)
           Res = -Res;
     </code>


    HISTORY

#/AutoDoc
#Code
  LONG z,Res,ysquared,yabs,tmp;
  yabs = fnum1 & (FFPMantisse_Mask + FFPExponent_Mask);

  if (FFP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return FFP_NAN;
  }

  z = SPFloor(SPDiv(pi, yabs));
  tmp  = SPMul(z,pi);
  tmp |= FFPSign_Mask; /* tmp = -tmp; */
  yabs = SPAdd(yabs, tmp);

  if ( (char)yabs > (char)pio2  &&  (yabs & FFPMantisse_Mask) > (pio2 & FFPMantisse_Mask) )
  {
    yabs |= FFPSign_Mask;
    yabs  = SPAdd(pi, yabs);
  }
  ysquared = SPMul(yabs,yabs);
  Res = SPMul(yabs,
        SPAdd(sinf1,
        SPMul(ysquared,
        SPAdd(sinf2,
        SPMul(ysquared,
        SPAdd(sinf3,
        SPMul(ysquared,
        SPAdd(sinf4,
        SPMul(ysquared,
        SPAdd(sinf5,
        SPMul(ysquared, sinf6)))))))))));

  if ((char)fnum1 < 0 )
    Res ^= FFPSign_Mask;

  if (TRUE == intern_SPisodd(z))
    Res ^= FFPSign_Mask;

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if ((char)Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float SPCos
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 7
#AutoDoc
    FUNCTION
      Calculate the cosine of a given ffp number in radians

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      Algorithm for Calculation of cos(y):
     <code>
         z    = floor ( |y| / pi );
         y_1  = |y| - z * pi;        => 0 <= y_1 < pi

         if (y_1 > pi/2 ) then y_1 = pi - y_1;

         => 0 <= y_1 < pi/2

         Res = 1 - y^2/2! + y^4/4! - y^6/6! + y^8/8! - y^10/10! =
             = 1 -(y^2(-1/2!+y^2(1/4!+y^2(-1/6!+y^2(1/8!-1/10!y^2)))));

         if (z was an odd number)
           Res = -Res;

         if (y_1 was greater than pi/2 in the test above)
           Res = -Res;
     </code>


    HISTORY

#/AutoDoc
#Code
  LONG z,Res,ysquared,yabs,tmp;
  yabs = fnum1 & (FFPMantisse_Mask + FFPExponent_Mask);

  if (FFP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return FFP_NAN;
  }

  z = SPFloor(SPDiv(pi, yabs));
  tmp  = SPMul(z,pi);
  tmp |= FFPSign_Mask; /* tmp = -tmp; */
  yabs = SPAdd(yabs, tmp);

  if ( (char)yabs > (char)pio2  &&  (yabs & FFPMantisse_Mask) > (pio2 & FFPMantisse_Mask) )
  {
    yabs |= FFPSign_Mask;
    yabs  =SPAdd(pi, yabs);
    tmp = TRUE;
  }
  else
    tmp = FALSE;

  ysquared = SPMul(yabs,yabs);
  Res = SPAdd(cosf1,
        SPMul(ysquared,
        SPAdd(cosf2,
        SPMul(ysquared,
        SPAdd(cosf3,
        SPMul(ysquared,
        SPAdd(cosf4,
        SPMul(ysquared,
        SPAdd(cosf5,
        SPMul(ysquared, cosf6))))))))));

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (TRUE == intern_SPisodd(z))
    Res ^= FFPSign_Mask;

        if (TRUE == tmp)
    Res ^= FFPSign_Mask;

  if ((char)Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float SPTan
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 8
#AutoDoc
    FUNCTION
      Calculate the tangens of a given FFP number in radians

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow :

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG z,SIN,Res,ysquared,yabs,tmp;
  yabs = fnum1 & (FFPMantisse_Mask + FFPExponent_Mask);

  if (FFP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return FFP_NAN;
  }

  z = SPFloor(SPDiv(pi, yabs));
  tmp  = SPMul(z,pi);
  tmp |= FFPSign_Mask; /* tmp = -tmp; */
  yabs = SPAdd(yabs, tmp);

  if ( (char)yabs > (char)pio2  &&  (yabs & FFPMantisse_Mask) > (pio2 & FFPMantisse_Mask) )
  {
    yabs |= FFPSign_Mask;
    yabs  =SPAdd(pi, yabs);
    tmp = TRUE;
  }
  else
    tmp = FALSE;
  ysquared = SPMul(yabs,yabs);
  SIN = SPMul(yabs,
        SPAdd(sinf1,
        SPMul(ysquared,
        SPAdd(sinf2,
        SPMul(ysquared,
        SPAdd(sinf3,
        SPMul(ysquared,
        SPAdd(sinf4,
        SPMul(ysquared,
        SPAdd(sinf5,
        SPMul(ysquared, sinf6)))))))))));
  /* cos  */
  z   = SPAdd(cosf1,
        SPMul(ysquared,
        SPAdd(cosf2,
        SPMul(ysquared,
        SPAdd(cosf3,
        SPMul(ysquared,
        SPAdd(cosf4,
        SPMul(ysquared,
        SPAdd(cosf5,
        SPMul(ysquared, cosf6))))))))));

  Res = SPDiv(z, SIN);

  if ((char)fnum1 < 0 )
    Res ^= FFPSign_Mask;

  if (TRUE == tmp)
    Res ^= FFPSign_Mask;

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if ((char)Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float SPSincos
#Parameter IPTR * pfnum2 D1
    Pointer to a Motorola fast floating point number
#/Parameter
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 9
#AutoDoc
    FUNCTION
      Calculate the cosine and the sine of the given ffp-number
      fnum1 that represents an angle in radians. The function
      returns the sine of that number as a result and puts
      the cosine of that number into *pfnum2 which must represent
      a valid pointer to a ffp-number.

    RESULT
      *pfnum2       - Motorola fast floating point number
      direct result - Motorola fast floating point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  * pfnum2 = SPCos(fnum1);
  return SPSin(fnum1);
#/Code
#/Function


#Function float SPSinh
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 10
#AutoDoc
    FUNCTION
      Calculate the hyperbolic sine of the ffp number

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big for ffp format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      sinh(x) = (1/2)*( e^x- e^(-x) )

      sinh( |x| >= 44 ) = infinity;
      sinh( |x| >=  9 ) = (1/2) * (e^x);

    HISTORY

#/AutoDoc
#Code
ULONG Res;
LONG tmp;
  /* sinh(-x) = -sinh(x) */
  Res = SPExp(fnum1 & (FFPMantisse_Mask + FFPExponent_Mask) );

  if ( FFP_Pinfty == Res )
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  tmp = (fnum1 & FFPExponent_Mask) - 0x41;

  if ( tmp <= 2  || (tmp == 3 && (fnum1 & FFPMantisse_Mask) < 0x90000000) )
    Res = SPAdd(Res, ((ULONG)SPDiv(Res, one) | FFPSign_Mask ));

  /* Res = Res / 2 */
  
  /* should be (char(Res))-- , but gcc on Linux screws up the result! */

  tmp = Res & 0xFFFFFF00;
  Res -= sizeof(char);
  Res = Res | tmp;

  if ( 0 == Res || (char)Res < 0 )
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* if the argument was negative, the result is also negative */
  if ((char)fnum1 < 0 )
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (Res | FFPSign_Mask);
  }
  return Res;
#/Code
#/Function


#Function float SPCosh
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 11
#AutoDoc
    FUNCTION
      Calculate the hyperbolic cosine of the ffp number

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : 0 (not possible)
        overflow : result too big for ffp-number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
     <code>
      cosh(x) = (1/2)*( e^x + e^(-x) )

      cosh( |x| >= 44 ) = infinity;
      cosh( |x| >= 9  ) = (1/2) * (e^x);
     </code>

    HISTORY

#/AutoDoc
#Code
ULONG Res;
LONG tmp;
  /* cosh(-x) = cosh(x) */
  fnum1 &= ( FFPMantisse_Mask + FFPExponent_Mask );

  Res = SPExp(fnum1);

  if ( FFP_Pinfty == Res )
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  tmp = (fnum1 & FFPExponent_Mask) - 0x41;

  if ( tmp <= 2 || (tmp == 3 && (fnum1 & FFPMantisse_Mask) < 0x90000000) )
    Res = SPAdd(Res, SPDiv(Res, one));

  /* Res = Res / 2 */
  /* should be ((char)Res) --, but gcc on Linux screws up the result  */
  tmp = Res & 0xFFFFFF00;
  Res -= sizeof(char); 
  Res = tmp | Res;
  
  if (0 == Res || (char)Res < 0 )
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }
  return Res;
#/Code
#/Function


#Function float SPTanh
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 12
#AutoDoc
    FUNCTION
      Calculate hyperbolic tangens of the ffp number

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : (not possible)

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
     <code>

                ( e^x - e^(-x) )
     tanh(x) =  ----------------
                ( e^x + e^(-x) )

     tanh( |x| > 9 ) = 1
     </code>

    HISTORY

#/AutoDoc
#Code
ULONG Res;
LONG tmp;
  tmp = (fnum1 & FFPExponent_Mask) - 0x41;

  if ( tmp >= 3  &&  (fnum1 & FFPMantisse_Mask) >= 0x90000000 )
  /* tanh( x > 9 ) =  1
  ** tanh( x <-9 ) = -1
  */
  {
    return (one | ( fnum1 & FFPSign_Mask ));
  }

  /* tanh(-x) = -tanh(x) */
  Res = SPExp(fnum1 & (FFPMantisse_Mask + FFPExponent_Mask ));
  Res = SPDiv( SPAdd(Res, SPDiv(Res, one)),
               SPAdd(Res, (ULONG)SPDiv(Res, one) | FFPSign_Mask )  );

  /* Result is zero */
  if (0 == Res )
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* Argument is negative -> result is negative */
  if ( (char) fnum1 < 0)
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (Res | FFPSign_Mask );
  }

  return Res;
#/Code
#/Function


#Function float SPExp
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 13
#AutoDoc
    FUNCTION
      Calculate e^x

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : 0
        overflow : the result was out of range for the ffp-format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
     <code>
      e^(>= 44): return FFP_Pinfty;
     </code>

    HISTORY

#/AutoDoc
#Code
const LONG ExpTable[] =
    { 0x8fa1fe6f,  /* e^32  */
      0x87975e58,  /* e^16  */
      0xba4f534c,  /* e^8   */
      0xda648146,  /* e^4   */
      0xec732543,  /* e^2   */
      0xadf85442,  /* e^1   */
      0xD3094C41,  /* e^(1/2) */
      0xA45aF241,  /* e^(1/4) */
      0x910b0241,  /* e^(1/8) */
      0x88415b41,  /* e^(1/16) */
      0x84102b41,  /* e^(1/32) */
      0x82040541,  /* e^(1/64) */
      0x81010141,  /* e^(1/128) */
      0x80804041,  /* e^(1/256) */
      0x80401041,  /* e^(1/512) */
      0x80200441,  /* e^(1/1024) */
      0x80100141,  /* e^(1/2048) */
      0x80080041,  /* e^(1/4096) */
      0x80040041,  /* e^(1/8192) */
      0x80020041,  /* e^(1/16384) */
      0x80010041,  /* e^(1/32768) */
      0x80008041,  /* e^(1/65536) */
      0x80004041,  /* e^(1/131072) */
      0x80002041,  /* e^(1/262144) */
      0x80001041,  /* e^(1/524288) */
      0x80000841,  /* e^(1/1048576) */
      0x80000441,  /* e^(1/2097152) */
      0x80000241,  /* e^(1/4194304) */
      0x80000141,  /* e^(1/8388608) */
    };
ULONG Res, i;
LONG Mantisse;
char Exponent;

  Exponent = (fnum1 & FFPExponent_Mask) - 0x41;

  /* e^0 = 1, e^(2^(<=-24)) = 1 */
  if ( 0 == fnum1 || Exponent <= -24 )
    return one;

  /* e^(>= 44) = overflow = infinity) */
  if (Exponent > 5)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return FFP_Pinfty;
  }

  i = 5 - Exponent;

  Mantisse = (fnum1 & FFPMantisse_Mask);
  Res = ExpTable[i++];
  Mantisse <<= 1;

  while ( 0 != Mantisse && i <= 28 )
  {
    /* is the highest bit set? */
    if ( Mantisse < 0 )
    {
      Res = SPMul(Res, ExpTable[i]);
      if (0 == Res)
      {
        SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }
      if (FFP_Pinfty == Res)
      {
        SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }
    }
    i++;
    Mantisse <<= 1;
  }
  if ( (char) fnum1 < 0)
    return SPDiv(one, Res);

  return Res;
#/Code
#/Function


#Function float SPLog
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 14
#AutoDoc
    FUNCTION
      Calculate logarithm (base 10) of the given ffp number

    RESULT
      ffp-number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return 0.
      If the Argument is 0 return 0xffffffff.

      All other cases:

      (ld is the logarithm with base 2)
      (ln is the logarithm with base e)
     <code>
      fnum1 = M * 2^E

      ln fnum1 = ln ( M * 2^E ) =

               = ln M + ln 2^E =

               = ln M + E * ln (2) =

                 ld M        ld 2
               = ----- + E * ----- =      [ld 2 = 1]
                 ld e        ld e

                 ld M + E
               = --------
                 ld e
     </code>

      ld e can be precalculated, of course.
      For calculating ld M see file intern_spld.c

    HISTORY

#/AutoDoc
#Code
  LONG ld_M, Exponent, Mask = 0x40, i, Sign;
  /* check for negative sign */
  if ((char) fnum1 < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* check for argument == 0 -> return (-infinity) */
  if (fnum1 == 0)
    return FFP_Ninfty;

  /* convert the Exponent of the argument (fnum1) to the ffp-format */
  Exponent = (fnum1 & FFPExponent_Mask) - 0x40;
  if (Exponent < 0 )
  {
    Exponent =-Exponent;
    Sign = FFPSign_Mask;
  }
  else
    Sign = 0;

  /* find the number of the highest set bit in the exponent */
  if (Exponent != 0)
  {
    i = 0;
    while ( (Mask & Exponent) == 0)
    {
      i ++;
      Mask >>= 1;
    }
  Exponent <<= (25 + i);
  Exponent |= (0x47 - i + Sign);
  }

  ld_M = intern_SPLd((struct MathTransBase *)MathTransBase, 
                     (fnum1 & FFPMantisse_Mask) | 0x40);

  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld e
  */

  return SPMul( SPAdd(ld_M, Exponent), InvLde);
#/Code
#/Function


#Function float SPPow
#Parameter float fnum1 D1
    Motorola fast floating point number
#/Parameter
#Parameter float fnum2 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 15
#AutoDoc
    FUNCTION
      Calculate fnum2 raised to the fnum1 power (fnum2^fnum1)

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  /* a     ^ b     = e^(b     * ln a    )
  ** fnum2 ^ fnum1 = e^(fnum1 * ln fnum2)
  */
  ULONG Res;
  Res = SPLog( fnum2 & (FFPMantisse_Mask + FFPExponent_Mask) );
  Res = SPMul(Res, fnum1);
  Res = SPExp(Res);
  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if ((char) Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float SPSqrt
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 16      
#AutoDoc      
    FUNCTION
      Calculate square root of ffp number

    RESULT
      Motorola fast floating point number

      flags:
         zero     : result is zero
         negative : 0
         overflow : square root could not be calculated

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

      ALGORITHM:
        First check for a zero and a negative argument and take
        appropriate action.
        fnum1 = M * 2^E

        If exponent is an odd number:
     <code>
          fnum = ( M*2 ) * 2^ (E-1)
          Now E' = E-1 is an even number and
               -> sqrt(fnum) = sqrt(M)   * sqrt(2)   * sqrt (2^E')
                             = sqrt(M)   * sqrt(2)   * 2^(E'/2)
           (with sqrt(M*2)>1)
                             = sqrt(M)   * sqrt(2)   * 2^(E'/2)
                             = sqrt(M)   * 1/sqrt(2) * 2^(1+(E'/2))
                             = sqrt(M/2)             * 2^(1+(E'/2))
     </code>


       If Exponent is an even number:
     <code>
           -> sqrt(fnum) = sqrt(M) * sqrt (2^E) =
                         = sqrt(M) * 2^(E/2)
     </code>

        Now calculate the square root of the mantisse.
        The following algorithm calculates the square of a number + delta
        and compares it to the mantisse. If the square of that  number +
        delta is less than the mantisse then keep that number + delta.
        Otherwise calculate a lower delta and try again.
        Start out with number = 0;


     <code>
        Exponent = -1;
        Root = 0;
        repeat
        {
          if ( ( Root + 2^Exponent ) ^2 < Mantisse)
            Root += 2^Exponent
          Exponent --;
        }
        until you`re happy with the accuracy
     </code>


    HISTORY

#/AutoDoc
#Code
  ULONG Res, ResSquared, Delta, X, TargetMantisse;
  int z;
  BYTE Exponent;

  if (0 == fnum1)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }
  /* is fnum negative */
  if ((char)fnum1 < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return fnum1;
  }

  /* let us calculate the square-root now! */

  TargetMantisse = ((ULONG)fnum1 & FFPMantisse_Mask);

  if (fnum1 & 1)
  {
    /* TargetMantisse = TargetMantisse / 2; */
    TargetMantisse >>= 1;
    Exponent = ((BYTE)fnum1 >> 1) + 0x21;
  }
  else
    Exponent = ((BYTE)fnum1 >> 1) + 0x20;


  Res = 0;
  ResSquared = 0;
  z = 0;

  /* this calculates the sqrt of the mantisse. It`s short, isn`t it?
  ** Delta starts out with 0.5, then 0.25, 0.125 etc.
  */
  while (ResSquared != TargetMantisse && z < 25)
  {
    Delta = (0x80000000 >> z);
    /* X = (Res+Delta)^2 =
    **   = Res^2      + 2*Res*Delta + Delta^2
    */
    X = ResSquared + (Res >> z)  + (Delta >> ++z);
    if (X <= TargetMantisse)
    {
      Res += Delta;
      ResSquared = X;
    }
  }

  /* an adjustment for precision */
  if ((char) Res < 0)
    Res += 0x100;

  Res &= FFPMantisse_Mask;
  Res |= Exponent;

  return Res;
#/Code
#/Function


#Function float SPTieee
#Parameter float fnum D0
    Motorola fast floating point number
#/Parameter
#LibOffset 17
#AutoDoc
    FUNCTION
       Convert FFP number to single precision ieee number

    RESULT
       IEEE Single Precision Floating Point

       flags:
         zero     : result is zero
         negative : result is negative
         overflow : exponent of the ieee-number was out of range for ffp

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Res;
  LONG Exponent;
  if (0 == fnum)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  Exponent = (fnum & FFPExponent_Mask) - 0x40 + 126;

  Res = ( Exponent << (30-7) );
  Res |= (((ULONG)fnum & 0x7fffff00) >> 8);

  if ((char) fnum < 0)
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Res |= IEEESPSign_Mask;
  }

  return Res;
#/Code
#/Function


#Function float SPFieee
#Parameter float ieeenum D0
    IEEE Single Precision floating point number
#/Parameter
#LibOffset 18
#AutoDoc
    FUNCTION
      Convert single precision ieee number to FFP number

    RESULT
      Motorola fast floating point number

      flags:
         zero     : result is zero
         negative : result is negative
         overflow : exponent of the ieee-number was out of range for
                    ffp

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Res;
  /* check for ieeenum == 0 */
  if (0 == ieeenum)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* calculate the exponent  */
  Res = (ieeenum & IEEESPExponent_Mask) >> 23;
  Res = Res - 126 + 0x40;

  /* exponent too big / small */
  if ((char) Res < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  Res |= (ieeenum << 8) | 0x80000000;

  /* check ieeenum-number for a sign */
  if (ieeenum < 0)
  {
    Res |= FFPSign_Mask;
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  }

  return Res;
#/Code
#/Function


#Function float SPAsin
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 19
#AutoDoc
    FUNCTION
      Calculate arcussin of the given number

    RESULT
      Motorola fast floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : fnum &lt; -1  or  fnum &gt; 1

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
*/

  /* 1> |x| >= 0.5 */
  LONG t,w,p,q,c,r,s,ix;
  ix = fnum1 & (FFPMantisse_Mask | FFPExponent_Mask); /* ix = |fnum| */

  if (one == ix) /* |fnum1| = 1 -> result = +-(pi/2) */
    return (pio2 | (fnum1 & FFPSign_Mask  ));

  if (1 == SPCmp(ix,one)) /* |fnum1| > 1 */
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return -1;
  }

  /* error: 1 ulp (unit in the last place)*/
  if (-1 == SPCmp(ix,onehalf)) /* |fnum1| < 0.5 */
  {
    if (-1 == SPCmp(ix,0xb89b6736)) /* |fnum1| < 70422/10000000 */
      return fnum1;
    t = SPMul(fnum1, fnum1);
    p = SPMul(t, SPAdd(pS0,
        SPMul(t, SPAdd(pS1,
        SPMul(t, SPAdd(pS2,
        SPMul(t, SPAdd(pS3,
        SPMul(t, SPAdd(pS4,
        SPMul(t, pS5)))))))))));
    q = SPAdd(one,
        SPMul(t, SPAdd(qS1,
        SPMul(t, SPAdd(qS2,
        SPMul(t, SPAdd(qS3,
        SPMul(t, qS4))))))));
    w = SPDiv(q, p);
    return SPAdd(fnum1, SPMul(fnum1, w));
  }


  w = SPSub(ix, one) ; /* w = 1 - fnum ; y = 1-x */
  t = SPMul(w, onehalf);  /* t = w / 2    ; z = y/2 */
  p = SPMul(t,SPAdd(pS0,
      SPMul(t,SPAdd(pS1,
      SPMul(t,SPAdd(pS2,
      SPMul(t,SPAdd(pS3,
      SPMul(t,SPAdd(pS4,
      SPMul(t,pS5)))))))))));
  q = SPAdd(one,
      SPMul(t,SPAdd(qS1,
      SPMul(t,SPAdd(qS2,
      SPMul(t,SPAdd(qS3,
      SPMul(t,qS4))))))));
  s = SPSqrt(t);      /* s = sqrt(t)  ; s = sqrt(z) */

  if(1 == SPCmp(ix, 0xf9999a40 /*0.975*/ )) /* |fnum| > 0.975 */
  {
    /*error: 2 ulp (4 ulp when |fnum| close to 1) */
    w = SPDiv(q,p); /* w = p / q; */
    /* res = pi/2-(2*(s+s*w)) */
    t = SPSub(SPMul(two,SPAdd(s,SPMul(s,w))),pio2);
    t = SPAdd(t, 0x8000002b); /* for better accuracy */
  }
  else
  {
    /* error: 2 ulp */
    w = s;
    c = SPDiv(SPAdd(s,w),SPSub(SPMul(w,w),t)); /* c=(t-w*w)/(s+w) */
    r = SPDiv(q,p);
    p = SPAdd(SPAdd(c,c),SPMul(SPAdd(s,s),r));
    q = SPSub(SPAdd(w,w) ,pio4);
    t = SPSub(SPSub(q,p) ,pio4);

   }
   return (t | (fnum1 & FFPSign_Mask )) ;
#/Code
#/Function


#Function float SPAcos
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 20
#AutoDoc
    FUNCTION
      Calculate arcuscos of the given number

    RESULT
      Motorola fast floating point number

      flags:
      zero     : result is zero
      negative : 0 (not possible)
      overflow : fnum &lt; -1  or  fnum &gt; 1

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
*/
  /* 1> |x| >= 0.5 */
  LONG z,p,q,r,w,s,c,ix,df;
  ix = fnum1 & (FFPMantisse_Mask | FFPExponent_Mask); /* ix = |fnum|  */

   z = SPCmp(ix,one);

   if (1==z) /* |fnum1| > 1 */
   {
     SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
     return -1;
   }

   if (0==z) /* |fnum1| = 1 */
   {
     if (fnum1 & FFPSign_Mask) /* |fnum| = -1 */
     return pi;
     SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
     return 0;
   }

  /* error: 1 ulp (unit in the last place) */
  if (-1 == SPCmp(ix,onehalf)) /* |fnum1| < 0.5 */
  {
    z = SPMul(fnum1, fnum1);
    p = SPMul(z, SPAdd(pS0,
        SPMul(z, SPAdd(pS1,
        SPMul(z, SPAdd(pS2,
        SPMul(z, SPAdd(pS3,
        SPMul(z, SPAdd(pS4,
        SPMul(z, pS5)))))))))));
    q = SPAdd(one,
        SPMul(z, SPAdd(qS1,
        SPMul(z, SPAdd(qS2,
        SPMul(z, SPAdd(qS3,
        SPMul(z, qS4))))))));
    r = SPDiv(q, p);
    return (SPSub(SPAdd(fnum1,SPMul(fnum1,r)),pio2));
  }

  /* error: 1 ulp */
  if (fnum1 & FFPSign_Mask) /* fnum1 < -0.5 */
  {
    z = SPMul(onehalf, SPAdd(one, fnum1));
    p = SPMul(z, SPAdd(pS0,
        SPMul(z, SPAdd(pS1,
        SPMul(z, SPAdd(pS2,
        SPMul(z, SPAdd(pS3,
        SPMul(z, SPAdd(pS4,
        SPMul(z, pS5)))))))))));
    q = SPAdd(one,
        SPMul(z, SPAdd(qS1,
        SPMul(z, SPAdd(qS2,
        SPMul(z, SPAdd(qS3,
        SPMul(z, qS4))))))));
    s = SPSqrt(z);
    r = SPDiv(q,p); /* r = p/q; */
    w = SPMul(r,s);
    return SPSub(SPMul(two, SPAdd(s, w)) ,pi);
  }

  /* error: 8 ulp (this is bad !!!!) */
  /* fnum1 > 0.5 */
  z = SPMul(onehalf, SPSub(fnum1, one));
  s = SPSqrt(z);
  df = s;
  df = df & 0xfff000ff;
  c = SPDiv(SPAdd(df,s),  SPSub( SPMul(df,df), z));
  p = SPMul(z, SPAdd(pS0,
      SPMul(z, SPAdd(pS1,
      SPMul(z, SPAdd(pS2,
      SPMul(z, SPAdd(pS3,
      SPMul(z, SPAdd(pS4,
      SPMul(z, pS5)))))))))));
  q = SPAdd(one,
      SPMul(z, SPAdd(qS1,
      SPMul(z, SPAdd(qS2,
      SPMul(z, SPAdd(qS3,
      SPMul(z, qS4))))))));
  r = SPDiv(q, p);
  w = SPAdd(c, SPMul(r,s));
  return SPAdd(SPMul(two, SPAdd(df,w)),0x800000a9);
#/Code
#/Function


#Function float SPLog10
#Parameter float fnum1 D0
    Motorola fast floating point number
#/Parameter
#LibOffset 21
#AutoDoc
    FUNCTION
      Calculate logarithm (base 10) of the given ffp number

    RESULT
      ffp number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return 0.
      If the Argument is 0 return 0xde5bd8fe.

      All other cases:

      (ld is the logarithm with base 2)
      (log is the logarithm with base 10)
      <code>
      fnum1 = M * 2^E

      log fnum1 = log ( M * 2^E ) =

                = log M + log 2^E =

                = log M + E * log (2) =

                  ld M        ld 2
                = ----- + E * ----- =      [ld 2 = 1]
                  ld 10       ld 10

                  ld M + E
                = --------
                  ld 10
      </code>

      ld 10 can be precalculated, of course.
      For calculating ld M see file intern_spld.c

    HISTORY

#/AutoDoc
#Code
  LONG ld_M, Exponent, Mask = 0x40, i, Sign;
  /* check for negative sign */
  if ((char) fnum1 < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (0 == fnum1)
    return 0xde5bd8fe; /* result of the orig. library */

  /* convert the Exponent of the argument (fnum1) to the ffp-format */
  Exponent = (fnum1 & FFPExponent_Mask) - 0x40;
  if (Exponent < 0 )
  {
    Exponent = -Exponent;
    Sign = FFPSign_Mask;
  }
  else
    Sign = 0;

  /* find the number of the highest set bit in the exponent */
  if (Exponent != 0)
  {
    i = 0;
    while ( (Mask & Exponent) == 0)
    {
      i ++;
      Mask >>= 1;
    }

  Exponent <<= (25 + i);
  Exponent |= (0x47 - i + Sign);
  }

  ld_M = intern_SPLd((struct MathTransBase *)MathTransBase, 
                     (fnum1 & FFPMantisse_Mask) | 0x40);

  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld e
  */

  return SPMul( SPAdd(ld_M, Exponent), InvLd10);
#/Code
#/Function

#/Archive

