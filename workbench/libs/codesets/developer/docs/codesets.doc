TABLE OF CONTENTS

codesets.library/codesets.library
codesets.library/CodesetsSupportedA
codesets.library/CodesetsFindA
codesets.library/CodesetsFindBestA
codesets.library/CodesetsConvertStrA
codesets.library/CodesetsFreeA
codesets.library/CodesetsFreeVecPooledA
codesets.library/CodesetsSetDefaultA
codesets.library/CodesetsListCreateA
codesets.library/CodesetsListDeleteA
codesets.library/CodesetsListAddA
codesets.library/CodesetsListRemoveA
codesets.library/CodesetsUTF8CreateA
codesets.library/CodesetsUTF8ToStrA
codesets.library/CodesetsUTF8Len
codesets.library/CodesetsIsValidUTF8
codesets.library/CodesetsIsLegalUTF8
codesets.library/CodesetsIsLegalUTF8Sequence
codesets.library/CodesetsStrLenA
codesets.library/CodesetsConvertUTF16toUTF32
codesets.library/CodesetsConvertUTF16toUTF8
codesets.library/CodesetsConvertUTF32toUTF16
codesets.library/CodesetsConvertUTF32toUTF8
codesets.library/CodesetsConvertUTF8toUTF16
codesets.library/CodesetsConvertUTF8toUTF32
codesets.library/CodesetsDecodeB64A
codesets.library/CodesetsEncodeB64A

codesets.library/codesets.library

    *******************************************************************
    Copyright (c) 2005-2008 by codesets.library Open Source Team
    $Id$
    $URL$

    codesets.library is an AmigaOS shared library which provides
    functions to deal with different kind of codesets. It provides
    general character conversion routines, e.g. for converting
    from one charset (e.g. UTF8) into another (e.g. ISO-8859-1) or
    vice versa.

    codesets.library is mainly based on some code from UNICODE, some
    code from the SimpleMail project as well as some additions done
    by the codesets.library Open Source Team.

    It is released and distributed under the terms of the GNU Lesser
    General Public License (LGPL) and available free of charge.

    Please visit http://www.sf.net/projects/codesetslib/ for
    the very latest version and information regarding codesets.library.
    *******************************************************************

    For some short introduction on how to use codesets.library, the
    following pharagraph should provide a good summary. What you
    usually want to do with codesets.library is, to convert strings from
    one so-called "Source Codeset" into another "Destination Codeset".
    The following list are only the main functions provided to
    developers, wanting to achieve this conversion in their applications:


    CodesetsSupportedA()
    --------------------

      For querying codesets library which codesets/charsets it supports
      either by its internal available charsets or by having obtained
      them from the operating system (e.g. AmigaOS4), this function
      can be used.

      E.g. in a MUI application you would do something like:

      -- cut here --
      STRPTR *array;

      if((array = CodesetsSupportedA(NULL)))
      {
        DoMethod(list, MUIM_List_Insert, array, -1, MUIV_List_Insert_Sorted);
        CodesetsFreeA(array, NULL);
      }
      -- cut here --



    CodesetsFindA()
    ---------------

      For processing/converting a specific string, you normally have to
      specify in which codeset this string has to be intepreted. For this
      purpose you have to pass a so-called "Source Codeset" to the main
      function of codesets.library. With the "CodesetsFindA()" function you
      can query codesets.library for providing you a pointer to the
      corresponding codeset structure which you afterwards will forward to
      the main conversion routines later on.

      For receiving the pointer to the Amiga-1251 codeset:
      -- cut here --
      struct codeset *cs;

      if((cs = CodesetsFind("Amiga-1251",
                            CSA_FallbackToDefault, FALSE,
                            TAG_DONE)))
      {
        ...
      }
      -- cut here --

      For querying codesets.library for the currently used system wide
      default of your running operating system:
      -- cut here --
      struct codeset *default;

      if((default = CodesetsFindA(NULL, NULL)))
      {
        ...
      }
      -- cut here --



    CodesetsConvertStrA()
    ---------------------

      The more or less most common function to use in codesets.library is
      definitly this function. It allows to convert a string from
      one "Source Codeset" to another "Destination Codeset". It takes
      the source string converts it internally into UTF8 if necessary and
      then directly convert the UTF8 to the specified destination codeset.

      To convert a string 'str' to a destination codeset:
      -- cut here --
      STRPTR destString;

      if((destString = CodesetsConvertStr(CSA_SourceCodeset, srcCodeset,
                                          CSA_DestCodeset,   destCodeset,
                                          CSA_Source,        str,
                                          TAG_DONE)))
      {
        ....

        CodesetsFreeA(destString, NULL);
      }
      -- cut here --

   Even if the above functions should cover most of the common functionality
   an ordinary user of codesets.library would require, it supplies a lot more
   functions which in fact we will not go into detail here but present
   certain examples in the respective documentation section of each function.

   However, if you find the documentation is still too limited or you feel
   some major functionality is missing regarding dealing with codesets,
   please let us know so that we or even you can improve it.


   Your codesets.library Open Source Team.
   February 2006

codesets.library/CodesetsSupportedA

   NAME
    CodesetsSupportedA - returns names of supported codesets

   SYNOPSIS
    array = CodesetsSupportedA(attrs);
                               A0

    STRPTR * CodesetsSupportedA(struct TagItem *);

    array = CodesetsSupported(tag1, ...);
                              A0

    STRPTR * CodesetsSupported(Tag, ...);

   FUNCTION
    Returns a NULL terminated array of the supported codeset
    names. The array _must_ be freed with CodesetsFreeA().

   INPUTS
    attrs - a list of additional tag items. Valid items are:

      CSA_CodesetList (struct codesetList *)
        You may supply an unlimited number of additional
        codeset lists which you have previously allocated/loaded
        with CodesetsListCreateA(). Otherwise just the internal
        list of available codesets will be searched.
        Default: NONE

   RESULT
    array - the names array or NULL on an error.

   EXAMPLE
    For printing out all supported codeset names:

    -- cut here --
    STRPTR *array;

    if((array = CodesetsSupportedA(NULL)))
    {
      int i;

      for(i=0; array[i] != NULL; i++)
        printf("%s", array[i]);

      CodesetsFreeA(array, NULL);
    }
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsListCreateA

codesets.library/CodesetsFindA

   NAME
    CodesetsFindA - finds a codeset

   SYNOPSIS
    codeset = CodesetsFindA(name, attrs);
    D0                      A0    A1

    struct codeset * CodesetsFindA(STRPTR, struct TagItem *);

    codeset = CodesetsFind(name, tag1, ...);
    D0                     A0    A1

    struct codeset * CodesetsFind(STRPTR, Tag, ...);

   FUNCTION
    Finds and returns a codeset by its name. The data behind the
    pointer should be considered read-only and must not be altered
    in any way.

   INPUTS
    name - the codeset name (or alias) to find
    attrs - a list of additional tag items. Valid items are:

      CSA_FallbackToDefault (BOOL)
        If TRUE the function never fails and returns the default
        codeset if the supplied codeset name can't be found.
        Default: TRUE

      CSA_CodesetList (struct codesetList *)
        You may supply an unlimited number of additional
        codeset lists which you have previously allocated/loaded
        with CodesetsListCreateA(). Otherwise just the internal
        list of available codesets will be searched.
        Default: NONE

   RESULT
    codeset - the codeset or NULL on an error

   EXAMPLE
     E.g. for receiving the pointer to the Amiga-1251 codeset:

     -- cut here --
     struct codeset *cs;

     if((cs = CodesetsFind("Amiga-1251",
                           CSA_FallbackToDefault, FALSE,
                           TAG_DONE)))
     {
       ...
     }
     -- cut here --

     For querying codesets.library for the currently used system
     wide default of your running operating system:
     -- cut here --
     struct codeset *default;

     if((default = CodesetsFindA(NULL, NULL)))
     {
       ...
     }
     -- cut here --

   NOTE
    Please note for querying the system's default codeset the
    method of finding this codeset is highly dependent on the way
    the operating system can be queried for it. E.g. on AmigaOS4
    the default codeset is queried with updated system functions,
    but for AmigaOS3 a static list of language<>codeset mappings
    is used.

   SEE ALSO
    codesets.library/CodesetsListCreateA

codesets.library/CodesetsFindBestA

   NAME
    CodesetsFindBestA - finds the best codeset matching a
                        string content.

   SYNOPSIS
    codeset = CodesetsFindBestA(attrs);
    D0                          A0

    struct codeset * CodesetsFindBestA(struct TagItem *);

    codeset = CodesetsFindBest(tag1, ...);
    D0                         A0

    struct codeset * CodesetsFindBest(Tag, ...);

   FUNCTION
    Returns the best found codeset for the given text in the supplied
    codeset family. In case no proper codeset for the supplied source string
    could be found, NULL is returned or the default codeset if the
    CSA_FallbackToDefault attribute is set to TRUE. In addition, in case
    the CSA_ErrPtr is given, the amount of failed identifications (chars)
    are returned.

   INPUTS
    attrs - a list of tag items. Valid items are:

      CSA_Source (STRPTR)
        The string which you want to convert. Must be supplied,
        otherwise the functions returns NULL.

      CSA_SourceLen (ULONG)
        Length of CSA_Source or less to check just a part
        Default: string length of CSA_Source

      CSA_ErrPtr (int *)
        Pointer to an integer variable which will be filled with the
        number of found errors (not identifyable chars)
        Default: NULL

      CSA_CodesetList (struct codesetList *)
        You may supply an unlimited number of additional
        codeset lists which you have previously allocated/loaded
        with CodesetsListCreateA(). Otherwise just the internal
        list of available codesets will be searched.
        Default: NONE

      CSA_CodesetFamily (ULONG)
        To narrow the analyze, a user might define the codeset family
        of which the supplied text might be composed of. The reason for
        this is, that there isn't a unique identification algorithm
        which can tell the codeset out of a given text. So to narrow
        the identification, the follow values might be specified:

          CSV_CodesetFamily_Latin    - Latin codeset family (e.g. ISO-8859-X)
          CSV_CodesetFamily_Cyrillic - Cyrillic codeset family (e.g. KOI8R)

        Default: CSV_CodesetFamily_Latin

      CSA_FallbackToDefault (BOOL)
        If TRUE the function never fails and returns the default
        codeset if the supplied text couldn't be identified
        Default: FALSE

   RESULT
    codeset - the best matching codeset or NULL in case a NULL pointer
              was supplied as the source string.

   EXAMPLE
     E.g. for receiving the pointer to 'best matching' codeset matching
     a KOI8-R string:

     -- cut here --
     struct codeset *cs;
     char str[] = "Невозможно перекодировать из кодировки";
     int errPtr;

     if((cs = CodesetsFindBest(CSA_Source, str,
                               CSA_ErrPtr, &errPtr,
                               CSA_CodesetFamily, CSV_CodesetFamily_Cyrillic,
                               CSA_FallBackToDefault, FALSE,
                               TAG_DONE)))
     {
       ... should return the KOI8-R codeset ...
     }
     -- cut here --

   SEE ALSO
    codesets.library/CodesetsListCreateA

codesets.library/CodesetsConvertStrA

   NAME
    CodesetsConvertStrA - converts a string from one source codeset to
                          another destination codeset.

   SYNOPSIS
    dest = CodesetsConvertStrA(attrs)
    D0                         A0

    STRPTR CodesetsConvertStrA(struct TagItem *);

    dest = CodesetsConvertStr(tag1, ...);
    D0                        A0

    STRPTR CodesetsConvertStr(Tag, ...);

   FUNCTION
    The function takes source string which is encoded in a so-called
    'Source codeset' and converts it immediately into an equivalent
    string which will be encoded in the corresponding 'Destination Codeset'.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_Source (STRPTR)
        The string which you want to convert. Must be supplied,
        otherwise the functions returns NULL.

      CSA_SourceLen (ULONG)
        Length of CSA_Source or less to convert just a part
        Default: string length of CSA_Source

      CSA_SourceCodeset (struct codeset *)
        The codeset in which the source string is encoded.
        Default: the system's default codeset

      CSA_DestCodeset (struct codeset *)
        The codeset to which the source string should be converted to.
        Default: the system's default codeset

      CSA_DestLenPtr (ULONG *)
        If supplied, will contain the length of the converted string
        which is returned.

      CSA_MapForeignChars (BOOL)
        If a character of the source string cannot be directly mapped
        to the destination codeset a "?" character will normally be used
        to signal this case. If this attribute is set, an internal
        replacement table will be used which tries to replace these
        "foreign" characters by "looklike" ASCII character sequences.
        Please note, that this functionality is mostly just usable by
        Latin users due to the straight mapping to ASCII (7bit).
        Default: FALSE

      CSA_MapForeignCharsHook (struct Hook *)
        If a character of the source string cannot be directly mapped
        to the destination codeset a "?" character will normally be used
        to signal this case. By using this attribute, a hook can be
        supplied which is called for every such foreign character.
        Within this hook the UTF8 sequence is supplied which cannot be
        directly mapped to the destination codeset. During the execution
        of the hook a replacement string might be specified, which in turn
        will be used by the internals of codesets.library to map this
        "foreign" char to a difference character or UTF8 sequence.

        If both, CSA_MapForeignChars and CSA_MapForeignCharsHook, are
        specified the hook will only be executed in case the internal
        routines don't supply an own mapping for the foreign UTF8 sequence.

        The hook function should be declared as:

        ULONG ASM SAVEDS fun(REG(a0, struct Hook *hook),
                             REG(a2, struct replaceMsg *msg),
                             REG(a1, void *dummy))

        struct Hook *hook
          Your hook

        msg->dst
          place your desired replacement string here

        msg->src
          the UTF8 sequence to be replaced, this string is READ-ONLY!

        msg->srclen
          the length of the UTF8 sequence to be replaced, do NOT peek
          beyond this limit.

        The return value of this hook function is the length of the replacement
        string. Return zero if no replacement did happen. Positive values will
        be treated as lengths of ASCII strings. Negative values signals a
        replacement by another UTF8 sequence. Please note, that in case you
        supply a UTF8 sequence as a replacement for the "foreign" UTF8, your
        hook might be called again if this sequence can still not be mapped to
        the destination codesets, thus is again a "foreign" sequence.


   RESULT
    either a pointer to the generated destination string or NULL
    on a found error.

   EXAMPLE
    To convert an ISO-8859-1 encoded string 'src' into an Amiga-1251
    equivalent 'dst' string:
    -- cut here --
    STRPTR src, dst;
    struct codeset *srcCodeset, *dstCodeset;

    srcCodeset = CodesetsFindA("ISO-8859-1", NULL);
    dstCodeset = CodesetsFindA("Amiga-1251", NULL);

    if((dst = CodesetsConvertStr(CSA_SourceCodeset, srcCodeset,
                                 CSA_DestCodeset,   dstCodeset,
                                 CSA_Source,        src,
                                 TAG_DONE)))
    {
      ....

      CodesetsFreeA(dst, NULL);
    }
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsFreeA

codesets.library/CodesetsFreeA

   NAME
    CodesetsFreeA - frees objects previously internally allocated
                    by codesets.library

   SYNOPSIS
    CodesetsFreeA(obj, attrs)
                  A0   A1
    void CodesetsFreeA(APTR, struct TagItem *);

    CodesetsFree(obj, tag1, ...);
                 A0   A1
    void CodesetsFree(APTR, Tag, ...);

   FUNCTION
    Frees object previously allocated by codesets.library. E.g. using
    functions like CodesetsSupportedA() or CodesetsConvertStrA().

   INPUTS
    obj - the object to free
    attrs - a list of additional tag items. Currently non items.

   RESULT
    no result

   EXAMPLE

    -- cut here --
    STRPTR *array;

    if((array = CodesetsSupportedA(NULL)))
    {
      ...

      CodesetsFreeA(array, NULL);
    }
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsSupportedA
    codesets.library/CodesetsConvertStrA

codesets.library/CodesetsFreeVecPooledA

   NAME
    CodesetsFreeVecPooledA - frees objects previously allocated
                             by methods supporting CSA_Pool

   SYNOPSIS
    CodesetsFreeVecPooledA(pool, obj, attrs)
                           A0    A1   A2
    void CodesetsFreeVecPooledA(APTR, APTR, struct TagItem *);

    CodesetsFreeVecPooled(pool, obj, tag1, ...);
                          A0    A1   A2
    void CodesetsFreeVecPooled(APTR, APTR, Tag, ...);

   FUNCTION
    Frees object previously allocated by codesets.library via a
    private memory pool which was previously used on codesets
    functions via the CSA_Pool tag.

   INPUTS
    pool - pointer to the private memory pool
    obj - the object to free
    attrs - a list of additional tag items. Valid tags are:

      CSA_PoolSem (struct SignalSemaphore *)
        A semaphore to lock when using CSA_Pool

   RESULT
    no result

   EXAMPLE

    -- cut here --
    UTF8   *utf8;
    STRPTR str;
    APTR   pool;

    if((utf8 = CodesetsUTF8Create(CSA_Source,     str,
                                  CSA_Pool,       pool,
                                  TAG_DONE)))
    {
        ...

        CodesetsFreeVecPooledA(pool,utf8,NULL);
    }
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8ToStrA

codesets.library/CodesetsSetDefaultA

   NAME
    CodesetsSetDefaultA - sets the default codeset, overwriting
                          the system default if necessary.

   SYNOPSIS
    codeset = CodesetsSetDefaultA(name, attrs);
                                  A0    A1

    struct codeset * CodesetsSetDefaultA(STRPTR, struct TagItem *);

    codeset = CodesetsSetDefault(name, tag1, ...);
                                 A0    A1

    struct codeset * CodesetsSetDefault(STRPTR, Tag, ...);

   FUNCTION
    Sets the default codeset to name. The codeset will be stored in
    the environment variable 'codeset_default'.

   INPUTS
    name - the name of the codeset to set as default
    attrs - a list of additional tag items. Valid items are:

      CSA_Save (BOOL)
        If TRUE the codeset will be permanently saved and survives
        a reset. Otherwise the default setting will just last until
        the next reboot.
        Default: FALSE

   RESULT
    codeset - the codeset or NULL

   NOTE
    In case the operating system supports the direct query of the
    currently active system's default codeset, this function will
    still overwrite this setting. So by using this method a user may
    overwrite all system's setting and set a global default codeset
    for his machine no matter what the OS suggests. However, in case
    your operating sytsem perfectly supports the querying of the
    system's default codeset (e.g. AmigaOS4) you are adviced to use
    this function with care - or even avoid to use it at all.

   SEE ALSO
    codesets.library/CodesetsFindA

codesets.library/CodesetsListCreateA

   NAME
    CodesetsListCreateA - creates a private, task-wise codeset list
                          and returns it to the user for further reference.

   SYNOPSIS
    list = CodesetsListCreateA(attrs);
    D0                         A0

    struct codesetList * CodesetsListCreateA(struct TagItem *);

    list = CodesetsListCreate(tag1, ...);
    D0                        A0

    struct codesetList * CodesetsListCreateA(Tag, ...);

   FUNCTION
    This function allows to create a private, task-wise codeset list by
    loading charset files from either a whole directory tree, a specific
    charset file or even by using an exsiting codeset structure.
    By using this function, an application might load and carry its very
    own private charsets in parallel to the internal charsets of
    codeset.library. This way each application can provide a different
    codeset list to the user without having to load and manage these
    lists on their own.

   INPUTS
    attrs - a list of addtional tag items. Valid items are:

      CSA_CodesetDir (STRPTR)
        The path to a whole directory which codesets library will
        walk through for searching for proper charset files.
        Default: NULL

      CSA_CodesetFile (STRPTR)
        The path to a specific file which codesets.library will try
        to load as a standard charset translation file.
        Default: NULL

      CSA_SourceCodeset (struct codeset *)
        The pointer to an already existing codeset structure which
        will immediately be added to the created list. Please be
        carefull to add one codeset to multiple lists, especially
        when you do a CodesetsListDelete() to free the list.
        Default: NULL

   RESULT
    list - the private codeset list or NULL on an error condition

   NOTE
    For convienence, if no tag item attribute at all is supplied to the
    function, codesets.library will try to load charsets from the
    corresponding "PROGDIR:Charsets" directoy and add found codeset to
    the list. However, in case a tag item is specified (no matter what
    kind) the PROGDIR: scanning will be omitted.

   EXAMPLE
    For loading all found charset files from PROGDIR:Charsets:

    -- cut here --
    struct codesetList *csList;

    if((csList = CodesetsListCreateA(NULL)))
    {
      STRPTR codesetArray = CodesetsSupported(CSA_CodesetList, csList,
                                              TAG_DONE);

      // codesetsArray should now also carry our private
      // codesets from PROGDIR:Charsets
      ...

      CodesetsListDeleteA(CSA_CodesetList, csList,
                          TAG_DONE);
    }
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsListDeleteA
    codesets.library/CodesetsListAddA
    codesets.library/CodesetsListRemoveA
    codesets.library/CodesetsListSupportedA
    codesets.library/CodesetsListFindA
    codesets.library/CodesetsListFindBestA

codesets.library/CodesetsListDeleteA

   NAME
    CodesetsListDeleteA - deletes/frees all resources of previously created
                          private codeset lists.

   SYNOPSIS
    result = CodesetsListDeleteA(attrs);
    D0                           A0

    BOOL CodesetsListDeleteA(struct TagItem *);

    result = CodesetsListDelete(tag1, ...);
    D0                          A0

    BOOL CodesetsListDelete(Tag, ...);

   FUNCTION
    This function deletes all resources (also the contained codeset
    structures per default) and frees the memory of previously allocated
    private codeset lists.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_CodesetList (struct codesetList *)
        Pointer to a previously created, private codeset list whos
        resources should be freed.
        Default: NULL

      CSA_FreeCodesets (BOOL)
        If TRUE, all contained codesets should also be freed/deleted,
        otherwise just frees the list object itself.
        Default: TRUE

   RESULT
    result - TRUE on success otherwise FALSE

   NOTE
    Please note that if you added an explicit codeset structure to more
    than two private codeset lists you may run into problems with you
    don't take care of this yourself. This is a dumb function which just
    walks through the list and frees all resources. Set CSA_FreeCodesets
    to FALSE in case you just want to free the list object.

   SEE ALSO
    codesets.library/CodesetsListCreateA
    codesets.library/CodesetsListAddA
    codesets.library/CodesetsListRemoveA

codesets.library/CodesetsListAddA

   NAME
    CodesetsListAddA - allows to add additional codesets to an already
                       existing private codeset list previously created with
                       CodesetsListCreateA().

   SYNOPSIS
    result = CodesetsListAddA(attrs);
    D0                        A0

    BOOL CodesetsListAddA(struct TagItem *);

    result = CodesetsListAdd(tag1, ...);
    D0                       A0

    BOOL CodesetsListAdd(Tag, ...);

   FUNCTION
    This function allows to add additional codesets to an already existing
    private codeset list. Either codesets themself may be added directly, or
    the path to either a file or a directory may be specified from which
    additional codesets may be loaded from known charset files.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_CodesetDir (STRPTR)
        The path to a whole directory which codesets library will
        walk through for searching for proper charset files.
        Default: NULL

      CSA_CodesetFile (STRPTR)
        The path to a specific file which codesets.library will try
        to load as a standard charset translation file.
        Default: NULL

      CSA_SourceCodeset (struct codeset *)
        The pointer to an already existing codeset structure which
        will immediately be added to the created list. Please be
        carefull to add one codeset to multiple lists, especially
        when you do a CodesetsListDelete() to free the list.
        Default: NULL

   RESULT
    result - TRUE on success otherwise FALSE

   NOTE
    Be careful when adding one codeset to more than one codeset list as
    you may run into problems when freeing the list afterwards.

   SEE ALSO
    codesets.library/CodesetsListCreateA
    codesets.library/CodesetsListDeleteA
    codesets.library/CodesetsListAddA

codesets.library/CodesetsListRemoveA

   NAME
    CodesetsListRemoveA - removes a single or multiple codesets from a
                          previously created codeset list.

   SYNOPSIS
    result = CodesetsListRemoveA(attrs);
    D0                           A0

    BOOL CodesetsListRemoveA(struct TagItem *);

    result = CodesetsListRemove(tag1, ...);
    D0                          A0

    BOOL CodesetsListRemove(Tag, ...);

   FUNCTION
    This function allows to remove single or multiple codesets from a
    previously created codeset list. The removed codeset structures will
    also be freed/deleted per default.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_SourceCodeset (struct codeset *)
        Pointer to a codeset structure which should be removed from
        its corresponding list. Per default its resources will also
        be internally freed.
        Default: NULL

      CSA_FreeCodesets (BOOL)
        If TRUE, all supplied codesets should also be freed/deleted,
        otherwise the codesets will just be removed from their lists.
        Default: TRUE

   RESULT
    result - TRUE on success otherwise FALSE

   NOTE
    The function will automatically prevent removal of codesets from the
    internal codeset list of codesets.library and will return FALSE in
    case a user tried to remove a codeset from the internal list.

   SEE ALSO
    codesets.library/CodesetsListDeleteA
    codesets.library/CodesetsListAddA

codesets.library/CodesetsUTF8CreateA

   NAME
    CodesetsUTF8CreateA - creates an UTF8 compliant string
                          interpretation out of a supplied source
                          string.


   SYNOPSIS
    utf8 = CodesetsUTF8CreateA(attrs);
                               A0
    UTF8 * CodesetsUTF8CreateA(struct TagItem *);

    utf8 = CodesetsUTF8Create(tag1, ...);
                              A0
    UTF8 * CodesetsUTF8Create(Tag, ...);


   FUNCTION
    Creates an UTF8 from a string which is encoded in specified
    codeset.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_Source (STRPTR)
        The string which you want to convert. Must be supplied,
        otherwise the functions returns NULL.

      CSA_SourceLen (ULONG)
        Length of CSA_Source or less to convert just a part
        Default: string length of CSA_Source

      CSA_SourceCodeset (struct codeset *)
        The codeset in which the source string is encoded.
        Default: the system's default codeset

      CSA_Dest (STRPTR)
        Destination buffer. If you supply a valid buffer here, you
        must also set CSA_DestLen to the length of your buffer. If
        CSA_AllocIfNeeded is TRUE, CSA_DestLen is checked to see if
        CSA_Dest may contain the whole utf8. If CSA_Dest can't
        contain the utf8, a brand new buffer is allocated. If
        CSA_AllocIfNeeded is FALSE, up to CSA_DestLen (ending '\0'
        included) are written to CSA_Dest. If CSA_DestHook is supplied,
        CSA_Dest is ignored.
        Default: NULL.

      CSA_DestHook (struct Hook *)
        Destination hook. If this is supplied, it is called with a
        partial converted string.

        The hook function should be declared as:

        ULONG ASM SAVEDS fun(REG(a0, struct Hook *hook),
                             REG(a2, struct convertMsg *msg),
                             REG(a1, STRPTR buf))

        struct Hook *hook
          Your hook

        STRPTR buf
          The partial '\0' terminated buffer

        msg->state - one of

          o CSV_Translating
            More calls to came

          o CSV_End
            Last call

        msg->Len
          length of string 'buf'

        You may define the min length of the buffer via CSA_DestLen.
        If so, accepted values are 16<=v<=sizeof_codeset_buffer.

        Don't count on this size to be fixed, even if you used
        CSA_DestLen !

      CSA_DestLen (ULONG)
        If CSA_DestHook is used, it represents the min length of the
        buffer that causes hook calls. Otherwise it is the size of
        the buffer supplied in CSA_Dest. So if CSA_DestHook is
        supplied, CSA_DestLen is optional, otherwise it is required.

      CSA_DestLenPtr (ULONG *)
        If supplied, will contain the length of the utf8 string

      CSA_AllocIfNeeded (BOOL)
        If the destination buffer length is too small to contain
        the UTF8 a new buffer is allocated
        Default: TRUE

      CSA_Pool (APTR)
        If a new destination buffer needs to be allocated (it happens
        if and only if CSA_DestHook is not used, CSA_AllocIfNeeded
        is TRUE, or if CSA_Dest buffer is too small for the utf8) this
        pool is used. The result must be freed via
        CodesetsFreeVecPooledA(pool, utf8, NULL).
        If CSA_Pool is not supplied, the destination buffer is allocated
        from the internal memory pool and must be freed via
        CodesetsFreeA(utf8, NULL).

      CSA_PoolSem (struct SignalSemaphore *)
        A semaphore to lock when using CSA_Pool

   RESULT
    utf8 - the utf8 string or NULL
           If CSA_DestHook is used always NULL.
           If CSA_DestHook is not used NULL means failure
           to allocate mem.

   EXAMPLE
    The shortest invocation is:
    -- cut here --
    UTF8   *utf8;
    STRPTR str;

    if((utf8 = CodesetsUTF8Create(CSA_Source, str,
                                  TAG_DONE)))
    {
        ...

        CodesetsFreeA(utf8,NULL);
    }
    -- cut here --


    In case you want to use your pool to allocate mem:
    -- cut here --
    UTF8   *utf8;
    STRPTR str;
    APTR   pool;

    if((utf8 = CodesetsUTF8Create(CSA_Source,     str,
                                  CSA_Pool,       pool,
                                  TAG_DONE)))
    {
        ...

        CodesetsFreeVecPooledA(pool,utf8,NULL);
    }
    -- cut here --


    If your pool is to be arbitrated via a semaphore:
    -- cut here --
    UTF8   *utf8;
    STRPTR str;
    APTR   pool;
    struct SignalSemaphore *sem;

    if((utf8 = CodesetsUTF8Create(CSA_Source,     str,
                                  CSA_Pool,       pool,
                                  CSA_PoolSem,    sem,
                                  TAG_DONE)))
    {
        ...

        CodesetsFreeVecPooledA(pool,utf8,NULL);
    }
    -- cut here --


    If you want to use your own buffer to reduce mem
    allocation:
    -- cut here --
    UTF8   *utf8;
    STRPTR buf[256];

    if((utf8 = CodesetsUTF8Create(CSA_Source,  str,
                                  CSA_Dest,    buf,
                                  CSA_DestLen, sizeof(buf),
                                  TAG_DONE)))
    {
        ...

        if(utf8 != buf)
          CodesetsFreeA(utf8,NULL);
    }
    -- cut here --


    If your string are max MAXLEN chars long (e.g. image to be
    in a MUI application and you know the max size of your
    string gadgets), you should better supply your own buffer:
    -- cut here --
    UTF8   *utf8;
    STRPTR buf[MAXSIZE*6+1];

    if((utf8 = CodesetsUTF8Create(CSA_Source, str,
                                  CSA_Dest,   buf,
                                  CSA_Dest,   sizeof(buf),
                                  TAG_DONE)))
    {
        ...
    }
    -- cut here --


    If you strings are very large and so you are sure there is
    no mem for them and or you have your own reasons to do
    that:
    -- cut here --
    static ULONG ASM SAVEDS
    destFun(REG(a0, struct Hook *hook),
            REG(a2, struct convertMsg *msg),
            REG(a1, STRPTR buf))
    {
      printf("[%3ld] [%s]\n",msg->len,buf);
      if(msg->state == CSV_End)
        printf("\n");

      return 0;
    }

    struct Hook dest;
    dest.h_Entry = (HOOKFUNC)destFun;

    CodesetsUTF8Create(CSA_Source,    str,
                       CSA_DestHook,  &dest,
                       TAG_DONE);
    -- cut here --

   SEE ALSO
    codesets.library/CodesetsUTF8ToStrA
    codesets.library/CodesetsUTF8Len

codesets.library/CodesetsUTF8ToStrA

   NAME
    CodesetsUTF8ToStrA - converts an UTF8 encoded string into
                         a specified destination codeset.


   SYNOPSIS
    str = CodesetsUTF8ToStrA(attrs);
    D0                       A0

    STRPTR CodesetsUTF8ToStrA(attrs);

    str = CodesetsUTF8ToStr(tag1, ...);
    D0                      A0

    STRPTR CodesetsUTF8ToStr(Tag,...);


   FUNCTION
    Convert an utf8 string to a specified codeset.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_Source (STRPTR)
        The string which you want to convert. Must be supplied,
        otherwise the functions returns NULL.

      CSA_SourceLen (ULONG)
        Length of CSA_Source. Must be > 0 or the function returns
        NULL.
        Default: string length of CSA_Source - strlen()

      CSA_Dest (STRPTR)
        Destination buffer. If you supply a valid buffer here, you
        must also set CSA_DestLen to the length of your buffer. If
        CSA_AllocIfNeeded is TRUE, CSA_DestLen is checked to see if
        CSA_Dest may contain the whole converted string. If CSA_Dest
        can't contain the output string, a brand new buffer is allocated.
        If CSA_AllocIfNeeded is FALSE, up to CSA_DestLen (ending '\0'
        included) are written to CSA_Dest. If CSA_DestHook is supplied,
        CSA_Dest is ignored.
        Default: NULL.

      CSA_DestCodeset (struct codeset *)
        The codeset to which the UTF8 string should be encoded to.
        Default: the system's default codeset

      CSA_DestHook (struct Hook *)
        Destination hook. If this is supplied, it is called with a
        partial converted string.

        The hook function should be declared as:

        ULONG ASM SAVEDS fun(REG(a0, struct Hook *hook),
                             REG(a2, struct convertMsg *msg),
                             REG(a1, STRPTR buf))

        struct Hook *hook
          Your hook

        STRPTR buf
          The partial '\0' terminated buffer

        msg->state - one of

          o CSV_Translating
            More calls to came

          o CSV_End
            Last call

        msg->Len
          length of string 'buf'

        You may define the min length of the buffer via CSA_DestLen.
        If so, accepted values are 16<=v<=sizeof_codeset_buffer.

        Don't count on this size to be fixed, even if you used
        CSA_DestLen !

      CSA_DestLen (ULONG)
        If CSA_DestHook is used, it represents the min length of the
        buffer that causes hook calls. Otherwise it is the size of
        the buffer supplied in CSA_Dest. So if CSA_DestHook is
        supplied, CSA_DestLen is optional, otherwise it is required.

      CSA_DestLenPtr (ULONG *)
        If supplied, will contain the length of the converted string.

      CSA_AllocIfNeeded (BOOL)
        If the destination buffer length is too small to contain
        the output string, a new buffer is allocated.
        Default: TRUE

      CSA_Pool (APTR)
        If a new destination buffer needs to be allocated (it happens
        if and only if CSA_DestHook is not used, CSA_AllocIfNeeded
        is TRUE, or if CSA_Dest buffer is too small for the utf8) this
        pool is used. The result must be freed via
        CodesetsFreeVecPooledA(pool, string, NULL).
        If CSA_Pool is not supplied, the destination buffer is allocated
        from the internal memory pool and must be freed via
        CodesetsFreeA(string, NULL).

      CSA_PoolSem (struct SignalSemaphore *)
        A semaphore to lock when using CSA_Pool

      CSA_ErrPtr (int *)
        Pointer to an integer variable which will be filled with the
        number of found issues (number of not convertable chars)
        Default: NULL

      CSA_MapForeignChars (BOOL)
        If a character of the source string cannot be directly mapped
        to the destination codeset a "?" character will normally be used
        to signal this case. If this attribute is set, an internal
        replacement table will be used which tries to replace these
        "foreign" characters by "looklike" ASCII character sequences.
        Please note, that this functionality is mostly just usable by
        Latin users due to the straight mapping to ASCII (7bit).
        Default: FALSE

      CSA_MapForeignCharsHook (struct Hook *)
        If a character of the source string cannot be directly mapped
        to the destination codeset a "?" character will normally be used
        to signal this case. By using this attribute, a hook can be
        supplied which is called for every such foreign character.
        Within this hook the UTF8 sequence is supplied which cannot be
        directly mapped to the destination codeset. During the execution
        of the hook a replacement string might be specified, which in turn
        will be used by the internals of codesets.library to map this
        "foreign" char to a difference character or UTF8 sequence.

        If both, CSA_MapForeignChars and CSA_MapForeignCharsHook, are
        specified the hook will only be executed in case the internal
        routines don't supply an own mapping for the foreign UTF8 sequence.

        The hook function should be declared as:

        ULONG ASM SAVEDS fun(REG(a0, struct Hook *hook),
                             REG(a2, struct replaceMsg *msg),
                             REG(a1, void *dummy))

        struct Hook *hook
          Your hook

        msg->dst
          place your desired replacement string here

        msg->src
          the UTF8 sequence to be replaced, this string is READ-ONLY!

        msg->srclen
          the length of the UTF8 sequence to be replaced, do NOT peek
          beyond this limit.

        The return value of this hook function is the length of the replacement
        string. Return zero if no replacement did happen. Positive values will
        be treated as lengths of ASCII strings. Negative values signals a
        replacement by another UTF8 sequence. Please note, that in case you
        supply a UTF8 sequence as a replacement for the "foreign" UTF8, your
        hook might be called again if this sequence can still not be mapped to
        the destination codesets, thus is again a "foreign" sequence.


   RESULT
    str - the string or NULL
          If CSA_DestHook is used always NULL.
          If CSA_DestHook is not used NULL means failure
          to allocate mem.

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8Len

codesets.library/CodesetsUTF8Len

   NAME
    CodesetsUTF8Len - returns the length of a supplied utf8 string.

   SYNOPSIS
    len = CodesetsUTF8Len(utf8);
    D0                    A0

    ULONG CodesetsUTF8Len(UTF8 *);

   FUNCTION
    Returns the amount of real characters stored in a supplied UTF8
    string. This is _NOT_ the space required to store the UTF8 string,
    it is the actual number of _real_ character the UTF8 represents.

   INPUTS
    utf8 - pointer to the UTF8 string generated by the internal
           functions of codesets.library

   RESULT
    len - length of utf8

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8ToStrA

codesets.library/CodesetsIsValidUTF8

   NAME
    CodesetsIsValidUTF8 - tells if a supplied standard string is meant to
                          carry a perfectly valid UTF8 sequence

   SYNOPSIS
    result = CodesetsIsValidUTF8(str);
    D0                           A0

    BOOL CodesetsIsValidUTF8(STRPTR);

   FUNCTION
    Returns TRUE in case the supplied string only contains char sequences
    which are compatible to the UTF8 standard.

   INPUTS
    str - a standard STRPTR string.

   RESULT
    result - TRUE in case the string conatins valid UTF8 data.

   NOTE
    This function uses the common 'GOOD_UCS' macro together with parsing
    the whole string. This means that it will only return TRUE in case
    the supplied string only contains UTF8 sequences. A mixture of UTF8
    and non-UTF8 sequences will result in the function returning FALSE.

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8ToStrA

codesets.library/CodesetsIsLegalUTF8

   NAME
    CodesetsIsLegalUTF8 - check a UTF8 sequence

   SYNOPSIS
    res = CodesetsIsLegalUTF8(source, length);
                              A0      D0

    ULONG CodesetsIsLegalUTF8(UTF8 *, ULONG);


   FUNCTION
    Checks if source is a valid UTF8 sequence generated
    by the internal functions of codesets.library

   INPUTS
    source - the char sequence to check
    length - size of source

   RESULT
    res - TRUE or FALSE

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8ToStrA

codesets.library/CodesetsIsLegalUTF8Sequence

   NAME
    CodesetsIsLegalUTF8Sequence - check a char sequence

   SYNOPSIS
    res = CodesetsIsLegalUTF8Sequence(source, end);
                                      A0      A1

    ULONG CodesetsIsLegalUTF8(UTF8 *, UTF8 *);

   FUNCTION
    Check if source is a valid UTF8 sequence within the
    source and end boundaries.

   INPUTS
    source - the char sequence to check
    end - pointer to the end of the sequence to check

   RESULT
    res - TRUE or FALSE

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA
    codesets.library/CodesetsUTF8ToStrA

codesets.library/CodesetsStrLenA

   NAME
    CodesetsStrLenA - returns the length of the source string
                      in case it will be converted to an UTF8
                      string.

   SYNOPSIS
    len = CodesetsStrLenA(str, attrs)
                          A0   A1

    ULONG CodesetsStrLenA(STRPTR, struct TagItem *);

    len = CodesetsStrLen(str, tag1, ...);
                         A0   A1

    ULONG CodesetsStrLen(STRPTR, Tag, ...);

   FUNCTION
    Return the length (size) of str in case it will be converted to
    an UTF8 compliant string.

   INPUTS
    str - the string to obtain length of
    attrs - a list of additional tag items. Valid items are:

      CSA_SourceCodeset (struct codeset *)
        The codeset the source string is encoded in.
        Default: the system's default codeset

      CSA_SourceLen (ULONG)
        The length of str
        Default: string length of CSA_Source

   RESULT
    len - the length of the string if it will be converted to
          an UTF8 string.

   SEE ALSO
    codesets.library/CodesetsUTF8CreateA

codesets.library/CodesetsConvertUTF16toUTF32

   NAME
    CodesetsConvertUTF16toUTF32 - converts from UTF16 to UTF32

   SYNOPSIS
    res = CodesetsConvertUTF16toUTF32(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF16toUTF32(const UTF16 **,const UTF16 *,UTF32 **,UTF32 *,ULONG);

   FUNCTION
    Converts UTF16 to UTF32.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsConvertUTF16toUTF8

   NAME
    CodesetsConvertUTF16toUTF8 - converts from UTF16 to UTF8

   SYNOPSIS
    res = CodesetsConvertUTF16toUTF8(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF16toUTF8(const UTF16 **,const UTF16 *,UTF8 **,UTF8 *,ULONG);

   FUNCTION
    Converts UTF16 to UTF8.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsConvertUTF32toUTF16

   NAME
    CodesetsConvertUTF32toUTF16 - converts from UTF32 to UTF16

   SYNOPSIS
    res = CodesetsConvertUTF32toUTF16(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF32toUTF16(const UTF32 **,const UTF32 *,UTF16 **,UTF16 *,ULONG);

   FUNCTION
    Converts UTF32 to UTF16.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsConvertUTF32toUTF8

   NAME
    CodesetsConvertUTF32toUTF8 - converts from UTF32 to UTF8

   SYNOPSIS
    res = CodesetsConvertUTF32toUTF8(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF32toUTF8(const UTF32 **,const UTF32 *,UTF8 **,UTF8 *,ULONG);

   FUNCTION
    Converts UTF32 to UTF16.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsConvertUTF8toUTF16

   NAME
    CodesetsConvertUTF8toUTF16 - converts from UTF8 to UTF16

   SYNOPSIS
    res = CodesetsConvertUTF8toUTF16(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF8toUTF16(const UTF8 **,const UTF8 *,UTF16 **,UTF16 *,ULONG);

   FUNCTION
    Converts UTF8 to UTF16.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsConvertUTF8toUTF32

   NAME
    CodesetsConvertUTF8toUTF32 - converts from UTF8 to UTF32

   SYNOPSIS
    res = CodesetsConvertUTF8toUTF32(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF8toUTF32(const UTF8 **,const UTF8 *,UTF32 **,UTF32 *,ULONG);

   FUNCTION
    Converts UTF8 to UTF32.

   INPUTS

   RESULT

   SEE ALSO

codesets.library/CodesetsDecodeB64A

   NAME
    CodesetsDecodeB64A - decodes a supplied base64 encoded string
                         or file into plain text charwise.

   SYNOPSIS
    res = CodesetsDecodeB64A(attrs);
    D0                       A0

    ULONG CodesetsDecodeB64A(struct TagItem *);

    res = CodesetsDecodeB64(tag1, ...);
    D0                      A0

    ULONG CodesetsDecodeB64A(Tag, ....);

   FUNCTION
    Decodes a string or a complete base64 encoded file to a
    plain text buffer or also a destination file

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_B64SourceString (STRPTR)
        The source string to decode

      CSA_B64SourceLen (ULONG)
        The length of CSA_B64SourceString Must be supplied if
        CSA_B64SourceString is used.

      CSA_B64SourceFile (STRPTR)
        Source file name.

      CSA_B64DestPtr (STRPTR *)
        Destination buffer pointer. Set to the allocated buffer.
        Must be supplied if CSA_B64DestFile is not used. To
        free the buffer use CodesetsFreeA().

      CSA_B64DestFile (STRPTR)
        Destination file name. Must be supplied if
        CSA_B64DestPtr is used.

      CSA_B64FLG_NtCheckErr (BOOL)
        Don't stop on error.

   RESULT
    res - result, one of (if 0 OK, if >0 error)
        CSR_B64_ERROR_OK
        CSR_B64_ERROR_MEM
        CSR_B64_ERROR_DOS
        CSR_B64_ERROR_INCOMPLETE
        CSR_B64_ERROR_ILLEGAL

   NOTE
    It fully operates charwise and doesn't take respect of the
    individual codeset the decoded data may be still be encoded to.

   SEE ALSO
    codesets.library/CodesetsEncodeB64A

codesets.library/CodesetsEncodeB64A

   NAME
    CodesetsEncodeB64A - encodes a string or whole file
                         to base64

   SYNOPSIS
    res = CodesetsEncodeB64A(attrs);
    D0                       A0

    ULONG CodesetsEncodeB64A(struct TagItem *);

    res = CodesetsEncodeB64(tag1, ...);
    D0                      A0

    ULONG CodesetsEncodeB64(Tag, ....);

   FUNCTION
    Encodes the supplied string or file to either a whole
    buffer or also to a file.

   INPUTS
    attrs - a list of mandatory tag items. Valid items are:

      CSA_B64SourceString (STRPTR)
        The source string to encode

      CSA_B64SourceLen (ULONG)
        The length of CSA_B64SourceString. Must be supplied if
        CSA_B64SourceString is used.

      CSA_B64SourceFile (STRPTR)
        Source file name.

      CSA_B64DestPtr (STRPTR *)
        Destination buffer pointer. Set to the allocated buffer.
        Must be supplied if CSA_B64DestFile is not used. To
        free the buffer use CodesetsFreeA().

      CSA_B64DestFile (STRPTR)
        Destination file name. Must be supplied if
        CSA_B64DestPtr is used.

      CSA_B64MaxLineLen (ULONG)
        Maximum length of encoded lines. 0<v<256
        Default: 72

      CSA_B64Unix (ULONG)
        If TRUE eol is \n (LF), otherwise \r\n (CRLF).
        Default: TRUE

   RESULT
    res - result, one of (if 0 OK, if >0 error)
        CSR_B64_ERROR_OK
        CSR_B64_ERROR_MEM
        CSR_B64_ERROR_DOS
        CSR_B64_ERROR_INCOMPLETE
        CSR_B64_ERROR_ILLEGAL

   NOTE
    It fully operates charwise and doesn't take respect of the
    individual codeset the decoded data may be encoded to.

   SEE ALSO
    codesets.library/CodesetsDecodeB64A

