/*
    Copyright © 1995-2001, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Function Archive for MathIeeeSingTrans.library
    Lang: english
*/
#Archive
#Header
#include <aros/libcall.h>
#include <proto/mathieeesingbas.h>
#include <proto/mathieeesingtrans.h>
#include <proto/exec.h>
#include <exec/types.h>
#include "mathieeesingtrans_intern.h"
#include <libraries/mathieeesp.h>
#/Header


#Function float IEEESPAcos
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 20
#AutoDoc
    FUNCTION
      Calculate arcuscos of the given number

    RESULT

      IEEE single precision floating point number


      flags:
      zero     : result is zero
      negative : 0 (not possible)
      overflow : y &lt; -1  or  y &gt; 1

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.

 * ====================================================
*/
  /* 1> |x| >= 0.5 */
  LONG z,p,q,r,w,s,c,ix,df;
  ix = y & (IEEESPMantisse_Mask | IEEESPExponent_Mask); /* ix = |y|  */

  z = IEEESPCmp(ix,one);

   if (1==z) /* |y| > 1 */
   {
     SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
     return 0x7fffffff;
   }

   if (0==z) /* |y| = 1 */
   {
     if (y & IEEESPSign_Mask) /* y = -1 */
       return pi;
     SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
     return 0;
   }

  /* error: 1 ulp (unit in the last place) */
  if (-1 == IEEESPCmp(ix,onehalf)) /* |fnum1| < 0.5 */
  {
    z = IEEESPMul(y, y);
    p = IEEESPMul(z, IEEESPAdd(pS0,
        IEEESPMul(z, IEEESPAdd(pS1,
        IEEESPMul(z, IEEESPAdd(pS2,
        IEEESPMul(z, IEEESPAdd(pS3,
        IEEESPMul(z, IEEESPAdd(pS4,
        IEEESPMul(z, pS5)))))))))));
    q = IEEESPAdd(one,
        IEEESPMul(z, IEEESPAdd(qS1,
        IEEESPMul(z, IEEESPAdd(qS2,
        IEEESPMul(z, IEEESPAdd(qS3,
        IEEESPMul(z, qS4))))))));
    r = IEEESPDiv(p, q);
    return (IEEESPSub(pio2,IEEESPAdd(y,IEEESPMul(y,r))));
  }

  /* error: 1 ulp */
  if (y & IEEESPSign_Mask) /* y < -0.5 */
  {
    z = IEEESPMul(onehalf, IEEESPAdd(one, y));
    p = IEEESPMul(z, IEEESPAdd(pS0,
        IEEESPMul(z, IEEESPAdd(pS1,
        IEEESPMul(z, IEEESPAdd(pS2,
        IEEESPMul(z, IEEESPAdd(pS3,
        IEEESPMul(z, IEEESPAdd(pS4,
        IEEESPMul(z, pS5)))))))))));
    q = IEEESPAdd(one,
        IEEESPMul(z, IEEESPAdd(qS1,
        IEEESPMul(z, IEEESPAdd(qS2,
        IEEESPMul(z, IEEESPAdd(qS3,
        IEEESPMul(z, qS4))))))));
    s = IEEESPSqrt(z);
    r = IEEESPDiv(p,q); /* r = p/q; */
    w = IEEESPMul(r,s);
    return IEEESPSub(pi, IEEESPMul(two, IEEESPAdd(s, w)));
  }

  /* fnum1 > 0.5 */
  /* error : 1 ulp */
  z = IEEESPMul(onehalf, IEEESPSub(one, y));
  s = IEEESPSqrt(z);
  df = s;
  //df = df & 0xfff000ff;
  c = IEEESPDiv(IEEESPSub(z, IEEESPMul(df,df)), IEEESPAdd(df,s) );
  p = IEEESPMul(z, IEEESPAdd(pS0,
      IEEESPMul(z, IEEESPAdd(pS1,
      IEEESPMul(z, IEEESPAdd(pS2,
      IEEESPMul(z, IEEESPAdd(pS3,
      IEEESPMul(z, IEEESPAdd(pS4,
      IEEESPMul(z, pS5)))))))))));
  q = IEEESPAdd(one,
      IEEESPMul(z, IEEESPAdd(qS1,
      IEEESPMul(z, IEEESPAdd(qS2,
      IEEESPMul(z, IEEESPAdd(qS3,
      IEEESPMul(z, qS4))))))));
  r = IEEESPDiv(p, q);
  w = IEEESPAdd(c, IEEESPMul(r,s));
  return IEEESPMul(two, IEEESPAdd(df,w));
#/Code
#/Function


#Function float IEEESPAsin
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 19
#AutoDoc
    FUNCTION
      Calculate arcussin of the given number

    RESULT
      IEEE single precision floating point number


      flags:
        zero     : result is zero
        negative : result is negative
        overflow : fnum &lt; -1  or  fnum &gt; 1

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.

 * ====================================================
*/

  /* 1> |x| >= 0.5 */
  LONG t,w,p,q,c,r,s,ix;
  ix = y & (IEEESPMantisse_Mask | IEEESPExponent_Mask); /* ix = |fnum| */

  if (one == ix) /* |y| = 1 -> result = +-(pi/2) */
    return (pio2 | (y & IEEESPSign_Mask  ));

  if (1 == IEEESPCmp(ix,one)) /* |y| > 1 */
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return 0x7fffffff;
  }

  /* error: 1 ulp (unit in the last place)*/
  if ( -1 == IEEESPCmp(ix, onehalf)) /* |y| < 0.5 */
  {
    t = IEEESPMul(y, y);
    p = IEEESPMul(t, IEEESPAdd(pS0,
        IEEESPMul(t, IEEESPAdd(pS1,
        IEEESPMul(t, IEEESPAdd(pS2,
        IEEESPMul(t, IEEESPAdd(pS3,
        IEEESPMul(t, IEEESPAdd(pS4,
        IEEESPMul(t, pS5) ))))))))));
    q = IEEESPAdd(one,
        IEEESPMul(t, IEEESPAdd(qS1,
        IEEESPMul(t, IEEESPAdd(qS2,
        IEEESPMul(t, IEEESPAdd(qS3,
        IEEESPMul(t, qS4))))))));
    w = IEEESPDiv(p, q);
    return IEEESPAdd(y, IEEESPMul(y, w));
  }


  w = IEEESPSub(one, ix) ; /* w = 1 - fnum ; y = 1-x */
  t = IEEESPMul(w, onehalf);  /* t = w / 2    ; z = y/2 */
  p = IEEESPMul(t,IEEESPAdd(pS0,
      IEEESPMul(t,IEEESPAdd(pS1,
      IEEESPMul(t,IEEESPAdd(pS2,
      IEEESPMul(t,IEEESPAdd(pS3,
      IEEESPMul(t,IEEESPAdd(pS4,
      IEEESPMul(t,pS5)))))))))));
  q = IEEESPAdd(one,
      IEEESPMul(t,IEEESPAdd(qS1,
      IEEESPMul(t,IEEESPAdd(qS2,
      IEEESPMul(t,IEEESPAdd(qS3,
      IEEESPMul(t,qS4))))))));
  s = IEEESPSqrt(t);      /* s = sqrt(t)  ; s = sqrt(z) */

  if(1 == IEEESPCmp(ix, 0x3f79999a /*0.975*/ )) /* |fnum| > 0.975 */
  {
    /*error: 2 ulp (4 ulp when |fnum| close to 1) */
    w = IEEESPDiv(p, q); /* w = p / q; */
    /* res = pi/2-(2*(s+s*w)) */
    t = IEEESPSub(pio2, IEEESPMul(two,IEEESPAdd(s,IEEESPMul(s,w))));
  }
  else
  {
    /* error: 2 ulp */
    w = s;
    c = IEEESPDiv(IEEESPSub(t,IEEESPMul(w,w)),IEEESPAdd(s,w)); /* c=(t-w*w)/(s+w) */
    r = IEEESPDiv(p,q);
    p = IEEESPAdd(IEEESPAdd(c,c),IEEESPMul(IEEESPAdd(s,s),r));
    q = IEEESPSub(pio4, IEEESPAdd(w,w));
    t = IEEESPSub(pio4, IEEESPSub(p,q));

   }
   return (t | (y & IEEESPSign_Mask )) ;
#/Code
#/Function


#Function float IEEESPAtan
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 5
#AutoDoc
    FUNCTION
      Calculates the angle of a given number representing the tangent
      of that angle. The angle will be in radians.


    RESULT
      IEEE single precision floating point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
{
  LONG yabs = y & (IEEESPMantisse_Mask | IEEESPExponent_Mask);
  LONG ysquared, ycubed;

  /* check for +- infinity -> output: +-pi/2 */
  if (IEEESP_Pinfty == yabs )
    return (pio2 | (y & IEEESPSign_Mask));

  /* atan(0) = 0 */
  if (0 == yabs)
  {
     SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
     return 0;
  }

  /* atan(x >= 128) = pi/2 - 1/x */
  if ( (yabs & IEEESPExponent_Mask) >= 0x43000000)
  {
    if (yabs == y) /* arg has ppositive sign */
    {
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);
      return IEEESPSub(pio2,IEEESPDiv(one,yabs));
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return (IEEESPSub(pio2,IEEESPDiv(one,yabs))) | IEEESPSign_Mask;
    }
  }

  /* atan(x >= 64) = pi/2 - 1/x +1/(3*x^3) */

  ysquared = IEEESPMul(yabs, yabs);

  if( (yabs & IEEESPExponent_Mask) >= 0x42000000)
  {
    ycubed   = IEEESPMul(yabs, ysquared);

    /* pi/2 - 1/x + 1/(3*x^3) = pi/2 + (1-3*x^2)/(3*x^3)*/
    if (yabs == y) /* arg has positive sign */
    {
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);
      return IEEESPAdd(pio2,
              IEEESPDiv(
              IEEESPAdd(IEEESPMul(three, ysquared) | IEEESPSign_Mask, one ),
              IEEESPMul(three, ycubed)
                       ));
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return IEEESPAdd(pio2,
              IEEESPDiv(
              IEEESPAdd(IEEESPMul(three, ysquared) | IEEESPSign_Mask, one ),
              IEEESPMul(three, ycubed)
                       )) | IEEESPSign_Mask;
    }
  }

  /* atan(x <= 64) */
  return IEEESPAsin(IEEESPDiv(y,IEEESPSqrt(IEEESPAdd(one,ysquared))));

} /* IEEESPAtan */
#/Code
#/Function


#Function float IEEESPCos
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 7
#AutoDoc
    FUNCTION
      Calculate the cosine of a given IEEE single precision number in radians

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
	Algorithm for Calculation of cos(y):
	<code>
	 z    = floor ( |y| / pi );
         y_1  = |y| - z * pi;        => 0 <= y_1 < pi

         if (y_1 > pi/2 ) then y_1 = pi - y_1;

         => 0 <= y_1 < pi/2

         Res = 1 - y^2/2! + y^4/4! - y^6/6! + y^8/8! - y^10/10! =
             = 1 -(y^2(-1/2!+y^2(1/4!+y^2(-1/6!+y^2(1/8!-1/10!y^2)))));

         if (z was an odd number)
           Res = -Res;

         if (y_1 was greater than pi/2 in the test above)
           Res = -Res;
      </code>


    HISTORY

#/AutoDoc
#Code
  LONG z,Res,ysquared,yabs,tmp;
  yabs = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask);

  if (IEEESP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return IEEESP_NAN;
  }

  z = IEEESPFloor(IEEESPDiv(yabs, pi));
  tmp  = IEEESPMul(z,pi);
  tmp |= IEEESPSign_Mask; /* tmp = -tmp; */
  yabs = IEEESPAdd(yabs, tmp);
  if (yabs > pio2)
  {
    yabs |= IEEESPSign_Mask;
    yabs  =IEEESPAdd(pi, yabs);
    tmp = TRUE;
  }
  else
    tmp = FALSE;

  ysquared = IEEESPMul(yabs,yabs);
  Res = IEEESPAdd(cosf1,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf2,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf3,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf4,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf5,
        IEEESPMul(ysquared, cosf6))))))))));

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (TRUE == intern_IEEESPisodd(z))
    Res ^= IEEESPSign_Mask;

  if (TRUE == tmp)
    Res ^= IEEESPSign_Mask;

  if (Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPCosh
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 11
#AutoDoc
    FUNCTION
      Calculate the hyperbolic cosine of the IEEE single precision number

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : 0 (not possible)
        overflow : result too big for ffp-number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      <code>
      cosh(x) = (1/2)*( e^x + e^(-x) )

      cosh( |x| >= 9  ) = (1/2) * (e^x);
      </code>

    HISTORY

#/AutoDoc
#Code
LONG Res;
  /* cosh(-x) = cosh(x) */
  y &= ( IEEESPMantisse_Mask + IEEESPExponent_Mask );

  if ( IEEESP_Pinfty == y)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return y;
  }

  Res = IEEESPExp(y);

  if ( IEEESP_Pinfty == Res )
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0x7f000000; /* Res; */
  }

  if ( y < 0x41100000  )
    Res = IEEESPAdd(Res, IEEESPDiv(one, Res));

  /* Res = Res / 2 */
  Res -= 0x00800000;

  if ( 0 == Res || Res < 0 )
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }
  return Res;
#/Code
#/Function


#Function float IEEESPExp
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 13
#AutoDoc
    FUNCTION
      Calculate e^x

    RESULT
      IEEE single precision number

      flags:
        zero     : result is zero
        negative : 0
        overflow : the result was out of range for the IEEE single precision
                   format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      <code>
      e^(>= 89): return 0x7f800000;
      e^(2^(<=-24)): return one;
      </code>

    HISTORY

#/AutoDoc
#Code
const LONG ExpTable[] =
    { 0x6da12cc2,  /* e^64  */
      0x568fa1fe,  /* e^32  */
      0x4b07975e,  /* e^16  */
      0x453a4f53,  /* e^8   */
      0x425a6481,  /* e^4   */
      0x40ec7325,  /* e^2   */
      0x402df854,  /* e^1   */
      0x3fd3094c,  /* e^(1/2) */
      0x3fa45af2,  /* e^(1/4) */
      0x3f910b02,  /* e^(1/8) */
      0x3f88415b,  /* e^(1/16) */
      0x3f84102b,  /* e^(1/32) */
      0x3f820405,  /* e^(1/64) */
      0x3f810101,  /* e^(1/128) */
      0x3f808040,  /* e^(1/256) */
      0x3f804010,  /* e^(1/512) */
      0x3f802004,  /* e^(1/1024) */
      0x3f801001,  /* e^(1/2048) */
      0x3f800800,  /* e^(1/4096) */
      0x3f800400,  /* e^(1/8192) */
      0x3f800200,  /* e^(1/16384) */
      0x3f800100,  /* e^(1/32768) */
      0x3f800080,  /* e^(1/65536) */
      0x3f800040,  /* e^(1/131072) */
      0x3f800020,  /* e^(1/262144) */
      0x3f800010,  /* e^(1/524288) */
      0x3f800008,  /* e^(1/1048576) */
      0x3f800004,  /* e^(1/2097152) */
      0x3f800002,  /* e^(1/4194304) */
      0x3f800001,  /* e^(1/8388608) */
    };
ULONG Res, i;
LONG Mantisse;
char Exponent;


  Exponent = ((y & IEEESPExponent_Mask) >> 23) -0x7f;

  /* e^0 = 1, e^(2^(<=-24)) = 1 */
  if ( 0 == y || Exponent <= -24 )
    return one;

  /* e^(>= 89) = overflow) */
  if (Exponent > 6)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return IEEESP_Pinfty;
  }

  i = 6 - Exponent;

  Mantisse = (y & IEEESPMantisse_Mask) << 9;
  Res = ExpTable[i++];

  while ( 0 != Mantisse && i <= 29 )
  {
    /* is the highest bit set? */
    if ( Mantisse < 0 )
    {
      Res = IEEESPMul(Res, ExpTable[i]);
      if (0 == Res)
      {
        SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }
      if (IEEESP_Pinfty == Res)
      {
        SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }
    }
    i++;
    Mantisse <<= 1;
  }
  if ( y < 0)
    return IEEESPDiv(one, Res);
  return Res;
#/Code
#/Function


#Function float IEEESPFieee
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 18
#AutoDoc
    FUNCTION
        Convert IEEE single to IEEE single
        It just returns the input parameter.

    RESULT
        IEEE single precision floting point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  return y;
#/Code
#/Function


#Function float IEEESPLog
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 14
#AutoDoc
    FUNCTION
      Calculate logarithm (base e) of the given IEEE single precision number

    RESULT
      IEEE single precision number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return 0.
      If the Argument is 0 return 0xffffffff.

      All other cases:

      (ld is the logarithm with base 2)
      (ln is the logarithm with base e)
      y = M * 2^E

      <code>
      ln y = ln ( M * 2^E ) =

           = ln M + ln 2^E =

           = ln M + E * ln (2) =

             ld M        ld 2
           = ----- + E * ----- =      [ld 2 = 1]
             ld e        ld e

             ld M + E
           = --------
             ld e
      </code>

      ld e can be precalculated, of course.
      For calculating ld M see file intern_ieeespld.c

    HISTORY

#/AutoDoc
#Code
  LONG ld_M, Exponent, Mask = 0x40, i, Sign;
  /* check for negative sign */
  if ( y < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* check for argument == 0 or argument == +infinity */
  if (0 == y || IEEESP_Pinfty == y)
    return y;

  /* convert the Exponent of the argument (y) to the ieeesp-format */
  Exponent = ((y & IEEESPExponent_Mask) >> 23) - 0x7e ;

  if (Exponent < 0 )
  {
    Exponent =-Exponent;
    Sign = IEEESPSign_Mask;
  }
  else
    Sign = 0;

  /* find the number of the highest set bit in the exponent */
  if (Exponent != 0)
  {
    i = 0;
    while ( (Mask & Exponent) == 0)
    {
      i ++;
      Mask >>= 1;
    }

  Exponent <<= (17 + i);
  Exponent &= IEEESPMantisse_Mask;
  Exponent |= ((0x85 - i ) << 23);
  Exponent |= Sign;
  }

  ld_M = intern_IEEESPLd( (struct MathIeeeSingTransBase *)
                                                  MathIeeeSingTransBase,
                          (y & IEEESPMantisse_Mask) | 0x3f000000 );

  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld e
  */

  return IEEESPMul( IEEESPAdd(ld_M, Exponent), InvLde);
#/Code
#/Function


#Function float IEEESPLog10
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 21
#AutoDoc
    FUNCTION
      Calculate logarithm (base 10) of the given IEEE single precision number

    RESULT
      IEEE single precision number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return 0.
      If the Argument is 0 return 0xffffffff.

      All other cases:

      (ld is the logarithm with base 2)
      (ln is the logarithm with base e)
      y = M * 2^E

      <code>
      ln y = ln ( M * 2^E ) =

           = ln M + ln 2^E =

           = ln M + E * ln (2) =

             ld M        ld 2
           = ----- + E * ----- =      [ld 2 = 1]
             ld 10       ld 10

             ld M + E
           = --------
             ld 10
      </code>

      ld 10 can be precalculated, of course.
      For calculating ld M see file intern_ieeespld.c

    HISTORY

#/AutoDoc
#Code
  LONG ld_M, Exponent, Mask = 0x40, i, Sign;
  /* check for negative sign */
  if ( y < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  /* check for argument == 0 or argument == +infinity */
  if (0 == y || IEEESP_Pinfty == y)
    return y;

  /* convert the Exponent of the argument (y) to the ieeesp-format */
  Exponent = ((y & IEEESPExponent_Mask) >> 23) - 0x7e ;

  if (Exponent < 0 )
  {
    Exponent =-Exponent;
    Sign = IEEESPSign_Mask;
  }
  else
    Sign = 0;

  /* find the number of the highest set bit in the exponent */
  if (Exponent != 0)
  {
    i = 0;
    while ( (Mask & Exponent) == 0)
    {
      i ++;
      Mask >>= 1;
    }

  Exponent <<= (17 + i);
  Exponent &= IEEESPMantisse_Mask;
  Exponent |= ((0x85 - i ) << 23);
  Exponent |= Sign;
  }

  ld_M = intern_IEEESPLd( (struct MathIeeeSingTransBase *)
                                                  MathIeeeSingTransBase,
                          (y & IEEESPMantisse_Mask) | 0x3f000000 );

  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld 10
  */

  return IEEESPMul( IEEESPAdd(ld_M, Exponent), InvLd10);
#/Code
#/Function


#Function float IEEESPPow
#Parameter float x D1
    IEEE single precision floating point number
#/Parameter
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 15
#AutoDoc
    FUNCTION
      Calculate y raised to the x power (y^x)

    RESULT
      IEEE single precision floating point number


      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  /* a ^ b  = e^(b * ln a )
  ** y ^ x  = e^(x * ln y )
  */
  LONG Res;

  /* y^x is illegal if y<0 and x is not an integer-value */
  if (y < 0 && x != IEEESPCeil(x) )
        return 0;

  Res = IEEESPLog( y & (IEEESPMantisse_Mask + IEEESPExponent_Mask) );
  Res = IEEESPMul(Res, x);
  Res = IEEESPExp(Res);

  /* if y < 0 and x was and even integer, the result is positive, otherwise
  ** it is negative.
  */
  if (y < 0 && TRUE == intern_IEEESPisodd(x) )
    Res |= IEEESPSign_Mask;

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);

  if ( Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  if ( IEEESP_Pinfty == (Res & (IEEESPMantisse_Mask + IEEESPExponent_Mask)) )
    /* don`t touch the Negative_Bit now!*/
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPSin
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 6
#AutoDoc
    FUNCTION
      Calculate the sine of a given IEEE single precision number in radians

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      Algorithm for Calculation of sin(y):
      <code>
         z    = floor ( |y| / pi );
         y_1  = |y| - z * pi;        => 0 <= y_1 < pi

         if (y_1 > pi/2 ) then y_1 = pi - y_1;

         => 0 <= y_1 < pi/2

         Res = y - y^3/3! + y^5/5! - y^7/7! + y^9/9! - y^11/11! =
             = y(1+y^2(-1/3!+y^2(1/5!+y^2(-1/7!+y^2(1/9!-1/11!y^2)))));

         if (y < 0)
           Res = -Res;

         if (z was an odd number)
           Res = -Res;
      </code>

    HISTORY

#/AutoDoc
#Code
LONG z,Res,ysquared,yabs,tmp;
  yabs = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask);

  if (IEEESP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return IEEESP_NAN;
  }

  z = IEEESPFloor(IEEESPDiv(yabs, pi));
  tmp  = IEEESPMul(z,pi);
  tmp |= IEEESPSign_Mask; /* tmp = -tmp; */
  yabs = IEEESPAdd(yabs, tmp);
  if (yabs > pio2)
  {
    yabs |= IEEESPSign_Mask;
    yabs  =IEEESPAdd(pi, yabs);
  }
  ysquared = IEEESPMul(yabs,yabs);
  Res = IEEESPMul(yabs,
        IEEESPAdd(sinf1,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf2,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf3,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf4,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf5,
        IEEESPMul(ysquared, sinf6)))))))))));

  if (y < 0 )
    Res ^= IEEESPSign_Mask;

  if (TRUE == intern_IEEESPisodd(z))
    Res ^= IEEESPSign_Mask;

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPSincos
#Parameter float * z A0
    pointer to an IEEE single precision floating point number
#/Parameter
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 9
#AutoDoc
    FUNCTION
      Calculate the cosine and the sine of the given IEEE single
      precision number where y represents an angle in radians. The 
      function returns the sine of that number as a result and puts
      the cosine of that number into *z which must represent
      a valid pointer to a IEEE single precision number.

    RESULT
      *z            - IEEE single precision floating point number
      direct result - IEEE single precision floating point number


    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  *z = IEEESPCos(y);
  return IEEESPSin(y);
#/Code
#/Function


#Function float IEEESPSinh
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 10
#AutoDoc
    FUNCTION
      Calculate the hyperbolic sine of the IEEE single precision number

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big for IEEE single precsion format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      <code>
      sinh(x) = (1/2)*( e^x- e^(-x) )

      sinh( |x| >=  9 ) = (1/2) * (e^x);
      </code>
    HISTORY

#/AutoDoc
#Code
LONG Res;
LONG y2 = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask);
LONG tmp;

  if ( IEEESP_Pinfty == y2)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return y;
  }

  /* sinh(-x) = -sinh(x) */
  Res = IEEESPExp(y2);

  if ( IEEESP_Pinfty == Res )
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  if ( y2 < 0x41100000 )
  {
    /* the following lines is neccessary or otherwise changes in
    ** the defines/mathieeesing*.h-files would have to be made!
    */
    tmp = IEEESPDiv(one, Res);
    Res = IEEESPAdd(Res, tmp | IEEESPSign_Mask );
  }
  /* Res = Res / 2 */
  Res -= 0x00800000;

  /* at this point Res has to be positive to be valid */
  if ( Res <= 0)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (y & IEEESPSign_Mask);
  }

  if ( y < 0)
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (Res | IEEESPSign_Mask);
  }
  return Res;
#/Code
#/Function


#Function float IEEESPSqrt
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 16
#AutoDoc
    FUNCTION
      Calculate square root of IEEE single precision number

    RESULT
      IEEE single precision number

      flags:
        zero     : result is zero
        negative : 0
        overflow : square root could not be calculated

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:
      <code>
        First check for a zero and a negative argument and take
        appropriate action.
        y = M * 2^E

        Exponent is an odd number:
        y = ( M*2 ) * 2^ (E-1)
        Now E' = E-1 is an even number and
              -> sqrt(y) = sqrt(M)   * sqrt(2)   * sqrt (2^E')
                         = sqrt(M)   * sqrt(2)   * 2^(E'/2)
        (with sqrt(M*2)>1)
                         = sqrt(M)   * sqrt(2)   * 2^(E'/2)
                                                                                     = sqrt(M)   * 1/sqrt(2) * 2^(1+(E'/2))
                         = sqrt(M/2)             * 2^(1+(E'/2))


        Exponent is an even number:
        -> sqrt(y) = sqrt(M) * sqrt (2^E) =
                   = sqrt(M) * 2^(E/2)

        Now calculate the square root of the mantisse.
        The following algorithm calculates the square of a number + delta
        and compares it to the mantisse. If the square of that  number +
        delta is less than the mantisse then keep that number + delta.
        Otherwise calculate a lower offset and try again.
        Start out with number = 0;


        Exponent = -1;
        Root = 0;
        repeat
        {
          if ( (Root + 2^Exponent)^2 < Mantisse)
          Root += 2^Exponent
          Exponent --;
        }
        until you`re happy with the accuracy
      </code>

    HISTORY

#/AutoDoc
#Code
  ULONG Res, ResSquared, Delta, X, TargetMantisse;
  int z;
  ULONG Exponent;

  if (0 == y)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }
  /* is fnum negative? */
  if (y < 0)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return y;
  }

  /* we can calculate the square-root now! */

  TargetMantisse = ((y & IEEESPMantisse_Mask) | 0x00800000) << 8;

  if (y & 0x00800000)
  {
    /* TargetMantisse = TargetMantisse / 2; */
    TargetMantisse >>= 1;
    Exponent = ((y >> 1) & IEEESPExponent_Mask) + 0x20000000;
  }
  else
    Exponent = ((y >> 1) & IEEESPExponent_Mask) + 0x1f800000;


  Res = 0;
  ResSquared = 0;
  z = 0;

  /* this calculates the sqrt of the mantisse. It`s short, isn`t it?
  ** Delta starts out with 0.5, then 0.25, 0.125 etc.
  */
  while (ResSquared != TargetMantisse && z < 25)
  {
    Delta = (0x80000000 >> z);
    /* X = (Res+Delta)^2 =
    **= Res^2      + 2*Res*Delta + Delta^2
    */
    X = ResSquared + (Res >> z)  + (Delta >> ++z);
    if (X <= TargetMantisse)
    {
      Res += Delta;
      ResSquared = X;
    }
  }

  /* an adjustment for precision
  */
  if ((char) Res < 0)
    Res += 0x100;

  Res >>=8;
  Res &= IEEESPMantisse_Mask;
  Res |= Exponent;

  return Res;
#/Code
#/Function


#Function float IEEESPTan
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 8
#AutoDoc
    FUNCTION
      Calculate the tangens of a given IEEE single precision number in radians

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow :

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG z,SIN,Res,ysquared,yabs,tmp;
  yabs = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask);

  if (IEEESP_Pinfty == yabs)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return IEEESP_NAN;
  }

  z = IEEESPFloor(IEEESPDiv(yabs, pi));
  tmp  = IEEESPMul(z,pi);
  tmp |= IEEESPSign_Mask; /* tmp = -tmp; */
  yabs = IEEESPAdd(yabs, tmp);
  if (yabs > pio2)
  {
    yabs |= IEEESPSign_Mask;
    yabs  =IEEESPAdd(pi, yabs);
    tmp = TRUE;
  }
  else
    tmp = FALSE;
  ysquared = IEEESPMul(yabs,yabs);
  SIN = IEEESPMul(yabs,
        IEEESPAdd(sinf1,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf2,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf3,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf4,
        IEEESPMul(ysquared,
        IEEESPAdd(sinf5,
        IEEESPMul(ysquared, sinf6)))))))))));
  /* cos: */
  z   = IEEESPAdd(cosf1,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf2,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf3,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf4,
        IEEESPMul(ysquared,
        IEEESPAdd(cosf5,
        IEEESPMul(ysquared, cosf6))))))))));


  Res = IEEESPDiv(SIN, z);

  if (y < 0 )
    Res ^= IEEESPSign_Mask;

  if (TRUE == tmp)
    Res ^= IEEESPSign_Mask;

  if (0 == Res)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (Res < 0)
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function float IEEESPTanh
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 12
#AutoDoc
    FUNCTION
      Calculate hyperbolic tangens of the IEEE single precision number

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : (not possible)

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

      <code>
                ( e^x - e^(-x) )
     tanh(x) =  ----------------
                ( e^x + e^(-x) )

     tanh( |x| >= 9 ) = 1
      </code>

    HISTORY

#/AutoDoc
#Code
LONG Res;
LONG y2 = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask );
LONG tmp;

  if ( y2 >= 0x41100000 )
  /* tanh( x > 9 ) =  1
  ** tanh( x <-9 ) = -1
  */
    return (one | ( y & IEEESPSign_Mask ));

  /* tanh(-x) = -tanh(x) */
  Res = IEEESPExp(y2);
  tmp = IEEESPDiv(one, Res);
  Res = IEEESPDiv( IEEESPAdd(Res, (tmp | IEEESPSign_Mask) ),
                   IEEESPAdd(Res, tmp) );

  /* Result is zero */
  if (0 == Res )
  {
    if (y < 0)
      SetSR(Zero_Bit | Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    else
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (y & IEEESPSign_Mask);
  }

  /* Argument is negative -> result is negative */
  if ( y < 0)
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return (Res | IEEESPSign_Mask );
  }

  return Res;
#/Code
#/Function


#Function float IEEESPTieee
#Parameter float y D0
    IEEE single precision floating point number
#/Parameter
#LibOffset 17
#AutoDoc
    FUNCTION
        Convert IEEE single to IEEE single
        It just returns the input parameter.

    RESULT
        IEEE single precision floting point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  return y;
#/Code
#/Function

#/Archive

