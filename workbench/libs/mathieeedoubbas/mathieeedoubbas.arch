/*
    Copyright © 1995-2001, The AROS Development Team. All rights reserved.
    $Id$

    Desc: Function Archive for MathIeeeDoubBas.library
    Lang: english
*/
#Archive
#Header
#Local
#include <aros/libcall.h>
#/Local
#include <proto/mathieeedoubbas.h>
#Local
#include <proto/exec.h>
#include <exec/types.h>
#include "mathieeedoubbas_intern.h"
#/Local
#/Header


#Function double IEEEDPAbs
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 9
#AutoDoc
    FUNCTION
      Calculate the absolute value of the given IEEE double precision
      floating point number

    RESULT
	absolute value of y

	Flags:
	  zero	   : result is zero
	  negative : 0
	  overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:
	set the sign-bit to zero

    HISTORY

#/AutoDoc
#Code
    QUAD * Qy = (QUAD *)&y;

    /*if (0 == (*Qy)) */
    if (is_eqC((*Qy),0,0))
    {
      /* value is 0 -> set the Zero Flag */
      SetSR( Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    }
    else
    {
      /* set the sign-bit to zero */
      /* (*Qy) &= (IEEEDPMantisse_Mask | IEEEDPExponent_Mask) */
      AND64QC((*Qy), (IEEEDPMantisse_Mask_Hi | IEEEDPExponent_Mask_Hi),
		     (IEEEDPMantisse_Mask_Lo | IEEEDPExponent_Mask_Lo));
      SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );
    }
    return y;
#/Code
#/Function



#Function double IEEEDPAdd
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#Parameter double z D2/D3
    IEEE double precision floting point number
#/Parameter
#LibOffset 11
#AutoDoc
    FUNCTION
        Calculate the sum of two IEEE double precision numbers

    RESULT
        sum of y and z

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : result is too large or too small for ffp format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  QUAD Res;
  QUAD Mant1, Mant2;
  QUAD Qtmp1, Qtmp2;
  LONG Shift;
  QUAD Exponent;
  LONG Ltmp1, Ltmp2;
  QUAD * Qy = (QUAD *)&y;
  QUAD * Qz = (QUAD *)&z;
  double * DRes = (double *)&Res;

  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  AND64C(Qtmp1, *Qy, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo);
  AND64C(Qtmp2, *Qz, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo);
  SHRU32(Ltmp1, Qtmp1, 52);
  SHRU32(Ltmp2, Qtmp2, 52);
  Shift = Ltmp1 - Ltmp2;

  if (is_neqC(*Qy, 0x0, 0x0) &&
      is_neqC(*Qy, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) )
  {
    AND64C(Mant1, *Qy, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
    OR64QC(Mant1, 0x00100000, 0x00000000);
  }
  else
  {
    Set_Value64C(Mant1, 0x0, 0x0);
  }

  if (is_neqC(*Qz, 0x0, 0x0) &&
      is_neqC(*Qz, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) )
  {
    /* Mant2 = (*Qz & IEEESPMantisse_Mask) | 0x00800000; */
    AND64C(Mant2, *Qz, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
    OR64QC(Mant2, 0x00100000, 0x00000000);
  }
  else
  {
    Set_Value64C(Mant2, 0x0, 0x0);
  }

  if (Shift > 0)
  {
    SHRU64(Mant2, Mant2, Shift);
    AND64C(Exponent, *Qy, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo);
  }
  else
  {
    SHRU64(Mant1, Mant1, (-Shift));
    AND64C(Exponent, *Qz, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo);
  }

  // sign(fnum1) == sign(fnum2)
  // simple addition
  // 0.25 <= res < 1
  AND64C(Qtmp1, *Qz, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
  AND64C(Qtmp2, *Qy, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
  if ( is_eq(Qtmp1, Qtmp2))
  {
    AND64C(Res, *Qy, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    ADD64Q(Mant1, Mant2);
    AND64C(Qtmp1, Mant1, 0x00200000, 0x0);
    if ( is_neqC(Qtmp1, 0x0, 0x0))
    {
        ADD64QC(Exponent, 0x00100000, 0x0);
        SHRU64(Mant1, Mant1, 1);
    }
    AND64QC(Mant1, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
  }
    // second case: sign(fnum1) != sign(fnum2)
    // -1 <= res < 1
  else
  {
    //printf("Exponent: %x\n",Exponent);
    if ( is_lessSC(*Qy, 0x0, 0x0))
    {
      SUB64(Mant1, Mant2, Mant1);
    }
    else // fnum2 < 0
    {
      SUB64(Mant1, Mant1, Mant2);
    }

    //if the result is below zero
    if (  is_lessSC(Mant1, 0x0, 0x0))
    {
      Set_Value64C(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
      NEG64(Mant1);
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    }
    else
      Set_Value64C(Res, 0x0, 0x0);

    if (is_eqC(Mant1, 0x0, 0x0))
    {
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      Set_Value64C(Res, 0x0, 0x0);
      return *(double *)&Res;
    }
    else
    {
      /* normalize the mantisse */
      AND64C(Qtmp1, Mant1, 0x00100000, 0x0);
      while ( is_eqC(Qtmp1, 0x0, 0x0))
      {
        SHL64(Mant1, Mant1, 1);  //one bit to the left.
        SUB64QC(Exponent, 0x00100000, 0x0);
        AND64C(Qtmp1, Mant1, 0x00100000, 0x0);
      }
      AND64QC(Mant1, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
    } /* else */

  } /* else */

  if ( is_lessSC(Exponent, 0x0, 0x0))
  {
    SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit); //do not change Negative_Bit!
    OR64QC(Res, (IEEEDPMantisse_Mask_Hi | IEEEDPExponent_Mask_Hi),
                (IEEEDPMantisse_Mask_Lo | IEEEDPExponent_Mask_Lo));
  }
  OR64Q(Res, Mant1);
  OR64Q(Res, Exponent);
  return *DRes;
#/Code
#/Function


#Function double IEEEDPCeil
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 16
#AutoDoc
    FUNCTION
        Calculates the ceil-value of a IEEE double precision number

    RESULT
        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO
        IEEEDPFloor()

    INTERNALS
      ALGORITHM:
         Ceil(y) = - Floor(-y)

    HISTORY

#/AutoDoc
#Code
  QUAD * Qy = (QUAD *)&y;

  if (is_eqC((*Qy),0,0))
  {
    SetSR(Zero_Bit, Negative_Bit|Overflow_Bit|Zero_Bit);
    return y;
  }

  XOR64QC((*Qy), IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
  /* Ceil(y) = -Floor(-y); */
  y = IEEEDPFloor(y);
  if (is_eqC((*Qy), 0x0, 0x0))
  {
    Set_Value64C((*Qy), 0, 0);
    return y;
  }
  else
  {
    XOR64QC((*Qy), IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo );
    return y;
  }
#/Code
#/Function


#Function LONG IEEEDPCmp
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#Parameter double z D2/D3
    IEEE double precision floting point number
#/Parameter
#LibOffset 7
#AutoDoc
    FUNCTION
	Compares two IEEE double precision numbers

    RESULT
       <code>
       +1 : y > z
	0 : y = z
       -1 : y < z

	Flags:
	  zero	   : y = z
	  negative : y < z
	  overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  QUAD * Qy = (QUAD *)&y;
  QUAD * Qz = (QUAD *)&z;

  if (is_eq(*Qy,*Qz))
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  if (is_lessSC(*Qy,0,0) /* y < 0 */ && is_lessSC(z,0,0) /* z < 0 */)
  {
    NEG64(*Qy);
    NEG64(*Qz);
    if (is_greater(*Qy,*Qz) /* -y > -z */ )
    {
      SetSR(0,  Zero_Bit | Negative_Bit | Overflow_Bit);
      return 1;
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return -1;
    }
  }

  if ( is_less(*Qy,*Qz)  /* (QUAD)y < (QUAD)z */ )
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return -1;
  }
  else
  {
    SetSR(0,  Zero_Bit | Negative_Bit | Overflow_Bit);
    return 1;
  }
#/Code
#/Function


#Function double IEEEDPDiv
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#Parameter double z D2/D3
    IEEE double precision floting point number
#/Parameter
#LibOffset 14
#AutoDoc
    FUNCTION
	Divides two IEEE double precision numbers

    RESULT
       <code>
       +1 : y > z
	0 : y = z
       -1 : y < z

	Flags:
	  zero	   : y = z
	  negative : y < z
	  overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code    
/*
  QUAD * Qy = (QUAD *)&y;
  QUAD * Qz = (QUAD *)&z;
*/
  QUAD Res = 0x0badc0de0badc0deULL;
  return *(double *)&Res;
#/Code
#/Function


#Function LONG IEEEDPFix
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 5
#AutoDoc
    FUNCTION
	Convert IEEE double precision floating point number to integer

    RESULT
	absolute value of y

	Flags:
	  zero	   : result is zero
	  negative : result is negative
	  overflow : ieeedp out of integer-range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
LONG Res, Shift, tmp;
QUAD y2;
QUAD * Qy = (QUAD *)&y;

  tmp = Get_High32of64(*Qy) & IEEEDPExponent_Mask_Hi;

  if ( tmp > 0x41d00000 )
  {
    if( is_lessSC(*Qy, 0x0, 0x0))
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0x80000000;
    }
    else
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      return 0x7fffffff;
    }
  }


  if (is_eqC(*Qy, 0x0, 0x0) ||
      is_eqC(*Qy,IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo)) /* y=+-0; */
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return 0;
  }

  Shift = (Get_High32of64(*Qy) & IEEEDPExponent_Mask_Hi) >> 20;
  Shift = 0x433 - Shift;
  tmp = Get_High32of64(*Qy);
  AND64QC(*Qy, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
  OR64QC(*Qy, 0x00100000, 0x00000000);
  SHRU64(y2, *Qy , Shift);
  Res = Get_Low32of64(y2);

  /* Test for a negative sign  */
  if (tmp < 0) /* y < 0 */
  {
    Res = -Res;
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  }

  return Res;
#/Code
#/Function


#Function double IEEEDPFloor
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 15
#AutoDoc
    FUNCTION
	Calculates the floor-value of a IEEE double precision number

    RESULT
       <code>
       +1 : y > z
	0 : y = z
       -1 : y < z

	Flags:
	  zero	   : y = z
	  negative : y < z
	  overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  QUAD Mask;
  QUAD y_tmp,y2;
  int shift;
  QUAD * Qy = (QUAD *)&y;

  if (is_eqC(*Qy,0,0))
    return *Qy;

  Set_Value64(y_tmp, *Qy);
  AND64QC(y_tmp, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo );

  if (is_lessC(y_tmp, one_Hi, one_Lo ))
  {
    if (is_lessSC(*Qy,0,0))
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    	Set_Value64C(*Qy, one_Hi | IEEEDPSign_Mask_Hi,
    	                  one_Lo | IEEEDPSign_Mask_Lo);
      return y;
    }
    else
    {
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      Set_Value64C(*Qy, 0,0);
      return y;
    }
  }

  /* |fnum| >= 1 */
  Set_Value64C(Mask, 0x80000000, 0x00000000);
  SHRU32(shift, y_tmp, 52);
  SHRS64(Mask, Mask, (shift-0x3ff+11));  /* leave the () there! StormC 1.1 needs 'em! */

  /* y is negative */
  if (is_leqSC(*Qy, 0x0, 0x0))
  {
    QUAD Mask2;
    NOT64(Mask2, Mask);
    Set_Value64(y2,*Qy);
    AND64Q(y2, Mask2);
    if (is_neqC(y2,0x0,0x0))
    {
      QUAD minusone;
      double * Dminusone = (double *)&minusone;
      Set_Value64C(minusone, one_Hi | IEEEDPSign_Mask_Hi,
    	                     one_Lo | IEEEDPSign_Mask_Lo);
      *Qy = IEEEDPAdd(*Qy, *Dminusone);
      Set_Value64C(Mask, 0x80000000, 0x00000000);
      SHRU32(shift, y_tmp, 52);
      SHRS64(Mask, Mask, (shift-0x3ff+11)); /* leave the () there! StormC 1.1 needs 'em! */
    }
  }

  if (is_lessSC(*Qy,0x0,0x0))
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  AND64Q(*Qy, Mask);

  return y;
#/Code
#/Function


#Function double IEEEDPFlt
#Options QUAD
#Parameter LONG y D0/D1
    Signed integer to convert
#/Parameter
#LibOffset 6
#AutoDoc
    FUNCTION


    RESULT
      IEEE double precision number

	Flags:
	  zero	   : result is zero
	  negative : result is negative
	  overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  LONG Exponent = 0;
  LONG TestMask = 0xFFFFFFFF;
  QUAD Res, yQuad, ExponentQuad;
  double * DRes = (double *)&Res;

  Set_Value64C(Res,0,0);

  if (0 == y)
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);  
    return *DRes; /* return 0 */
  }

  if (y < 0 )
  {
    Set_Value64C(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    y = -y;
  }
  /* find out which is the number of the highest set bit */
  while (TestMask & y)
  {
    Exponent ++;
    TestMask <<= 1;
  }

  SHL32(yQuad , y , (53 - Exponent) );

  AND64QC(yQuad,  IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);

  Exponent += 0x3fe;

  /* adapt Exponent to IEEEDP-Format */
  SHL32(ExponentQuad, Exponent, 52);
  OR64Q(Res, yQuad);
  OR64Q(Res, ExponentQuad);
  if ( is_lessSC(Res,0,0) ) /* Res < 0 */
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return *DRes;
#/Code
#/Function


#Function double IEEEDPMul
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#Parameter double z D2/D3
    IEEE double precision floting point number
#/Parameter
#LibOffset 13
#AutoDoc
    FUNCTION
	Multiplies two IEEE double precision numbers

    RESULT
	<code>
       +1 : y > z
	0 : y = z
       -1 : y < z

	Flags:
	  zero	   : y = z
	  negative : y < z
	  overflow : 0
	</code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  return 0x0badc0de0badc0deULL;
#/Code
#/Function


#Function double IEEEDPNeg
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 10
#AutoDoc
    FUNCTION
	Switch the sign of the given IEEE double precision floating point
	number

    RESULT
	-y

	Flags:
	  zero	   : result is zero
	  negative : result is negative
	  overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

	Flip the sign-bit (even for zeroes).

    HISTORY

#/AutoDoc
#Code
  QUAD * Qy = (QUAD *)&y;

  /* change the sign-bit */
  XOR64QC(*Qy, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (is_eqC(*Qy, 0x0, 0x0 ) ||
      is_eqC(*Qy, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) )
  {
    SetSR( Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
   return y;
  }

  /* if (y < 0) */
  if(is_lessSC(*Qy, 0x0, 0x0) )
  /* result is negative */
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  else
  /* result is positive */
    SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  return y;
#/Code
#/Function


#Function double IEEEDPSub
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#Parameter double z D2/D3
    IEEE double precision floting point number
#/Parameter
#LibOffset 12
#AutoDoc
    FUNCTION
        Subtracts two IEEE double precision numbers

    RESULT
       <code>
       +1 : y > z
        0 : y = z
       -1 : y < z

        Flags:
          zero     : y = z
          negative : y < z
          overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  QUAD * Qz = (QUAD *)&z;

  XOR64QC(*Qz, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo );
  return IEEEDPAdd(y,z);
#/Code
#/Function


#Function LONG IEEEDPTst
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floting point number
#/Parameter
#LibOffset 8
#AutoDoc
    FUNCTION
	Compare a IEEE double precision floting point number against zero.

    RESULT
       <code>
	+1 : y > 0.0
	 0 : y = 0.0
	-1 : y < 0.0

	Flags:
	  zero	   : result is zero
	  negative : result is negative
	  overflow : 0
       </code>

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:
	Sign is negative: return -1
	y == 0		: return 0
	Otherwise	: return 1

    HISTORY

#/AutoDoc
#Code
  QUAD * Qy = (QUAD *)&y;

  /* y is negative */
  if (is_lessSC(*Qy, 0x0, 0x0) /* y < 0 */)
  {
    SetSR(Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return -1;
  }

  /* fnum1 is zero */
  if (is_eqC(*Qy, 0x0, 0x0) /* y == 0 */)
  {
    SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    return 0;
  }

  /* fnum1 is positive */
  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );
  return 1;
#/Code
#/Function

#/Archive
