/*
    (C) 1995-98 AROS - The Amiga Research OS
    $Id$

    Desc: Function Archive for MathIeeeDoubTrans.library
    Lang: english
*/
#Archive
#Header
#include <aros/libcall.h>
#include <proto/mathieeedoubbas.h>
#include <proto/mathieeedoubtrans.h>
#include <proto/exec.h>
#include <exec/types.h>
#include "mathieeedoubtrans_intern.h"
#/Header


#Function double IEEEDPAcos
#Options QUAD
#Parameter double x D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 20
#AutoDoc
    FUNCTION
      Calculate the arcus cosine of the IEEE double precision number

    RESULT
      IEEE double precision floating point number

      flags:
	zero	 : result is zero
	negative : result is negative
	overflow : argument is out of range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
  QUAD z,p,q,r,w,s,c,df, tmp;
  int hx,ix;

  #if defined AROS_64BIT_TYPE || defined __GNUC__
  #else
    #undef two_64
    #undef pio2_lo_64
    #undef one_64
    const QUAD two_64	  = two,
	       pio2_lo_64 = pio2_lo,
	       one_64	  = oneC;
  #endif

  hx = Get_High32of64(x);
  ix = hx & 0x7fffffff;
  if(ix >= 0x3ff00000)
  {    /* |x| >= 1 */
    if(( (ix-0x3ff00000) | Get_Low32of64(x) ) == 0)
    {  /* |x|==1 */
      if(hx>0)
      {
      /* if this is a 32bit -compiler we need to define some variables, otherwise
	 these are available as 64bit constants
       */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef zero_64
	QUAD zero_64 = zero;
      #endif

	return zero_64;
      }   /* acos(1) = 0  */
      else
      {
      /* if this is a 32bit -compiler we need to define some variables, otherwise
	 these are available as 64bit constants
       */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef pi_64
	QUAD pi_64 = pi;
      #endif

	return pi_64;	  /* acos(-1)= pi */
      }
    }
    {
     /* if this is a 32bit -compiler we need to define some variables, otherwise
	these are available as 64bit constants
      */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef IEEEDPNAN_64
	QUAD IEEEDPNAN_64;
	Set_Value64C(IEEEDPNAN_64, IEEEDPNAN_Hi, IEEEDPNAN_Lo, 0UUL /* dummy - unused */);
      #endif

      return IEEEDPNAN_64;	   /* acos(|x|>1) is NaN */
    }
  }
  {
  /* if this is a 32bit -compiler we need to define some variables, otherwise
     these are available as 64bit constants
   */
  #if defined AROS_64BIT_TYPE || defined __GNUC__
  #else
    #undef pS0_64
    #undef pS1_64
    #undef pS2_64
    #undef pS3_64
    #undef pS4_64
    #undef pS5_64
    #undef qS1_64
    #undef qS2_64
    #undef qS3_64
    #undef qS4_64

    #undef pio2_hi_64
     /* Ok, let's define some constants */
    const QUAD pS0_64 = pS0,
	       pS1_64 = pS1,
	       pS2_64 = pS2,
	       pS3_64 = pS3,
	       pS4_64 = pS4,
	       pS5_64 = pS5;
    const QUAD qS1_64 = qS1,
	       qS2_64 = qS2,
	       qS3_64 = qS3,
	       qS4_64 = qS4;
    const QUAD pio2_hi_64 = pio2_hi;
  #endif

    if(ix < 0x3fe00000)
    {	  /* |x| < 0.5 */
      if(ix <= 0x3c600000)
	return pio2_hi_64;/*if|x|<2**-57*/

      Set_Value64(z, IEEEDPMul(x,x));
      Set_Value64(p, IEEEDPMul(z,IEEEDPAdd(pS0_64,
		     IEEEDPMul(z,IEEEDPAdd(pS1_64,
		     IEEEDPMul(z,IEEEDPAdd(pS2_64,
		     IEEEDPMul(z,IEEEDPAdd(pS3_64,
		     IEEEDPMul(z,IEEEDPAdd(pS4_64,
		     IEEEDPMul(z,pS5_64))))))))))));

      Set_Value64(q, IEEEDPAdd(one_64,
		     IEEEDPMul(z,IEEEDPAdd(qS1_64,
		     IEEEDPMul(z,IEEEDPAdd(qS2_64,
		     IEEEDPMul(z,IEEEDPAdd(qS3_64,
		     IEEEDPMul(z,qS4_64)))))))));
      Set_Value64(r, IEEEDPDiv(p,q));

      Set_Value64(tmp, IEEEDPSub(pio2_hi_64,
		       IEEEDPSub(x,
		       IEEEDPSub(pio2_lo_64, IEEEDPMul(x,r)))));
      return tmp;
    }
    else
    {
     /* if this is a 32bit -compiler we need to define some variables, otherwise
	these are available as 64bit constants
      */
     #if defined AROS_64BIT_TYPE || defined __GNUC__
     #else
       #undef onehalf_64
       const QUAD onehalf_64 = onehalf;
     #endif

      if (hx < 0)
      { 	    /* x < -0.5 */
      /* if this is a 32bit -compiler we need to define some variables, otherwise
	 these are available as 64bit constants
       */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef pi_64
	const QUAD pi_64 = pi;
      #endif

	Set_Value64(z, IEEEDPMul(IEEEDPAdd(one_64,x),onehalf_64));
	Set_Value64(p, IEEEDPMul(z, IEEEDPAdd(pS0_64,
		       IEEEDPMul(z, IEEEDPAdd(pS1_64,
		       IEEEDPMul(z, IEEEDPAdd(pS2_64,
		       IEEEDPMul(z, IEEEDPAdd(pS3_64,
		       IEEEDPMul(z, IEEEDPAdd(pS4_64,
		       IEEEDPMul(z, pS5_64))))))))))));
	Set_Value64(q, IEEEDPAdd(one_64,
		       IEEEDPMul(z, IEEEDPAdd(qS1_64,
		       IEEEDPMul(z, IEEEDPAdd(qS2_64,
		       IEEEDPMul(z, IEEEDPAdd(qS3_64,
		       IEEEDPMul(z,qS4_64)))))))));
	Set_Value64(s, IEEEDPSqrt(z));
	Set_Value64(r, IEEEDPDiv(p,q));
	Set_Value64(w, IEEEDPSub(IEEEDPMul(r,s),pio2_lo_64));
	return IEEEDPSub(pi_64, IEEEDPMul(two_64, IEEEDPAdd(s,w)));
      }
      else
      {  /* x > 0.5 */

	Set_Value64(z, IEEEDPMul(IEEEDPSub(one_64,x),onehalf_64));
	Set_Value64(s, IEEEDPSqrt(z));
	Set_Value64(df,s);
	AND64QC(df,0xffffffff, 0x0);
	Set_Value64(c, IEEEDPDiv(IEEEDPSub(z,IEEEDPMul(df,df)),IEEEDPAdd(s,df)));
	Set_Value64(p, IEEEDPMul(z, IEEEDPAdd(pS0_64,
		       IEEEDPMul(z, IEEEDPAdd(pS1_64,
		       IEEEDPMul(z, IEEEDPAdd(pS2_64,
		       IEEEDPMul(z, IEEEDPAdd(pS3_64,
		       IEEEDPMul(z, IEEEDPAdd(pS4_64,
		       IEEEDPMul(z,pS5_64))))))))))));
	Set_Value64(q, IEEEDPAdd(one_64,
		       IEEEDPMul(z, IEEEDPAdd(qS1_64,
		       IEEEDPMul(z, IEEEDPAdd(qS2_64,
		       IEEEDPMul(z, IEEEDPAdd(qS3_64,
		       IEEEDPMul(z,qS4_64)))))))));
	Set_Value64(r, IEEEDPDiv(p,q));
	Set_Value64(w, IEEEDPAdd(IEEEDPMul(r,s),c));
	return IEEEDPMul(two_64,IEEEDPAdd(df,w));
      }
    }
  }
#/Code
#/Function


#Function double IEEEDPAsin
#Options QUAD
#Parameter double x D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 19
#AutoDoc
    FUNCTION
      Calculate the arcus sine of the IEEE double precision number

    RESULT
      IEEE double precision floating point number

      flags:
	zero	 : result is zero
	negative : result is negative
	overflow : argument is out of range

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
/*
 * ====================================================
 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
 *
 * Developed at SunSoft, a Sun Microsystems, Inc. business.
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
  QUAD t,w,p,q,c,r,s;
  int hx,ix;
  /* if this is a 32bit -compiler we need to define some variables, otherwise
     these are available as 64bit constants
   */
  #if defined AROS_64BIT_TYPE || defined __GNUC__
  #else
    #undef two_64
    #undef pio2_lo_64
    #undef one_64
    const QUAD two_64	  = two,
	       pio2_lo_64 = pio2_lo,
	       one_64	  = oneC;
  #endif

  hx = Get_High32of64(x);
  ix = hx & 0x7fffffff;
  if(ix >= 0x3ff00000)
  {    /* |x| >= 1 */
    if(( (ix-0x3ff00000) | Get_Low32of64(x) ) == 0)
    {  /* |x|==1 -> asin(1) = pi/2 */
     /* if this is a 32bit -compiler we need to define some variables, otherwise
	these are available as 64bit constants
      */
      if (hx > 0)
      {
       #if defined AROS_64BIT_TYPE || defined __GNUC__
       #else
	 #undef pio2_hi_64
	 QUAD pio2_hi_64 = pio2_hi;
       #endif
	 return pio2_hi_64;
      }
      else
      {
       #if defined AROS_64BIT_TYPE || defined __GNUC__
       #else
	 #undef neg_pio2_hi_64
	 QUAD neg_pio2_hi_64 = neg_pio2_hi;
       #endif
	 return neg_pio2_hi_64;
      }
    }
    else  /* asin(>1) = NAN  */
    {
     /* if this is a 32bit -compiler we need to define some variables, otherwise
	these are available as 64bit constants
      */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef IEEEDPNAN_64
	QUAD IEEEDPNAN_64;
	Set_Value64C(IEEEDPNAN_64, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
      #endif

	return IEEEDPNAN_64;	 /* acos(>1)= NAN */
    } /* else */


  } /* if */

  {
  /* if this is a 32bit -compiler we need to define some variables, otherwise
     these are available as 64bit constants
   */
  #if defined AROS_64BIT_TYPE || defined __GNUC__
  #else
    #undef pS0_64
    #undef pS1_64
    #undef pS2_64
    #undef pS3_64
    #undef pS4_64
    #undef pS5_64
    #undef qS1_64
    #undef qS2_64
    #undef qS3_64
    #undef qS4_64

    #undef pio2_hi_64
     /* Ok, let's define some constants */
    const QUAD pS0_64 = pS0,
	       pS1_64 = pS1,
	       pS2_64 = pS2,
	       pS3_64 = pS3,
	       pS4_64 = pS4,
	       pS5_64 = pS5;
    const QUAD qS1_64 = qS1,
	       qS2_64 = qS2,
	       qS3_64 = qS3,
	       qS4_64 = qS4;
    const QUAD pio2_hi_64 = pio2_hi;
  #endif

    if(ix < 0x3fe00000)
    {	  /* |x| < 0.5 */
      if(ix <= 0x3e400000)
	return x;/* if|x|<2**-27 -> asin(x)=x */

      Set_Value64(t, IEEEDPMul(x,x));
      Set_Value64(p, IEEEDPMul(t,IEEEDPAdd(pS0_64,
		     IEEEDPMul(t,IEEEDPAdd(pS1_64,
		     IEEEDPMul(t,IEEEDPAdd(pS2_64,
		     IEEEDPMul(t,IEEEDPAdd(pS3_64,
		     IEEEDPMul(t,IEEEDPAdd(pS4_64,
		     IEEEDPMul(t,pS5_64))))))))))));

      Set_Value64(q, IEEEDPAdd(one_64,
		     IEEEDPMul(t,IEEEDPAdd(qS1_64,
		     IEEEDPMul(t,IEEEDPAdd(qS2_64,
		     IEEEDPMul(t,IEEEDPAdd(qS3_64,
		     IEEEDPMul(t,qS4_64)))))))));
      Set_Value64(w, IEEEDPDiv(p,q));

      Set_Value64(t, IEEEDPAdd(x,IEEEDPMul(x,w)) );
      return t;
    } /* if */
    {
     /* if this is a 32bit -compiler we need to define some variables, otherwise
	these are available as 64bit constants
      */
      #if defined AROS_64BIT_TYPE || defined __GNUC__
      #else
	#undef one_64
	#undef onehalf_64
	#undef two_64
	#undef pio2_hi_64
	#undef pio2_lo_64
	#undef pio4_hi_64
	const QUAD one_64     = oneC,
		   onehalf_64 = onehalf,
		   two_64     = two,
		   pio2_hi_64 = pio2_hi,
		   pio2_lo_64 = pio2_lo,
		   pio4_hi_64 = pio4_hi;
      #endif
      /* 1 > |x| >= 0.5 */
      AND64QC(x, (IEEEDPMantisse_Mask_Hi|IEEEDPExponent_Mask_Hi),
		 (IEEEDPMantisse_Mask_Lo|IEEEDPExponent_Mask_Lo) );
      Set_Value64(w, IEEEDPSub(one_64,x));
      Set_Value64(t, IEEEDPMul(w, onehalf_64));
      Set_Value64(p, IEEEDPMul(t,IEEEDPAdd(pS0_64,
		     IEEEDPMul(t,IEEEDPAdd(pS1_64,
		     IEEEDPMul(t,IEEEDPAdd(pS2_64,
		     IEEEDPMul(t,IEEEDPAdd(pS3_64,
		     IEEEDPMul(t,IEEEDPAdd(pS4_64,
		     IEEEDPMul(t,pS5_64))))))))))));

      Set_Value64(q, IEEEDPAdd(one_64,
		     IEEEDPMul(t,IEEEDPAdd(qS1_64,
		     IEEEDPMul(t,IEEEDPAdd(qS2_64,
		     IEEEDPMul(t,IEEEDPAdd(qS3_64,
		     IEEEDPMul(t,qS4_64)))))))));
      Set_Value64(s, IEEEDPSqrt(t));

      if(ix >= 0x3fef3333) /* if |x| > 0.975 */
      {
	Set_Value64(w, IEEEDPDiv(p,q));
	Set_Value64(t, IEEEDPSub(pio2_hi_64,
		       IEEEDPSub(
		       IEEEDPMul(two_64,
		       IEEEDPAdd(s,
		       IEEEDPMul(s,w))),pio2_lo_64 )));
      }
      else
      {
	Set_Value64(w,s);
	AND64QC(w,0xffffffff,0x0);
	Set_Value64(c, IEEEDPDiv(IEEEDPSub(t,IEEEDPMul(w,w)),
				 IEEEDPAdd(s,w)
				)
		   );
	Set_Value64(r, IEEEDPDiv(p,q));
	Set_Value64(p, IEEEDPSub(IEEEDPMul( IEEEDPMul(two_64,s),r
					  ),
				 IEEEDPSub(pio2_lo_64,IEEEDPMul(two_64,c)
					  )
				)
		   );
	Set_Value64(q, IEEEDPSub(pio4_hi_64,IEEEDPMul(two_64,w)));
	Set_Value64(t, IEEEDPSub(pio4_hi_64,IEEEDPSub(p,q)));
      } /* else */
      if (hx > 0)
	return t;
      else
      {
	OR64QC(t, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
	return t;
      } /* else */
    }
  }
#/Code
#/Function


#Function double IEEEDPAtan
#Options QUAD
#Parameter double y D0/D1
      IEEE double precision floating point number
#/Parameter
#LibOffset 5
#AutoDoc
    FUNCTION
      Calculates the angle of a given number representing the tangent
      of that angle. The angle will be in radians.

    RESULT
      IEEE double precision floating point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  QUAD yabs;
  QUAD ysquared, ycubed, ypow5, one;

  AND64C(yabs, y, (IEEEDPMantisse_Mask_Hi | IEEEDPExponent_Mask_Hi), 
                  (IEEEDPMantisse_Mask_Lo | IEEEDPExponent_Mask_Lo) );

  /* check for +- infinity -> output: +-pi/2 */
  if (is_eqC(yabs, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
    AND64QC(y, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    OR64QC(y, pio2_hi_Hi, pio2_hi_Lo);
    return y;
  }
  /* atan(0) = 0 */
  if (is_eqC(yabs, 0, 0) /* 0 == yabs */ )
  {
     SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
     return y;
  }

  ysquared = IEEEDPMul(yabs, yabs);
  ycubed = IEEEDPMul(yabs, ysquared);

  Set_Value64C(one, one_Hi, one_Lo);

  /* atan(x >= 860) = pi/2 - 1/x + 1/(3*x^3) */
  if ( Get_High32of64(yabs)  >= 0x408ae000)
  {
    QUAD tmp1, onethird;
    Set_Value64C(tmp1, pio2_hi_Hi, pio2_hi_Lo);
    Set_Value64C(onethird, onethird_Hi, onethird_Lo);

    tmp1 = IEEEDPAdd(tmp1,IEEEDPDiv(IEEEDPSub(onethird, ysquared),ycubed)); 

    if (is_eq(yabs,y)) /* arg has positive sign */
    {
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);
      return tmp1;
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      OR64QC(tmp1, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
      return tmp1;
    }
  }

  /* atan(x >= 128) = pi/2 - 1/x + 1/(3*x^3) -1/(5*x^5) 
   *                = pi/2 + (1/3*x^2 - x^4 - 1/5) / x^5
   */
  if ( Get_High32of64(yabs) >= 0x40600000)
  {
    QUAD tmp1, onethird, onefifth;
    Set_Value64C(tmp1, pio2_hi_Hi, pio2_hi_Lo);
    Set_Value64C(onethird, onethird_Hi, onethird_Lo);
    Set_Value64C(onefifth, onefifth_Hi, onefifth_Lo);
    ypow5 = IEEEDPMul(ycubed, ysquared);

    tmp1 = IEEEDPAdd(tmp1, 
           IEEEDPDiv( 
             IEEEDPSub(
             IEEEDPSub(
               IEEEDPMul(onethird,ysquared),
               IEEEDPMul(ysquared,ysquared)),onefifth),ypow5 ));

    if (is_eq(yabs,y)) /* arg has positive sign */
    {
      SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);
      return tmp1;     
    }
    else
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      OR64QC(tmp1, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
      return tmp1;
    }
  }

  /* atan(x) = asin(x/sqrt(1+x^2)) */

  return IEEEDPAsin(IEEEDPDiv(y,IEEEDPSqrt(IEEEDPAdd(one,ysquared))));
#/Code
#/Function

	
#Function double IEEEDPCos
#Options QUAD
#Parameter double y D0/D1
      IEEE double precision floating point number
#/Parameter
#LibOffset 7
#AutoDoc
    FUNCTION
      Calculate the cosine of a given IEEE double precision number in radians

    RESULT
      IEEE double precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      cos (x) = sin (x+ pi/2);

    HISTORY

#/AutoDoc
#Code
  LONG tmp;
  QUAD z,Res, ysquared, yabs, Qtmp;
  AND64C(yabs, y, (IEEEDPMantisse_Mask_Hi | IEEEDPExponent_Mask_Hi),
                  (IEEEDPMantisse_Mask_Lo | IEEEDPExponent_Mask_Lo));


  if (is_eqC(yabs, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
		SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
		Set_Value64C(Res, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
		return Res;
  }

  z = IEEEDPFloor(IEEEDPDiv(yabs, pi));
  Qtmp  = IEEEDPMul(z,pi);
  OR64QC(tmp, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) /* Qtmp=-Qtmp */
  yabs = IEEEDPAdd(yabs, Qtmp);
  if (is_greaterC(yabs, pio2_Hi, pio2_Lo))
  {
    OR64QC(Qtmp, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) /* Qtmp=-Qtmp */
    yabs  =IEEEDPAdd(pi, yabs);
    tmp = TRUE;
  }
  else
    tmp = FALSE;

  ysquared = IEEEDPMul(yabs,yabs);
  Res = IEEEDPAdd(cosf1,
         IEEEDPMul(ysquared,
          IEEEDPAdd(cosf2,
           IEEEDPMul(ysquared,
            IEEEDPAdd(cosf3,
             IEEEDPMul(ysquared,
              IEEEDPAdd(cosf4,
               IEEEDPMul(ysquared,
                IEEEDPAdd(cosf5,
                 IEEEDPMul(ysquared, 
                  IEEEDPAdd(cosf6,
                   IEEEDPMul(ysquared,
                    IEEEDPAdd(cosf7,
                     IEEEDPMul(ysquared, cosf8)
                    )
                   )
                  )
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        );

  if (is_eqC(Res, 0x0, 0x0))
  {
  	SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
  	Set_Value64C(Res, 0x0, 0x0);
  	return Res;
  }

  if (TRUE == intern_IEEEDPisodd(z))
    XOR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (TRUE == tmp)
    XOR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (is_lessSC(Res, 0x0, 0x0))
  	SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function double IEEEDPCosh
#Options QUAD
#Parameter double y D0/D1
      IEEE single precision floating point number
#/Parameter
#LibOffset 11
#AutoDoc
    FUNCTION
      Calculate the hyperbolic cosine of the IEEE single precision number

    RESULT
      IEEE single precision floating point number

      flags:
        zero     : result is zero
        negative : 0 (not possible)
        overflow : result too big for ffp-number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      cosh(x) = (1/2)*( e^x + e^(-x) )

      cosh( |x| >= 18 ) = (1/2) * (e^x);

    HISTORY

#/AutoDoc
#Code
QUAD Res;
  /* cosh(-x) = cosh(x) */
  /* y &= ( IEEEDPMantisse_Mask + IEEEDPExponent_Mask ); */
  AND64QC(y, (IEEEDPMantisse_Mask_Hi + IEEEDPExponent_Mask_Hi),
             (IEEEDPMantisse_Mask_Lo + IEEEDPExponent_Mask_Lo) );

  if ( is_eqC(y, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return y;
  }

  Res = IEEEDPExp(y);

  if ( is_eqC(Res, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return  Res;
  }

  /* does adding of 1/(e^x) still change the result? */
  if ( is_lessC(y, 0x40320000, 0x0 ))
  {
    QUAD One;
    Set_Value64C(One, 0x3ff00000, 0x0);

    Res = IEEEDPAdd(Res, IEEEDPDiv(One, Res));
  }
  /* Res = Res / 2 */
  ADD64QC(Res, 0xFFF00000, 0x0);

  if ( is_eqC   (Res, 0x0, 0x0) ||
       is_lessSC(Res, 0x0, 0x0) )
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, 0x0, 0x0);
    return Res;
  }
  return Res;
#/Code
#/Function


#Function double IEEEDPExp
#Options QUAD
#Parameter double y D0/D1
      IEEE double precision number
#/Parameter
#LibOffset 13
#AutoDoc
    FUNCTION
      Calculate e^x

    RESULT
      IEEE double precision number

      flags:
        zero     : result is zero
        negative : 0
        overflow : the result was out of range for the IEEE single precision
                   format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      e^(>= ): return 0x7f800000;
      e^(2^(<=-24)): return one;

    HISTORY

#/AutoDoc
#Code
const QUAD ExpTable[] =
    {
      QuadData(0x6e194765, 0x04ba852e,0x6e19476504ba852eULL) , /* e^(2^9)  */
      QuadData(0x57041c7a, 0x8814beba,0x57041c7a8814bebaULL) , /* e^(2^8)  */
      QuadData(0x4b795e54, 0xc5dd4217,0x4b795e54c5dd4217ULL) , /* e^(2^7)  */
      QuadData(0x45b42598, 0x2cf597cd,0x45b425982cf597cdULL) , /* e^(2^6)  */
      QuadData(0x42d1f43f, 0xcc4b662c,0x42d1f43fcc4b662cULL) , /* e^(2^5)  */
      QuadData(0x4160f2eb, 0xd0a80020,0x4160f2ebd0a80020ULL) , /* e^(2^4)  */
      QuadData(0x40a749ea, 0x7d470c6d,0x40a749ea7d470c6dULL) , /* e^(2^3)  */
      QuadData(0x404b4c90, 0x2e273a58,0x404b4c902e273a58ULL) , /* e^(2^2)  */
      QuadData(0x401d8e64, 0xb8d4ddad,0x401d8e64b8d4ddadULL) , /* e^(2^1)  */
      QuadData(0x4005bf0a, 0x8b145769,0x4005bf0a8b145769ULL) , /* e^(2^0)  */
      QuadData(0x3ffa6129, 0x8e1e069b,0x3ffa61298e1e069bULL) , /* e^(2^-1) */
      QuadData(0x3ff48b5e, 0x3c3e8186,0x3ff48b5e3c3e8186ULL) , /* e^(2^-2) */
      QuadData(0x3ff22160, 0x45b6f5cc,0x3ff2216045b6f5ccULL) , /* e^(2^-3) */
      QuadData(0x3ff1082b, 0x577d34ed,0x3ff1082b577d34edULL) , /* e^(2^-4) */
      QuadData(0x3ff08205, 0x601127ec,0x3ff08205601127ecULL) , /* e^(2^-5) */
      QuadData(0x3ff04080, 0xab55de39,0x3ff04080ab55de39ULL) , /* e^(2^-6) */
      QuadData(0x3ff02020, 0x15600445,0x3ff0202015600445ULL) , /* e^(2^-7) */
      QuadData(0x3ff01008, 0x02ab5577,0x3ff0100802ab5577ULL) , /* e^(2^-8) */
      QuadData(0x3ff00802, 0x00556001,0x3ff0080200556001ULL) , /* e^(2^-9) */
      QuadData(0x3ff00400, 0x800aabff,0x3ff00400800aabffULL) , /* e^(2^-10) */
      QuadData(0x3ff00200, 0x2001ff60,0x3ff002002001ff60ULL) , /* e^(2^-11) */
      QuadData(0x3ff00100, 0x08002aab,0x3ff0010008002aabULL) , /* e^(2^-12) */
      QuadData(0x3ff00080, 0x02000555,0x3ff0008002000555ULL) , /* e^(2^-13) */
      QuadData(0x3ff00040, 0x008000aa,0x3ff00040008000aaULL) , /* e^(2^-14) */
      QuadData(0x3ff00020, 0x00200015,0x3ff0002000200015ULL) , /* e^(2^-15) */
      QuadData(0x3ff00010, 0x00080002,0x3ff0001000080002ULL) , /* e^(2^-16) */
      QuadData(0x3ff00008, 0x00020000,0x3ff0000800020000ULL) , /* e^(2^-17) */
      QuadData(0x3ff00004, 0x00008000,0x3ff0000400008000ULL) , /* e^(2^-18) */
      QuadData(0x3ff00002, 0x00002000,0x3ff0000200002000ULL) , /* e^(2^-19) */
      QuadData(0x3ff00001, 0x00000800,0x3ff0000100000800ULL) , /* e^(2^-20) */
      QuadData(0x3ff00000, 0x80000200,0x3ff0000080000200ULL) , /* e^(2^-21) */
      QuadData(0x3ff00000, 0x40000080,0x3ff0000040000080ULL) , /* e^(2^-22) */
      QuadData(0x3ff00000, 0x20000020,0x3ff0000020000020ULL) , /* e^(2^-23) */
      QuadData(0x3ff00000, 0x10000008,0x3ff0000010000008ULL) , /* e^(2^-24) */
      QuadData(0x3ff00000, 0x08000002,0x3ff0000008000002ULL) , /* e^(2^-25) */
      QuadData(0x3ff00000, 0x04000000,0x3ff0000004000000ULL) , /* e^(2^-26) */
      QuadData(0x3ff00000, 0x02000000,0x3ff0000002000000ULL) , /* e^(2^-27) */
      QuadData(0x3ff00000, 0x01000000,0x3ff0000001000000ULL) , /* e^(2^-28) */
      QuadData(0x3ff00000, 0x00800000,0x3ff0000000800000ULL) , /* e^(2^-29) */
      QuadData(0x3ff00000, 0x00400000,0x3ff0000000400000ULL) , /* e^(2^-30) */
      QuadData(0x3ff00000, 0x00200000,0x3ff0000000200000ULL) , /* e^(2^-31) */
      QuadData(0x3ff00000, 0x00100000,0x3ff0000000100000ULL) , /* e^(2^-32) */
      QuadData(0x3ff00000, 0x00080000,0x3ff0000000080000ULL) , /* e^(2^-33) */
      QuadData(0x3ff00000, 0x00040000,0x3ff0000000040000ULL) , /* e^(2^-34) */
      QuadData(0x3ff00000, 0x00020000,0x3ff0000000020000ULL) , /* e^(2^-35) */
      QuadData(0x3ff00000, 0x00010000,0x3ff0000000010000ULL) , /* e^(2^-36) */
      QuadData(0x3ff00000, 0x00008000,0x3ff0000000008000ULL) , /* e^(2^-37) */
      QuadData(0x3ff00000, 0x00004000,0x3ff0000000004000ULL) , /* e^(2^-38) */
      QuadData(0x3ff00000, 0x00002000,0x3ff0000000002000ULL) , /* e^(2^-39) */
      QuadData(0x3ff00000, 0x00001000,0x3ff0000000001000ULL) , /* e^(2^-40) */
      QuadData(0x3ff00000, 0x00000800,0x3ff0000000000800ULL) , /* e^(2^-41) */
      QuadData(0x3ff00000, 0x00000400,0x3ff0000000000400ULL) , /* e^(2^-42) */
      QuadData(0x3ff00000, 0x00000200,0x3ff0000000000200ULL) , /* e^(2^-43) */
      QuadData(0x3ff00000, 0x00000100,0x3ff0000000000100ULL) , /* e^(2^-44) */
      QuadData(0x3ff00000, 0x00000080,0x3ff0000000000080ULL) , /* e^(2^-45) */
      QuadData(0x3ff00000, 0x00000040,0x3ff0000000000040ULL) , /* e^(2^-46) */
      QuadData(0x3ff00000, 0x00000020,0x3ff0000000000020ULL) , /* e^(2^-47) */
      QuadData(0x3ff00000, 0x00000010,0x3ff0000000000010ULL) , /* e^(2^-48) */
      QuadData(0x3ff00000, 0x00000008,0x3ff0000000000008ULL) , /* e^(2^-49) */
      QuadData(0x3ff00000, 0x00000004,0x3ff0000000000004ULL) , /* e^(2^-50) */
      QuadData(0x3ff00000, 0x00000002,0x3ff0000000000002ULL) , /* e^(2^-51) */
      QuadData(0x3ff00000, 0x00000001,0x3ff0000000000001ULL) , /* e^(2^-52) */

      QuadData(0x11c44109, 0xedb20931,0x11c44109edb20931ULL) , /* e^(-2^9)  */
      QuadData(0x28d97559, 0x56ad4e9b,0x28d9755956ad4e9bULL) , /* e^(-2^8)  */
      QuadData(0x34642eb9, 0xf39afb0b,0x34642eb9f39afb0bULL) , /* e^(-2^7)  */
      QuadData(0x3a2969d4, 0x7321e4cb,0x3a2969d47321e4cbULL) , /* e^(-2^6)  */
      QuadData(0x3d0c8464, 0xf7616468,0x3d0c8464f7616468ULL) , /* e^(-2^5)  */
      QuadData(0x3e7e355b, 0xbaee85ca,0x3e7e355bbaee85caULL) , /* e^(-2^4)  */
      QuadData(0x3f35fc21, 0x041027ac,0x3f35fc21041027acULL) , /* e^(-2^3)  */
      QuadData(0x3f92c155, 0xb8213cf4,0x3f92c155b8213cf4ULL) , /* e^(-2^2)  */
      QuadData(0x3fc152aa, 0xa3bf81cb,0x3fc152aaa3bf81cbULL) , /* e^(-2^1)  */
      QuadData(0x3fd78b56, 0x362cef37,0x3fd78b56362cef37ULL) , /* e^(-2^0)  */
      QuadData(0x3fe368b2, 0xfc6f9609,0x3fe368b2fc6f9609ULL) , /* e^(-2^-1)  */
      QuadData(0x3fe8ebef, 0x9eac820a,0x3fe8ebef9eac820aULL) , /* e^(-2^-2)  */
      QuadData(0x3fec3d6a, 0x24ed8221,0x3fec3d6a24ed8221ULL) , /* e^(-2^-3)  */
      QuadData(0x3fee0fab, 0xfbc702a3,0x3fee0fabfbc702a3ULL) , /* e^(-2^-4)  */
      QuadData(0x3fef03f5, 0x6a88b5d7,0x3fef03f56a88b5d7ULL) , /* e^(-2^-5)  */
      QuadData(0x3fef80fe, 0xabfeefa4,0x3fef80feabfeefa4ULL) , /* e^(-2^-6)  */
      QuadData(0x3fefc03f, 0xd56aa224,0x3fefc03fd56aa224ULL) , /* e^(-2^-7)  */
      QuadData(0x3fefe00f, 0xfaabffbb,0x3fefe00ffaabffbbULL) , /* e^(-2^-8)  */
      QuadData(0x3feff003, 0xff556aa8,0x3feff003ff556aa8ULL) , /* e^(-2^-9)  */
      QuadData(0x3feff800, 0xffeaabff,0x3feff800ffeaabffULL) , /* e^(-2^-10)  */
      QuadData(0x3feffc00, 0x3ffd556a,0x3feffc003ffd556aULL) , /* e^(-2^-11)  */
      QuadData(0x3feffe00, 0x0fffaaab,0x3feffe000fffaaabULL) , /* e^(-2^-12)  */
      QuadData(0x3fefff00, 0x03fff555,0x3fefff0003fff555ULL) , /* e^(-2^-13)  */
      QuadData(0x3fefff80, 0x00fffeaa,0x3fefff8000fffeaaULL) , /* e^(-2^-14)  */
      QuadData(0x3fefffc0, 0x003fffd5,0x3fefffc0003fffd5ULL) , /* e^(-2^-15)  */
      QuadData(0x3fefffe0, 0x000ffffa,0x3fefffe0000ffffaULL) , /* e^(-2^-16)  */
      QuadData(0x3feffff0, 0x0003ffff,0x3feffff00003ffffULL) , /* e^(-2^-17)  */
      QuadData(0x3feffff8, 0x000ffffl,0x3feffff8000fffffULL) , /* e^(-2^-18)  */
      QuadData(0x3feffffc, 0x00003fff,0x3feffffc00003fffULL) , /* e^(-2^-19)  */
      QuadData(0x3feffffe, 0x00000fff,0x3feffffe00000fffULL) , /* e^(-2^-20)  */
      QuadData(0x3fefffff, 0x000003ff,0x3fefffff000003ffULL) , /* e^(-2^-21)  */
      QuadData(0x3fefffff, 0x800000ff,0x3fefffff800000ffULL) , /* e^(-2^-22)  */
      QuadData(0x3fefffff, 0xc000003f,0x3fefffffc000003fULL) , /* e^(-2^-23)  */
      QuadData(0x3fefffff, 0xe000000f,0x3fefffffe000000fULL) , /* e^(-2^-24)  */
      QuadData(0x3fefffff, 0xf0000003,0x3feffffff0000003ULL) , /* e^(-2^-25)  */
      QuadData(0x3fefffff, 0xf8000000,0x3feffffff8000000ULL) , /* e^(-2^-26)  */
      QuadData(0x3fefffff, 0xfc000000,0x3feffffffc000000ULL) , /* e^(-2^-27)  */
      QuadData(0x3fefffff, 0xfe000000,0x3feffffffe000000ULL) , /* e^(-2^-28)  */
      QuadData(0x3fefffff, 0xff000000,0x3fefffffff000000ULL) , /* e^(-2^-29)  */
      QuadData(0x3fefffff, 0xff800000,0x3fefffffff800000ULL) , /* e^(-2^-30)  */
      QuadData(0x3fefffff, 0xffc00000,0x3fefffffffc00000ULL) , /* e^(-2^-31)  */
      QuadData(0x3fefffff, 0xffe00000,0x3fefffffffe00000ULL) , /* e^(-2^-32)  */
      QuadData(0x3fefffff, 0xfff00000,0x3feffffffff00000ULL) , /* e^(-2^-33)  */
      QuadData(0x3fefffff, 0xfff80000,0x3feffffffff80000ULL) , /* e^(-2^-34)  */
      QuadData(0x3fefffff, 0xfffc0000,0x3feffffffffc0000ULL) , /* e^(-2^-35)  */
      QuadData(0x3fefffff, 0xfffe0000,0x3feffffffffe0000ULL) , /* e^(-2^-36)  */
      QuadData(0x3fefffff, 0xffff0000,0x3fefffffffff0000ULL) , /* e^(-2^-37)  */
      QuadData(0x3fefffff, 0xffff8000,0x3fefffffffff8000ULL) , /* e^(-2^-38)  */
      QuadData(0x3fefffff, 0xffffc000,0x3fefffffffffc000ULL) , /* e^(-2^-39)  */
      QuadData(0x3fefffff, 0xffffe000,0x3fefffffffffe000ULL) , /* e^(-2^-40)  */
      QuadData(0x3fefffff, 0xfffff000,0x3feffffffffff000ULL) , /* e^(-2^-41)  */
      QuadData(0x3fefffff, 0xfffff800,0x3feffffffffff800ULL) , /* e^(-2^-42)  */
      QuadData(0x3fefffff, 0xfffffc00,0x3feffffffffffc00ULL) , /* e^(-2^-43)  */
      QuadData(0x3fefffff, 0xfffffe00,0x3feffffffffffe00ULL) , /* e^(-2^-44)  */
      QuadData(0x3fefffff, 0xffffff00,0x3fefffffffffff00ULL) , /* e^(-2^-45)  */
      QuadData(0x3fefffff, 0xffffff80,0x3fefffffffffff80ULL) , /* e^(-2^-46)  */
      QuadData(0x3fefffff, 0xffffffc0,0x3fefffffffffffc0ULL) , /* e^(-2^-47)  */
      QuadData(0x3fefffff, 0xffffffe0,0x3fefffffffffffe0ULL) , /* e^(-2^-48)  */
      QuadData(0x3fefffff, 0xfffffff0,0x3feffffffffffff0ULL) , /* e^(-2^-49)  */
      QuadData(0x3fefffff, 0xfffffff8,0x3feffffffffffff8ULL) , /* e^(-2^-50)  */
      QuadData(0x3fefffff, 0xfffffffc,0x3feffffffffffffcULL) , /* e^(-2^-51)  */
      QuadData(0x3fefffff, 0xfffffffe,0x3feffffffffffffeULL) , /* e^(-2^-52)  */
      QuadData(0x3fefffff, 0xffffffff,0x3fefffffffffffffULL)   /* e^(-2^-53)  */   };
QUAD Res;
QUAD Mantisse;
LONG Exponent;
int i, Offset;

  Exponent = ((Get_High32of64(y) & IEEEDPExponent_Mask_Hi) >> 20) - 0x3ff;


  /* e^(+-0) = 1, e^(2^(<=-24)) = 1 */
  if ( is_eqC(y, 0x0, 0x0) ||
       is_eqC(y, 0x80000000, 0x0) ||
       Exponent < -52 )
  {
    Set_Value64C(Res, 0x3ff00000, 0x0);
    return Res;
  }

  if ( is_lessSC(y, 0x0, 0x0)) /* y < 0 */
  {
    if (Exponent >= 10)
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      Set_Value64C(Res , 0x0, 0x0);
      return Res;
    }
    Offset = 62;
  }
  else
  {
    if (Exponent >= 10)
    {
      SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      Set_Value64C(Res , IEEEDPPInfty_Hi, IEEEDPPInfty_Lo);
      return Res;
    }
  Offset = 0;
  }

  /* e^(>= 1024) = overflow) */

  i = 9 - Exponent + Offset;

  /* Mantisse = (y & IEEEDPMantisse_Mask) << 9; */
  Set_Value64(Mantisse, y);
  AND64QC(y, IEEEDPMantisse_Mask_Lo, IEEEDPMantisse_Mask_Hi);

  SHL64(Mantisse, Mantisse, 12);
  Res = ExpTable[i++];

  while ( is_neqC(Mantisse, 0x0, 0x0) && i <= (61+Offset) )
  {
    /* is the highest bit set? */
    if ( is_lessSC(Mantisse, 0x0, 0x0) /* Mantisse < 0 */ )
    {
      Res = IEEEDPMul(Res, ExpTable[i]);


      if (is_eqC(Res, 0x0, 0x0) /* 0 == Res */ )
      {
        SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }

      if (is_eqC(Res, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
      {
        SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
        return Res;
      }
    }
    i++;
    SHL64(Mantisse, Mantisse, 1);
  }

  return Res;
#/Code
#/Function


#Function double IEEEDPFieee
#Options QUAD
#Parameter LONG y D0/D1
        IEEE single precision floating point number
#/Parameter
#LibOffset 18
#AutoDoc
    FUNCTION
        Convert IEEE single to IEEE double precision

    RESULT
        IEEE double precision floting point number

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
LONG tmpL = y & IEEESPExponent_Mask; /* get the Exponent */
QUAD Res, tmpQ;

  SetSR( 0, Zero_Bit | Overflow_Bit | Negative_Bit);

  if (0 == y)
  {
    SetSR( Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
    Set_Value64C(Res, 0x0, 0x0);
    return Res;
  }

  tmpL >>= 23;
  tmpL = tmpL - 0x7e + 0x3fe;

  /* set the Exponent */
  SHL32(Res, tmpL, 52);

  /* set the Mantisse */
  tmpL = y & IEEESPMantisse_Mask;
  SHL32(tmpQ, tmpL, 29);
  OR64Q(Res, tmpQ);

  if (y < 0)
  {
    OR64QC(Res,  IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    SetSR( Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit);
  }

  return Res;
#/Code
#/Function


#Function double IEEEDPLog
#Options QUAD
#Parameter double y D0/D1
      IEEE double precision number
#/Parameter
#LibOffset 14
#AutoDoc
    FUNCTION
      Calculate logarithm (base e) of the given IEEE double precision number

    RESULT
      IEEE double precision number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return NAN.
      If the Argument is 0 return 0xFFF0000000000000.
      If the Argument is pos. Infinity return pos. Infinity.

      All other cases:

      (ld is the logarithm with base 2)
      (ln is the logarithm with base e)
      y = M * 2^E

      ln y = ln ( M * 2^E ) =

           = ln M + ln 2^E =

           = ln M + E * ln (2) =

             ld M        ld 2
           = ----- + E * ----- =      [ld 2 = 1]
             ld e        ld e

             ld M + E
           = --------
             ld e

      ld e can be precalculated, of course.
      For calculating ld M see file intern_ieeespld.c

    HISTORY

#/AutoDoc
#Code
QUAD Res, tmp, Exponent64, ld_M;
LONG Exponent;
  /* check for negative sign */
  if ( is_lessSC(y, 0x0, 0x0) /* y<0 */)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
    return Res;
  }

  if ( is_eqC(y, 0x0, 0x0) )
  {
    Set_Value64C(Res, (IEEEDPSign_Mask_Hi + IEEEDPExponent_Mask_Hi),
                      (IEEEDPSign_Mask_Lo + IEEEDPExponent_Mask_Lo) );
    return Res;
  }
  /* check for argument == 0 or argument == +infinity */
  if ( is_eqC(y, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo) ||
       is_eqC(y, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo ))
    return y;

  /* convert the Exponent of the argument (y) to the ieeedp-format */
  Exponent = ((Get_High32of64(y) & IEEEDPExponent_Mask_Hi) >> 20) - 0x3fe;
  Exponent64 = IEEEDPFlt(Exponent);

  Set_Value64(tmp, y);
  AND64QC(tmp, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
  OR64QC(tmp, 0x3fe00000, 0x0);
  ld_M = intern_IEEEDPLd( (struct MathIeeeDoubTransBase *)
                                           MathIeeeDoubTransBase,
                          tmp );
  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld e
  */
  Set_Value64C(tmp, 0x3fe62e42, 0xfefa39ef ); /* ln 2*/
  return IEEEDPMul( IEEEDPAdd(ld_M, Exponent64), tmp);
#/Code
#/Function


#Function double IEEEDPLog10
#Options QUAD
#Parameter double y D0/D1
      IEEE double precision number
#/Parameter
#LibOffset 21
#AutoDoc
    FUNCTION
      Calculate logarithm (base 10) of the given IEEE double precision number

    RESULT
      IEEE double precision number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : argument was negative

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:

      If the Argument is negative set overflow-flag and return NAN.
      If the Argument is 0 return 0xFFF0000000000000.
      If the Argument is pos. Infinity return pos. Infinity.

      All other cases:

      (ld is the logarithm with base 2)
      (ln is the logarithm with base e)
      y = M * 2^E

      ln y = ln ( M * 2^E ) =

           = ln M + ln 2^E =

           = ln M + E * ln (2) =

             ld M        ld 2
           = ----- + E * ----- =      [ld 2 = 1]
             ld 10       ld 10

             ld M + E
           = --------
             ld 10

      ld 10 can be precalculated, of course.
      For calculating ld M see file intern_ieeespld.c

    HISTORY

#/AutoDoc
#Code
QUAD Res, tmp, Exponent64, ld_M;
LONG Exponent;
  /* check for negative sign */
  if ( is_lessSC(y, 0x0, 0x0) /* y<0 */)
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
    return Res;
  }

  if ( is_eqC(y, 0x0, 0x0) )
  {
    Set_Value64C(Res, (IEEEDPSign_Mask_Hi + IEEEDPExponent_Mask_Hi),
                      (IEEEDPSign_Mask_Lo + IEEEDPExponent_Mask_Lo) );
    return Res;
  }
  /* check for argument == 0 or argument == +infinity */
  if ( is_eqC(y, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo) ||
       is_eqC(y, IEEEDPExponent_Mask_Hi, IEEEDPExponent_Mask_Lo ) )
    return y;

  /* convert the Exponent of the argument (y) to the ieeedp-format */
  Exponent = ((Get_High32of64(y) & IEEEDPExponent_Mask_Hi) >> 20) - 0x3fe;
  Exponent64 = IEEEDPFlt(Exponent);

  Set_Value64(tmp, y);
  AND64QC(tmp, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo );
  OR64QC(tmp, 0x3fe00000, 0x0);
  ld_M = intern_IEEEDPLd( (struct MathIeeeDoubTransBase *)
                                                  MathIeeeDoubTransBase,
                          tmp );
  /*               ld M + E
  ** log(fnum1) =  --------
  **                 ld 10
  */

  Set_Value64C(tmp, 0x3fd34413, 0x509f79ff ); /* 1/ld 10*/
  return IEEEDPMul( IEEEDPAdd(ld_M, Exponent64), tmp);
#/Code
#/Function


#Function double IEEEDPPow
#Options QUAD
#Parameter double x D2/D3
    IEEE double precision floating point number
#/Parameter
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 15
#AutoDoc
    FUNCTION
      Calculate y raised to the x power (y^x)

    RESULT
      IEEE double precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  /* a ^ b  = e^(b * ln a )
  ** y ^ x  = e^(x * ln y )
  */
  QUAD Res, tmp;

  /* y^x is illegal if y<0 and x is not an integer-value */
  if (is_lessSC(y, 0x0, 0x0) &&
      is_neq(x, IEEEDPCeil(x))            )
  {
    Set_Value64C(Res, 0x0, 0x0);
    return Res;
  }

  if (is_eqC(y, 0x0, 0x0))
  {
    Set_Value64C(Res, 0x3ff00000, 0x0);
    return Res;
  }
  Set_Value64(tmp, y);
  AND64QC(tmp, (IEEEDPMantisse_Mask_Hi + IEEEDPExponent_Mask_Hi),
               (IEEEDPMantisse_Mask_Lo + IEEEDPExponent_Mask_Lo) );

  Res = IEEEDPLog(tmp);
  Res = IEEEDPMul(Res, x);
  Res = IEEEDPExp(Res);

  /* if y < 0 and x was and even integer, the result is positive, otherwise
  ** it is negative.
  */
  if ( is_lessSC(y, 0x0, 0x0) &&
       TRUE == intern_IEEEDPisodd(x) )
    OR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (is_eqC(Res, 0x0, 0x0))
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, 0x0, 0x0);
    return Res;
  }

  SetSR(0, Zero_Bit | Negative_Bit | Overflow_Bit);

  if (is_lessSC(Res, 0x0, 0x0))
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  Set_Value64(tmp, Res);
  AND64QC(tmp, (IEEEDPMantisse_Mask_Hi + IEEEDPExponent_Mask_Hi),
               (IEEEDPMantisse_Mask_Lo + IEEEDPExponent_Mask_Lo));

  if ( is_eqC(Res, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  /* don`t touch the Negative_Bit now!*/
  SetSR(Overflow_Bit, Zero_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function double IEEEDPSin
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 6
#AutoDoc
    FUNCTION
      Calculate the sine of a given IEEE double precision number in radians

    RESULT
      IEEE double precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : 0

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      Algorithm for Calculation of sin(y):
         z    = floor ( |y| / pi );
         y_1  = |y| - z * pi;        => 0 <= y_1 < pi

         if (y_1 > pi/2 ) then y_1 = pi - y_1;

         => 0 <= y_1 < pi/2

         Res = y - y^3/3! + y^5/5! - y^7/7! + y^9/9! - y^11/11! =
             = y(1+y^2(-1/3!+y^2(1/5!+y^2(-1/7!+y^2(1/9!-1/11!y^2)))));

         if (y < 0)
           Res = -Res;

         if (z was an odd number)
           Res = -Res;

    HISTORY

#/AutoDoc
#Code
  QUAD z,Res,ysquared,yabs, Qtmp;
  AND64C(yabs, y, (IEEEDPMantisse_Mask_Hi | IEEEDPExponent_Mask_Hi),
                  (IEEEDPMantisse_Mask_Lo | IEEEDPExponent_Mask_Lo));

  if (is_eqC(yabs, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
    return Res;
  }

  z = IEEEDPFloor(IEEEDPDiv(yabs, pi));
  Qtmp  = IEEEDPMul(z,pi);
  OR64QC(Qtmp, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) /* Qtmp=-Qtmp */
  yabs = IEEEDPAdd(yabs, Qtmp);
  if (is_greaterC(yabs, pio2_Hi, pio2_Lo))
  {
    OR64QC(Qtmp, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo) /* Qtmp=-Qtmp */
    yabs  =IEEEDPAdd(pi, yabs);
  }
  ysquared = IEEEDPMul(yabs,yabs);
  Res = IEEEDPMul(yabs,
         IEEEDPAdd(sinf1,
          IEEEDPMul(ysquared,
           IEEEDPAdd(sinf2,
            IEEEDPMul(ysquared,
             IEEEDPAdd(sinf3,
              IEEEDPMul(ysquared,
               IEEEDPAdd(sinf4,
                IEEEDPMul(ysquared,
                 IEEEDPAdd(sinf5,
                  IEEEDPMul(ysquared, 
                   IEEEDPAdd(sinf6,
                    IEEEDPMul(ysquared,
                     IEEEDPAdd(sinf7,
                      IEEEDPMul(ysquared, sinf8)
                     )
                    )
                   )
                  )
                 )
                )
               )
              )
             )
            )
           )
          )
         )
        );

  if (is_lessSC(y, 0x0, 0x0) )
    XOR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (TRUE == intern_IEEEDPisodd(z))
    XOR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

  if (is_eqC(Res, 0x0, 0x0))
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  if (is_lessSC(Res, 0x0 ,0x0))
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);

  return Res;
#/Code
#/Function


#Function double IEEEDPSincos
#Options QUAD
#Parameter double * z A0
      Pointer to an IEEE double precision floating point number
#/Parameter
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 9
#AutoDoc
    FUNCTION
      Calculate the cosine and the sine of the given IEEE double
      precision number where y represents an angle in radians. The 
      function returns the sine of that number as a result and puts
      the cosine of that number into *z which must represent
      a valid pointer to a IEEE double precision number.

    RESULT
      *z            - IEEE double precision floating point number
      direct result - IEEE double precision floating point number

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
  *z = IEEEDPCos(y);
  return IEEEDPSin(y);
#/Code
#/Function


#Function double IEEEDPSinh
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 10
#AutoDoc
    FUNCTION
      Calculate the hyperbolic sine of the IEEE double precision number

    RESULT
      IEEE double precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : result is too big for IEEE double precsion format

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      sinh(x) = (1/2)*( e^x- e^(-x) )

      sinh( |x| >=  18 ) = (1/2) * (e^x);

    HISTORY

#/AutoDoc
#Code
QUAD Res;
QUAD y2;

  /* y2 = y & (IEEEDPMantisse_Mask + IEEEDPExponent_Mask); */
  Set_Value64(y2, y);
  AND64QC(y2, (IEEEDPMantisse_Mask_Hi + IEEEDPExponent_Mask_Hi),
              (IEEEDPMantisse_Mask_Lo + IEEEDPExponent_Mask_Lo) );

  if ( is_eqC(y, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo))
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return y;
  }

  /* sinh(-x) = -sinh(x) */
  Res = IEEEDPExp(y2);

  if ( is_eqC(Res, IEEEDPPInfty_Hi, IEEEDPPInfty_Lo ))
   {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    if ( is_lessSC(y, 0x0, 0x0))
      OR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo );
    return Res;
  }

  if ( is_lessC(y2, 0x40320000, 0x0) )
  {
    QUAD One, ResTmp;
    Set_Value64C(One, one_Hi, one_Lo);
    ResTmp = IEEEDPDiv(One, Res);
    OR64QC(ResTmp, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);

    Res = IEEEDPAdd(Res, ResTmp);
  }
  /* Res = Res / 2 */
  ADD64QC(Res, 0xFFF00000, 0x0);

  /* at this point Res has to be positive to be valid */
  if ( is_leqSC(Res, 0x0, 0x0))
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    AND64QC(y, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    return y;
  }

  if ( is_lessSC(y, 0x0, 0x0))
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    OR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo );

    return Res;
  }
  return Res;
#/Code
#/Function


#Function double IEEEDPSqrt
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 16
#AutoDoc
    FUNCTION
      Calculate square root of IEEE double precision floating point number

    RESULT
      Motorola fast floating point number

      flags:
	zero	 : result is zero
	negative : 0
	overflow : square root could not be calculated

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS
      ALGORITHM:
	First check for a zero and a negative argument and take
	appropriate action.
	fnum = M * 2^E

	Exponent is an odd number:
	fnum = ( M*2 ) * 2^ (E-1)
	Now E' = E-1 is an even number and
	   -> sqrt(fnum) = sqrt(M)   * sqrt(2)   * sqrt (2^E')
			 = sqrt(M)   * sqrt(2)   * 2^(E'/2)
	(with sqrt(M*2)>1)
			 = sqrt(M)   * sqrt(2)   * 2^(E'/2)
										     = sqrt(M)   * 1/sqrt(2) * 2^(1+(E'/2))
			 = sqrt(M/2)             * 2^(1+(E'/2))


	Exponent is an even number:
	-> sqrt(fnum) = sqrt(M) * sqrt (2^E) =
		      = sqrt(M) * 2^(E/2)

	Now calculate the square root of the mantisse.
	The following algorithm calculates the square of a number + delta
	and compares it to the mantisse. If the square of that	number +
	delta is less than the mantisse then keep that number + delta.
	Otherwise calculate a lower offset and try again.
	Start out with number = 0;


	Exponent = -1;
	Root = 0;
	repeat
	{
	  if ( (Root + 2^Exponent)^2 < Mantisse)
	  Root += 2^Exponent
	  Exponent --;
	}
	until you`re happy with the accuracy

    HISTORY

#/AutoDoc
#Code
  QUAD Res, ResSquared, Delta, X, TargetMantisse, y2, tmp;
  int z;
  ULONG Exponent;

  if (is_eqC(y, 0, 0)) /* 0 == y */
  {
    SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, 0, 0);
    return Res;
  }
  /* is fnum negative? */
  if (is_lessSC(y, 0, 0)) /* y < 0 */
  {
    SetSR(Overflow_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    Set_Value64C(Res, IEEEDPNAN_Hi, IEEEDPNAN_Lo);
    return Res;
  }

  /* we can calculate the square-root now! */

  Set_Value64(y2, y);
  AND64QC(y2, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo);
  OR64QC(y2, 0x00100000, 0x00000000 );
  SHL64(TargetMantisse, y2, 11);

  Exponent = (Get_High32of64(y) >> 1) & IEEEDPExponent_Mask_Hi;

  /* do we have an odd exponent? */
  if (Get_High32of64(y) & 0x00100000)
  {
    /* TargetMantisse = TargetMantisse / 2; */
    SHRU64(TargetMantisse, TargetMantisse, 1); /* TargetMantisse >>= 1; */
    Exponent += 0x20000000;
  }
  else
    Exponent += 0x1ff00000;


  Set_Value64C(Res,        0x0, 0x0);
  Set_Value64C(ResSquared, 0x0, 0x0);
  z = 0;

  /* this calculates the sqrt of the mantisse. It`s short, isn`t it?
  ** Delta starts out with 0.5, then 0.25, 0.125 etc.
  */
  while ( is_neq(ResSquared, TargetMantisse) && z < 53)
  {
    QUAD Restmp, Deltatmp;
    Set_Value64C(Delta, 0x80000000, 0x00000000);
    SHRU64(Delta, Delta, z); /* Delta >> = z */

    /* X = (Res+Delta)^2 =
    **= Res^2	   + 2*Res*Delta + Delta^2
    */
    SHRU64(Restmp, Res, z);     /* Restmp   = Res   >> z */
    z++;
    SHRU64(Deltatmp, Delta, z); /* Deltatmp = Delta >> (z+1) */

    /* X = ResSquared + (Res >> z)  + (Delta >> ++z); */
		Set_Value64(X, ResSquared);
		ADD64Q(X, Restmp);
		ADD64Q(X, Deltatmp);

    if (is_leq(X, TargetMantisse)) /* X <= TargetMantisse */
    {
    //printf("setting a bit!\n");
    //OUTPUT(X);OUTPUT(TargetMantisse);
      ADD64(Res, Res, Delta );     /* Res += Delta */
      Set_Value64(ResSquared, X);   /* ResSquared = X; */
    }
  }

  SHRU64(Res, Res, 11);
  AND64QC(Res, IEEEDPMantisse_Mask_Hi, IEEEDPMantisse_Mask_Lo );
  SHL32(tmp, Exponent, 32);
  OR64Q(Res, tmp);

  return Res;
#/Code
#/Function


#Function double IEEEDPTanh
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 12
#AutoDoc
    FUNCTION
      Calculate hyperbolic tangens of the IEEE double precision number

    RESULT
      IEEE double precision floating point number

      flags:
        zero     : result is zero
        negative : result is negative
        overflow : (not possible)

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

                ( e^x - e^(-x) )
     tanh(x) =  ----------------
                ( e^x + e^(-x) )

     tanh( |x| >= 18 ) = 1

    HISTORY

#/AutoDoc
#Code
QUAD Res;
QUAD y2;
  /* y2 = y & (IEEESPMantisse_Mask + IEEESPExponent_Mask ); */
  Set_Value64(y2, y);
  AND64QC(y2, (IEEEDPMantisse_Mask_Hi + IEEEDPExponent_Mask_Hi),
              (IEEEDPMantisse_Mask_Lo + IEEEDPExponent_Mask_Lo) );

  if ( is_geqC(y2, 0x40320000, 0x0) )
  {
  /* tanh( x > 18 ) =  1
  ** tanh( x <-18 ) = -1
  */
    if ( is_lessSC(y, 0x0, 0x0))
    {
      SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
      Set_Value64C(Res, 0xbfefffff, 0xffffffff);
    }
    else
      Set_Value64C(Res, 0x3fefffff, 0xffffffff);

    return Res;
  }
  /* tanh(-x) = -tanh(x) */
  {
  QUAD One, tmp1, tmp2;
  Set_Value64C(One, 0x3ff00000, 0x0);

  Res = IEEEDPExp(y2);
  tmp1 = IEEEDPDiv(One, Res);
  Set_Value64(tmp2, tmp1);
  OR64QC(tmp2, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
  Res = IEEEDPDiv( IEEEDPAdd(Res, tmp2) ,
                   IEEEDPAdd(Res, tmp1) );
        }
  /* Result is zero */
  if (is_eqC(Res, 0x0, 0x0) )
  {
    if (is_lessSC(y, 0x0, 0x0))
      SetSR(Zero_Bit | Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    else
      SetSR(Zero_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    return Res;
  }

  /* Argument is negative -> result is negative */
  if ( is_lessSC(y, 0x0, 0x0))
  {
    SetSR(Negative_Bit, Zero_Bit | Negative_Bit | Overflow_Bit);
    OR64QC(Res, IEEEDPSign_Mask_Hi, IEEEDPSign_Mask_Lo);
    return Res;
  }

  return Res;
#/Code
#/Function


#Function LONG IEEEDPTieee
#Options QUAD
#Parameter double y D0/D1
    IEEE double precision floating point number
#/Parameter
#LibOffset 17
#AutoDoc
    FUNCTION
        Convert IEEE double to IEEE single precision number

    RESULT
        IEEE single precision number

        Flags:
          zero     : result is zero
          negative : result is negative
          overflow : value was out of range for IEEE single precision

    NOTES

    EXAMPLE

    BUGS

    SEE ALSO

    INTERNALS

    HISTORY

#/AutoDoc
#Code
LONG Res, tmp;

  SetSR(0, Zero_Bit | Overflow_Bit | Negative_Bit );

  if (is_eqC(y, 0x0, 0x0))
  {
    SetSR(Zero_Bit, Zero_Bit | Overflow_Bit | Negative_Bit );
    return 0;
  }

  SHRU32(Res, y, 52 );
  SHRU32(tmp, y, 29 );
  /* calculate the exponent */
  Res &=0x7ff;
  Res = Res + 0x7e - 0x3fe;
  Res <<= 23;

  Res |= (tmp & IEEESPMantisse_Mask);

  if (is_lessSC(y, 0x0, 0x0))
  {
    SetSR(Negative_Bit, Zero_Bit | Overflow_Bit | Negative_Bit );
    Res |= IEEESPSign_Mask;
  }

  return Res;
#/Code
#/Function

#/Archive

