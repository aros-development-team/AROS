##begin config
version 1.3
libbasetype struct GLUBase
##end config
##begin cdef
#include <GL/glu.h>
##end cdef
##begin cdefprivate
#include "glu_intern.h"
##end cdefprivate
##begin functionlist
.skip 30
void gluBeginCurve(GLUnurbs * nurb) (A0)
void gluBeginPolygon(GLUtesselator * tess) (A0)
void gluBeginSurface(GLUnurbs * nurb) (A0)
void gluBeginTrim(GLUnurbs * nurb) (A0)
GLint gluBuild1DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data) (D0, D1, D2, D3, D4, D5, D6, D7, A0)
GLint gluBuild1DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void * data) (D0, D1, D2, D3, D4, A0)
GLint gluBuild2DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data) (D0, D1, D2, D3, D4, D5, D6, D7, A0, A1)
GLint gluBuild2DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void * data) (D0, D1, D2, D3, D4, D5, A0)
GLint gluBuild3DMipmapLevels(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void * data) (D0, D1, D2, D3, D4, D5, D6, D7, A0, A1, A2)
GLint gluBuild3DMipmaps(GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data) (D0, D1, D2, D3, D4, D5, D6, A0)
GLboolean gluCheckExtension(const GLubyte * extName, const GLubyte * extString) (A0, A1)
void gluCylinder(GLUquadric * quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) (A0, D0, D1, D2, D3, D4)
void gluDeleteNurbsRenderer(GLUnurbs * nurb) (A0)
void gluDeleteQuadric(GLUquadric * quad) (A0)
void gluDeleteTess(GLUtesselator * tess) (A0)
void gluDisk(GLUquadric * quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) (A0, D0, D1, D2, D3)
void gluEndCurve(GLUnurbs * nurb) (A0)
void gluEndPolygon(GLUtesselator * tess) (A0)
void gluEndSurface(GLUnurbs * nurb) (A0)
void gluEndTrim(GLUnurbs * nurb) (A0)
const GLubyte * gluErrorString(GLenum error) (D0)
void gluGetNurbsProperty(GLUnurbs * nurb, GLenum property, GLfloat * data) (A0, D0, A1)
const GLubyte * gluGetString(GLenum name) (D0)
void gluGetTessProperty(GLUtesselator * tess, GLenum which, GLdouble * data) (A0, D0, A1)
void gluLoadSamplingMatrices(GLUnurbs * nurb, const GLfloat * model, const GLfloat * perspective, const GLint * view) (A0, A1, A2, A3)
void gluLookAt(GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) (D0, D1, D2, D3, D4, D5, D6, D7, A0)
GLUnurbs* gluNewNurbsRenderer() ()
GLUquadric* gluNewQuadric() ()
GLUtesselator* gluNewTess() ()
void gluNextContour(GLUtesselator * tess, GLenum type) (A0, D0)
void gluNurbsCallback(GLUnurbs * nurb, GLenum which, _GLUfuncptr CallBackFunc) (A0, D0, D1)
void gluNurbsCallbackData(GLUnurbs * nurb, GLvoid * userData) (A0, A1)
void gluNurbsCallbackDataEXT(GLUnurbs * nurb, GLvoid * userData) (A0, A1)
void gluNurbsCurve(GLUnurbs * nurb, GLint knotCount, GLfloat * knots, GLint stride, GLfloat * control, GLint order, GLenum type) (A0, D0, A1, D1, A2, D2, D3)
void gluNurbsProperty(GLUnurbs * nurb, GLenum property, GLfloat value) (A0, D0, D1)
void gluNurbsSurface(GLUnurbs * nurb, GLint sKnotCount, GLfloat * sKnots, GLint tKnotCount, GLfloat * tKnots, GLint sStride, GLint tStride, GLfloat * control, GLint sOrder, GLint tOrder, GLenum type) (A0, D0, A1, D1, A2, D2, D3, A3, D4, D5, D6)
void gluOrtho2D(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) (D0, D1, D2, D3)
void gluPartialDisk(GLUquadric * quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) (A0, D0, D1, D2, D3, D4, D5)
void gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) (D0, D1, D2, D3)
void gluPickMatrix(GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint * viewport) (D0, D1, D2, D3, A0)
GLint gluProject(GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble * winX, GLdouble * winY, GLdouble * winZ) (D0, D1, D2, A0, A1, A2, A3, A4, A5)
void gluPwlCurve(GLUnurbs * nurb, GLint count, GLfloat * data, GLint stride, GLenum type) (A0, D0, A1, D1, D2)
void gluQuadricCallback(GLUquadric * quad, GLenum which, _GLUfuncptr CallBackFunc) (A0, D0, D1)
void gluQuadricDrawStyle(GLUquadric * quad, GLenum draw) (A0, D0)
void gluQuadricNormals(GLUquadric * quad, GLenum normal) (A0, D0)
void gluQuadricOrientation(GLUquadric * quad, GLenum orientation) (A0, D0)
void gluQuadricTexture(GLUquadric * quad, GLboolean texture) (A0, D0)
GLint gluScaleImage(GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void * dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid * dataOut) (D0, D1, D2, D3, A0, D4, D5, D6, A1)
void gluSphere(GLUquadric * quad, GLdouble radius, GLint slices, GLint stacks) (A0, D0, D1, D2)
void gluTessBeginContour(GLUtesselator * tess) (A0)
void gluTessBeginPolygon(GLUtesselator * tess, GLvoid * data) (A0, A1)
void gluTessCallback(GLUtesselator * tess, GLenum which, _GLUfuncptr CallBackFunc) (A0, D0, D1)
void gluTessEndContour(GLUtesselator * tess) (A0)
void gluTessEndPolygon(GLUtesselator * tess) (A0)
void gluTessNormal(GLUtesselator * tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) (A0, D0, D1, D2)
void gluTessProperty(GLUtesselator * tess, GLenum which, GLdouble data) (A0, D0, D1)
void gluTessVertex(GLUtesselator * tess, GLdouble * location, GLvoid * data) (A0, A1, A2)
GLint gluUnProject(GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble * model, const GLdouble * proj, const GLint * view, GLdouble * objX, GLdouble * objY, GLdouble * objZ) (D0, D1, D2, A0, A1, A2, A3, A4, A5)
##end functionlist
