diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglcompiler.h ./src/egl/main/eglcompiler.h
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglcompiler.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/eglcompiler.h	2010-12-30 11:34:12.000000000 +0100
@@ -7,6 +7,7 @@
  */
 #if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
 #  include <stdint.h>
+#  include <stddef.h>
 #elif defined(_MSC_VER)
    typedef __int8             int8_t;
    typedef unsigned __int8    uint8_t;
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglcurrent.c ./src/egl/main/eglcurrent.c
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglcurrent.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/eglcurrent.c	2010-12-31 14:59:03.000000000 +0100
@@ -94,6 +94,35 @@
    return EGL_TRUE;
 }
 
+#elif defined(_EGL_OS_AROS)
+
+#include "aros/tls.h"
+
+static struct TaskLocalStorage * tls = NULL;
+
+static INLINE void _eglSetTSD(const _EGLThreadInfo *t)
+{
+    InsertIntoTLS(tls, (APTR)t);
+}
+
+static INLINE _EGLThreadInfo *_eglGetTSD(void)
+{
+    return (_EGLThreadInfo *)GetFromTLS(tls);
+}
+
+static INLINE EGLBoolean _eglInitTSD(void (*dtor)(_EGLThreadInfo *))
+{
+    /* FIXME: What to do with dtor? */
+    /* FIXME: atexit -> clear from TLS */
+    if (!tls)
+        tls = CreateTLS();
+
+    if (tls)
+        return EGL_TRUE;
+    else
+        return EGL_FALSE;
+}
+
 #else /* PTHREADS */
 static const _EGLThreadInfo *_egl_TSD;
 static void (*_egl_FreeTSD)(_EGLThreadInfo *);
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldisplay.c ./src/egl/main/egldisplay.c
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldisplay.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/egldisplay.c	2010-12-31 14:59:03.000000000 +0100
@@ -28,7 +28,8 @@
       { _EGL_PLATFORM_WINDOWS, "gdi" },
       { _EGL_PLATFORM_X11, "x11" },
       { _EGL_PLATFORM_DRM, "drm" },
-      { _EGL_PLATFORM_FBDEV, "fbdev" }
+      { _EGL_PLATFORM_FBDEV, "fbdev" },
+      { _EGL_PLATFORM_AROS, "aros" }
    };
    _EGLPlatformType plat = _EGL_INVALID_PLATFORM;
    const char *plat_name;
@@ -117,8 +118,15 @@
    /* search the display list first */
    dpy = _eglGlobal.DisplayList;
    while (dpy) {
+#if !defined(_EGL_OS_AROS)
+   /* It seems the _eglGlobal.DisplayList should unique per opener (not per task).
+      This is not true on AROS (_eglGlobal.DisplayList  is global for all 
+      openers). The workaround is to always create a new display object. This 
+      might fail with multithreaded applications as they might expect to have 
+      the same display object returned by GetDisplay */
       if (dpy->Platform == plat && dpy->PlatformDisplay == plat_dpy)
          break;
+#endif
       dpy = dpy->Next;
    }
 
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldisplay.h ./src/egl/main/egldisplay.h
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldisplay.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/egldisplay.h	2010-12-30 11:34:12.000000000 +0100
@@ -13,6 +13,7 @@
    _EGL_PLATFORM_X11,
    _EGL_PLATFORM_DRM,
    _EGL_PLATFORM_FBDEV,
+   _EGL_PLATFORM_AROS,
 
    _EGL_NUM_PLATFORMS,
    _EGL_INVALID_PLATFORM = -1
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldriver.c ./src/egl/main/egldriver.c
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egldriver.c	2010-10-05 03:58:00.000000000 +0200
+++ ./src/egl/main/egldriver.c	2010-12-30 11:34:12.000000000 +0100
@@ -42,6 +42,7 @@
 static _EGLArray *_eglModules;
 
 
+#if !defined(_EGL_OS_AROS)
 /**
  * Wrappers for dlopen/dlclose()
  */
@@ -204,6 +205,7 @@
    mod->Driver = NULL;
    mod->Handle = NULL;
 }
+#endif /* !defined(_EGL_OS_AROS) */
 
 
 /**
@@ -246,6 +248,7 @@
 }
 
 
+#if !defined(_EGL_OS_AROS)
 /**
  * Free a module.
  */
@@ -490,6 +493,7 @@
       _eglPreloadForEach(search_path, _eglLoaderFile, name);
    }
 }
+#endif /* !defined(_EGL_OS_AROS) */
 
 
 /**
@@ -503,9 +507,16 @@
       return EGL_TRUE;
 
    /* the order here decides the priorities of the drivers */
+#if !defined(_EGL_OS_AROS)
    _eglAddUserDriver();
    _eglAddDefaultDrivers();
    _eglPreloadForEach(_eglGetSearchPath(), _eglLoaderPattern, (void *) "egl_");
+#else
+   /* On AROS there is only one, compiled in driver - Gallium3D */
+   _EGLModule * module = _eglAddModule("EGLGALLIUMCOMPILEDIN");
+   if (module->Driver == NULL)
+      module->Driver = _eglMain(NULL); /* Explicit call to Gallium3D driver's init function */
+#endif
 
    return (_eglModules != NULL);
 }
@@ -558,6 +569,7 @@
          break;
    }
 
+#if !defined(_EGL_OS_AROS)
    /* load more modules */
    if (!best_drv) {
       EGLint first_unloaded = i;
@@ -598,6 +610,7 @@
          }
       }
    }
+#endif
 
    _eglUnlockMutex(&_eglModuleMutex);
 
@@ -734,6 +747,7 @@
 }
 
 
+#if !defined(_EGL_OS_AROS)
 /**
  * Invoke a callback function on each EGL search path.
  *
@@ -747,3 +761,4 @@
    const char *search_path = _eglGetSearchPath();
    _eglPreloadForEach(search_path, callback, callback_data);
 }
+#endif
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglglobals.c ./src/egl/main/eglglobals.c
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglglobals.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/eglglobals.c	2010-12-30 11:34:12.000000000 +0100
@@ -38,7 +38,7 @@
       _eglLockMutex(_eglGlobal.Mutex);
 
       if (!registered) {
-         atexit(_eglAtExit);
+//TODO FIXME         atexit(_eglAtExit);
          registered = EGL_TRUE;
       }
 
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egllog.c ./src/egl/main/egllog.c
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egllog.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/egllog.c	2010-12-31 16:00:25.000000000 +0100
@@ -26,11 +26,18 @@
    _EGLLogProc logger;
    EGLint num_messages;
 } logging = {
+#if !defined(_EGL_OS_AROS)
    _EGL_MUTEX_INITIALIZER,
    EGL_FALSE,
    FALLBACK_LOG_LEVEL,
    NULL,
    0
+#else
+   .initialized = EGL_FALSE,
+   .level = FALLBACK_LOG_LEVEL,
+   .logger = NULL,
+   .num_messages = 0
+#endif
 };
 
 static const char *level_strings[] = {
@@ -92,13 +99,20 @@
 }
 
 
+#if defined(_EGL_OS_AROS)
+#include <aros/debug.h>
+#endif
 /**
  * The default logger.  It prints the message to stderr.
  */
 static void
 _eglDefaultLogger(EGLint level, const char *msg)
 {
+#if !defined(_EGL_OS_AROS)
    fprintf(stderr, "libEGL %s: %s\n", level_strings[level], msg);
+#else
+   bug("[EGL]: %s: %s\n", level_strings[level], msg);
+#endif
 }
 
 
@@ -130,6 +144,9 @@
    logging.logger = _eglDefaultLogger;
    logging.level = (level >= 0) ? level : FALLBACK_LOG_LEVEL;
    logging.initialized = EGL_TRUE;
+#if defined(_EGL_OS_AROS)
+   _eglInitMutex(&logging.mutex);
+#endif
 
    /* it is fine to call _eglLog now */
    if (log_env && level < 0) {
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglmutex.h ./src/egl/main/eglmutex.h
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/eglmutex.h	2010-02-05 01:10:39.000000000 +0100
+++ ./src/egl/main/eglmutex.h	2010-12-31 16:06:43.000000000 +0100
@@ -35,6 +35,48 @@
 #define _EGL_DECLARE_MUTEX(m) \
    _EGLMutex m = _EGL_MUTEX_INITIALIZER
 
+#elif defined(_EGL_OS_AROS)
+
+#include <proto/exec.h>
+
+typedef struct SignalSemaphore _EGLMutex;
+
+static INLINE void _eglInitMutex(_EGLMutex *m)
+{
+   InitSemaphore(m);
+}
+
+static INLINE void
+_eglDestroyMutex(_EGLMutex *m)
+{
+   /* No Op */
+}
+
+static INLINE void
+_eglLockMutex(_EGLMutex *m)
+{
+   ObtainSemaphore(m);
+}
+
+static INLINE void
+_eglUnlockMutex(_EGLMutex *m)
+{
+   ReleaseSemaphore(m);
+}
+
+/* This is not supported. _eglInitMutex must alway be used */
+/* #define _EGL_MUTEX_INITIALIZER */
+
+#include <aros/symbolsets.h> /* For ADD2INIT */
+/* Declare variable, declare init function, add to auto init. Ugly but works. */
+#define _EGL_DECLARE_MUTEX(m)   \
+   _EGLMutex m;                 \
+static void init##m()           \
+{                               \
+    _eglInitMutex(&m);          \
+}                               \
+ADD2INIT(init##m, 5);
+
 #else
 
 typedef int _EGLMutex;
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egltypedefs.h ./src/egl/main/egltypedefs.h
--- /data/deadwood/source/Mesa-7.9-staging/src/egl/main/egltypedefs.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/egl/main/egltypedefs.h	2010-12-31 14:59:03.000000000 +0100
@@ -8,6 +8,12 @@
 
 #include "eglcompiler.h"
 
+#if defined(_EGL_OS_AROS)
+#include <stddef.h> /* for size_t */
+#include "egl/eglapim.h"
+#include "egl/egl_mangle.h"
+#endif
+
 typedef struct _egl_api _EGLAPI;
 
 typedef struct _egl_array _EGLArray;
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_thread.h ./src/gallium/auxiliary/os/os_thread.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_thread.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/auxiliary/os/os_thread.h	2010-12-31 16:30:53.000000000 +0100
@@ -229,6 +229,52 @@
 
 #endif /* pre-Vista win32 */
 
+#elif defined(PIPE_OS_AROS)
+
+#include <proto/exec.h>
+
+#include "os/os_time.h"
+
+typedef struct SignalSemaphore pipe_mutex;
+
+#define pipe_mutex_init(mutex) \
+   InitSemaphore(&mutex) 
+
+#define pipe_mutex_destroy(mutex) \
+   (void) mutex
+
+#define pipe_mutex_lock(mutex) \
+   ObtainSemaphore(&mutex)
+
+#define pipe_mutex_unlock(mutex) \
+   ReleaseSemaphore(&mutex)
+
+typedef int64_t pipe_condvar;
+
+#define pipe_static_condvar(condvar) \
+   static pipe_condvar condvar = 1000
+
+#define pipe_condvar_init(condvar) \
+   (void) (condvar = 1000)
+
+#define pipe_condvar_destroy(condvar) \
+   (void) condvar
+
+/* Poor man's pthread_cond_wait():
+   Just release the mutex and sleep for one millisecond.
+   The caller's while() loop does all the work. */
+#define pipe_condvar_wait(condvar, mutex) \
+   do { pipe_mutex_unlock(mutex); \
+        os_time_sleep(condvar); \
+        pipe_mutex_lock(mutex); \
+   } while (0)
+
+#define pipe_condvar_signal(condvar) \
+   (void) condvar
+
+#define pipe_condvar_broadcast(condvar) \
+   (void) condvar
+
 #else
 
 #include "os/os_time.h"
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_time.c ./src/gallium/auxiliary/os/os_time.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_time.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/auxiliary/os/os_time.c	2010-12-31 16:52:59.000000000 +0100
@@ -37,7 +37,7 @@
 
 #if !defined(PIPE_OS_EMBEDDED)
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_APPLE) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_AROS)
 #  include <sys/time.h> /* timeval */
 #elif defined(PIPE_SUBSYSTEM_WINDOWS_DISPLAY)
 #  include <windows.h>
@@ -57,7 +57,7 @@
 int64_t
 os_time_get(void)
 {
-#if defined(PIPE_OS_UNIX)
+#if defined(PIPE_OS_UNIX) || defined(PIPE_OS_AROS)
 
    struct timeval tv;
    gettimeofday(&tv, NULL);
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_time.h ./src/gallium/auxiliary/os/os_time.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/os/os_time.h	2010-04-27 23:41:59.000000000 +0200
+++ ./src/gallium/auxiliary/os/os_time.h	2010-12-31 16:51:21.000000000 +0100
@@ -38,7 +38,7 @@
 
 #include "pipe/p_config.h"
 
-#if defined(PIPE_OS_UNIX)
+#if defined(PIPE_OS_UNIX) || defined(PIPE_OS_AROS)
 #  include <unistd.h> /* usleep */
 #endif
 
@@ -60,7 +60,7 @@
 /*
  * Sleep.
  */
-#if defined(PIPE_OS_UNIX)
+#if defined(PIPE_OS_UNIX) || defined(PIPE_OS_AROS)
 #define os_time_sleep(_usecs) usleep(_usecs)
 #else
 void
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_atomic.h ./src/gallium/auxiliary/util/u_atomic.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_atomic.h	2010-10-02 01:55:56.000000000 +0200
+++ ./src/gallium/auxiliary/util/u_atomic.h	2010-12-26 19:20:30.000000000 +0100
@@ -29,8 +29,12 @@
 #define PIPE_ATOMIC_ASM_MSVC_X86                
 #elif (defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86))
 #define PIPE_ATOMIC_ASM_GCC_X86
+#elif (defined(PIPE_CC_GCC) && defined(PIPE_ARCH_ARM))
+#define PIPE_ATOMIC_ASM_GCC_ARM
 #elif (defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86_64))
 #define PIPE_ATOMIC_ASM_GCC_X86_64
+#elif defined(PIPE_OS_AROS) && defined(PIPE_ARCH_M68K)
+#define PIPE_ATOMIC_OS_AROS_CPU_M68K
 #elif defined(PIPE_CC_GCC) && (PIPE_CC_GCC_VERSION >= 401)
 #define PIPE_ATOMIC_GCC_INTRINSIC
 #else
@@ -130,6 +134,69 @@
 
 #endif
 
+#if defined(PIPE_ATOMIC_ASM_GCC_ARM)
+
+#define PIPE_ATOMIC "GCC ARM assembly"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define p_atomic_set(_v, _i) (*(_v) = (_i))
+#define p_atomic_read(_v) (*(_v))
+
+static INLINE boolean
+p_atomic_dec_zero(int32_t *v)
+{
+   unsigned long temp;
+   int result;
+   unsigned long cc;
+   __asm__ __volatile__("\n1: ldrex %0, [%3]; subs %0, %0, #1; moveq %2, #1; movne %2, #0; strex %1, %0, [%3]; teq %1, #0; bne 1b"
+						   :"=&r"(result), "=&r"(temp), "=&r"(cc)
+						   :"r"(v)
+						   :"cc");
+   return cc;
+}
+
+static INLINE void
+p_atomic_inc(int32_t *v)
+{
+   unsigned long temp;
+   int result;
+   __asm__ __volatile__("\n1: ldrex %0, [%2]; add %0, %0, #1; strex %1, %0, [%2]; teq %1, #0; bne 1b"
+		   	   	   	   	   :"=&r"(result), "=&r"(temp)
+		   	   	   	   	   :"r"(v)
+		   	   	   	   	   :"cc");
+}
+
+static INLINE void
+p_atomic_dec(int32_t *v)
+{
+   unsigned long temp;
+   int result;
+   __asm__ __volatile__("\n1: ldrex %0, [%2]; sub %0, %0, #1; strex %1, %0, [%2]; teq %1, #0; bne 1b"
+			   	   	   	   :"=&r"(result), "=&r"(temp)
+			   	   	   	   :"r"(v)
+			   	   	   	   :"cc");
+}
+
+static INLINE int32_t
+p_atomic_cmpxchg(int32_t *v, int32_t old, int32_t _new)
+{
+	  int32_t oldval;
+	   unsigned long temp;
+	   __asm__ __volatile__("\n1: ldrex %0,[%2]; teq %0, %3; strexeq %1, %4, [%2]; teq %1, #0; bne 1b"
+	                                                   :"=&r"(oldval), "=&r"(temp)
+	                                                   :"r"(v), "Ir"(old), "r"(_new)
+	                                                   :"cc");
+	   return oldval;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
 
 
 /* Implementation using GCC-provided synchronization intrinsics
@@ -343,6 +410,64 @@
 #endif
 
 
+#if defined(PIPE_ATOMIC_OS_AROS_CPU_M68K)
+
+#define PIPE_ATOMIC "AROS OS atomic functions"
+
+#include <aros/atomic.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define p_atomic_set(_v, _i) (*(_v) = (_i))
+#define p_atomic_read(_v) (*(_v))
+
+static INLINE boolean
+p_atomic_dec_zero(int32_t *v)
+{
+   boolean n;
+ 
+   /* FIXME: AROS needs an atomic decrement and return... */
+   Disable();
+   AROS_ATOMIC_DEC(*(LONG *)v);
+   n = (*v != 0) ? TRUE : FALSE;
+   Enable();
+
+   return n;
+}
+
+#define p_atomic_inc(_v) AROS_ATOMIC_INC(*(LONG *)_v)
+#define p_atomic_dec(_v) AROS_ATOMIC_DEC(*(LONG *)_v)
+
+static INLINE int32_t
+p_atomic_cmpxchg(int32_t *v, int32_t o, int32_t n)
+{
+	int32_t ret;
+
+	/* FIXME: AROS needs an atomic cmpxchg, using CAS.
+	 * However we can't do this if:
+	 *  a) We are on a 68000 or
+	 *  b) The 'v' points to Chip RAM (no r/m/w possible)
+	 *
+	 *  Settle for Disable()/Enable() for now.
+	 */
+	Disable();
+	if (*v == o)
+		*v = (n);
+	ret = *v;
+	Enable();
+
+	return ret;
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
 #ifndef PIPE_ATOMIC
 #error "No pipe_atomic implementation selected"
 #endif
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_cpu_detect.c ./src/gallium/auxiliary/util/u_cpu_detect.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_cpu_detect.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/auxiliary/util/u_cpu_detect.c	2010-12-26 19:20:30.000000000 +0100
@@ -195,9 +195,12 @@
    );
 #elif defined(PIPE_CC_GCC) && defined(PIPE_ARCH_X86_64)
    __asm __volatile (
+     "pushq %%rbx\n\t"
      "cpuid\n\t"
+     "movl %%ebx, %%esi\n\t"
+     "popq %%rbx"
      : "=a" (p[0]),
-       "=b" (p[1]),
+       "=S" (p[1]),
        "=c" (p[2]),
        "=d" (p[3])
      : "0" (ax)
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_math.c ./src/gallium/auxiliary/util/u_math.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_math.c	2010-02-05 01:10:39.000000000 +0100
+++ ./src/gallium/auxiliary/util/u_math.c	2010-12-26 19:20:30.000000000 +0100
@@ -42,6 +42,13 @@
       pow2_table[i] = (float) pow(2.0, (i - POW2_TABLE_OFFSET) / POW2_TABLE_SCALE);
 }
 
+#if defined(PIPE_OS_AROS)
+/*
+ * NOTE: log_base_2(x) = log(x) / log(2)
+ * NOTE: 1.442695 = 1/log(2).
+ */
+#define log2(x)  ((float) (log(x) * 1.442695f))
+#endif
 
 /** log2(x), for x in [1.0, 2.0) */
 float log2_table[LOG2_TABLE_SIZE];
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_math.h ./src/gallium/auxiliary/util/u_math.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/auxiliary/util/u_math.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/auxiliary/util/u_math.h	2010-12-30 11:34:12.000000000 +0100
@@ -394,6 +394,8 @@
 }
 #elif defined(__MINGW32__)
 #define ffs __builtin_ffs
+#elif defined(PIPE_OS_AROS)
+#define ffs __builtin_ffs
 #endif
 
 #ifdef __MINGW32__
@@ -498,7 +500,13 @@
 static INLINE unsigned
 util_bitcount(unsigned n)
 {
-#if defined(PIPE_CC_GCC)
+#if defined(PIPE_OS_AROS)
+   unsigned int bits;
+   for (bits = 0; n > 0; n = n >> 1) {
+      bits += (n & 1);
+   }
+   return bits;
+#elif defined(PIPE_CC_GCC)
    return __builtin_popcount(n);
 #else
    /* K&R classic bitcount.
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/drivers/nvfx/nvfx_fragprog.c ./src/gallium/drivers/nvfx/nvfx_fragprog.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/drivers/nvfx/nvfx_fragprog.c	2010-10-05 03:58:00.000000000 +0200
+++ ./src/gallium/drivers/nvfx/nvfx_fragprog.c	2010-12-26 19:20:30.000000000 +0100
@@ -1556,7 +1556,7 @@
 			struct nvfx_fragment_program_bo* next = fpbo->next;
 			nouveau_bo_unmap(fpbo->bo);
 			nouveau_bo_ref(0, &fpbo->bo);
-			free(fpbo);
+			os_free_aligned(fpbo);
 			fpbo = next;
 		}
 		while(fpbo != fp->fpbo);
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/include/pipe/p_config.h ./src/gallium/include/pipe/p_config.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/include/pipe/p_config.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/include/pipe/p_config.h	2010-12-26 19:20:30.000000000 +0100
@@ -82,6 +82,10 @@
 #define PIPE_ARCH_X86
 #endif
 
+#if defined(__arm__)
+#define PIPE_ARCH_ARM
+#endif
+
 #if defined(__x86_64__) /* gcc */ || defined(_M_X64) /* msvc */ || defined(_M_AMD64) /* msvc */ || defined(__x86_64) /* Sun cc */
 #define PIPE_ARCH_X86_64
 #endif
@@ -106,12 +110,16 @@
 #endif
 #endif
 
+#if defined(__mc68000) /* gcc */
+#define PIPE_ARCH_M68K
+#endif
+
 
 /*
  * Endian detection.
  */
 
-#if defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64)
+#if defined(PIPE_ARCH_X86) || defined(PIPE_ARCH_X86_64) || defined(PIPE_ARCH_ARM)
 #define PIPE_ARCH_LITTLE_ENDIAN
 #elif defined(PIPE_ARCH_PPC) || defined(PIPE_ARCH_PPC_64)
 #define PIPE_ARCH_BIG_ENDIAN
@@ -128,6 +136,15 @@
  * See subsystem below for a more fine-grained distinction.
  */
 
+/*
+ * In some situations __AROS__ definition can coexist with anything of
+ * the below (for example this happens on ARM port which is compiled using Linux
+ * compiler at the moment). So if we have __AROS__ we don't evaluate anything else
+ */
+#if defined(__AROS__)
+#define PIPE_OS_AROS
+#else
+
 #if defined(__linux__)
 #define PIPE_OS_LINUX
 #define PIPE_OS_UNIX
@@ -180,6 +197,8 @@
 #define PIPE_OS_UNIX
 #endif
 
+#endif
+
 /*
  * Try to auto-detect the subsystem.
  * 
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/egl_g3d.c ./src/gallium/state_trackers/egl/common/egl_g3d.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/egl_g3d.c	2010-10-05 03:58:00.000000000 +0200
+++ ./src/gallium/state_trackers/egl/common/egl_g3d.c	2010-12-31 12:55:02.000000000 +0100
@@ -75,6 +75,12 @@
          nplat = native_get_fbdev_platform();
 #endif
          break;
+      case _EGL_PLATFORM_AROS:
+         plat_name = "AROS";
+#ifdef HAVE_AROS_BACKEND
+         nplat = native_get_aros_platform();
+#endif
+         break;
       default:
          break;
       }
@@ -402,6 +408,7 @@
       gctx->stctxi->notify_invalid_framebuffer(gctx->stctxi, gsurf->stfbi);
 }
 
+#if !defined(PIPE_OS_AROS)
 static struct pipe_screen *
 egl_g3d_new_drm_screen(struct native_display *ndpy, const char *name, int fd)
 {
@@ -423,6 +430,11 @@
    egl_g3d_new_drm_screen,
    egl_g3d_new_sw_screen
 };
+#else
+static struct native_event_handler egl_g3d_native_event_handler = {
+   egl_g3d_invalid_surface
+};
+#endif
 
 static void
 egl_g3d_free_config(void *conf)
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/egl_g3d_loader.h ./src/gallium/state_trackers/egl/common/egl_g3d_loader.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/egl_g3d_loader.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/state_trackers/egl/common/egl_g3d_loader.h	2010-12-30 11:34:12.000000000 +0100
@@ -41,8 +41,10 @@
    struct st_api *(*get_st_api)(enum st_api_type api);
    struct st_api *(*guess_gl_api)(enum st_profile_type profile);
 
+#if !defined(PIPE_OS_AROS)
    struct pipe_screen *(*create_drm_screen)(const char *name, int fd);
    struct pipe_screen *(*create_sw_screen)(struct sw_winsys *ws);
+#endif
 };
 
 _EGLDriver *
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/native.h ./src/gallium/state_trackers/egl/common/native.h
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/state_trackers/egl/common/native.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/state_trackers/egl/common/native.h	2010-12-30 11:34:12.000000000 +0100
@@ -197,10 +197,12 @@
                            struct native_surface *nsurf,
                            unsigned int seq_num);
 
+#if !defined(PIPE_OS_AROS)
    struct pipe_screen *(*new_drm_screen)(struct native_display *ndpy,
                                          const char *name, int fd);
    struct pipe_screen *(*new_sw_screen)(struct native_display *ndpy,
                                         struct sw_winsys *ws);
+#endif
 };
 
 /**
@@ -232,4 +234,7 @@
 const struct native_platform *
 native_get_fbdev_platform(void);
 
+const struct native_platform *
+native_get_aros_platform(void);
+
 #endif /* _NATIVE_H_ */
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/gallium/targets/egl/egl.c ./src/gallium/targets/egl/egl.c
--- /data/deadwood/source/Mesa-7.9-staging/src/gallium/targets/egl/egl.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/gallium/targets/egl/egl.c	2010-12-30 11:34:12.000000000 +0100
@@ -68,6 +68,7 @@
    return t;
 }
 
+#if !defined(PIPE_OS_AROS)
 static EGLBoolean
 dlopen_st_module_cb(const char *dir, size_t len, void *callback_data)
 {
@@ -93,16 +94,20 @@
 
    return !(stmod->lib);
 }
+#endif
 
 static boolean
 load_st_module(struct st_module *stmod,
                        const char *name, const char *procname)
 {
+#if !defined(PIPE_OS_AROS)
    struct st_api *(*create_api)(void);
+#endif
 
    _eglLog(_EGL_DEBUG, "searching for st module %s", name);
 
    stmod->name = loader_strdup(name);
+#if !defined(PIPE_OS_AROS)
    if (stmod->name)
       _eglSearchPathForEach(dlopen_st_module_cb, (void *) stmod);
    else
@@ -119,6 +124,11 @@
          stmod->lib = NULL;
       }
    }
+#else
+   /* Select API based on requested name. Only GL for now */
+   stmod->stapi = st_api_create_OpenGL();
+   stmod->lib = NULL;
+#endif
 
    if (!stmod->stapi) {
       FREE(stmod->name);
@@ -128,6 +138,7 @@
    return (stmod->stapi != NULL);
 }
 
+#if !defined(PIPE_OS_AROS)
 static EGLBoolean
 dlopen_pipe_module_cb(const char *dir, size_t len, void *callback_data)
 {
@@ -186,6 +197,7 @@
 
    return (pmod->drmdd != NULL);
 }
+#endif
 
 static struct st_api *
 get_st_api_full(enum st_api_type api, enum st_profile_type profile)
@@ -233,9 +245,11 @@
    }
 
    if (!stmod->stapi) {
+#if !defined(PIPE_OS_AROS)
       EGLint level = (egl_g3d_loader.profile_masks[api]) ?
          _EGL_WARNING : _EGL_DEBUG;
       _eglLog(level, "unable to load " ST_PREFIX "%s" UTIL_DL_EXT, names[0]);
+#endif
    }
 
    stmod->initialized = TRUE;
@@ -271,6 +285,7 @@
    return get_st_api_full(ST_API_OPENGL, profile);
 }
 
+#if !defined(PIPE_OS_AROS)
 static struct pipe_module *
 get_pipe_module(const char *name)
 {
@@ -313,6 +328,7 @@
    return (pmod && pmod->swrast_create_screen) ?
       pmod->swrast_create_screen(ws) : NULL;
 }
+#endif
 
 static const struct egl_g3d_loader *
 loader_init(void)
@@ -333,8 +349,10 @@
 
    egl_g3d_loader.get_st_api = get_st_api;
    egl_g3d_loader.guess_gl_api = guess_gl_api;
+#if !defined(PIPE_OS_AROS)
    egl_g3d_loader.create_drm_screen = create_drm_screen;
    egl_g3d_loader.create_sw_screen = create_sw_screen;
+#endif
 
    return &egl_g3d_loader;
 }
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/glsl/ir.h ./src/glsl/ir.h
--- /data/deadwood/source/Mesa-7.9-staging/src/glsl/ir.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/glsl/ir.h	2010-12-26 19:20:30.000000000 +0100
@@ -41,6 +41,14 @@
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))
 #endif
 
+#if defined(__AROS__)
+#include <aros/debug.h>
+#undef VOLATILE
+#undef STATIC
+#define log2(x)             ((float) (log(x) * 1.442695f))
+#define printf(fmt, ...)    bug(fmt, ##__VA_ARGS__)
+#endif
+
 /**
  * \defgroup IR Intermediate representation nodes
  *
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/glsl/s_expression.cpp ./src/glsl/s_expression.cpp
--- /data/deadwood/source/Mesa-7.9-staging/src/glsl/s_expression.cpp	2010-10-02 00:51:28.000000000 +0200
+++ ./src/glsl/s_expression.cpp	2010-12-26 19:20:30.000000000 +0100
@@ -28,6 +28,11 @@
 #include <assert.h>
 #include "s_expression.h"
 
+#if defined(__AROS__)
+#include <aros/debug.h>
+#define printf(fmt, ...)    bug(fmt, ##__VA_ARGS__)
+#endif
+
 s_symbol::s_symbol(const char *tmp, size_t n)
 {
    this->str = talloc_strndup (this, tmp, n);
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mapi/glapi/glapi.h ./src/mapi/glapi/glapi.h
--- /data/deadwood/source/Mesa-7.9-staging/src/mapi/glapi/glapi.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/mapi/glapi/glapi.h	2010-12-26 19:20:30.000000000 +0100
@@ -82,6 +82,32 @@
 typedef void (*_glapi_proc)(void);
 struct _glapi_table;
 
+#if defined(__AROS__)
+
+#if defined(__i386__)
+register struct MesaBase * REGMesaBase __asm__("ebx");
+#elif defined(__x86_64__)
+register struct MesaBase * REGMesaBase __asm__("rbx");
+#elif defined(__arm__)
+register struct MesaBase * REGMesaBase __asm__("r10");
+#elif defined(PPC) || defined (__powerpc__)
+/*
+ * r11 or r12 emit call clobbered register warnings
+ * r13 works as well, but is small data area pointer
+ * in SysV ABI, which we might use in the future
+ */
+register struct MesaBase * REGMesaBase __asm__("r14");
+#else
+#error Select register for your architecture
+#endif
+
+#define SAVE_REG            struct MesaBase * reg = REGMesaBase;
+#define PUT_MESABASE_IN_REG REGMesaBase = (struct MesaBase *)MesaBase;
+#define RESTORE_REG         REGMesaBase = reg;
+extern void                     **GETMESABASECTX(void);
+extern struct _glapi_table      **GETMESABASEDDISPATCH(void);
+#endif
+
 
 #if defined (GLX_USE_TLS)
 
@@ -99,8 +125,18 @@
 
 #else
 
+#if defined(__AROS__)
+# if defined(USE_MGL_NAMESPACE)
+#  define _mglapi_Context *(GETMESABASECTX())
+#  define _mglapi_Dispatch *(GETMESABASEDDISPATCH())
+# else
+#  define _glapi_Context *(GETMESABASECTX())
+#  define _glapi_Dispatch *(GETMESABASEDDISPATCH())
+# endif
+#else
 _GLAPI_EXPORT extern struct _glapi_table *_glapi_Dispatch;
 _GLAPI_EXPORT extern void *_glapi_Context;
+#endif
 
 # ifdef THREADS
 
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mapi/mapi/u_current.c ./src/mapi/mapi/u_current.c
--- /data/deadwood/source/Mesa-7.9-staging/src/mapi/mapi/u_current.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/mapi/mapi/u_current.c	2010-12-30 11:34:12.000000000 +0100
@@ -111,9 +111,22 @@
 
 #else
 
+#if defined(__AROS__)
+#include "aros/arosmesa_intern.h"
+void **GETMESABASECTX(void)
+{
+    return &(REGMesaBase->mglb_CurrentContext);
+}
+
+struct _glapi_table **GETMESABASEDDISPATCH(void)
+{
+    return (struct _glapi_table **)&(REGMesaBase->mglb_Dispatch);
+}
+#else
 struct mapi_table *u_current_table =
    (struct mapi_table *) table_noop_array;
 void *u_current_user;
+#endif
 
 #ifdef THREADS
 struct u_tsd u_current_table_tsd;
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mapi/mapi/u_thread.c ./src/mapi/mapi/u_thread.c
--- /data/deadwood/source/Mesa-7.9-staging/src/mapi/mapi/u_thread.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/mapi/mapi/u_thread.c	2010-12-26 19:20:30.000000000 +0100
@@ -222,7 +222,7 @@
  */
 
 unsigned long
-_glthread_GetID(void)
+u_thread_self(void)
 {
    return 0;
 }
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/compiler.h ./src/mesa/main/compiler.h
--- /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/compiler.h	2010-10-02 00:51:28.000000000 +0200
+++ ./src/mesa/main/compiler.h	2010-12-26 19:20:30.000000000 +0100
@@ -251,6 +251,8 @@
 #elif defined(__APPLE__)
 #include <CoreFoundation/CFByteOrder.h>
 #define CPU_TO_LE32( x )	CFSwapInt32HostToLittle( x )
+#elif defined(__AROS__)
+#define CPU_TO_LE32( x )    AROS_BE2LONG( x )
 #elif (defined(_AIX) || defined(__blrts))
 static INLINE GLuint CPU_TO_LE32(GLuint x)
 {
@@ -318,6 +320,9 @@
 /**
  * ASSERT macro
  */
+#if defined(__AROS__)
+#undef ASSERT
+#endif
 #if !defined(_WIN32_WCE)
 #if defined(BUILD_FOR_SNAP) && defined(CHECKED)
 #  define ASSERT(X)   _CHECK(X) 
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/context.c ./src/mesa/main/context.c
--- /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/context.c	2010-10-05 03:58:00.000000000 +0200
+++ ./src/mesa/main/context.c	2010-12-26 19:20:30.000000000 +0100
@@ -439,7 +439,7 @@
    /* Hopefully atexit() is widely available.  If not, we may need some
     * #ifdef tests here.
     */
-   atexit(_mesa_destroy_shader_compiler);
+//TODO FIXME   atexit(_mesa_destroy_shader_compiler);
 
    dummy_enum_func();
 }
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/imports.c ./src/mesa/main/imports.c
--- /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/imports.c	2010-10-02 00:51:28.000000000 +0200
+++ ./src/mesa/main/imports.c	2010-12-26 19:20:30.000000000 +0100
@@ -457,7 +457,7 @@
 int
 _mesa_ffs(int32_t i)
 {
-#if (defined(_WIN32) ) || defined(__IBMC__) || defined(__IBMCPP__)
+#if (defined(_WIN32) ) || defined(__IBMC__) || defined(__IBMCPP__) || defined(__AROS__)
    register int bit = 0;
    if (i != 0) {
       if ((i & 0xffff) == 0) {
@@ -520,7 +520,8 @@
 unsigned int
 _mesa_bitcount(unsigned int n)
 {
-#if defined(__GNUC__) && \
+/* AROS: don't use __builtin_popcount */
+#if !defined(__AROS__) && defined(__GNUC__) && \
 	((_GNUC__ == 3 && __GNUC_MINOR__ >= 4) || __GNUC__ >= 4)
    return __builtin_popcount(n);
 #else
diff -ur /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/querymatrix.c ./src/mesa/main/querymatrix.c
--- /data/deadwood/source/Mesa-7.9-staging/src/mesa/main/querymatrix.c	2010-10-05 03:58:00.000000000 +0200
+++ ./src/mesa/main/querymatrix.c	2010-12-26 19:20:30.000000000 +0100
@@ -76,6 +76,10 @@
      (defined(__sun) && defined(__GNUC__))
 
 /* fpclassify is available. */
+#elif defined(__AROS__)
+
+#undef fpclassify
+#define fpclassify(x)   FP_NORMAL
 
 #elif !defined(_XOPEN_SOURCE) || _XOPEN_SOURCE < 600
 
