diff -ur ./xf86-video-nouveau-src/nouveau_local.h ./xf86-video-nouveau/nouveau_local.h
--- ./xf86-video-nouveau-src/nouveau_local.h	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nouveau_local.h	2011-05-03 09:44:27.000000000 +0200
@@ -23,6 +23,7 @@
 #ifndef __NOUVEAU_LOCAL_H__
 #define __NOUVEAU_LOCAL_H__
 
+#if !defined(__AROS__)
 #include "compiler.h"
 #include "xf86_OSproc.h"
 
@@ -40,6 +41,7 @@
 	return FALSE;                         \
 } while(0)
 #endif
+#endif
 
 #define NOUVEAU_ALIGN(x,bytes) (((x) + ((bytes) - 1)) & ~((bytes) - 1))
 
diff -ur ./xf86-video-nouveau-src/nv30_exa.c ./xf86-video-nouveau/nv30_exa.c
--- ./xf86-video-nouveau-src/nv30_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv30_exa.c	2011-05-03 10:10:56.000000000 +0200
@@ -25,7 +25,13 @@
 
 #include "nv_include.h"
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+#include <aros/debug.h>
+
+#define NV30EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -54,8 +60,10 @@
 		float height;
 	} unit[2];
 } nv30_exa_state_t;
+#if !defined(__AROS__)
 static nv30_exa_state_t exa_state;
 #define NV30EXA_STATE nv30_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV30SurfaceFormat[] = {
@@ -223,7 +231,8 @@
 /* Atop        */ { 1, 1, BF(          DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) }
+/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
+/* OverAlpha   */ { 1, 0, BF(          SRC_ALPHA), BF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -299,8 +308,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv30_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -326,9 +340,17 @@
 	if (OUT_RELOCl(chan, bo, 0, tex_reloc) ||
 	    OUT_RELOCd(chan, bo, NV34TCL_TX_FORMAT_DIMS_2D | (1 << 16) | 8 |
 		       (fmt->card_fmt << NV34TCL_TX_FORMAT_FORMAT_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.width) <<
+#else
+		       (log2i(pPix->width) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_U_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.height) <<
+#else
+		       (log2i(pPix->height) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_V_SHIFT),
 		       tex_reloc | NOUVEAU_BO_OR,
 		       NV34TCL_TX_FORMAT_DMA0, NV34TCL_TX_FORMAT_DMA1))
@@ -343,12 +365,21 @@
 	OUT_RING  (chan, (card_filter << NV34TCL_TX_FILTER_MINIFY_SHIFT) /* min */ |
 			(card_filter << NV34TCL_TX_FILTER_MAGNIFY_SHIFT) /* mag */ |
 			0x2000 /* engine lock */);
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 
 	return TRUE;
 }
@@ -379,6 +410,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -460,7 +492,9 @@
 	NV30EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV30EXAPrepareComposite(int op, PicturePtr psPict,
 		PicturePtr pmPict,
@@ -470,6 +504,17 @@
 		PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV30EXAPrepareComposite(int op, PicturePtr psPict,
+		PicturePtr pmPict,
+		PicturePtr pdPict,
+		PixmapPtr  psPix,
+		PixmapPtr  pmPix,
+		PixmapPtr  pdPix,
+		ScrnInfoPtr pScrn, nv30_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -487,7 +532,11 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV30_SetupSurface(pScrn, pdPix, pdPict) ||
+#if !defined(__AROS__)
 	    !NV30EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV30EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
@@ -507,7 +556,11 @@
 #endif
 
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -537,6 +590,7 @@
 	BEGIN_RING(chan, rankine, 0x23c, 1);
 	OUT_RING  (chan, pmPict?3:1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -545,6 +599,7 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV30EXAStateCompositeReemit;
+#endif
 	return TRUE;
 }
 
@@ -555,15 +610,21 @@
 NV30EXATransformCoord(PictTransformPtr t, int x, int y, float sx, float sy,
 					  float *x_ret, float *y_ret)
 {
+#if !defined(__AROS__)
 	PictVector v;
+#endif
 
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
 		v.vector[2] = xFixed1;
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]);
 		*y_ret = xFixedToFloat(v.vector[1]);
+#endif
 	} else {
 		*x_ret = (float)x;
 		*y_ret = (float)y;
@@ -584,6 +645,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -591,6 +653,14 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, ScrnInfoPtr pScrn, nv30_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -652,6 +722,7 @@
 	OUT_RING  (chan, 0);
 }
 
+#if !defined(__AROS__)
 void
 NV30EXADoneComposite(PixmapPtr pdPix)
 {
@@ -661,6 +732,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 Bool
 NVAccelInitNV30TCL(ScrnInfoPtr pScrn)
@@ -914,3 +986,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV303DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv30_exa_state_t state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV30EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata, &state))
+    {
+        NV30EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv30_shaders.c ./xf86-video-nouveau/nv30_shaders.c
--- ./xf86-video-nouveau-src/nv30_shaders.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv30_shaders.c	2011-05-02 23:41:21.000000000 +0200
@@ -20,9 +20,10 @@
  * SOFTWARE.
  */
 
-
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#endif
 
 void NV30_UploadFragProg(NVPtr pNv, nv_shader_t *shader, int *hw_offset)
 {
diff -ur ./xf86-video-nouveau-src/nv40_exa.c ./xf86-video-nouveau/nv40_exa.c
--- ./xf86-video-nouveau-src/nv40_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv40_exa.c	2011-05-03 09:32:24.000000000 +0200
@@ -22,7 +22,13 @@
 
 #include "nv_include.h"
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+#include <aros/debug.h>
+
+#define NV40EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -51,8 +57,10 @@
 		float height;
 	} unit[2];
 } nv40_exa_state_t;
+#if !defined(__AROS__)
 static nv40_exa_state_t exa_state;
 #define NV40EXA_STATE nv40_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV40SurfaceFormat[] = {
@@ -172,7 +180,8 @@
 /* Atop        */ { 1, 1, SF(          DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) }
+/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) },
+/* OverAlpha   */ { 1, 0, SF(          SRC_ALPHA), DF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -233,8 +242,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv40_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -291,6 +305,7 @@
 		OUT_RING  (chan, NV40TCL_TEX_FILTER_MIN_NEAREST |
 				 NV40TCL_TEX_FILTER_MAG_NEAREST | 0x3fd6);
 	}
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << 16) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
@@ -300,6 +315,17 @@
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << 16) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
+	OUT_RING  (chan, (1 << NV40TCL_TEX_SIZE1_DEPTH_SHIFT) |
+			 (uint32_t)pPix->pitch);
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 	return TRUE;
 }
 
@@ -329,6 +355,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -406,7 +433,9 @@
 	NV40EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV40EXAPrepareComposite(int op, PicturePtr psPict,
 				PicturePtr pmPict,
@@ -416,6 +445,17 @@
 				PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV40EXAPrepareComposite(int op, PicturePtr psPict,
+				PicturePtr pmPict,
+				PicturePtr pdPict,
+				PixmapPtr  psPix,
+				PixmapPtr  pmPix,
+				PixmapPtr  pdPix,
+				ScrnInfoPtr pScrn, nv40_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
@@ -433,14 +473,22 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV40_SetupSurface(pScrn, pdPix, pdPict->format) ||
+#if !defined(__AROS__)
 	    !NV40EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV40EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
 
 	NV40_LoadVtxProg(pScrn, &nv40_vp_exa_render);
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -476,6 +524,7 @@
 	BEGIN_RING(chan, curie, NV40TCL_TEX_CACHE_CTL, 1);
 	OUT_RING  (chan, 1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -484,6 +533,7 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV40EXAStateCompositeReemit;
+#endif
 	return TRUE;
 }
 
@@ -495,6 +545,9 @@
 					  float *x_ret, float *y_ret)
 {
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		PictVector v;
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
@@ -502,6 +555,7 @@
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]) / sx;
 		*y_ret = xFixedToFloat(v.vector[1]) / sy;
+#endif
 	} else {
 		*x_ret = (float)x / sx;
 		*y_ret = (float)y / sy;
@@ -522,6 +576,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -529,11 +584,19 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, ScrnInfoPtr pScrn, nv40_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
-	float sX0, sX1, sX2, sY0, sY1, sY2;
-	float mX0, mX1, mX2, mY0, mY1, mY2;
+	float sX0=0.0f, sX1=0.0f, sX2=0.0f, sY0=0.0f, sY1=0.0f, sY2=0.0f;
+	float mX0=0.0f, mX1=0.0f, mX2=0.0f, mY0=0.0f, mY1=0.0f, mY2=0.0f;
 	NV40EXA_STATE;
 
 	WAIT_RING(chan, 64);
@@ -587,6 +650,7 @@
 	OUT_RING  (chan, NV40TCL_BEGIN_END_STOP);
 }
 
+#if !defined(__AROS__)
 void
 NV40EXADoneComposite(PixmapPtr pdPix)
 {
@@ -596,6 +660,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 #define NV40TCL_CHIPSET_4X_MASK 0x00000baf
 #define NV44TCL_CHIPSET_4X_MASK 0x00005450
@@ -760,3 +825,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV403DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv40_exa_state_t state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV40EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata, &state))
+    {
+        NV40EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv_accel_common.c ./xf86-video-nouveau/nv_accel_common.c
--- ./xf86-video-nouveau-src/nv_accel_common.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv_accel_common.c	2011-05-03 09:29:28.000000000 +0200
@@ -21,8 +21,19 @@
  */
 
 #include "nv_include.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+
+#include <aros/debug.h>
+
+/* Some overriding defines for AROS */
+#define NOUVEAU_CREATE_PIXMAP_ZETA      0x10000000
+#define NOUVEAU_CREATE_PIXMAP_TILED     0x20000000
+#define NOUVEAU_CREATE_PIXMAP_SCANOUT   0x40000000
+#endif
 
+#if !defined(__AROS__)
 Bool
 nouveau_allocate_surface(ScrnInfoPtr scrn, int width, int height, int bpp,
 			 int usage_hint, int *pitch, struct nouveau_bo **bo)
@@ -149,6 +160,7 @@
 	BEGIN_RING(chan, blit, 0x00000130, 1);
 	OUT_RING  (chan, 0);
 }
+#endif
 
 static Bool
 NVAccelInitDmaNotifier0(ScrnInfoPtr pScrn)
@@ -193,6 +205,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 /* FLAGS_ROP_AND, DmaFB, DmaFB, 0 */
 static Bool
 NVAccelInitContextBeta1(ScrnInfoPtr pScrn)
@@ -233,11 +246,16 @@
 	OUT_RING  (chan, 0xffff0000);
 	return TRUE;
 }
+#endif
 
 Bool
 NVAccelGetCtxSurf2DFormatFromPixmap(PixmapPtr pPix, int *fmt_ret)
 {
+#if !defined(__AROS__)
 	switch (pPix->drawable.bitsPerPixel) {
+#else
+    switch (pPix->bytesperpixel * 8) {
+#endif
 	case 32:
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_A8R8G8B8;
 		break;
@@ -245,7 +263,11 @@
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X8R8G8B8_Z8R8G8B8;
 		break;
 	case 16:
+#if !defined(__AROS__)
 		if (pPix->drawable.depth == 16)
+#else
+        if (pPix->depth == 16)
+#endif
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_R5G6B5;
 		else
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X1R5G5B5_Z1R5G5B5;
@@ -260,6 +282,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 Bool
 NVAccelGetCtxSurf2DFormatFromPicture(PicturePtr pPict, int *fmt_ret)
 {
@@ -292,6 +315,7 @@
 	else
 		return (PixmapPtr) pDraw;
 }
+#endif
 
 static Bool
 NVAccelInitImagePattern(ScrnInfoPtr pScrn)
@@ -339,7 +363,7 @@
 	BEGIN_RING(chan, rop, NV03_CONTEXT_ROP_DMA_NOTIFY, 1);
 	OUT_RING  (chan, chan->nullobj->handle);
 
-	pNv->currentRop = ~0;
+//	pNv->currentRop = ~0;
 	return TRUE;
 }
 
@@ -421,6 +445,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitScaledImage(ScrnInfoPtr pScrn)
 {
@@ -491,6 +516,7 @@
 
 	return TRUE;
 }
+#endif
 
 /* FLAGS_NONE, NvDmaFB, NvDmaAGP, NvDmaNotifier0 */
 static Bool
@@ -522,6 +548,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitImageFromCpu(ScrnInfoPtr pScrn)
 {
@@ -571,6 +598,7 @@
 
 	return TRUE;
 }
+#endif
 
 static Bool
 NVAccelInit2D_NV50(ScrnInfoPtr pScrn)
@@ -602,10 +630,11 @@
 	BEGIN_RING(chan, eng2d, 0x58c, 1);
 	OUT_RING  (chan, 0x111);
 
-	pNv->currentRop = 0xfffffffa;
+//	pNv->currentRop = 0xfffffffa;
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 #define INIT_CONTEXT_OBJECT(name) do {                                        \
 	ret = NVAccelInit##name(pScrn);                                       \
 	if (!ret) {                                                           \
@@ -615,6 +644,16 @@
 		return FALSE;                                                 \
 	}                                                                     \
 } while(0)
+#else
+#define INIT_CONTEXT_OBJECT(name) do {                                      \
+	ret = NVAccelInit##name(pScrn);                                         \
+	if (!ret) {                                                             \
+		bug("[nouveau] Failed to initialise context object: "#name          \
+			   " (%d)\n", ret);                                             \
+		return FALSE;                                                       \
+	}                                                                       \
+} while(0)
+#endif
 
 Bool
 NVAccelCommonInit(ScrnInfoPtr pScrn)
@@ -622,8 +661,10 @@
 	NVPtr pNv = NVPTR(pScrn);
 	Bool ret;
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return TRUE;
+#endif
 
 	/* General engine objects */
 	if (pNv->Architecture < NV_ARCH_C0)
@@ -632,45 +673,45 @@
 	/* 2D engine */
 	if (pNv->Architecture < NV_ARCH_50) {
 		INIT_CONTEXT_OBJECT(ContextSurfaces);
-		INIT_CONTEXT_OBJECT(ContextBeta1);
-		INIT_CONTEXT_OBJECT(ContextBeta4);
+//		INIT_CONTEXT_OBJECT(ContextBeta1);
+//		INIT_CONTEXT_OBJECT(ContextBeta4);
 		INIT_CONTEXT_OBJECT(ImagePattern);
 		INIT_CONTEXT_OBJECT(RasterOp);
 		INIT_CONTEXT_OBJECT(Rectangle);
 		INIT_CONTEXT_OBJECT(ImageBlit);
-		INIT_CONTEXT_OBJECT(ScaledImage);
-		INIT_CONTEXT_OBJECT(ClipRectangle);
-		INIT_CONTEXT_OBJECT(ImageFromCpu);
+//		INIT_CONTEXT_OBJECT(ScaledImage);
+//		INIT_CONTEXT_OBJECT(ClipRectangle);
+//		INIT_CONTEXT_OBJECT(ImageFromCpu);
 	} else
 	if (pNv->Architecture < NV_ARCH_C0) {
 		INIT_CONTEXT_OBJECT(2D_NV50);
 	} else {
-		INIT_CONTEXT_OBJECT(2D_NVC0);
+//		INIT_CONTEXT_OBJECT(2D_NVC0);
 	}
 
 	if (pNv->Architecture < NV_ARCH_C0)
 		INIT_CONTEXT_OBJECT(MemFormat);
-	else
-		INIT_CONTEXT_OBJECT(M2MF_NVC0);
+//	else
+//		INIT_CONTEXT_OBJECT(M2MF_NVC0);
 
 	/* 3D init */
 	switch (pNv->Architecture) {
-	case NV_ARCH_C0:
-		INIT_CONTEXT_OBJECT(3D_NVC0);
-		break;
-	case NV_ARCH_50:
-		INIT_CONTEXT_OBJECT(NV50TCL);
-		break;
+//	case NV_ARCH_C0:
+//		INIT_CONTEXT_OBJECT(3D_NVC0);
+//		break;
+//	case NV_ARCH_50:
+//		INIT_CONTEXT_OBJECT(NV50TCL);
+//		break;
 	case NV_ARCH_40:
 		INIT_CONTEXT_OBJECT(NV40TCL);
 		break;
 	case NV_ARCH_30:
 		INIT_CONTEXT_OBJECT(NV30TCL);
 		break;
-	case NV_ARCH_20:
-	case NV_ARCH_10:
-		INIT_CONTEXT_OBJECT(NV10TCL);
-		break;
+//	case NV_ARCH_20:
+//	case NV_ARCH_10:
+//		INIT_CONTEXT_OBJECT(NV10TCL);
+//		break;
 	default:
 		break;
 	}
@@ -682,27 +723,29 @@
 {
 	NVPtr pNv = NVPTR(pScrn);
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return;
+#endif
 
 	nouveau_notifier_free(&pNv->notify0);
-	nouveau_notifier_free(&pNv->vblank_sem);
+//	nouveau_notifier_free(&pNv->vblank_sem);
 
 	nouveau_grobj_free(&pNv->NvContextSurfaces);
-	nouveau_grobj_free(&pNv->NvContextBeta1);
-	nouveau_grobj_free(&pNv->NvContextBeta4);
+//	nouveau_grobj_free(&pNv->NvContextBeta1);
+//	nouveau_grobj_free(&pNv->NvContextBeta4);
 	nouveau_grobj_free(&pNv->NvImagePattern);
 	nouveau_grobj_free(&pNv->NvRop);
 	nouveau_grobj_free(&pNv->NvRectangle);
 	nouveau_grobj_free(&pNv->NvImageBlit);
-	nouveau_grobj_free(&pNv->NvScaledImage);
-	nouveau_grobj_free(&pNv->NvClipRectangle);
-	nouveau_grobj_free(&pNv->NvImageFromCpu);
+//	nouveau_grobj_free(&pNv->NvScaledImage);
+//	nouveau_grobj_free(&pNv->NvClipRectangle);
+//	nouveau_grobj_free(&pNv->NvImageFromCpu);
 	nouveau_grobj_free(&pNv->Nv2D);
 	nouveau_grobj_free(&pNv->NvMemFormat);
-	nouveau_grobj_free(&pNv->NvSW);
+//	nouveau_grobj_free(&pNv->NvSW);
 	nouveau_grobj_free(&pNv->Nv3D);
 
-	nouveau_bo_ref(NULL, &pNv->tesla_scratch);
+//	nouveau_bo_ref(NULL, &pNv->tesla_scratch);
 	nouveau_bo_ref(NULL, &pNv->shader_mem);
 }
diff -ur ./xf86-video-nouveau-src/nv_include.h ./xf86-video-nouveau/nv_include.h
--- ./xf86-video-nouveau-src/nv_include.h	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv_include.h	2011-05-03 10:02:14.000000000 +0200
@@ -1,84 +1,106 @@
 #ifndef __NV_INCLUDE_H__
 #define __NV_INCLUDE_H__
+/*
+    Copyright © 2011, The AROS Development Team. All rights reserved.
+    $Id$
+*/
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <string.h>
-#include <math.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-/* All drivers should typically include these */
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#define PPC_MMIO_IS_BE
-#include "compiler.h"
-
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
-/* Drivers that need to access the PCI config space directly need this */
-#include "xf86Pci.h"
-
-/* All drivers initialising the SW cursor need this */
-#include "mipointer.h"
-
-/* All drivers implementing backing store need this */
-#include "mibstore.h"
-
-#include "micmap.h"
-
-#include "xf86DDC.h"
-
-#include "vbe.h"
-
-#include "xf86RandR12.h"
-
-#include "nv_const.h"
-
-#include "dixstruct.h"
-#include "scrnintstr.h"
-
-#include "fb.h"
-
-#include "xf86cmap.h"
-#include "shadowfb.h"
-
-#include "xf86xv.h"
-#include <X11/extensions/Xv.h>
-
-#include "xf86Cursor.h"
-#include "xf86DDC.h"
-
-#include "region.h"
-
-#include <X11/extensions/randr.h>
-
-#ifdef HAVE_XEXTPROTO_71
-#include <X11/extensions/dpmsconst.h>
-#else
-#define DPMS_SERVER
-#include <X11/extensions/dpms.h>
-#endif
-
-#define NV_DMA_DEBUG 0
-
-#include "nv_type.h"
-#include "nv_proto.h"
-#include "nv_dma.h"
+#include "nouveau_intern.h"
 #include "nouveau_class.h"
-#include "sarea.h"
 
-#include "nouveau_drmif.h"
-#include "nouveau_device.h"
-#include "nouveau_channel.h"
-#include "nouveau_bo.h"
-#include "nouveau_grobj.h"
-#include "nouveau_notifier.h"
 #include "nouveau_local.h"
-#include "nouveau_pushbuf.h"
+
+/* Some overriding defines for AROS */
+#define Bool                        BOOL
+#define ScrnInfoPtr                 struct CardData *
+#define NVPTR(x)                    x
+#define NVPtr                       struct CardData *
+#define Architecture                architecture
+#define PixmapPtr                   struct HIDDNouveauBitMapData *
+#define xf86DrvMsg(a, b, fmt, ...)  bug(fmt, ##__VA_ARGS__)
+#define ErrorF(msg)                 bug(msg)
+#define PictFormatShort             LONG
+#define PictTransformPtr            APTR
+
+struct Picture
+{
+    LONG format;
+    BOOL componentAlpha;
+    LONG filter;
+    BOOL repeat;
+    LONG repeatType;
+};
+
+typedef struct Picture * PicturePtr;
+
+#define PictFilterNearest   1
+#define PictFilterBilinear  2
+
+#define RepeatNormal        1
+#define RepeatReflect       2
+#define RepeatPad           3
+
+#define PICT_UNKNOWN        0
+#define PICT_a8r8g8b8       1
+#define PICT_x8r8g8b8       2
+#define PICT_x8b8g8r8       3
+#define PICT_a8b8g8r8       4
+#define PICT_a1r5g5b5       5
+#define PICT_x1r5g5b5       6
+#define PICT_a1b5g5r5       7
+#define PICT_x1b5g5r5       8
+#define PICT_x4r4g4b4       9
+#define PICT_a4r4g4b4       10
+#define PICT_x4b4g4r4       11
+#define PICT_a4b4g4r4       12
+#define PICT_r5g6b5         13
+#define PICT_b5g6r5         14
+#define PICT_a8             15
+
+#define nouveau_pixmap_bo(x)    (x->bo)
+#define exaGetPixmapPitch(x)    (x->pitch)
+
+#define PictOpSaturate      14
+
+Bool NVAccelInitNV40TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV30TCL(ScrnInfoPtr pScrn);
+
+
+static inline BOOL PICT_FORMAT_A(int format)
+{
+    if ((format == PICT_a8r8g8b8) || (format == PICT_a1r5g5b5) || (format == PICT_a8))
+        return TRUE;
+
+    return FALSE;
+}
+
+#define PICT_FORMAT_RGB(x)  !PICT_FORMAT_A(x)
+
+static inline VOID HIDDNouveauFillPictureFromBitMapData(struct Picture * pPict, 
+    struct HIDDNouveauBitMapData * bmdata)
+{
+    /* pPict->format */
+    if (bmdata->depth == 32)
+        pPict->format = PICT_a8r8g8b8;
+    else if (bmdata->depth == 24)
+        pPict->format = PICT_x8r8g8b8;
+    else if (bmdata->depth == 16)
+        pPict->format = PICT_r5g6b5;
+    else
+        pPict->format = PICT_UNKNOWN;
+
+    /* pPict->componentAlpha - keep this always as FALSE, used when mask
+       bitmap would be present (which is not the case in AROS */
+    pPict->componentAlpha = FALSE;
+    
+    /* pPict->filter - keep this always as PictFilterNearest, unless you want
+       bi-linear (probably slower and might give weird effects */
+    pPict->filter = PictFilterNearest;
+    
+    /* pPict->repeat - keep this always as FALSE */
+    pPict->repeat = FALSE;
+    /* pPict->repeatType - value does not matter as long as repeat is FALSE */
+    pPict->repeatType = RepeatNormal;
+}
 
 #endif /* __NV_INCLUDE_H__ */
