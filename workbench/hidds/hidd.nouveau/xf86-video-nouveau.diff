diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nouveau_exa.c xf86-video-nouveau/nouveau_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nouveau_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nouveau_exa.c	2011-10-05 18:57:25.000000000 +0200
@@ -22,6 +22,7 @@
 
 #include "nv_include.h"
 #include "nv04_pushbuf.h"
+#if !defined(__AROS__)
 #include "exa.h"
 
 static inline Bool
@@ -40,17 +41,31 @@
 
 	return TRUE;
 }
+#endif
 
+#if !defined(__AROS__)
 static inline Bool
 NVAccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
 		    char *dst, unsigned dst_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pspix->drawable.pScreen->myNum];
+#else
+static inline Bool
+NVAccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
+		    char *dst, unsigned dst_pitch,
+		    HIDDT_StdPixFmt dstPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pspix);
+#if !defined(__AROS__)
 	unsigned cpp = pspix->drawable.bitsPerPixel / 8;
+#else
+	unsigned cpp = pspix->depth > 16 ? 4 : 2;
+#endif
 	unsigned line_len = w * cpp;
 	unsigned src_offset = 0, src_pitch = 0, linear = 0;
 	/* Maximum DMA transfer */
@@ -90,8 +105,13 @@
 				BEGIN_RING(chan, m2mf, NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_IN, 7);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, bo->tile_mode << 4);
+#if !defined(__AROS__)
 				OUT_RING  (chan, pspix->drawable.width * cpp);
 				OUT_RING  (chan, pspix->drawable.height);
+#else
+				OUT_RING  (chan, pspix->width * cpp);
+				OUT_RING  (chan, pspix->height);
+#endif
 				OUT_RING  (chan, 1);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, (y << 16) | (x * cpp));
@@ -134,6 +154,7 @@
 			return FALSE;
 		}
 		src = pNv->GART->map;
+#if !defined(__AROS__)
 		if (dst_pitch == line_len) {
 			memcpy(dst, src, dst_pitch * line_count);
 			dst += dst_pitch * line_count;
@@ -144,6 +165,15 @@
 				dst += dst_pitch;
 			}
 		}
+#else
+        (void)i;
+        HiddNouveauReadIntoRAM(
+            src, line_len,
+            dst, dst_pitch, dstPixFmt,
+            w, line_count,
+            cl, o);
+        dst += dst_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (linear)
@@ -155,16 +185,29 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static inline Bool
 NVAccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
 		  const char *src, int src_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdpix->drawable.pScreen->myNum];
+#else
+static inline Bool
+NVAccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
+		  const char *src, int src_pitch, 
+		  HIDDT_StdPixFmt srcPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pdpix);
+#if !defined(__AROS__)
 	unsigned cpp = pdpix->drawable.bitsPerPixel / 8;
+#else
+	unsigned cpp = pdpix->depth > 16 ? 4 : 2;
+#endif
 	unsigned line_len = w * cpp;
 	unsigned dst_offset = 0, dst_pitch = 0, linear = 0;
 	/* Maximum DMA transfer */
@@ -191,6 +234,7 @@
 		if (nouveau_bo_map(pNv->GART, NOUVEAU_BO_WR))
 			return FALSE;
 		dst = pNv->GART->map;
+#if !defined(__AROS__)
 		if (src_pitch == line_len) {
 			memcpy(dst, src, src_pitch * line_count);
 			src += src_pitch * line_count;
@@ -201,6 +245,15 @@
 				dst += line_len;
 			}
 		}
+#else
+        (void)i;
+        HiddNouveauWriteFromRAM(
+            (APTR)src, src_pitch, srcPixFmt,
+            dst, line_len,
+            w, line_count,
+            cl, o);
+        src += src_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (MARK_RING(chan, 32, 6))
@@ -223,8 +276,13 @@
 				BEGIN_RING(chan, m2mf, NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_OUT, 7);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, bo->tile_mode << 4);
+#if !defined(__AROS__)
 				OUT_RING  (chan, pdpix->drawable.width * cpp);
 				OUT_RING  (chan, pdpix->drawable.height);
+#else
+				OUT_RING  (chan, pdpix->width * cpp);
+				OUT_RING  (chan, pdpix->height);
+#endif
 				OUT_RING  (chan, 1);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, (y << 16) | (x * cpp));
@@ -270,6 +328,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static int
 nouveau_exa_mark_sync(ScreenPtr pScreen)
 {
@@ -350,11 +409,16 @@
 	nouveau_bo_ref(NULL, &nvpix->bo);
 	free(nvpix);
 }
+#endif
 
-bool
+Bool
 nv50_style_tiled_pixmap(PixmapPtr ppix)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[ppix->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 
 	return pNv->Architecture >= NV_ARCH_50 &&
@@ -362,6 +426,7 @@
 		 NOUVEAU_BO_TILE_LAYOUT_MASK);
 }
 
+#if !defined(__AROS__)
 static Bool
 nouveau_exa_download_from_screen(PixmapPtr pspix, int x, int y, int w, int h,
 				 char *dst, int dst_pitch)
@@ -593,3 +658,55 @@
 	pNv->EXADriverPtr = exa;
 	return TRUE;
 }
+#endif
+
+
+/* AROS CODE */
+
+Bool NVC0AccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
+		    const char *src, int src_pitch,
+		    HIDDT_StdPixFmt srcPixFmt, OOP_Class *cl, OOP_Object *o);
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes lock on GART object is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HiddNouveauNVAccelUploadM2MF(
+    UBYTE * srcpixels, ULONG srcpitch, HIDDT_StdPixFmt srcPixFmt,
+    LONG x, LONG y, LONG width, LONG height, 
+    OOP_Class *cl, OOP_Object *o)
+{
+    struct HIDDNouveauBitMapData * bmdata = OOP_INST_DATA(cl, o);
+    struct CardData * carddata = &(SD(cl)->carddata);
+    
+    if (carddata->architecture >= NV_ARCH_C0)
+        return NVC0AccelUploadM2MF(bmdata, x, y, width, height,
+		        srcpixels, srcpitch, srcPixFmt, cl, o);
+    else
+        return NVAccelUploadM2MF(bmdata, x, y, width, height,
+		        srcpixels, srcpitch, srcPixFmt, cl, o);
+}
+
+Bool
+NVC0AccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
+		      char *dst, unsigned dst_pitch,
+		      HIDDT_StdPixFmt dstPixFmt, OOP_Class *cl, OOP_Object *o);
+		      
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes lock on GART object is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HiddNouveauNVAccelDownloadM2MF(
+    UBYTE * dstpixels, ULONG dstpitch, HIDDT_StdPixFmt dstPixFmt,
+    LONG x, LONG y, LONG width, LONG height, 
+    OOP_Class *cl, OOP_Object *o)  
+{
+    struct HIDDNouveauBitMapData * bmdata = OOP_INST_DATA(cl, o);
+    struct CardData * carddata = &(SD(cl)->carddata);
+
+    if (carddata->architecture >= NV_ARCH_C0)
+        return NVC0AccelDownloadM2MF(bmdata, x, y, width, height,
+		        dstpixels, dstpitch, dstPixFmt, cl, o);
+    else
+        return NVAccelDownloadM2MF(bmdata, x, y, width, height,
+		        dstpixels, dstpitch, dstPixFmt, cl, o);
+}
+
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nouveau_local.h xf86-video-nouveau/nouveau_local.h
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nouveau_local.h	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nouveau_local.h	2011-05-29 21:41:00.000000000 +0200
@@ -23,8 +23,10 @@
 #ifndef __NOUVEAU_LOCAL_H__
 #define __NOUVEAU_LOCAL_H__
 
+#if !defined(__AROS__)
 #include "compiler.h"
 #include "xf86_OSproc.h"
+#endif
 
 /* Debug output */
 #define NOUVEAU_MSG(fmt,args...) ErrorF(fmt, ##args)
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv04_exa.c xf86-video-nouveau/nv04_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv04_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv04_exa.c	2011-10-05 18:49:17.000000000 +0200
@@ -40,6 +40,7 @@
 	OUT_RING  (chan, pat1);
 }
 
+#if !defined(__AROS__)
 static void 
 NV04EXASetROP(ScrnInfoPtr pScrn, CARD32 alu, CARD32 planemask)
 {
@@ -63,7 +64,20 @@
 		pNv->currentRop = alu;
 	}
 }
+#else
+static void 
+NV04EXASetROP(ScrnInfoPtr pScrn, CARD32 alu, CARD32 planemask)
+{
+	NVPtr pNv = NVPTR(pScrn);
+	struct nouveau_channel *chan = pNv->chan;
+	struct nouveau_grobj *rop = pNv->NvRop;
+	
+	BEGIN_RING(chan, rop, NV03_CONTEXT_ROP_ROP, 1);
+	OUT_RING  (chan, NVROP[alu].copy);
+}
+#endif
 
+#if !defined(__AROS__)
 static void
 NV04EXAStateSolidResubmit(struct nouveau_channel *chan)
 {
@@ -72,11 +86,16 @@
 
 	NV04EXAPrepareSolid(pNv->pdpix, pNv->alu, pNv->planemask, pNv->fg_colour);
 }
+#endif
 
 Bool
 NV04EXAPrepareSolid(PixmapPtr pPixmap, int alu, Pixel planemask, Pixel fg)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *surf2d = pNv->NvContextSurfaces;
@@ -87,10 +106,14 @@
 	if (MARK_RING(chan, 64, 2))
 		return FALSE;
 
+#if !defined(__AROS__)
 	planemask |= ~0 << pPixmap->drawable.bitsPerPixel;
 	if (planemask != ~0 || alu != GXcopy) {
 		if (pPixmap->drawable.bitsPerPixel == 32)
 			return FALSE;
+#else
+	if (alu != 0x03 /* DrawMode_Copy */) {
+#endif
 		BEGIN_RING(chan, rect, NV04_GDI_RECTANGLE_TEXT_OPERATION, 1);
 		OUT_RING  (chan, 1); /* ROP_AND */
 		NV04EXASetROP(pScrn, alu, planemask);
@@ -103,6 +126,7 @@
 		return FALSE;
 	pitch = exaGetPixmapPitch(pPixmap);
 
+#if !defined(__AROS__)
 	if (pPixmap->drawable.bitsPerPixel == 16) {
 		if (pPixmap->drawable.depth == 16) {
 			fmt2 = NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_A16R5G6B5;
@@ -110,6 +134,10 @@
 			fmt2 = NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_X16A1R5G5B5;
 		}
 	}
+#else
+	if (pPixmap->depth == 16)
+		fmt2 = NV04_GDI_RECTANGLE_TEXT_COLOR_FORMAT_A16R5G6B5;
+#endif
 
 	/* When SURFACE_FORMAT_A8R8G8B8 is used with GDI_RECTANGLE_TEXT, the 
 	 * alpha channel gets forced to 0xFF for some reason.  We're using 
@@ -132,18 +160,26 @@
 	BEGIN_RING(chan, rect, NV04_GDI_RECTANGLE_TEXT_COLOR1_A, 1);
 	OUT_RING (chan, fg);
 
+#if !defined(__AROS__)
 	pNv->pdpix = pPixmap;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	pNv->fg_colour = fg;
 	chan->flush_notify = NV04EXAStateSolidResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
 void
 NV04EXASolid (PixmapPtr pPixmap, int x1, int y1, int x2, int y2)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[pPixmap->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rect = pNv->NvRectangle;
@@ -155,10 +191,13 @@
 	OUT_RING  (chan, (x1 << 16) | y1);
 	OUT_RING  (chan, (width << 16) | height);
 
+#if !defined(__AROS__)
 	if((width * height) >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NV04EXADoneSolid (PixmapPtr pPixmap)
 {
@@ -177,12 +216,17 @@
 	NV04EXAPrepareCopy(pNv->pspix, pNv->pdpix, 0, 0, pNv->alu,
 			   pNv->planemask);
 }
+#endif
 
 Bool
 NV04EXAPrepareCopy(PixmapPtr pSrcPixmap, PixmapPtr pDstPixmap, int dx, int dy,
 		   int alu, Pixel planemask)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[pSrcPixmap->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *surf2d = pNv->NvContextSurfaces;
@@ -191,8 +235,12 @@
 	struct nouveau_bo *dst_bo = nouveau_pixmap_bo(pDstPixmap);
 	int fmt;
 
+#if !defined(__AROS__)
 	if (pSrcPixmap->drawable.bitsPerPixel !=
 	    pDstPixmap->drawable.bitsPerPixel)
+#else
+	if (pSrcPixmap->depth != pDstPixmap->depth)
+#endif
 		return FALSE;
 
 	if (!NVAccelGetCtxSurf2DFormatFromPixmap(pDstPixmap, &fmt))
@@ -201,12 +249,16 @@
 	if (MARK_RING(chan, 64, 2))
 		return FALSE;
 
+#if !defined(__AROS__)
 	planemask |= ~0 << pDstPixmap->drawable.bitsPerPixel;
 	if (planemask != ~0 || alu != GXcopy) {
 		if (pDstPixmap->drawable.bitsPerPixel == 32) {
 			MARK_UNDO(chan);
 			return FALSE;
 		}
+#else
+	if (alu != 0x03 /* DrawMode_Copy */) {
+#endif
 
 		BEGIN_RING(chan, blit, NV01_IMAGE_BLIT_OPERATION, 1);
 		OUT_RING  (chan, 1); /* ROP_AND */
@@ -227,11 +279,15 @@
 		return FALSE;
 	}
 
+#if !defined(__AROS__)
 	pNv->pspix = pSrcPixmap;
 	pNv->pdpix = pDstPixmap;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	chan->flush_notify = NV04EXAStateCopyResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -239,10 +295,15 @@
 NV04EXACopy(PixmapPtr pDstPixmap, int srcX, int srcY, int dstX, int dstY,
 	    int width, int height)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[pDstPixmap->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *blit = pNv->NvImageBlit;
+#if !defined(__AROS__)
 	int split_dstY = NOUVEAU_ALIGN(dstY + 1, 64);
 	int split_height = split_dstY - dstY;
 
@@ -278,16 +339,20 @@
 		height -= split_height;
 		dstY = 0;
 	}
+#endif
 
 	BEGIN_RING(chan, blit, NV01_IMAGE_BLIT_POINT_IN, 3);
 	OUT_RING  (chan, (srcY << 16) | srcX);
 	OUT_RING  (chan, (dstY << 16) | dstX);
 	OUT_RING  (chan, (height  << 16) | width);
 
+#if !defined(__AROS__)
 	if((width * height) >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NV04EXADoneCopy(PixmapPtr pDstPixmap)
 {
@@ -419,5 +484,43 @@
 		FIRE_RING(chan);
 	return TRUE;
 }
+#endif
 
+/* AROS CODE */
 
+VOID HIDDNouveauNV04SetPattern(struct CardData * carddata, LONG clr0, LONG clr1,
+		  LONG pat0, LONG pat1)
+{
+    NV04EXASetPattern(carddata, clr0, clr1, pat0, pat1);
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HIDDNouveauNV04FillSolidRect(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * bmdata, LONG minX, LONG minY, LONG maxX,
+    LONG maxY, ULONG drawmode, ULONG color)
+{
+    if (NV04EXAPrepareSolid(bmdata, drawmode, ~0, color))
+    {
+        NV04EXASolid(bmdata, minX, minY, maxX + 1, maxY + 1);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HIDDNouveauNV04CopySameFormat(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG drawmode)
+{
+    if (NV04EXAPrepareCopy(srcdata, destdata, 0, 0, drawmode, ~0))
+    {
+        NV04EXACopy(destdata, srcX, srcY, destX, destY, width, height);
+        return TRUE;
+    }
+
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv10_exa.c xf86-video-nouveau/nv10_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv10_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv10_exa.c	2011-09-26 21:10:47.000000000 +0200
@@ -65,7 +65,11 @@
 static int
 get_tex_format(PicturePtr pict)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[pict->pDrawable->pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 
 	/* If repeat is set we're always handling a 1x1 texture with
@@ -120,6 +124,7 @@
 	{ SF(ONE_MINUS_DST_ALPHA), DF(SRC_ALPHA) },	      /* AtopReverse */
 	{ SF(ONE_MINUS_DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) }, /* Xor */
 	{ SF(ONE),		   DF(ONE) },		      /* Add */
+	{ SF(SRC_ALPHA),   DF(ONE_MINUS_SRC_ALPHA) }, /* OverAlpha */
 };
 
 static inline Bool
@@ -141,6 +146,7 @@
 	return mask && mask->componentAlpha && PICT_FORMAT_RGB(mask->format);
 }
 
+#if !defined(__AROS__)
 static Bool
 check_texture(PicturePtr pict)
 {
@@ -368,6 +374,7 @@
 	print_fallback_info("Accelerating", op, src, mask, dst);
 	return TRUE;
 }
+#endif
 
 static Bool
 setup_texture(NVPtr pNv, int unit, PicturePtr pict, PixmapPtr pixmap)
@@ -376,8 +383,13 @@
 	struct nouveau_grobj *celsius = pNv->Nv3D;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pixmap);
 	unsigned tex_reloc = NOUVEAU_BO_VRAM | NOUVEAU_BO_GART | NOUVEAU_BO_RD;
+#if !defined(__AROS__)
 	long w = pict->pDrawable->width,
 	     h = pict->pDrawable->height;
+#else
+	long w = pixmap->width,
+	     h = pixmap->height;
+#endif
 	unsigned int txfmt =
 		NV10TCL_TX_FORMAT_WRAP_T_CLAMP_TO_EDGE |
 		NV10TCL_TX_FORMAT_WRAP_S_CLAMP_TO_EDGE |
@@ -481,8 +493,13 @@
 	(NV10TCL_RC_IN_RGB_##input##_INPUT_CONSTANT_COLOR##unit |	\
 	 NV10TCL_RC_IN_RGB_##input##_COMPONENT_USAGE_##chan)
 
+#if !defined(__AROS__)
 static void
 setup_combiners(NVPtr pNv, PicturePtr src, PicturePtr mask)
+#else
+static void
+setup_combiners(NVPtr pNv, PicturePtr src, PicturePtr mask, int op)
+#endif
 {
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
@@ -499,7 +516,11 @@
 		rc_in_alpha |= RC_IN_ONE(B);
 
 	if (effective_component_alpha(mask)) {
+#if !defined(__AROS__)
 		if (!needs_src_alpha(pNv->alu)) {
+#else
+		if (!needs_src_alpha(op)) {
+#endif
 			/* The alpha channels won't be used for blending. Drop
 			 * them, as our pixels only have 4 components...
 			 * output_i = src_i * mask_i
@@ -535,24 +556,41 @@
 	OUT_RING  (chan, rc_in_rgb);
 }
 
+#if !defined(__AROS__)
 static void
 setup_blend_function(NVPtr pNv)
+#else
+static void
+setup_blend_function(NVPtr pNv, PicturePtr dst, PicturePtr mask, int blendop)
+#endif
 {
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
+#if !defined(__AROS__)
 	struct pict_op *op = &nv10_pict_op[pNv->alu];
+#else
+	struct pict_op *op = &nv10_pict_op[blendop];
+#endif
 	int src_factor = op->src;
 	int dst_factor = op->dst;
 
 	if (src_factor == SF(ONE_MINUS_DST_ALPHA) &&
+#if !defined(__AROS__)
 	    !PICT_FORMAT_A(pNv->pdpict->format))
+#else
+	    !PICT_FORMAT_A(dst->format))
+#endif
 		/* ONE_MINUS_DST_ALPHA doesn't always do the right thing for
 		 * framebuffers without alpha channel. But it's the same as
 		 * ZERO in that case.
 		 */
 		src_factor = SF(ZERO);
 
+#if !defined(__AROS__)
 	if (effective_component_alpha(pNv->pmpict)) {
+#else
+	if (effective_component_alpha(mask)) {
+#endif
 		if (dst_factor == DF(SRC_ALPHA))
 			dst_factor = DF(SRC_COLOR);
 		else if (dst_factor == DF(ONE_MINUS_SRC_ALPHA))
@@ -566,6 +604,7 @@
 	OUT_RING  (chan, 1);
 }
 
+#if !defined(__AROS__)
 static void
 NV10StateCompositeReemit(struct nouveau_channel *chan)
 {
@@ -575,6 +614,7 @@
 	NV10EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
 Bool
 NV10EXAPrepareComposite(int op,
@@ -585,13 +625,18 @@
 			PixmapPtr mask,
 			PixmapPtr dst)
 {
+#if !defined(__AROS__)
 	ScrnInfoPtr pScrn = xf86Screens[dst->drawable.pScreen->myNum];
+#else
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 
 	if (MARK_RING(chan, 128, 5))
 		return FALSE;
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = pict_src;
 	pNv->pmpict = pict_mask;
@@ -599,6 +644,7 @@
 	pNv->pspix = src;
 	pNv->pmpix = mask;
 	pNv->pdpix = dst;
+#endif
 
 	/* Set dst format */
 	if (!setup_render_target(pNv, pict_dst, dst))
@@ -613,6 +659,7 @@
 	    !setup_texture(pNv, 1, pict_mask, mask))
 		goto fail;
 
+#if !defined(__AROS__)
 	/* Set the register combiners up. */
 	setup_combiners(pNv, pict_src, pict_mask);
 
@@ -620,6 +667,15 @@
 	setup_blend_function(pNv);
 
 	chan->flush_notify = NV10StateCompositeReemit;
+#else
+	/* Set the register combiners up. */
+	setup_combiners(pNv, pict_src, pict_mask, op);
+
+	/* Set PictOp */
+	setup_blend_function(pNv, pict_dst, pict_mask, op);
+
+	chan->flush_notify = NULL;
+#endif
 
 	return TRUE;
 
@@ -629,6 +685,20 @@
 	return FALSE;
 }
 
+#if defined(__AROS__)
+/* WARNING: These defines are only used to hack QUAD/MAP/OUT_RINGi defines 
+   in this use case. They WILL NOT work in generic case. DO NOT reuse them. */
+struct _PictVector
+{
+    float vector[3];
+};
+typedef struct _PictVector PictVector;
+#define xFixed1             0.0f
+#define xFixedFrac(x)       0
+#define xFixedToInt(x)      (x)
+#define IntToxFixed(x)      (float)(x)
+#endif
+
 #define QUAD(x, y, w, h)					\
 	{{{ IntToxFixed(x),     IntToxFixed(y),     xFixed1 }},	\
 	 {{ IntToxFixed(x + w), IntToxFixed(y),     xFixed1 }},	\
@@ -670,6 +740,7 @@
 	OUT_RINGf (chan, 0);
 }
 
+#if !defined(__AROS__)
 static inline void
 transform_vertex(PictTransformPtr t, int i, PictVector vs[])
 {
@@ -685,18 +756,34 @@
 		 int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pix_dst->drawable.pScreen->myNum];
+#else
+static void
+NV10EXAComposite(PixmapPtr pix_dst,
+		 int srcX, int srcY,
+		 int maskX, int maskY,
+		 int dstX, int dstY,
+		 int width, int height, 
+		 PicturePtr src, PicturePtr mask)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
+#if !defined(__AROS__)
 	PicturePtr mask = pNv->pmpict,
 		src = pNv->pspict;
+#endif
 	PictVector dstq[4] = QUAD(dstX, dstY, width, height),
 		maskq[4] = QUAD(maskX, maskY, width, height),
 		srcq[4] = QUAD(srcX, srcY, width, height);
 
+#if !defined(__AROS__)
+    /* We are not doing any transformations */
 	MAP(transform_vertex, src->transform, srcq);
 	if (mask)
 		MAP(transform_vertex, mask->transform, maskq);
+#endif
 
 	WAIT_RING (chan, 64);
 	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_BEGIN_END, 1);
@@ -708,6 +795,7 @@
 	OUT_RING  (chan, NV10TCL_VERTEX_BEGIN_END_STOP);
 }
 
+#if !defined(__AROS__)
 void
 NV10EXADoneComposite(PixmapPtr dst)
 {
@@ -717,6 +805,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 Bool
 NVAccelInitNV10TCL(ScrnInfoPtr pScrn)
@@ -969,3 +1058,32 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV103DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    LONG maskX = 0; LONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV10EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata))
+    {
+        NV10EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, &sPict, NULL);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv30_exa.c xf86-video-nouveau/nv30_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv30_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv30_exa.c	2011-09-26 21:11:04.000000000 +0200
@@ -26,6 +26,10 @@
 #include "nv_include.h"
 #include "nv30_shaders.h"
 #include "nv04_pushbuf.h"
+#if defined(__AROS__)
+#include <aros/debug.h>
+#define NV30EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -54,8 +58,10 @@
 		float height;
 	} unit[2];
 } nv30_exa_state_t;
+#if !defined(__AROS__)
 static nv30_exa_state_t exa_state;
 #define NV30EXA_STATE nv30_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV30SurfaceFormat[] = {
@@ -223,7 +229,8 @@
 /* Atop        */ { 1, 1, BF(          DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) }
+/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
+/* OverAlpha   */ { 1, 0, BF(          SRC_ALPHA), BF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -299,8 +306,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv30_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -326,9 +338,17 @@
 	if (OUT_RELOCl(chan, bo, 0, tex_reloc) ||
 	    OUT_RELOCd(chan, bo, NV34TCL_TX_FORMAT_DIMS_2D | (1 << 16) | 8 |
 		       (fmt->card_fmt << NV34TCL_TX_FORMAT_FORMAT_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.width) <<
+#else
+		       (log2i(pPix->width) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_U_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.height) <<
+#else
+		       (log2i(pPix->height) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_V_SHIFT),
 		       tex_reloc | NOUVEAU_BO_OR,
 		       NV34TCL_TX_FORMAT_DMA0, NV34TCL_TX_FORMAT_DMA1))
@@ -343,12 +363,21 @@
 	OUT_RING  (chan, (card_filter << NV34TCL_TX_FILTER_MINIFY_SHIFT) /* min */ |
 			(card_filter << NV34TCL_TX_FILTER_MAGNIFY_SHIFT) /* mag */ |
 			0x2000 /* engine lock */);
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 
 	return TRUE;
 }
@@ -379,6 +408,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -460,7 +490,9 @@
 	NV30EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV30EXAPrepareComposite(int op, PicturePtr psPict,
 		PicturePtr pmPict,
@@ -470,6 +502,18 @@
 		PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV30EXAPrepareComposite(int op, PicturePtr psPict,
+		PicturePtr pmPict,
+		PicturePtr pdPict,
+		PixmapPtr  psPix,
+		PixmapPtr  pmPix,
+		PixmapPtr  pdPix,
+		nv30_exa_state_t * state)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -487,7 +531,11 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV30_SetupSurface(pScrn, pdPix, pdPict) ||
+#if !defined(__AROS__)
 	    !NV30EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV30EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
@@ -507,7 +555,11 @@
 #endif
 
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -537,6 +589,7 @@
 	BEGIN_RING(chan, rankine, 0x23c, 1);
 	OUT_RING  (chan, pmPict?3:1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -545,6 +598,9 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV30EXAStateCompositeReemit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -555,15 +611,21 @@
 NV30EXATransformCoord(PictTransformPtr t, int x, int y, float sx, float sy,
 					  float *x_ret, float *y_ret)
 {
+#if !defined(__AROS__)
 	PictVector v;
+#endif
 
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
 		v.vector[2] = xFixed1;
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]);
 		*y_ret = xFixedToFloat(v.vector[1]);
+#endif
 	} else {
 		*x_ret = (float)x;
 		*y_ret = (float)y;
@@ -584,6 +646,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -591,6 +654,15 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, nv30_exa_state_t * state)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -652,6 +724,7 @@
 	OUT_RING  (chan, 0);
 }
 
+#if !defined(__AROS__)
 void
 NV30EXADoneComposite(PixmapPtr pdPix)
 {
@@ -661,6 +734,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 Bool
 NVAccelInitNV30TCL(ScrnInfoPtr pScrn)
@@ -914,3 +988,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV303DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv30_exa_state_t state;
+    LONG maskX = 0; LONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV30EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, &state))
+    {
+        NV30EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv30_shaders.c xf86-video-nouveau/nv30_shaders.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv30_shaders.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv30_shaders.c	2011-09-05 20:03:01.000000000 +0200
@@ -20,7 +20,6 @@
  * SOFTWARE.
  */
 
-
 #include "nv30_shaders.h"
 #include "nv04_pushbuf.h"
 
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv40_exa.c xf86-video-nouveau/nv40_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv40_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv40_exa.c	2011-09-26 21:11:21.000000000 +0200
@@ -23,6 +23,10 @@
 #include "nv_include.h"
 #include "nv30_shaders.h"
 #include "nv04_pushbuf.h"
+#if defined(__AROS__)
+#include <aros/debug.h>
+#define NV40EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -51,8 +55,10 @@
 		float height;
 	} unit[2];
 } nv40_exa_state_t;
+#if !defined(__AROS__)
 static nv40_exa_state_t exa_state;
 #define NV40EXA_STATE nv40_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV40SurfaceFormat[] = {
@@ -172,7 +178,8 @@
 /* Atop        */ { 1, 1, SF(          DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) }
+/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) },
+/* OverAlpha   */ { 1, 0, SF(          SRC_ALPHA), DF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -233,8 +240,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv40_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -291,6 +303,7 @@
 		OUT_RING  (chan, NV40TCL_TEX_FILTER_MIN_NEAREST |
 				 NV40TCL_TEX_FILTER_MAG_NEAREST | 0x3fd6);
 	}
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << 16) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
@@ -300,6 +313,17 @@
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << 16) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
+	OUT_RING  (chan, (1 << NV40TCL_TEX_SIZE1_DEPTH_SHIFT) |
+			 (uint32_t)pPix->pitch);
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 	return TRUE;
 }
 
@@ -329,6 +353,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -406,7 +431,9 @@
 	NV40EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV40EXAPrepareComposite(int op, PicturePtr psPict,
 				PicturePtr pmPict,
@@ -416,6 +443,18 @@
 				PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV40EXAPrepareComposite(int op, PicturePtr psPict,
+				PicturePtr pmPict,
+				PicturePtr pdPict,
+				PixmapPtr  psPix,
+				PixmapPtr  pmPix,
+				PixmapPtr  pdPix,
+				nv40_exa_state_t * state)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
@@ -433,14 +472,22 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV40_SetupSurface(pScrn, pdPix, pdPict->format) ||
+#if !defined(__AROS__)
 	    !NV40EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV40EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
 
 	NV40_LoadVtxProg(pScrn, &nv40_vp_exa_render);
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -476,6 +523,7 @@
 	BEGIN_RING(chan, curie, NV40TCL_TEX_CACHE_CTL, 1);
 	OUT_RING  (chan, 1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -484,6 +532,9 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV40EXAStateCompositeReemit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -495,6 +546,9 @@
 					  float *x_ret, float *y_ret)
 {
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		PictVector v;
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
@@ -502,6 +556,7 @@
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]) / sx;
 		*y_ret = xFixedToFloat(v.vector[1]) / sy;
+#endif
 	} else {
 		*x_ret = (float)x / sx;
 		*y_ret = (float)y / sy;
@@ -522,6 +577,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -529,11 +585,20 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, nv40_exa_state_t * state)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
-	float sX0, sX1, sX2, sY0, sY1, sY2;
-	float mX0, mX1, mX2, mY0, mY1, mY2;
+	float sX0=0.0f, sX1=0.0f, sX2=0.0f, sY0=0.0f, sY1=0.0f, sY2=0.0f;
+	float mX0=0.0f, mX1=0.0f, mX2=0.0f, mY0=0.0f, mY1=0.0f, mY2=0.0f;
 	NV40EXA_STATE;
 
 	WAIT_RING(chan, 64);
@@ -587,6 +652,7 @@
 	OUT_RING  (chan, NV40TCL_BEGIN_END_STOP);
 }
 
+#if !defined(__AROS__)
 void
 NV40EXADoneComposite(PixmapPtr pdPix)
 {
@@ -596,6 +662,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 #define NV40TCL_CHIPSET_4X_MASK 0x00000baf
 #define NV44TCL_CHIPSET_4X_MASK 0x00005450
@@ -760,3 +827,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV403DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv40_exa_state_t state;
+    LONG maskX = 0; LONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV40EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, &state))
+    {
+        NV40EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv50_accel.c xf86-video-nouveau/nv50_accel.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv50_accel.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv50_accel.c	2011-05-29 21:41:00.000000000 +0200
@@ -23,6 +23,7 @@
 #include "nv_include.h"
 #include "nv50_accel.h"
 
+#if !defined(__AROS__)
 void
 NV50SyncToVBlank(PixmapPtr ppix, BoxPtr box)
 {
@@ -52,6 +53,7 @@
 	BEGIN_RING(chan, nvsw, 0x0068, 1);
 	OUT_RING  (chan, 0x11111111);
 }
+#endif
 
 Bool
 NVAccelInitNV50TCL(ScrnInfoPtr pScrn)
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv50_exa.c xf86-video-nouveau/nv50_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv50_exa.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv50_exa.c	2011-09-26 21:06:19.000000000 +0200
@@ -37,6 +37,7 @@
 		float height;
 	} unit[2];
 };
+#if !defined(__AROS__)
 static struct nv50_exa_state exa_state;
 
 #define NV50EXA_LOCALS(p)                                              \
@@ -46,6 +47,15 @@
 	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
 	struct nouveau_grobj *tesla = pNv->Nv3D; (void)tesla;          \
 	struct nv50_exa_state *state = &exa_state; (void)state
+#else
+#define NV50EXA_LOCALS(p)                                          \
+	ScrnInfoPtr pScrn = globalcarddataptr;                         \
+	NVPtr pNv = NVPTR(pScrn);                                      \
+	struct nouveau_channel *chan = pNv->chan; (void)chan;          \
+	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
+	struct nouveau_grobj *tesla = pNv->Nv3D; (void)tesla;
+
+#endif
 
 #define BF(f) NV50TCL_BLEND_FUNC_SRC_RGB_##f
 
@@ -71,6 +81,7 @@
 /* AtopReverse */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
+/* OverAlpha   */ { 1, 0, BF(          SRC_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 };
 
 static Bool
@@ -78,7 +89,11 @@
 {
 	NV50EXA_LOCALS(ppix);
 
+#if !defined(__AROS__)
 	switch (ppix->drawable.bitsPerPixel) {
+#else
+	switch (ppix->depth) {
+#endif
 	case 8 : *fmt = NV50_2D_SRC_FORMAT_R8_UNORM; break;
 	case 15: *fmt = NV50_2D_SRC_FORMAT_X1R5G5B5_UNORM; break;
 	case 16: *fmt = NV50_2D_SRC_FORMAT_R5G6B5_UNORM; break;
@@ -135,14 +150,23 @@
 	}
 
 	BEGIN_RING(chan, eng2d, mthd + 0x18, 4);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, ppix->height);
+#endif
 	if (OUT_RELOCh(chan, bo, 0, bo_flags) ||
 	    OUT_RELOCl(chan, bo, 0, bo_flags))
 		return FALSE;
 
 	if (is_src == 0)
+#if !defined(__AROS__)
 		NV50EXASetClip(ppix, 0, 0, ppix->drawable.width, ppix->drawable.height);
+#else
+		NV50EXASetClip(ppix, 0, 0, ppix->width, ppix->height);
+#endif
 
 	return TRUE;
 }
@@ -159,6 +183,7 @@
 	OUT_RING  (chan, pat1);
 }
 
+#if !defined(__AROS__)
 static void
 NV50EXASetROP(PixmapPtr pdpix, int alu, Pixel planemask)
 {
@@ -210,7 +235,43 @@
 		pNv->currentRop = alu;
 	}
 }
+#else
+static void
+NV50EXASetROP(PixmapPtr pdpix, int alu, Pixel planemask)
+{
+	NV50EXA_LOCALS(pdpix);
+	int rop;
+
+	rop = NVROP[alu].copy;
+
+	BEGIN_RING(chan, eng2d, NV50_2D_OPERATION, 1);
+	if (alu == 0x03 /* DrawMode_Copy */) {
+		OUT_RING  (chan, NV50_2D_OPERATION_SRCCOPY);
+		return;
+	} else {
+		OUT_RING  (chan, NV50_2D_OPERATION_SRCCOPY_PREMULT);
+	}
+
+	BEGIN_RING(chan, eng2d, NV50_2D_PATTERN_FORMAT, 2);
+	switch (pdpix->depth) {
+		case  8: OUT_RING  (chan, 3); break;
+		case 15: OUT_RING  (chan, 1); break;
+		case 16: OUT_RING  (chan, 0); break;
+		case 24:
+		case 32:
+		default:
+			 OUT_RING  (chan, 2);
+			 break;
+	}
+	OUT_RING  (chan, 1);
+
+
+	BEGIN_RING(chan, eng2d, NV50_2D_ROP, 1);
+	OUT_RING  (chan, rop);
+}
+#endif
 
+#if !defined(__AROS__)
 static void
 NV50EXAStateSolidResubmit(struct nouveau_channel *chan)
 {
@@ -220,6 +281,7 @@
 	NV50EXAPrepareSolid(pNv->pdpix, pNv->alu, pNv->planemask,
 			    pNv->fg_colour);
 }
+#endif
 
 Bool
 NV50EXAPrepareSolid(PixmapPtr pdpix, int alu, Pixel planemask, Pixel fg)
@@ -245,11 +307,15 @@
 	OUT_RING  (chan, fmt);
 	OUT_RING  (chan, fg);
 
+#if !defined(__AROS__)
 	pNv->pdpix = pdpix;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	pNv->fg_colour = fg;
 	chan->flush_notify = NV50EXAStateSolidResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -265,10 +331,13 @@
 	OUT_RING  (chan, x2);
 	OUT_RING  (chan, y2);
 
+#if !defined(__AROS__)
 	if((x2 - x1) * (y2 - y1) >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NV50EXADoneSolid(PixmapPtr pdpix)
 {
@@ -286,6 +355,7 @@
 	NV50EXAPrepareCopy(pNv->pspix, pNv->pdpix, 0, 0, pNv->alu,
 			   pNv->planemask);
 }
+#endif
 
 Bool
 NV50EXAPrepareCopy(PixmapPtr pspix, PixmapPtr pdpix, int dx, int dy,
@@ -308,11 +378,15 @@
 
 	NV50EXASetROP(pdpix, alu, planemask);
 
+#if !defined(__AROS__)
 	pNv->pspix = pspix;
 	pNv->pdpix = pdpix;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	chan->flush_notify = NV50EXAStateCopyResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -342,10 +416,13 @@
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, srcY);
 
+#if !defined(__AROS__)
 	if(width * height >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NV50EXADoneCopy(PixmapPtr pdpix)
 {
@@ -463,6 +540,7 @@
 
 	return TRUE;
 }
+#endif
 
 static Bool
 NV50EXARenderTarget(PixmapPtr ppix, PicturePtr ppict)
@@ -505,14 +583,20 @@
 	OUT_RING  (chan, bo->tile_mode << 4);
 	OUT_RING  (chan, 0x00000000);
 	BEGIN_RING(chan, tesla, NV50TCL_RT_HORIZ(0), 2);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, ppix->height);
+#endif
 	BEGIN_RING(chan, tesla, NV50TCL_RT_ARRAY_MODE, 1);
 	OUT_RING  (chan, 0x00000001);
 
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV50EXACheckTexture(PicturePtr ppict, PicturePtr pdpict, int op)
 {
@@ -572,13 +656,19 @@
 
 	return TRUE;
 }
+#endif
 
 #define _(X1,X2,X3,X4,FMT) (NV50TIC_0_0_TYPER_UNORM | NV50TIC_0_0_TYPEG_UNORM | NV50TIC_0_0_TYPEB_UNORM | NV50TIC_0_0_TYPEA_UNORM | \
 			    NV50TIC_0_0_MAP##X1 | NV50TIC_0_0_MAP##X2 | NV50TIC_0_0_MAP##X3 | NV50TIC_0_0_MAP##X4 | \
 			    NV50TIC_0_0_FMT_##FMT)
 
+#if !defined(__AROS__)
 static Bool
 NV50EXATexture(PixmapPtr ppix, PicturePtr ppict, unsigned unit)
+#else
+static Bool
+NV50EXATexture(PixmapPtr ppix, PicturePtr ppict, unsigned unit, struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(ppix);
 	struct nouveau_bo *bo = nouveau_pixmap_bo(ppix);
@@ -678,8 +768,13 @@
 		       NOUVEAU_BO_HIGH | NOUVEAU_BO_OR, mode, mode))
 		return FALSE;
 	OUT_RING  (chan, 0x00300000);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, (1 << NV50TIC_0_5_DEPTH_SHIFT) | ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, (1 << NV50TIC_0_5_DEPTH_SHIFT) | ppix->height);
+#endif
 	OUT_RING  (chan, 0x03000000);
 	OUT_RING  (chan, 0x00000000);
 
@@ -736,12 +831,19 @@
 	OUT_RING  (chan, 0x00000000);
 	OUT_RING  (chan, 0x00000000);
 
+#if !defined(__AROS__)
 	state->unit[unit].width = ppix->drawable.width;
 	state->unit[unit].height = ppix->drawable.height;
 	state->unit[unit].transform = ppict->transform;
+#else
+	state->unit[unit].width = ppix->width;
+	state->unit[unit].height = ppix->height;
+	state->unit[unit].transform = NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV50EXACheckBlend(int op)
 {
@@ -749,6 +851,7 @@
 		NOUVEAU_FALLBACK("unsupported blend op %d\n", op);
 	return TRUE;
 }
+#endif
 
 static void
 NV50EXABlend(PixmapPtr ppix, PicturePtr ppict, int op, int component_alpha)
@@ -793,6 +896,7 @@
 	}
 }
 
+#if !defined(__AROS__)
 Bool
 NV50EXACheckComposite(int op,
 		      PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict)
@@ -829,11 +933,20 @@
 	NV50EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV50EXAPrepareComposite(int op,
 			PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict,
 			PixmapPtr pspix, PixmapPtr pmpix, PixmapPtr pdpix)
+#else
+static Bool
+NV50EXAPrepareComposite(int op,
+			PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict,
+			PixmapPtr pspix, PixmapPtr pmpix, PixmapPtr pdpix,
+			struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(pspix);
 	const unsigned shd_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD;
@@ -866,13 +979,21 @@
 		return FALSE;
 	}
 
+#if !defined(__AROS__)
 	if (!NV50EXATexture(pspix, pspict, 0)) {
+#else
+	if (!NV50EXATexture(pspix, pspict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		NOUVEAU_FALLBACK("src picture invalid\n");
 	}
 
 	if (pmpict) {
+#if !defined(__AROS__)
 		if (!NV50EXATexture(pmpix, pmpict, 1)) {
+#else
+		if (!NV50EXATexture(pmpix, pmpict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			NOUVEAU_FALLBACK("mask picture invalid\n");
 		}
@@ -910,6 +1031,7 @@
 	BEGIN_RING(chan, tesla, NV50TCL_BIND_TIC(2), 1);
 	OUT_RING  (chan, 0x203);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = pspict;
 	pNv->pmpict = pmpict;
@@ -918,6 +1040,9 @@
 	pNv->pmpix = pmpix;
 	pNv->pdpix = pdpix;
 	chan->flush_notify = NV50EXAStateCompositeResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -928,6 +1053,9 @@
 		 float *x_ret, float *y_ret)
 {
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		PictVector v;
 
 		v.vector[0] = IntToxFixed(x);
@@ -936,18 +1064,25 @@
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]) / sx;
 		*y_ret = xFixedToFloat(v.vector[1]) / sy;
+#endif
 	} else {
 		*x_ret = (float)x / sx;
 		*y_ret = (float)y / sy;
 	}
 }
 
+#if !defined(__AROS__)
 void
 NV50EXAComposite(PixmapPtr pdpix, int sx, int sy, int mx, int my,
 		 int dx, int dy, int w, int h)
+#else
+static void
+NV50EXAComposite(PixmapPtr pdpix, int sx, int sy, int mx, int my,
+		 int dx, int dy, int w, int h, struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(pdpix);
-	float sX0, sX1, sX2, sY0, sY1, sY2;
+	float sX0=0.0f, sX1=0.0f, sX2=0.0f, sY0=0.0f, sY1=0.0f, sY2=0.0f;
 
 	WAIT_RING (chan, 64);
 	BEGIN_RING(chan, tesla, NV50TCL_SCISSOR_HORIZ(0), 2);
@@ -967,7 +1102,7 @@
 			 &sX2, &sY2);
 
 	if (state->have_mask) {
-		float mX0, mX1, mX2, mY0, mY1, mY2;
+		float mX0=0.0f, mX1=0.0f, mX2=0.0f, mY0=0.0f, mY1=0.0f, mY2=0.0f;
 
 		NV50EXATransform(state->unit[1].transform, mx, my + (h * 2),
 				 state->unit[1].width, state->unit[1].height,
@@ -992,6 +1127,7 @@
 	OUT_RING  (chan, 0);
 }
 
+#if !defined(__AROS__)
 void
 NV50EXADoneComposite(PixmapPtr pdpix)
 {
@@ -999,4 +1135,71 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
+/* AROS CODE */
+
+VOID HIDDNouveauNV50SetPattern(struct CardData * carddata, LONG col0, 
+    LONG col1, LONG pat0, LONG pat1)
+{
+    NV50EXASetPattern(NULL, col0, col1, pat0, pat1);
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HIDDNouveauNV50FillSolidRect(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * bmdata, LONG minX, LONG minY, LONG maxX,
+    LONG maxY, ULONG drawmode, ULONG color)
+{
+    if (NV50EXAPrepareSolid(bmdata, drawmode, ~0, color))
+    {
+        NV50EXASolid(bmdata, minX, minY, maxX + 1, maxY + 1);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HIDDNouveauNV50CopySameFormat(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG drawmode)
+{
+    if (NV50EXAPrepareCopy(srcdata, destdata, 0, 0, drawmode, ~0))
+    {
+        NV50EXACopy(destdata, srcX, srcY, destX , destY, width, height);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV503DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    struct nv50_exa_state state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV50EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, &state))
+    {
+        NV50EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv_accel_common.c xf86-video-nouveau/nv_accel_common.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv_accel_common.c	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv_accel_common.c	2011-10-05 19:06:30.000000000 +0200
@@ -22,7 +22,11 @@
 
 #include "nv_include.h"
 #include "nv04_pushbuf.h"
+#if defined(__AROS__)
+#include <aros/debug.h>
+#endif
 
+#if !defined(__AROS__)
 Bool
 nouveau_allocate_surface(ScrnInfoPtr scrn, int width, int height, int bpp,
 			 int usage_hint, int *pitch, struct nouveau_bo **bo)
@@ -149,6 +153,7 @@
 	BEGIN_RING(chan, blit, 0x00000130, 1);
 	OUT_RING  (chan, 0);
 }
+#endif
 
 static Bool
 NVAccelInitDmaNotifier0(ScrnInfoPtr pScrn)
@@ -193,6 +198,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 /* FLAGS_ROP_AND, DmaFB, DmaFB, 0 */
 static Bool
 NVAccelInitContextBeta1(ScrnInfoPtr pScrn)
@@ -233,11 +239,16 @@
 	OUT_RING  (chan, 0xffff0000);
 	return TRUE;
 }
+#endif
 
 Bool
 NVAccelGetCtxSurf2DFormatFromPixmap(PixmapPtr pPix, int *fmt_ret)
 {
+#if !defined(__AROS__)
 	switch (pPix->drawable.bitsPerPixel) {
+#else
+	switch (pPix->depth) {
+#endif
 	case 32:
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_A8R8G8B8;
 		break;
@@ -245,7 +256,11 @@
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X8R8G8B8_Z8R8G8B8;
 		break;
 	case 16:
+#if !defined(__AROS__)
 		if (pPix->drawable.depth == 16)
+#else
+        if (pPix->depth == 16)
+#endif
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_R5G6B5;
 		else
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X1R5G5B5_Z1R5G5B5;
@@ -260,6 +275,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 Bool
 NVAccelGetCtxSurf2DFormatFromPicture(PicturePtr pPict, int *fmt_ret)
 {
@@ -292,6 +308,7 @@
 	else
 		return (PixmapPtr) pDraw;
 }
+#endif
 
 static Bool
 NVAccelInitImagePattern(ScrnInfoPtr pScrn)
@@ -339,7 +356,7 @@
 	BEGIN_RING(chan, rop, NV03_CONTEXT_ROP_DMA_NOTIFY, 1);
 	OUT_RING  (chan, chan->nullobj->handle);
 
-	pNv->currentRop = ~0;
+//	pNv->currentRop = ~0;
 	return TRUE;
 }
 
@@ -421,6 +438,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitScaledImage(ScrnInfoPtr pScrn)
 {
@@ -491,6 +509,7 @@
 
 	return TRUE;
 }
+#endif
 
 /* FLAGS_NONE, NvDmaFB, NvDmaAGP, NvDmaNotifier0 */
 static Bool
@@ -522,6 +541,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitImageFromCpu(ScrnInfoPtr pScrn)
 {
@@ -571,6 +591,7 @@
 
 	return TRUE;
 }
+#endif
 
 static Bool
 NVAccelInit2D_NV50(ScrnInfoPtr pScrn)
@@ -602,10 +623,11 @@
 	BEGIN_RING(chan, eng2d, 0x58c, 1);
 	OUT_RING  (chan, 0x111);
 
-	pNv->currentRop = 0xfffffffa;
+//	pNv->currentRop = 0xfffffffa;
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 #define INIT_CONTEXT_OBJECT(name) do {                                        \
 	ret = NVAccelInit##name(pScrn);                                       \
 	if (!ret) {                                                           \
@@ -615,6 +637,16 @@
 		return FALSE;                                                 \
 	}                                                                     \
 } while(0)
+#else
+#define INIT_CONTEXT_OBJECT(name) do {                                      \
+	ret = NVAccelInit##name(pScrn);                                         \
+	if (!ret) {                                                             \
+		bug("[nouveau] Failed to initialise context object: "#name          \
+			   " (%d)\n", ret);                                             \
+		return FALSE;                                                       \
+	}                                                                       \
+} while(0)
+#endif
 
 Bool
 NVAccelCommonInit(ScrnInfoPtr pScrn)
@@ -622,8 +654,10 @@
 	NVPtr pNv = NVPTR(pScrn);
 	Bool ret;
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return TRUE;
+#endif
 
 	/* General engine objects */
 	if (pNv->Architecture < NV_ARCH_C0)
@@ -632,15 +666,19 @@
 	/* 2D engine */
 	if (pNv->Architecture < NV_ARCH_50) {
 		INIT_CONTEXT_OBJECT(ContextSurfaces);
+#if !defined(__AROS__)
 		INIT_CONTEXT_OBJECT(ContextBeta1);
 		INIT_CONTEXT_OBJECT(ContextBeta4);
+#endif
 		INIT_CONTEXT_OBJECT(ImagePattern);
 		INIT_CONTEXT_OBJECT(RasterOp);
 		INIT_CONTEXT_OBJECT(Rectangle);
 		INIT_CONTEXT_OBJECT(ImageBlit);
+#if !defined(__AROS__)
 		INIT_CONTEXT_OBJECT(ScaledImage);
 		INIT_CONTEXT_OBJECT(ClipRectangle);
 		INIT_CONTEXT_OBJECT(ImageFromCpu);
+#endif
 	} else
 	if (pNv->Architecture < NV_ARCH_C0) {
 		INIT_CONTEXT_OBJECT(2D_NV50);
@@ -682,22 +720,28 @@
 {
 	NVPtr pNv = NVPTR(pScrn);
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return;
+#endif
 
 	nouveau_notifier_free(&pNv->notify0);
 	nouveau_notifier_free(&pNv->vblank_sem);
 
 	nouveau_grobj_free(&pNv->NvContextSurfaces);
+#if !defined(__AROS__)
 	nouveau_grobj_free(&pNv->NvContextBeta1);
 	nouveau_grobj_free(&pNv->NvContextBeta4);
+#endif
 	nouveau_grobj_free(&pNv->NvImagePattern);
 	nouveau_grobj_free(&pNv->NvRop);
 	nouveau_grobj_free(&pNv->NvRectangle);
 	nouveau_grobj_free(&pNv->NvImageBlit);
+#if !defined(__AROS__)
 	nouveau_grobj_free(&pNv->NvScaledImage);
 	nouveau_grobj_free(&pNv->NvClipRectangle);
 	nouveau_grobj_free(&pNv->NvImageFromCpu);
+#endif
 	nouveau_grobj_free(&pNv->Nv2D);
 	nouveau_grobj_free(&pNv->NvMemFormat);
 	nouveau_grobj_free(&pNv->NvSW);
@@ -706,3 +750,16 @@
 	nouveau_bo_ref(NULL, &pNv->tesla_scratch);
 	nouveau_bo_ref(NULL, &pNv->shader_mem);
 }
+
+
+/* AROS CODE */
+
+BOOL HIDDNouveauAccelCommonInit(struct CardData * carddata)
+{
+    return NVAccelCommonInit(carddata);
+}
+
+VOID HIDDNouveauAccelFree(struct CardData * carddata)
+{
+    NVAccelFree(carddata);
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nvc0_accel.c xf86-video-nouveau/nvc0_accel.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nvc0_accel.c	2011-09-24 10:24:30.000000000 +0200
+++ xf86-video-nouveau/nvc0_accel.c	2011-09-24 10:24:51.000000000 +0200
@@ -76,7 +76,9 @@
 	OUT_RING  (chan, 1);
 	FIRE_RING (chan);
 
+#if !defined(__AROS__)
 	pNv->currentRop = 0xfffffffa;
+#endif
 	return TRUE;
 }
 
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nvc0_exa.c xf86-video-nouveau/nvc0_exa.c
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nvc0_exa.c	2011-09-25 16:32:02.000000000 +0200
+++ xf86-video-nouveau/nvc0_exa.c	2011-10-05 19:00:37.000000000 +0200
@@ -28,29 +28,55 @@
 
 #define NOUVEAU_BO(a, b, c) (NOUVEAU_BO_##a | NOUVEAU_BO_##b | NOUVEAU_BO_##c)
 
+#if !defined(__AROS__)
 Bool
 NVC0AccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
 		      char *dst, unsigned dst_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pspix->drawable.pScreen->myNum];
+#else
+Bool
+NVC0AccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
+		      char *dst, unsigned dst_pitch,
+		      HIDDT_StdPixFmt dstPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pspix);
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
+#if !defined(__AROS__)
 	const int cpp = pspix->drawable.bitsPerPixel / 8;
 	const int line_len = w * cpp;
 	const int line_limit = (128 << 10) / line_len;
 	unsigned src_offset = 0, src_pitch = 0, tiled = 1;
+#else
+	const int cpp = pspix->depth > 16 ? 4 : 2;
+	const int line_len = w * cpp;
+	const int line_limit = pNv->GART->size / line_len;
+	unsigned src_offset = 0, src_pitch = 0, tiled = 1;
+	unsigned int exec = (1 << 20) | NVC0_M2MF_EXEC_LINEAR_OUT;
+#endif
 
 	if (!nv50_style_tiled_pixmap(pspix)) {
+
 		tiled = 0;
 		src_pitch = exaGetPixmapPitch(pspix);
 		src_offset = (y * src_pitch) + (x * cpp);
+#if defined(__AROS__)
+		exec |= NVC0_M2MF_EXEC_LINEAR_IN;
+#endif
 	} else {
 		BEGIN_RING(chan, m2mf, NVC0_M2MF_TILING_MODE_IN, 5);
 		OUT_RING  (chan, bo->tile_mode);
+#if !defined(__AROS__)
 		OUT_RING  (chan, pspix->drawable.width * cpp);
 		OUT_RING  (chan, pspix->drawable.height);
+#else
+		OUT_RING  (chan, pspix->width * cpp);
+		OUT_RING  (chan, pspix->height);
+#endif
 		OUT_RING  (chan, 1);
 		OUT_RING  (chan, 0);
 	}
@@ -86,7 +112,11 @@
 		}
 
 		BEGIN_RING(chan, m2mf, NVC0_M2MF_EXEC, 1);
+#if !defined(__AROS__)
 		OUT_RING  (chan, 0x100000 | (tiled << 8));
+#else
+		OUT_RING  (chan, exec | (tiled << 8));
+#endif
 
 		if (nouveau_bo_map(pNv->GART, NOUVEAU_BO_RD)) {
 			MARK_UNDO(chan);
@@ -94,6 +124,7 @@
 		}
 		src = pNv->GART->map;
 
+#if !defined(__AROS__)
 		if (dst_pitch == line_len) {
 			memcpy(dst, src, dst_pitch * line_count);
 			dst += dst_pitch * line_count;
@@ -104,6 +135,15 @@
 				dst += dst_pitch;
 			}
 		}
+#else
+        (void)i;
+        HiddNouveauReadIntoRAM(
+            (char *)src, line_len,
+            dst, dst_pitch, dstPixFmt,
+            w, line_count,
+            cl, o);
+        dst += dst_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (!tiled)
@@ -115,29 +155,54 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 Bool
 NVC0AccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
 		    const char *src, int src_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdpix->drawable.pScreen->myNum];
+#else
+Bool
+NVC0AccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
+		    const char *src, int src_pitch,
+		    HIDDT_StdPixFmt srcPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+	ScrnInfoPtr pScrn = globalcarddataptr;
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pdpix);
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
+#if !defined(__AROS__)
 	int cpp = pdpix->drawable.bitsPerPixel / 8;
 	int line_len = w * cpp;
 	int line_limit = (128 << 10) / line_len;
 	unsigned dst_offset = 0, dst_pitch = 0, tiled = 1;
+#else
+	int cpp = pdpix->depth > 16 ? 4 : 2;
+	int line_len = w * cpp;
+	int line_limit = pNv->GART->size / line_len;
+	unsigned dst_offset = 0, dst_pitch = 0, tiled = 1;
+	unsigned int exec = (1 << 20) | NVC0_M2MF_EXEC_LINEAR_IN;
+#endif
 
 	if (!nv50_style_tiled_pixmap(pdpix)) {
 		tiled = 0;
 		dst_pitch = exaGetPixmapPitch(pdpix);
 		dst_offset = (y * dst_pitch) + (x * cpp);
+#if defined(__AROS__)
+		exec |= NVC0_M2MF_EXEC_LINEAR_OUT;
+#endif
 	} else {
 		BEGIN_RING(chan, m2mf, NVC0_M2MF_TILING_MODE_OUT, 5);
 		OUT_RING  (chan, bo->tile_mode);
+#if !defined(__AROS__)
 		OUT_RING  (chan, pdpix->drawable.width * cpp);
 		OUT_RING  (chan, pdpix->drawable.height);
+#else
+		OUT_RING  (chan, pdpix->width * cpp);
+		OUT_RING  (chan, pdpix->height);
+#endif
 		OUT_RING  (chan, 1);
 		OUT_RING  (chan, 0);
 	}
@@ -154,6 +219,7 @@
 			return FALSE;
 		dst = pNv->GART->map;
 
+#if !defined(__AROS__)
 		if (src_pitch == line_len) {
 			memcpy(dst, src, src_pitch * line_count);
 			src += src_pitch * line_count;
@@ -162,8 +228,17 @@
 				memcpy(dst, src, line_len);
 				src += src_pitch;
 				dst += line_len;
-                        }
+            }
 		}
+#else
+        (void)i;
+        HiddNouveauWriteFromRAM(
+            (APTR)src, src_pitch, srcPixFmt,
+            dst, line_len,
+            w, line_count,
+            cl, o);
+        src += src_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (MARK_RING(chan, 16, 4))
@@ -191,7 +266,11 @@
 		OUT_RING  (chan, line_count);
 
 		BEGIN_RING(chan, m2mf, NVC0_M2MF_EXEC, 1);
+#if !defined(__AROS__)
 		OUT_RING  (chan, 0x100000 | (tiled << 4));
+#else
+		OUT_RING  (chan, exec | (tiled << 4));
+#endif
 		FIRE_RING (chan);
 
 		if (!tiled)
@@ -203,7 +282,7 @@
 	return TRUE;
 }
 
-
+#if !defined(__AROS__)
 struct nvc0_exa_state {
 	struct {
 		PictTransformPtr transform;
@@ -215,7 +294,9 @@
 };
 
 static struct nvc0_exa_state exa_state;
+#endif
 
+#if !defined(__AROS__)
 #define NVC0EXA_LOCALS(p)                                              \
 	ScrnInfoPtr pScrn = xf86Screens[(p)->drawable.pScreen->myNum]; \
 	NVPtr pNv = NVPTR(pScrn);                                      \
@@ -224,7 +305,17 @@
 	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
 	struct nouveau_grobj *fermi = pNv->Nv3D; (void)fermi;          \
 	struct nvc0_exa_state *state = &exa_state; (void)state
+#else
+#define NVC0EXA_LOCALS(p)                                          \
+	ScrnInfoPtr pScrn = globalcarddataptr;                         \
+	NVPtr pNv = NVPTR(pScrn);                                      \
+	struct nouveau_channel *chan = pNv->chan; (void)chan;          \
+	struct nouveau_grobj *m2mf = pNv->NvMemFormat; (void)m2mf;     \
+	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
+	struct nouveau_grobj *fermi = pNv->Nv3D; (void)fermi;
+#endif
 
+#if !defined(__AROS__)
 #define BF(f) NV50_BLEND_FACTOR_##f
 
 struct nvc0_blend_op {
@@ -250,13 +341,18 @@
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
 };
+#endif
 
 static Bool
 NVC0EXA2DSurfaceFormat(PixmapPtr ppix, uint32_t *fmt)
 {
 	NVC0EXA_LOCALS(ppix);
 
+#if !defined(__AROS__)
 	switch (ppix->drawable.bitsPerPixel) {
+#else
+	switch (ppix->depth) {
+#endif
 	case 8 : *fmt = NV50_2D_SRC_FORMAT_R8_UNORM; break;
 	case 15: *fmt = NV50_2D_SRC_FORMAT_X1R5G5B5_UNORM; break;
 	case 16: *fmt = NV50_2D_SRC_FORMAT_R5G6B5_UNORM; break;
@@ -313,14 +409,23 @@
 	}
 
 	BEGIN_RING(chan, eng2d, mthd + 0x18, 4);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, ppix->height);
+#endif
 	if (OUT_RELOCh(chan, bo, 0, bo_flags) ||
 	    OUT_RELOCl(chan, bo, 0, bo_flags))
 		return FALSE;
 
 	if (is_src == 0)
+#if !defined(__AROS__)
 		NVC0EXASetClip(ppix, 0, 0, ppix->drawable.width, ppix->drawable.height);
+#else
+		NVC0EXASetClip(ppix, 0, 0, ppix->width, ppix->height);
+#endif
 
 	return TRUE;
 }
@@ -337,6 +442,7 @@
 	OUT_RING  (chan, pat1);
 }
 
+#if !defined(__AROS__)
 static void
 NVC0EXASetROP(PixmapPtr pdpix, int alu, Pixel planemask)
 {
@@ -388,7 +494,42 @@
 		pNv->currentRop = alu;
 	}
 }
+#else
+static void
+NVC0EXASetROP(PixmapPtr pdpix, int alu, Pixel planemask)
+{
+	NVC0EXA_LOCALS(pdpix);
+	LONG rop;
+
+	rop = NVROP[alu].copy;
+
+	BEGIN_RING(chan, eng2d, NV50_2D_OPERATION, 1);
+	if (alu == 0x03 /* DrawMode_Copy */) {
+		OUT_RING  (chan, NV50_2D_OPERATION_SRCCOPY);
+		return;
+	} else {
+		OUT_RING  (chan, NV50_2D_OPERATION_SRCCOPY_PREMULT);
+	}
 
+	BEGIN_RING(chan, eng2d, NV50_2D_PATTERN_FORMAT, 2);
+	switch (pdpix->depth) {
+	case  8: OUT_RING  (chan, 3); break;
+	case 15: OUT_RING  (chan, 1); break;
+	case 16: OUT_RING  (chan, 0); break;
+	case 24:
+	case 32:
+	default:
+		 OUT_RING  (chan, 2);
+		 break;
+	}
+	OUT_RING  (chan, 1);
+
+	BEGIN_RING(chan, eng2d, NV50_2D_ROP, 1);
+	OUT_RING  (chan, rop);
+}
+#endif
+
+#if !defined(__AROS__)
 static void
 NVC0EXAStateSolidResubmit(struct nouveau_channel *chan)
 {
@@ -398,6 +539,7 @@
 	NVC0EXAPrepareSolid(pNv->pdpix, pNv->alu, pNv->planemask,
 			    pNv->fg_colour);
 }
+#endif
 
 Bool
 NVC0EXAPrepareSolid(PixmapPtr pdpix, int alu, Pixel planemask, Pixel fg)
@@ -423,11 +565,15 @@
 	OUT_RING  (chan, fmt);
 	OUT_RING  (chan, fg);
 
+#if !defined(__AROS__)
 	pNv->pdpix = pdpix;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	pNv->fg_colour = fg;
 	chan->flush_notify = NVC0EXAStateSolidResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -443,10 +589,13 @@
 	OUT_RING  (chan, x2);
 	OUT_RING  (chan, y2);
 
+#if !defined(__AROS__)
 	if ((x2 - x1) * (y2 - y1) >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NVC0EXADoneSolid(PixmapPtr pdpix)
 {
@@ -464,6 +613,7 @@
 	NVC0EXAPrepareCopy(pNv->pspix, pNv->pdpix, 0, 0, pNv->alu,
 			   pNv->planemask);
 }
+#endif
 
 Bool
 NVC0EXAPrepareCopy(PixmapPtr pspix, PixmapPtr pdpix, int dx, int dy,
@@ -486,11 +636,15 @@
 
 	NVC0EXASetROP(pdpix, alu, planemask);
 
+#if !defined(__AROS__)
 	pNv->pspix = pspix;
 	pNv->pdpix = pdpix;
 	pNv->alu = alu;
 	pNv->planemask = planemask;
 	chan->flush_notify = NVC0EXAStateCopyResubmit;
+#else
+	chan->flush_notify = NULL;
+#endif
 	return TRUE;
 }
 
@@ -520,10 +674,13 @@
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, srcY);
 
+#if !defined(__AROS__)
 	if (width * height >= 512)
+#endif
 		FIRE_RING (chan);
 }
 
+#if !defined(__AROS__)
 void
 NVC0EXADoneCopy(PixmapPtr pdpix)
 {
@@ -1201,4 +1358,43 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
+/* AROS CODE */
+
+VOID HIDDNouveauNVC0SetPattern(struct CardData * carddata, LONG clr0, LONG clr1,
+		  LONG pat0, LONG pat1)
+{
+    NVC0EXASetPattern(NULL, clr0, clr1, pat0, pat1);
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HIDDNouveauNVC0FillSolidRect(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * bmdata, LONG minX, LONG minY, LONG maxX,
+    LONG maxY, ULONG drawmode, ULONG color)
+{
+    if (NVC0EXAPrepareSolid(bmdata, drawmode, ~0, color))
+    {
+        NVC0EXASolid(bmdata, minX, minY, maxX + 1, maxY + 1);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/* NOTE: Assumes lock on both bitmaps is already made */
+/* NOTE: Assumes both buffers are not mapped */
+BOOL HIDDNouveauNVC0CopySameFormat(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    LONG srcX, LONG srcY, LONG destX, LONG destY, LONG width, LONG height,
+    ULONG drawmode)
+{
+    if (NVC0EXAPrepareCopy(srcdata, destdata, 0, 0, drawmode, ~0))
+    {
+        NVC0EXACopy(destdata, srcX, srcY, destX , destY, width, height);
+        return TRUE;
+    }
+
+    return FALSE;
+}
diff -ur /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv_include.h xf86-video-nouveau/nv_include.h
--- /data/deadwood/source/xf86-video-nouveau-src-2011-08-23/nv_include.h	2011-08-23 04:10:58.000000000 +0200
+++ xf86-video-nouveau/nv_include.h	2011-09-26 21:07:38.000000000 +0200
@@ -1,84 +1,168 @@
 #ifndef __NV_INCLUDE_H__
 #define __NV_INCLUDE_H__
+/*
+    Copyright © 2011, The AROS Development Team. All rights reserved.
+    $Id$
+*/
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <string.h>
-#include <math.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-/* All drivers should typically include these */
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#define PPC_MMIO_IS_BE
-#include "compiler.h"
-
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
-/* Drivers that need to access the PCI config space directly need this */
-#include "xf86Pci.h"
-
-/* All drivers initialising the SW cursor need this */
-#include "mipointer.h"
-
-/* All drivers implementing backing store need this */
-#include "mibstore.h"
-
-#include "micmap.h"
-
-#include "xf86DDC.h"
-
-#include "vbe.h"
-
-#include "xf86RandR12.h"
-
-#include "nv_const.h"
-
-#include "dixstruct.h"
-#include "scrnintstr.h"
-
-#include "fb.h"
-
-#include "xf86cmap.h"
-#include "shadowfb.h"
-
-#include "xf86xv.h"
-#include <X11/extensions/Xv.h>
-
-#include "xf86Cursor.h"
-#include "xf86DDC.h"
-
-#include "region.h"
-
-#include <X11/extensions/randr.h>
-
-#ifdef HAVE_XEXTPROTO_71
-#include <X11/extensions/dpmsconst.h>
-#else
-#define DPMS_SERVER
-#include <X11/extensions/dpms.h>
-#endif
-
-#define NV_DMA_DEBUG 0
-
-#include "nv_type.h"
-#include "nv_proto.h"
-#include "nv_dma.h"
+#include "nouveau_intern.h"
 #include "nouveau_class.h"
-#include "sarea.h"
 
-#include "nouveau_drmif.h"
-#include "nouveau_device.h"
-#include "nouveau_channel.h"
-#include "nouveau_bo.h"
-#include "nouveau_grobj.h"
-#include "nouveau_notifier.h"
 #include "nouveau_local.h"
-#include "nouveau_pushbuf.h"
+
+/* Some overriding defines for AROS */
+#define Bool                        BOOL
+#define ScrnInfoPtr                 struct CardData *
+#define NVPTR(x)                    x
+#define NVPtr                       struct CardData *
+#define Architecture                architecture
+#define PixmapPtr                   struct HIDDNouveauBitMapData *
+#define xf86DrvMsg(a, b, fmt, ...)  bug(fmt, ##__VA_ARGS__)
+#define ErrorF(msg, ...)            bug(msg, ##__VA_ARGS__)
+#define PictFormatShort             LONG
+#define PictTransformPtr            APTR
+#define Pixel                       HIDDT_Pixel
+#define CARD32                      LONG
+
+struct Picture
+{
+    LONG format;
+    BOOL componentAlpha;
+    LONG filter;
+    BOOL repeat;
+    LONG repeatType;
+};
+
+typedef struct Picture * PicturePtr;
+
+/* This construction is implemented so that original EXA funtion calls don't 
+   have to be extended with ScrnInfoPtr parameter which makes code harder to
+   maintain */
+extern struct CardData * globalcarddataptr;
+
+#define PictFilterNearest   1
+#define PictFilterBilinear  2
+
+#define RepeatNone          0 /* This must be zero/FALSE, see nv10_exa for usage against ppict->repeat which is BOOL */
+#define RepeatNormal        1
+#define RepeatReflect       2
+#define RepeatPad           3
+
+#define PICT_UNKNOWN        0
+#define PICT_a8r8g8b8       1
+#define PICT_x8r8g8b8       2
+#define PICT_a8b8g8r8       3
+#define PICT_x8b8g8r8       4
+#define PICT_b8g8r8a8       5
+#define PICT_b8g8r8x8       6
+#define PICT_a2b10g10r10    7
+#define PICT_x2b10g10r10    8
+#define PICT_a2r10g10b10    9
+#define PICT_x2r10g10b10    10
+#define PICT_a1r5g5b5       11
+#define PICT_x1r5g5b5       12
+#define PICT_a1b5g5r5       13
+#define PICT_x1b5g5r5       14
+#define PICT_x4r4g4b4       15
+#define PICT_a4r4g4b4       16
+#define PICT_x4b4g4r4       17
+#define PICT_a4b4g4r4       18
+#define PICT_r5g6b5         19
+#define PICT_b5g6r5         20
+#define PICT_a8             21
+
+
+#define nouveau_pixmap_bo(x)    (x->bo)
+#define exaGetPixmapPitch(x)    (x->pitch)
+
+#define PictOpSaturate      14
+
+Bool NVAccelInitNV50TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV40TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV30TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV10TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitM2MF_NVC0(ScrnInfoPtr pScrn);
+Bool NVAccelInit2D_NVC0(ScrnInfoPtr pScrn);
+Bool NVAccelInit3D_NVC0(ScrnInfoPtr pScrn);
+Bool nv50_style_tiled_pixmap(PixmapPtr ppix);
+
+
+static inline BOOL PICT_FORMAT_A(int format)
+{
+    switch(format)
+    {
+    case(PICT_a8r8g8b8):
+    case(PICT_a8b8g8r8):
+    case(PICT_b8g8r8a8):
+    case(PICT_a2b10g10r10):
+    case(PICT_a2r10g10b10):
+    case(PICT_a1r5g5b5):
+    case(PICT_a1b5g5r5):
+    case(PICT_a4r4g4b4):
+    case(PICT_a4b4g4r4):
+    case(PICT_a8):
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static inline BOOL PICT_FORMAT_RGB(int format)
+{
+    switch(format)
+    {
+    case(PICT_a8r8g8b8):
+    case(PICT_x8r8g8b8):
+    case(PICT_x8b8g8r8):
+    case(PICT_a8b8g8r8):
+    case(PICT_b8g8r8a8):
+    case(PICT_b8g8r8x8):
+    case(PICT_a2b10g10r10):
+    case(PICT_x2b10g10r10):
+    case(PICT_a2r10g10b10):
+    case(PICT_x2r10g10b10):
+    case(PICT_a1r5g5b5):
+    case(PICT_x1r5g5b5):
+    case(PICT_a1b5g5r5):
+    case(PICT_x1b5g5r5):
+    case(PICT_x4r4g4b4):
+    case(PICT_a4r4g4b4):
+    case(PICT_x4b4g4r4):
+    case(PICT_a4b4g4r4):
+    case(PICT_r5g6b5):
+    case(PICT_b5g6r5):
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+static inline VOID HIDDNouveauFillPictureFromBitMapData(struct Picture * pPict, 
+    struct HIDDNouveauBitMapData * bmdata)
+{
+    /* pPict->format */
+    if (bmdata->depth == 32)
+        pPict->format = PICT_a8r8g8b8;
+    else if (bmdata->depth == 24)
+        pPict->format = PICT_x8r8g8b8;
+    else if (bmdata->depth == 16)
+        pPict->format = PICT_r5g6b5;
+    else
+        pPict->format = PICT_UNKNOWN;
+
+    /* pPict->componentAlpha - keep this always as FALSE, used when mask
+       bitmap would be present (which is not the case in AROS */
+    pPict->componentAlpha = FALSE;
+    
+    /* pPict->filter - keep this always as PictFilterNearest, unless you want
+       bi-linear (probably slower and might give weird effects */
+    pPict->filter = PictFilterNearest;
+    
+    /* pPict->repeat - keep this always as FALSE */
+    pPict->repeat = FALSE;
+    /* pPict->repeatType - value does not matter as long as repeat is FALSE */
+    pPict->repeatType = RepeatNone;
+}
 
 #endif /* __NV_INCLUDE_H__ */
