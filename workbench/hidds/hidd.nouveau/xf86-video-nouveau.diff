diff -ur ./xf86-video-nouveau-src/nouveau_exa.c ./xf86-video-nouveau/nouveau_exa.c
--- ./xf86-video-nouveau-src/nouveau_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nouveau_exa.c	2011-05-07 21:30:39.000000000 +0200
@@ -21,6 +21,7 @@
  */
 
 #include "nv_include.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
 #include "exa.h"
 
@@ -40,23 +41,40 @@
 
 	return TRUE;
 }
+#endif
 
+#if !defined(__AROS__)
 static inline Bool
 NVAccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
 		    char *dst, unsigned dst_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pspix->drawable.pScreen->myNum];
+#else
+static inline Bool
+NVAccelDownloadM2MF(PixmapPtr pspix, int x, int y, int w, int h,
+		    char *dst, unsigned dst_pitch,
+		    ScrnInfoPtr pScrn, HIDDT_StdPixFmt dstPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pspix);
+#if !defined(__AROS__)
 	unsigned cpp = pspix->drawable.bitsPerPixel / 8;
+#else
+	unsigned cpp = pspix->bytesperpixel;
+#endif
 	unsigned line_len = w * cpp;
 	unsigned src_offset = 0, src_pitch = 0, linear = 0;
 	/* Maximum DMA transfer */
 	unsigned line_count = pNv->GART->size / line_len;
 
+#if !defined(__AROS__)
 	if (!nv50_style_tiled_pixmap(pspix)) {
+#else
+	if (!nv50_style_tiled_pixmap(pspix, pScrn)) {
+#endif
 		linear     = 1;
 		src_pitch  = exaGetPixmapPitch(pspix);
 		src_offset += (y * src_pitch) + (x * cpp);
@@ -90,8 +108,13 @@
 				BEGIN_RING(chan, m2mf, NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_IN, 7);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, bo->tile_mode << 4);
+#if !defined(__AROS__)
 				OUT_RING  (chan, pspix->drawable.width * cpp);
 				OUT_RING  (chan, pspix->drawable.height);
+#else
+				OUT_RING  (chan, pspix->width * cpp);
+				OUT_RING  (chan, pspix->height);
+#endif
 				OUT_RING  (chan, 1);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, (y << 16) | (x * cpp));
@@ -134,6 +157,7 @@
 			return FALSE;
 		}
 		src = pNv->GART->map;
+#if !defined(__AROS__)
 		if (dst_pitch == line_len) {
 			memcpy(dst, src, dst_pitch * line_count);
 			dst += dst_pitch * line_count;
@@ -144,6 +168,15 @@
 				dst += dst_pitch;
 			}
 		}
+#else
+        (void)i;
+        HiddNouveauReadIntoRAM(
+            src, line_len,
+            dst, dst_pitch, dstPixFmt,
+            w, line_count,
+            cl, o);
+        dst += dst_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (linear)
@@ -155,22 +188,38 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static inline Bool
 NVAccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
 		  const char *src, int src_pitch)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdpix->drawable.pScreen->myNum];
+#else
+static inline Bool
+NVAccelUploadM2MF(PixmapPtr pdpix, int x, int y, int w, int h,
+		  const char *src, int src_pitch, 
+		  ScrnInfoPtr pScrn, HIDDT_StdPixFmt srcPixFmt, OOP_Class *cl, OOP_Object *o)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *m2mf = pNv->NvMemFormat;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pdpix);
+#if !defined(__AROS__)
 	unsigned cpp = pdpix->drawable.bitsPerPixel / 8;
+#else
+	unsigned cpp = pdpix->bytesperpixel;
+#endif
 	unsigned line_len = w * cpp;
 	unsigned dst_offset = 0, dst_pitch = 0, linear = 0;
 	/* Maximum DMA transfer */
 	unsigned line_count = pNv->GART->size / line_len;
 
+#if !defined(__AROS__)
 	if (!nv50_style_tiled_pixmap(pdpix)) {
+#else
+	if (!nv50_style_tiled_pixmap(pdpix, pScrn)) {
+#endif
 		linear     = 1;
 		dst_pitch  = exaGetPixmapPitch(pdpix);
 		dst_offset += (y * dst_pitch) + (x * cpp);
@@ -191,6 +240,7 @@
 		if (nouveau_bo_map(pNv->GART, NOUVEAU_BO_WR))
 			return FALSE;
 		dst = pNv->GART->map;
+#if !defined(__AROS__)
 		if (src_pitch == line_len) {
 			memcpy(dst, src, src_pitch * line_count);
 			src += src_pitch * line_count;
@@ -201,6 +251,15 @@
 				dst += line_len;
 			}
 		}
+#else
+        (void)i;
+        HiddNouveauWriteFromRAM(
+            (APTR)src, src_pitch, srcPixFmt,
+            dst, line_len,
+            w, line_count,
+            cl, o);
+        src += src_pitch * line_count;
+#endif
 		nouveau_bo_unmap(pNv->GART);
 
 		if (MARK_RING(chan, 32, 6))
@@ -223,8 +282,13 @@
 				BEGIN_RING(chan, m2mf, NV50_MEMORY_TO_MEMORY_FORMAT_LINEAR_OUT, 7);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, bo->tile_mode << 4);
+#if !defined(__AROS__)
 				OUT_RING  (chan, pdpix->drawable.width * cpp);
 				OUT_RING  (chan, pdpix->drawable.height);
+#else
+				OUT_RING  (chan, pdpix->width * cpp);
+				OUT_RING  (chan, pdpix->height);
+#endif
 				OUT_RING  (chan, 1);
 				OUT_RING  (chan, 0);
 				OUT_RING  (chan, (y << 16) | (x * cpp));
@@ -270,6 +334,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static int
 nouveau_exa_mark_sync(ScreenPtr pScreen)
 {
@@ -350,11 +415,18 @@
 	nouveau_bo_ref(NULL, &nvpix->bo);
 	free(nvpix);
 }
+#endif
 
+#if !defined(__AROS__)
 bool
 nv50_style_tiled_pixmap(PixmapPtr ppix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[ppix->drawable.pScreen->myNum];
+#else
+Bool
+nv50_style_tiled_pixmap(PixmapPtr ppix, ScrnInfoPtr pScrn)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 
 	return pNv->Architecture >= NV_ARCH_50 &&
@@ -362,6 +434,7 @@
 		 NOUVEAU_BO_TILE_LAYOUT_MASK);
 }
 
+#if !defined(__AROS__)
 static Bool
 nouveau_exa_download_from_screen(PixmapPtr pspix, int x, int y, int w, int h,
 				 char *dst, int dst_pitch)
@@ -593,3 +666,38 @@
 	pNv->EXADriverPtr = exa;
 	return TRUE;
 }
+#endif
+
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes lock on GART object is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HiddNouveauNVAccelUploadM2MF(
+    UBYTE * srcpixels, ULONG srcpitch, HIDDT_StdPixFmt srcPixFmt,
+    ULONG x, ULONG y, ULONG width, ULONG height, 
+    OOP_Class *cl, OOP_Object *o)
+{
+    struct HIDDNouveauBitMapData * bmdata = OOP_INST_DATA(cl, o);
+    struct CardData * carddata = &(SD(cl)->carddata);
+
+    return NVAccelUploadM2MF(bmdata, x, y, width, height,
+		  srcpixels, srcpitch, carddata, srcPixFmt, cl, o);
+}
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes lock on GART object is already made */
+/* NOTE: Assumes buffer is not mapped */
+BOOL HiddNouveauNVAccelDownloadM2MF(
+    UBYTE * dstpixels, ULONG dstpitch, HIDDT_StdPixFmt dstPixFmt,
+    ULONG x, ULONG y, ULONG width, ULONG height, 
+    OOP_Class *cl, OOP_Object *o)  
+{
+    struct HIDDNouveauBitMapData * bmdata = OOP_INST_DATA(cl, o);
+    struct CardData * carddata = &(SD(cl)->carddata);
+
+    return NVAccelDownloadM2MF(bmdata, x, y, width, height,
+		    dstpixels, dstpitch, carddata, dstPixFmt, cl, o);
+}
+
diff -ur ./xf86-video-nouveau-src/nouveau_local.h ./xf86-video-nouveau/nouveau_local.h
--- ./xf86-video-nouveau-src/nouveau_local.h	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nouveau_local.h	2011-05-07 16:16:56.000000000 +0200
@@ -23,8 +23,10 @@
 #ifndef __NOUVEAU_LOCAL_H__
 #define __NOUVEAU_LOCAL_H__
 
+#if !defined(__AROS__)
 #include "compiler.h"
 #include "xf86_OSproc.h"
+#endif
 
 /* Debug output */
 #define NOUVEAU_MSG(fmt,args...) ErrorF(fmt, ##args)
diff -ur ./xf86-video-nouveau-src/nv10_exa.c ./xf86-video-nouveau/nv10_exa.c
--- ./xf86-video-nouveau-src/nv10_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv10_exa.c	2011-05-03 14:51:06.000000000 +0200
@@ -28,7 +28,9 @@
 #endif
 
 #include "nv_include.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#endif
 
 /* Texture/Render target formats. */
 static struct pict_format {
@@ -62,10 +64,16 @@
 	{},
 };
 
+#if !defined(__AROS__)
 static int
 get_tex_format(PicturePtr pict)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pict->pDrawable->pScreen->myNum];
+#else
+static int
+get_tex_format(PicturePtr pict, ScrnInfoPtr pScrn)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 
 	/* If repeat is set we're always handling a 1x1 texture with
@@ -120,6 +128,7 @@
 	{ SF(ONE_MINUS_DST_ALPHA), DF(SRC_ALPHA) },	      /* AtopReverse */
 	{ SF(ONE_MINUS_DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) }, /* Xor */
 	{ SF(ONE),		   DF(ONE) },		      /* Add */
+	{ SF(SRC_ALPHA),   DF(ONE_MINUS_SRC_ALPHA) }, /* OverAlpha */
 };
 
 static inline Bool
@@ -141,6 +150,7 @@
 	return mask && mask->componentAlpha && PICT_FORMAT_RGB(mask->format);
 }
 
+#if !defined(__AROS__)
 static Bool
 check_texture(PicturePtr pict)
 {
@@ -368,6 +378,7 @@
 	print_fallback_info("Accelerating", op, src, mask, dst);
 	return TRUE;
 }
+#endif
 
 static Bool
 setup_texture(NVPtr pNv, int unit, PicturePtr pict, PixmapPtr pixmap)
@@ -376,14 +387,23 @@
 	struct nouveau_grobj *celsius = pNv->Nv3D;
 	struct nouveau_bo *bo = nouveau_pixmap_bo(pixmap);
 	unsigned tex_reloc = NOUVEAU_BO_VRAM | NOUVEAU_BO_GART | NOUVEAU_BO_RD;
+#if !defined(__AROS__)
 	long w = pict->pDrawable->width,
 	     h = pict->pDrawable->height;
+#else
+	long w = pixmap->width,
+	     h = pixmap->height;
+#endif
 	unsigned int txfmt =
 		NV10TCL_TX_FORMAT_WRAP_T_CLAMP_TO_EDGE |
 		NV10TCL_TX_FORMAT_WRAP_S_CLAMP_TO_EDGE |
 		log2i(w) << 20 | log2i(h) << 16 |
 		1 << 12 | /* lod == 1 */
+#if !defined(__AROS__)
 		get_tex_format(pict) |
+#else
+		get_tex_format(pict, pNv) |
+#endif
 		0x50 /* UNK */;
 
 	BEGIN_RING(chan, celsius, NV10TCL_TX_OFFSET(unit), 1);
@@ -481,8 +501,13 @@
 	(NV10TCL_RC_IN_RGB_##input##_INPUT_CONSTANT_COLOR##unit |	\
 	 NV10TCL_RC_IN_RGB_##input##_COMPONENT_USAGE_##chan)
 
+#if !defined(__AROS__)
 static void
 setup_combiners(NVPtr pNv, PicturePtr src, PicturePtr mask)
+#else
+static void
+setup_combiners(NVPtr pNv, PicturePtr src, PicturePtr mask, int op)
+#endif
 {
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
@@ -499,7 +524,11 @@
 		rc_in_alpha |= RC_IN_ONE(B);
 
 	if (effective_component_alpha(mask)) {
+#if !defined(__AROS__)
 		if (!needs_src_alpha(pNv->alu)) {
+#else
+		if (!needs_src_alpha(op)) {
+#endif
 			/* The alpha channels won't be used for blending. Drop
 			 * them, as our pixels only have 4 components...
 			 * output_i = src_i * mask_i
@@ -535,24 +564,41 @@
 	OUT_RING  (chan, rc_in_rgb);
 }
 
+#if !defined(__AROS__)
 static void
 setup_blend_function(NVPtr pNv)
+#else
+static void
+setup_blend_function(NVPtr pNv, PicturePtr dst, PicturePtr mask, int blendop)
+#endif
 {
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
+#if !defined(__AROS__)
 	struct pict_op *op = &nv10_pict_op[pNv->alu];
+#else
+	struct pict_op *op = &nv10_pict_op[blendop];
+#endif
 	int src_factor = op->src;
 	int dst_factor = op->dst;
 
 	if (src_factor == SF(ONE_MINUS_DST_ALPHA) &&
+#if !defined(__AROS__)
 	    !PICT_FORMAT_A(pNv->pdpict->format))
+#else
+	    !PICT_FORMAT_A(dst->format))
+#endif
 		/* ONE_MINUS_DST_ALPHA doesn't always do the right thing for
 		 * framebuffers without alpha channel. But it's the same as
 		 * ZERO in that case.
 		 */
 		src_factor = SF(ZERO);
 
+#if !defined(__AROS__)
 	if (effective_component_alpha(pNv->pmpict)) {
+#else
+	if (effective_component_alpha(mask)) {
+#endif
 		if (dst_factor == DF(SRC_ALPHA))
 			dst_factor = DF(SRC_COLOR);
 		else if (dst_factor == DF(ONE_MINUS_SRC_ALPHA))
@@ -566,6 +612,7 @@
 	OUT_RING  (chan, 1);
 }
 
+#if !defined(__AROS__)
 static void
 NV10StateCompositeReemit(struct nouveau_channel *chan)
 {
@@ -575,7 +622,9 @@
 	NV10EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV10EXAPrepareComposite(int op,
 			PicturePtr pict_src,
@@ -586,12 +635,24 @@
 			PixmapPtr dst)
 {
 	ScrnInfoPtr pScrn = xf86Screens[dst->drawable.pScreen->myNum];
+#else
+static Bool
+NV10EXAPrepareComposite(int op,
+			PicturePtr pict_src,
+			PicturePtr pict_mask,
+			PicturePtr pict_dst,
+			PixmapPtr src,
+			PixmapPtr mask,
+			PixmapPtr dst, ScrnInfoPtr pScrn)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 
 	if (MARK_RING(chan, 128, 5))
 		return FALSE;
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = pict_src;
 	pNv->pmpict = pict_mask;
@@ -599,6 +660,7 @@
 	pNv->pspix = src;
 	pNv->pmpix = mask;
 	pNv->pdpix = dst;
+#endif
 
 	/* Set dst format */
 	if (!setup_render_target(pNv, pict_dst, dst))
@@ -613,6 +675,7 @@
 	    !setup_texture(pNv, 1, pict_mask, mask))
 		goto fail;
 
+#if !defined(__AROS__)
 	/* Set the register combiners up. */
 	setup_combiners(pNv, pict_src, pict_mask);
 
@@ -620,6 +683,15 @@
 	setup_blend_function(pNv);
 
 	chan->flush_notify = NV10StateCompositeReemit;
+#else
+	/* Set the register combiners up. */
+	setup_combiners(pNv, pict_src, pict_mask, op);
+
+	/* Set PictOp */
+	setup_blend_function(pNv, pict_dst, pict_mask, op);
+
+	chan->flush_notify = NULL;
+#endif
 
 	return TRUE;
 
@@ -629,6 +701,20 @@
 	return FALSE;
 }
 
+#if defined(__AROS__)
+/* WARNING: These defines are only used to hack QUAD/MAP/OUT_RINGi defines 
+   in this use case. They WILL NOT work in generic case. DO NOT reuse them. */
+struct _PictVector
+{
+    float vector[3];
+};
+typedef struct _PictVector PictVector;
+#define xFixed1             0.0f
+#define xFixedFrac(x)       0
+#define xFixedToInt(x)      (x)
+#define IntToxFixed(x)      (float)(x)
+#endif
+
 #define QUAD(x, y, w, h)					\
 	{{{ IntToxFixed(x),     IntToxFixed(y),     xFixed1 }},	\
 	 {{ IntToxFixed(x + w), IntToxFixed(y),     xFixed1 }},	\
@@ -670,6 +756,7 @@
 	OUT_RINGf (chan, 0);
 }
 
+#if !defined(__AROS__)
 static inline void
 transform_vertex(PictTransformPtr t, int i, PictVector vs[])
 {
@@ -685,18 +772,33 @@
 		 int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pix_dst->drawable.pScreen->myNum];
+#else
+static void
+NV10EXAComposite(PixmapPtr pix_dst,
+		 int srcX, int srcY,
+		 int maskX, int maskY,
+		 int dstX, int dstY,
+		 int width, int height, 
+		 ScrnInfoPtr pScrn, PicturePtr src, PicturePtr mask)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *celsius = pNv->Nv3D;
+#if !defined(__AROS__)
 	PicturePtr mask = pNv->pmpict,
 		src = pNv->pspict;
+#endif
 	PictVector dstq[4] = QUAD(dstX, dstY, width, height),
 		maskq[4] = QUAD(maskX, maskY, width, height),
 		srcq[4] = QUAD(srcX, srcY, width, height);
 
+#if !defined(__AROS__)
+    /* We are not doing any transformations */
 	MAP(transform_vertex, src->transform, srcq);
 	if (mask)
 		MAP(transform_vertex, mask->transform, maskq);
+#endif
 
 	WAIT_RING (chan, 64);
 	BEGIN_RING(chan, celsius, NV10TCL_VERTEX_BEGIN_END, 1);
@@ -708,6 +810,7 @@
 	OUT_RING  (chan, NV10TCL_VERTEX_BEGIN_END_STOP);
 }
 
+#if !defined(__AROS__)
 void
 NV10EXADoneComposite(PixmapPtr dst)
 {
@@ -717,6 +820,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 Bool
 NVAccelInitNV10TCL(ScrnInfoPtr pScrn)
@@ -969,3 +1073,32 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV103DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV10EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata))
+    {
+        NV10EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &sPict, NULL);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv30_exa.c ./xf86-video-nouveau/nv30_exa.c
--- ./xf86-video-nouveau-src/nv30_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv30_exa.c	2011-05-03 10:27:48.000000000 +0200
@@ -25,7 +25,13 @@
 
 #include "nv_include.h"
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+#include <aros/debug.h>
+
+#define NV30EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -54,8 +60,10 @@
 		float height;
 	} unit[2];
 } nv30_exa_state_t;
+#if !defined(__AROS__)
 static nv30_exa_state_t exa_state;
 #define NV30EXA_STATE nv30_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV30SurfaceFormat[] = {
@@ -223,7 +231,8 @@
 /* Atop        */ { 1, 1, BF(          DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) }
+/* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
+/* OverAlpha   */ { 1, 0, BF(          SRC_ALPHA), BF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -299,8 +308,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV30EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv30_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -326,9 +340,17 @@
 	if (OUT_RELOCl(chan, bo, 0, tex_reloc) ||
 	    OUT_RELOCd(chan, bo, NV34TCL_TX_FORMAT_DIMS_2D | (1 << 16) | 8 |
 		       (fmt->card_fmt << NV34TCL_TX_FORMAT_FORMAT_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.width) <<
+#else
+		       (log2i(pPix->width) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_U_SHIFT) |
+#if !defined(__AROS__)
 		       (log2i(pPix->drawable.height) <<
+#else
+		       (log2i(pPix->height) <<
+#endif
 			NV34TCL_TX_FORMAT_BASE_SIZE_V_SHIFT),
 		       tex_reloc | NOUVEAU_BO_OR,
 		       NV34TCL_TX_FORMAT_DMA0, NV34TCL_TX_FORMAT_DMA1))
@@ -343,12 +365,21 @@
 	OUT_RING  (chan, (card_filter << NV34TCL_TX_FILTER_MINIFY_SHIFT) /* min */ |
 			(card_filter << NV34TCL_TX_FILTER_MAGNIFY_SHIFT) /* mag */ |
 			0x2000 /* engine lock */);
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << NV34TCL_TX_NPOT_SIZE_W_SHIFT) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 
 	return TRUE;
 }
@@ -379,6 +410,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV30EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -460,7 +492,9 @@
 	NV30EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV30EXAPrepareComposite(int op, PicturePtr psPict,
 		PicturePtr pmPict,
@@ -470,6 +504,17 @@
 		PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV30EXAPrepareComposite(int op, PicturePtr psPict,
+		PicturePtr pmPict,
+		PicturePtr pdPict,
+		PixmapPtr  psPix,
+		PixmapPtr  pmPix,
+		PixmapPtr  pdPix,
+		ScrnInfoPtr pScrn, nv30_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -487,7 +532,11 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV30_SetupSurface(pScrn, pdPix, pdPict) ||
+#if !defined(__AROS__)
 	    !NV30EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV30EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
@@ -507,7 +556,11 @@
 #endif
 
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV30EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -537,6 +590,7 @@
 	BEGIN_RING(chan, rankine, 0x23c, 1);
 	OUT_RING  (chan, pmPict?3:1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -545,6 +599,7 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV30EXAStateCompositeReemit;
+#endif
 	return TRUE;
 }
 
@@ -555,15 +610,21 @@
 NV30EXATransformCoord(PictTransformPtr t, int x, int y, float sx, float sy,
 					  float *x_ret, float *y_ret)
 {
+#if !defined(__AROS__)
 	PictVector v;
+#endif
 
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
 		v.vector[2] = xFixed1;
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]);
 		*y_ret = xFixedToFloat(v.vector[1]);
+#endif
 	} else {
 		*x_ret = (float)x;
 		*y_ret = (float)y;
@@ -584,6 +645,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -591,6 +653,14 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV30EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, ScrnInfoPtr pScrn, nv30_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *rankine = pNv->Nv3D;
@@ -652,6 +722,7 @@
 	OUT_RING  (chan, 0);
 }
 
+#if !defined(__AROS__)
 void
 NV30EXADoneComposite(PixmapPtr pdPix)
 {
@@ -661,6 +732,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 Bool
 NVAccelInitNV30TCL(ScrnInfoPtr pScrn)
@@ -914,3 +986,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV303DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv30_exa_state_t state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV30EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata, &state))
+    {
+        NV30EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv30_shaders.c ./xf86-video-nouveau/nv30_shaders.c
--- ./xf86-video-nouveau-src/nv30_shaders.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv30_shaders.c	2011-05-02 23:41:21.000000000 +0200
@@ -20,9 +20,10 @@
  * SOFTWARE.
  */
 
-
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#endif
 
 void NV30_UploadFragProg(NVPtr pNv, nv_shader_t *shader, int *hw_offset)
 {
diff -ur ./xf86-video-nouveau-src/nv40_exa.c ./xf86-video-nouveau/nv40_exa.c
--- ./xf86-video-nouveau-src/nv40_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv40_exa.c	2011-05-03 10:27:48.000000000 +0200
@@ -22,7 +22,13 @@
 
 #include "nv_include.h"
 #include "nv30_shaders.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+#include <aros/debug.h>
+
+#define NV40EXA_STATE
+#endif
 
 typedef struct nv_pict_surface_format {
 	int	 pict_fmt;
@@ -51,8 +57,10 @@
 		float height;
 	} unit[2];
 } nv40_exa_state_t;
+#if !defined(__AROS__)
 static nv40_exa_state_t exa_state;
 #define NV40EXA_STATE nv40_exa_state_t *state = &exa_state
+#endif
 
 static nv_pict_surface_format_t
 NV40SurfaceFormat[] = {
@@ -172,7 +180,8 @@
 /* Atop        */ { 1, 1, SF(          DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
 /* AtopReverse */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, SF(ONE_MINUS_DST_ALPHA), DF(ONE_MINUS_SRC_ALPHA) },
-/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) }
+/* Add         */ { 0, 0, SF(                ONE), DF(                ONE) },
+/* OverAlpha   */ { 1, 0, SF(          SRC_ALPHA), DF(ONE_MINUS_SRC_ALPHA) }
 };
 
 static nv_pict_op_t *
@@ -233,8 +242,13 @@
 	}
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit)
+#else
+static Bool
+NV40EXATexture(ScrnInfoPtr pScrn, PixmapPtr pPix, PicturePtr pPict, int unit, nv40_exa_state_t * state)
+#endif
 {
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
@@ -291,6 +305,7 @@
 		OUT_RING  (chan, NV40TCL_TEX_FILTER_MIN_NEAREST |
 				 NV40TCL_TEX_FILTER_MAG_NEAREST | 0x3fd6);
 	}
+#if !defined(__AROS__)
 	OUT_RING  (chan, (pPix->drawable.width << 16) | pPix->drawable.height);
 	OUT_RING  (chan, 0); /* border ARGB */
 	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
@@ -300,6 +315,17 @@
 	state->unit[unit].width		= (float)pPix->drawable.width;
 	state->unit[unit].height	= (float)pPix->drawable.height;
 	state->unit[unit].transform	= pPict->transform;
+#else
+	OUT_RING  (chan, (pPix->width << 16) | pPix->height);
+	OUT_RING  (chan, 0); /* border ARGB */
+	BEGIN_RING(chan, curie, NV40TCL_TEX_SIZE1(unit), 1);
+	OUT_RING  (chan, (1 << NV40TCL_TEX_SIZE1_DEPTH_SHIFT) |
+			 (uint32_t)pPix->pitch);
+
+	state->unit[unit].width		= (float)pPix->width;
+	state->unit[unit].height	= (float)pPix->height;
+	state->unit[unit].transform	= NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 	return TRUE;
 }
 
@@ -329,6 +355,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV40EXACheckCompositeTexture(PicturePtr pPict, PicturePtr pdPict, int op)
 {
@@ -406,7 +433,9 @@
 	NV40EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV40EXAPrepareComposite(int op, PicturePtr psPict,
 				PicturePtr pmPict,
@@ -416,6 +445,17 @@
 				PixmapPtr  pdPix)
 {
 	ScrnInfoPtr pScrn = xf86Screens[psPix->drawable.pScreen->myNum];
+#else
+static Bool
+NV40EXAPrepareComposite(int op, PicturePtr psPict,
+				PicturePtr pmPict,
+				PicturePtr pdPict,
+				PixmapPtr  psPix,
+				PixmapPtr  pmPix,
+				PixmapPtr  pdPix,
+				ScrnInfoPtr pScrn, nv40_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
@@ -433,14 +473,22 @@
 			 PICT_FORMAT_RGB(pmPict->format)));
 
 	if (!NV40_SetupSurface(pScrn, pdPix, pdPict->format) ||
+#if !defined(__AROS__)
 	    !NV40EXATexture(pScrn, psPix, psPict, 0)) {
+#else
+	    !NV40EXATexture(pScrn, psPix, psPict, 0, state)) {
+#endif
 		MARK_UNDO(chan);
 		return FALSE;
 	}
 
 	NV40_LoadVtxProg(pScrn, &nv40_vp_exa_render);
 	if (pmPict) {
+#if !defined(__AROS__)
 		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1)) {
+#else
+		if (!NV40EXATexture(pScrn, pmPix, pmPict, 1, state)) {
+#endif
 			MARK_UNDO(chan);
 			return FALSE;
 		}
@@ -476,6 +524,7 @@
 	BEGIN_RING(chan, curie, NV40TCL_TEX_CACHE_CTL, 1);
 	OUT_RING  (chan, 1);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = psPict;
 	pNv->pmpict = pmPict;
@@ -484,6 +533,7 @@
 	pNv->pmpix = pmPix;
 	pNv->pdpix = pdPix;
 	chan->flush_notify = NV40EXAStateCompositeReemit;
+#endif
 	return TRUE;
 }
 
@@ -495,6 +545,9 @@
 					  float *x_ret, float *y_ret)
 {
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		PictVector v;
 		v.vector[0] = IntToxFixed(x);
 		v.vector[1] = IntToxFixed(y);
@@ -502,6 +555,7 @@
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]) / sx;
 		*y_ret = xFixedToFloat(v.vector[1]) / sy;
+#endif
 	} else {
 		*x_ret = (float)x / sx;
 		*y_ret = (float)y / sy;
@@ -522,6 +576,7 @@
 	OUT_RING  (chan, ((dy)<<16)|(dx));                                     \
 } while(0)
 
+#if !defined(__AROS__)
 void
 NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
 				  int maskX, int maskY,
@@ -529,11 +584,19 @@
 				  int width, int height)
 {
 	ScrnInfoPtr pScrn = xf86Screens[pdPix->drawable.pScreen->myNum];
+#else
+static void
+NV40EXAComposite(PixmapPtr pdPix, int srcX , int srcY,
+				  int maskX, int maskY,
+				  int dstX , int dstY,
+				  int width, int height, ScrnInfoPtr pScrn, nv40_exa_state_t * state)
+{
+#endif
 	NVPtr pNv = NVPTR(pScrn);
 	struct nouveau_channel *chan = pNv->chan;
 	struct nouveau_grobj *curie = pNv->Nv3D;
-	float sX0, sX1, sX2, sY0, sY1, sY2;
-	float mX0, mX1, mX2, mY0, mY1, mY2;
+	float sX0=0.0f, sX1=0.0f, sX2=0.0f, sY0=0.0f, sY1=0.0f, sY2=0.0f;
+	float mX0=0.0f, mX1=0.0f, mX2=0.0f, mY0=0.0f, mY1=0.0f, mY2=0.0f;
 	NV40EXA_STATE;
 
 	WAIT_RING(chan, 64);
@@ -587,6 +650,7 @@
 	OUT_RING  (chan, NV40TCL_BEGIN_END_STOP);
 }
 
+#if !defined(__AROS__)
 void
 NV40EXADoneComposite(PixmapPtr pdPix)
 {
@@ -596,6 +660,7 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
 #define NV40TCL_CHIPSET_4X_MASK 0x00000baf
 #define NV44TCL_CHIPSET_4X_MASK 0x00005450
@@ -760,3 +825,33 @@
 
 	return TRUE;
 }
+
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV403DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    nv40_exa_state_t state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV40EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata, &state))
+    {
+        NV40EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv50_accel.c ./xf86-video-nouveau/nv50_accel.c
--- ./xf86-video-nouveau-src/nv50_accel.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv50_accel.c	2011-05-07 16:16:56.000000000 +0200
@@ -23,6 +23,7 @@
 #include "nv_include.h"
 #include "nv50_accel.h"
 
+#if !defined(__AROS__)
 void
 NV50SyncToVBlank(PixmapPtr ppix, BoxPtr box)
 {
@@ -52,6 +53,7 @@
 	BEGIN_RING(chan, nvsw, 0x0068, 1);
 	OUT_RING  (chan, 0x11111111);
 }
+#endif
 
 Bool
 NVAccelInitNV50TCL(ScrnInfoPtr pScrn)
diff -ur ./xf86-video-nouveau-src/nv50_accel.h ./xf86-video-nouveau/nv50_accel.h
--- ./xf86-video-nouveau-src/nv50_accel.h	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv50_accel.h	2011-05-07 16:16:56.000000000 +0200
@@ -1,7 +1,9 @@
 #ifndef __NV50_ACCEL_H__
 #define __NV50_ACCEL_H__
 
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#endif
 
 /* "Tesla scratch buffer" offsets */
 #define PVP_OFFSET  0x00000000 /* Vertex program */
diff -ur ./xf86-video-nouveau-src/nv50_exa.c ./xf86-video-nouveau/nv50_exa.c
--- ./xf86-video-nouveau-src/nv50_exa.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv50_exa.c	2011-05-07 20:26:40.000000000 +0200
@@ -22,9 +22,11 @@
  */
 
 #include "nv_include.h"
+#if !defined(__AROS__)
 #include "nv_rop.h"
 
 #include "nv04_pushbuf.h"
+#endif
 #include "nv50_accel.h"
 #include "nv50_texture.h"
 
@@ -37,6 +39,7 @@
 		float height;
 	} unit[2];
 };
+#if !defined(__AROS__)
 static struct nv50_exa_state exa_state;
 
 #define NV50EXA_LOCALS(p)                                              \
@@ -46,6 +49,14 @@
 	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
 	struct nouveau_grobj *tesla = pNv->Nv3D; (void)tesla;          \
 	struct nv50_exa_state *state = &exa_state; (void)state
+#else
+#define NV50EXA_LOCALS(p)                                              \
+	NVPtr pNv = NVPTR(pScrn);                                      \
+	struct nouveau_channel *chan = pNv->chan; (void)chan;          \
+	struct nouveau_grobj *eng2d = pNv->Nv2D; (void)eng2d;          \
+	struct nouveau_grobj *tesla = pNv->Nv3D; (void)tesla;
+
+#endif
 
 #define BF(f) NV50TCL_BLEND_FUNC_SRC_RGB_##f
 
@@ -71,8 +82,10 @@
 /* AtopReverse */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(          SRC_ALPHA) },
 /* Xor         */ { 1, 1, BF(ONE_MINUS_DST_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 /* Add         */ { 0, 0, BF(                ONE), BF(                ONE) },
+/* OverAlpha   */ { 1, 0, BF(          SRC_ALPHA), BF(ONE_MINUS_SRC_ALPHA) },
 };
 
+#if !defined(__AROS__)
 static Bool
 NV50EXA2DSurfaceFormat(PixmapPtr ppix, uint32_t *fmt)
 {
@@ -463,16 +476,26 @@
 
 	return TRUE;
 }
+#endif
 
+#if !defined(__AROS__)
 static Bool
 NV50EXARenderTarget(PixmapPtr ppix, PicturePtr ppict)
+#else
+static Bool
+NV50EXARenderTarget(PixmapPtr ppix, PicturePtr ppict, ScrnInfoPtr pScrn)
+#endif
 {
 	NV50EXA_LOCALS(ppix);
 	struct nouveau_bo *bo = nouveau_pixmap_bo(ppix);
 	unsigned format;
 
 	/*XXX: Scanout buffer not tiled, someone needs to figure it out */
+#if !defined(__AROS__)
 	if (!nv50_style_tiled_pixmap(ppix))
+#else
+	if (!nv50_style_tiled_pixmap(ppix, pScrn))
+#endif
 		NOUVEAU_FALLBACK("pixmap is scanout buffer\n");
 
 	switch (ppict->format) {
@@ -505,14 +528,20 @@
 	OUT_RING  (chan, bo->tile_mode << 4);
 	OUT_RING  (chan, 0x00000000);
 	BEGIN_RING(chan, tesla, NV50TCL_RT_HORIZ(0), 2);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, ppix->height);
+#endif
 	BEGIN_RING(chan, tesla, NV50TCL_RT_ARRAY_MODE, 1);
 	OUT_RING  (chan, 0x00000001);
 
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV50EXACheckTexture(PicturePtr ppict, PicturePtr pdpict, int op)
 {
@@ -572,13 +601,19 @@
 
 	return TRUE;
 }
+#endif
 
 #define _(X1,X2,X3,X4,FMT) (NV50TIC_0_0_TYPER_UNORM | NV50TIC_0_0_TYPEG_UNORM | NV50TIC_0_0_TYPEB_UNORM | NV50TIC_0_0_TYPEA_UNORM | \
 			    NV50TIC_0_0_MAP##X1 | NV50TIC_0_0_MAP##X2 | NV50TIC_0_0_MAP##X3 | NV50TIC_0_0_MAP##X4 | \
 			    NV50TIC_0_0_FMT_##FMT)
 
+#if !defined(__AROS__)
 static Bool
 NV50EXATexture(PixmapPtr ppix, PicturePtr ppict, unsigned unit)
+#else
+static Bool
+NV50EXATexture(PixmapPtr ppix, PicturePtr ppict, unsigned unit, ScrnInfoPtr pScrn, struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(ppix);
 	struct nouveau_bo *bo = nouveau_pixmap_bo(ppix);
@@ -586,7 +621,11 @@
 	uint32_t mode;
 
 	/*XXX: Scanout buffer not tiled, someone needs to figure it out */
+#if !defined(__AROS__)
 	if (!nv50_style_tiled_pixmap(ppix))
+#else
+	if (!nv50_style_tiled_pixmap(ppix, pScrn))
+#endif
 		NOUVEAU_FALLBACK("pixmap is scanout buffer\n");
 
 	BEGIN_RING(chan, tesla, NV50TCL_TIC_ADDRESS_HIGH, 3);
@@ -678,8 +717,13 @@
 		       NOUVEAU_BO_HIGH | NOUVEAU_BO_OR, mode, mode))
 		return FALSE;
 	OUT_RING  (chan, 0x00300000);
+#if !defined(__AROS__)
 	OUT_RING  (chan, ppix->drawable.width);
 	OUT_RING  (chan, (1 << NV50TIC_0_5_DEPTH_SHIFT) | ppix->drawable.height);
+#else
+	OUT_RING  (chan, ppix->width);
+	OUT_RING  (chan, (1 << NV50TIC_0_5_DEPTH_SHIFT) | ppix->height);
+#endif
 	OUT_RING  (chan, 0x03000000);
 	OUT_RING  (chan, 0x00000000);
 
@@ -736,12 +780,19 @@
 	OUT_RING  (chan, 0x00000000);
 	OUT_RING  (chan, 0x00000000);
 
+#if !defined(__AROS__)
 	state->unit[unit].width = ppix->drawable.width;
 	state->unit[unit].height = ppix->drawable.height;
 	state->unit[unit].transform = ppict->transform;
+#else
+	state->unit[unit].width = ppix->width;
+	state->unit[unit].height = ppix->height;
+	state->unit[unit].transform = NULL; /* Keep this NULL, we are doing simple blits */
+#endif
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NV50EXACheckBlend(int op)
 {
@@ -749,9 +800,15 @@
 		NOUVEAU_FALLBACK("unsupported blend op %d\n", op);
 	return TRUE;
 }
+#endif
 
+#if !defined(__AROS__)
 static void
 NV50EXABlend(PixmapPtr ppix, PicturePtr ppict, int op, int component_alpha)
+#else
+static void
+NV50EXABlend(PixmapPtr ppix, PicturePtr ppict, int op, int component_alpha, ScrnInfoPtr pScrn)
+#endif
 {
 	NV50EXA_LOCALS(ppix);
 	struct nv50_blend_op *b = &NV50EXABlendOp[op];
@@ -793,6 +850,7 @@
 	}
 }
 
+#if !defined(__AROS__)
 Bool
 NV50EXACheckComposite(int op,
 		      PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict)
@@ -829,11 +887,20 @@
 	NV50EXAPrepareComposite(pNv->alu, pNv->pspict, pNv->pmpict, pNv->pdpict,
 				pNv->pspix, pNv->pmpix, pNv->pdpix);
 }
+#endif
 
+#if !defined(__AROS__)
 Bool
 NV50EXAPrepareComposite(int op,
 			PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict,
 			PixmapPtr pspix, PixmapPtr pmpix, PixmapPtr pdpix)
+#else
+static Bool
+NV50EXAPrepareComposite(int op,
+			PicturePtr pspict, PicturePtr pmpict, PicturePtr pdpict,
+			PixmapPtr pspix, PixmapPtr pmpix, PixmapPtr pdpix,
+			ScrnInfoPtr pScrn, struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(pspix);
 	const unsigned shd_flags = NOUVEAU_BO_VRAM | NOUVEAU_BO_RD;
@@ -844,13 +911,22 @@
 	BEGIN_RING(chan, eng2d, 0x0110, 1);
 	OUT_RING  (chan, 0);
 
+#if !defined(__AROS__)
 	if (!NV50EXARenderTarget(pdpix, pdpict)) {
+#else
+	if (!NV50EXARenderTarget(pdpix, pdpict, pScrn)) {
+#endif
 		MARK_UNDO(chan);
 		NOUVEAU_FALLBACK("render target invalid\n");
 	}
 
+#if !defined(__AROS__)
 	NV50EXABlend(pdpix, pdpict, op, pmpict && pmpict->componentAlpha &&
 		     PICT_FORMAT_RGB(pmpict->format));
+#else
+	NV50EXABlend(pdpix, pdpict, op, pmpict && pmpict->componentAlpha &&
+		     PICT_FORMAT_RGB(pmpict->format), pScrn);
+#endif
 
 	BEGIN_RING(chan, tesla, NV50TCL_VP_ADDRESS_HIGH, 2);
 	if (OUT_RELOCh(chan, pNv->tesla_scratch, PVP_OFFSET, shd_flags) ||
@@ -866,13 +942,21 @@
 		return FALSE;
 	}
 
+#if !defined(__AROS__)
 	if (!NV50EXATexture(pspix, pspict, 0)) {
+#else
+	if (!NV50EXATexture(pspix, pspict, 0, pScrn, state)) {
+#endif
 		MARK_UNDO(chan);
 		NOUVEAU_FALLBACK("src picture invalid\n");
 	}
 
 	if (pmpict) {
+#if !defined(__AROS__)
 		if (!NV50EXATexture(pmpix, pmpict, 1)) {
+#else
+		if (!NV50EXATexture(pmpix, pmpict, 1, pScrn, state)) {
+#endif
 			MARK_UNDO(chan);
 			NOUVEAU_FALLBACK("mask picture invalid\n");
 		}
@@ -910,6 +994,7 @@
 	BEGIN_RING(chan, tesla, NV50TCL_BIND_TIC(2), 1);
 	OUT_RING  (chan, 0x203);
 
+#if !defined(__AROS__)
 	pNv->alu = op;
 	pNv->pspict = pspict;
 	pNv->pmpict = pmpict;
@@ -918,6 +1003,7 @@
 	pNv->pmpix = pmpix;
 	pNv->pdpix = pdpix;
 	chan->flush_notify = NV50EXAStateCompositeResubmit;
+#endif
 	return TRUE;
 }
 
@@ -928,6 +1014,9 @@
 		 float *x_ret, float *y_ret)
 {
 	if (t) {
+	/* Note: current t is always NULL in AROS. That is good enought for
+	   operations beeing done (simple blits with alpha) */
+#if !defined(__AROS__)
 		PictVector v;
 
 		v.vector[0] = IntToxFixed(x);
@@ -936,18 +1025,25 @@
 		PictureTransformPoint(t, &v);
 		*x_ret = xFixedToFloat(v.vector[0]) / sx;
 		*y_ret = xFixedToFloat(v.vector[1]) / sy;
+#endif
 	} else {
 		*x_ret = (float)x / sx;
 		*y_ret = (float)y / sy;
 	}
 }
 
+#if !defined(__AROS__)
 void
 NV50EXAComposite(PixmapPtr pdpix, int sx, int sy, int mx, int my,
 		 int dx, int dy, int w, int h)
+#else
+static void
+NV50EXAComposite(PixmapPtr pdpix, int sx, int sy, int mx, int my,
+		 int dx, int dy, int w, int h, ScrnInfoPtr pScrn, struct nv50_exa_state * state)
+#endif
 {
 	NV50EXA_LOCALS(pdpix);
-	float sX0, sX1, sX2, sY0, sY1, sY2;
+	float sX0=0.0f, sX1=0.0f, sX2=0.0f, sY0=0.0f, sY1=0.0f, sY2=0.0f;
 
 	WAIT_RING (chan, 64);
 	BEGIN_RING(chan, tesla, NV50TCL_SCISSOR_HORIZ(0), 2);
@@ -967,7 +1063,7 @@
 			 &sX2, &sY2);
 
 	if (state->have_mask) {
-		float mX0, mX1, mX2, mY0, mY1, mY2;
+		float mX0=0.0f, mX1=0.0f, mX2=0.0f, mY0=0.0f, mY1=0.0f, mY2=0.0f;
 
 		NV50EXATransform(state->unit[1].transform, mx, my + (h * 2),
 				 state->unit[1].width, state->unit[1].height,
@@ -992,6 +1088,7 @@
 	OUT_RING  (chan, 0);
 }
 
+#if !defined(__AROS__)
 void
 NV50EXADoneComposite(PixmapPtr pdpix)
 {
@@ -999,4 +1096,34 @@
 
 	chan->flush_notify = NULL;
 }
+#endif
 
+/* AROS CODE */
+
+/* NOTE: Assumes lock on bitmap is already made */
+/* NOTE: Assumes buffer is not mapped */
+/* NOTE: Allows different formats of source and destination */
+BOOL HIDDNouveauNV503DCopyBox(struct CardData * carddata,
+    struct HIDDNouveauBitMapData * srcdata, struct HIDDNouveauBitMapData * destdata,
+    ULONG srcX, ULONG srcY, ULONG destX, ULONG destY, ULONG width, ULONG height,
+    ULONG blendop)
+{
+    struct Picture sPict, dPict;
+    struct nv50_exa_state state;
+    ULONG maskX = 0; ULONG maskY = 0;
+
+    HIDDNouveauFillPictureFromBitMapData(&sPict, srcdata);   
+    HIDDNouveauFillPictureFromBitMapData(&dPict, destdata);
+
+    if (NV50EXAPrepareComposite(blendop,
+        &sPict, NULL, &dPict, srcdata, NULL, destdata, carddata, &state))
+    {
+        NV50EXAComposite(destdata, srcX, srcY,
+				      maskX, maskY,
+				      destX , destY,
+				      width, height, carddata, &state);
+        return TRUE;
+    }
+    
+    return FALSE;
+}
diff -ur ./xf86-video-nouveau-src/nv_accel_common.c ./xf86-video-nouveau/nv_accel_common.c
--- ./xf86-video-nouveau-src/nv_accel_common.c	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv_accel_common.c	2011-05-07 16:16:56.000000000 +0200
@@ -21,8 +21,19 @@
  */
 
 #include "nv_include.h"
+#if !defined(__AROS__)
 #include "nv04_pushbuf.h"
+#else
+
+#include <aros/debug.h>
 
+/* Some overriding defines for AROS */
+#define NOUVEAU_CREATE_PIXMAP_ZETA      0x10000000
+#define NOUVEAU_CREATE_PIXMAP_TILED     0x20000000
+#define NOUVEAU_CREATE_PIXMAP_SCANOUT   0x40000000
+#endif
+
+#if !defined(__AROS__)
 Bool
 nouveau_allocate_surface(ScrnInfoPtr scrn, int width, int height, int bpp,
 			 int usage_hint, int *pitch, struct nouveau_bo **bo)
@@ -149,6 +160,7 @@
 	BEGIN_RING(chan, blit, 0x00000130, 1);
 	OUT_RING  (chan, 0);
 }
+#endif
 
 static Bool
 NVAccelInitDmaNotifier0(ScrnInfoPtr pScrn)
@@ -193,6 +205,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 /* FLAGS_ROP_AND, DmaFB, DmaFB, 0 */
 static Bool
 NVAccelInitContextBeta1(ScrnInfoPtr pScrn)
@@ -233,11 +246,16 @@
 	OUT_RING  (chan, 0xffff0000);
 	return TRUE;
 }
+#endif
 
 Bool
 NVAccelGetCtxSurf2DFormatFromPixmap(PixmapPtr pPix, int *fmt_ret)
 {
+#if !defined(__AROS__)
 	switch (pPix->drawable.bitsPerPixel) {
+#else
+    switch (pPix->bytesperpixel * 8) {
+#endif
 	case 32:
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_A8R8G8B8;
 		break;
@@ -245,7 +263,11 @@
 		*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X8R8G8B8_Z8R8G8B8;
 		break;
 	case 16:
+#if !defined(__AROS__)
 		if (pPix->drawable.depth == 16)
+#else
+        if (pPix->depth == 16)
+#endif
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_R5G6B5;
 		else
 			*fmt_ret = NV04_CONTEXT_SURFACES_2D_FORMAT_X1R5G5B5_Z1R5G5B5;
@@ -260,6 +282,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 Bool
 NVAccelGetCtxSurf2DFormatFromPicture(PicturePtr pPict, int *fmt_ret)
 {
@@ -292,6 +315,7 @@
 	else
 		return (PixmapPtr) pDraw;
 }
+#endif
 
 static Bool
 NVAccelInitImagePattern(ScrnInfoPtr pScrn)
@@ -339,7 +363,7 @@
 	BEGIN_RING(chan, rop, NV03_CONTEXT_ROP_DMA_NOTIFY, 1);
 	OUT_RING  (chan, chan->nullobj->handle);
 
-	pNv->currentRop = ~0;
+//	pNv->currentRop = ~0;
 	return TRUE;
 }
 
@@ -421,6 +445,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitScaledImage(ScrnInfoPtr pScrn)
 {
@@ -491,6 +516,7 @@
 
 	return TRUE;
 }
+#endif
 
 /* FLAGS_NONE, NvDmaFB, NvDmaAGP, NvDmaNotifier0 */
 static Bool
@@ -522,6 +548,7 @@
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 static Bool
 NVAccelInitImageFromCpu(ScrnInfoPtr pScrn)
 {
@@ -571,6 +598,7 @@
 
 	return TRUE;
 }
+#endif
 
 static Bool
 NVAccelInit2D_NV50(ScrnInfoPtr pScrn)
@@ -602,10 +630,11 @@
 	BEGIN_RING(chan, eng2d, 0x58c, 1);
 	OUT_RING  (chan, 0x111);
 
-	pNv->currentRop = 0xfffffffa;
+//	pNv->currentRop = 0xfffffffa;
 	return TRUE;
 }
 
+#if !defined(__AROS__)
 #define INIT_CONTEXT_OBJECT(name) do {                                        \
 	ret = NVAccelInit##name(pScrn);                                       \
 	if (!ret) {                                                           \
@@ -615,6 +644,16 @@
 		return FALSE;                                                 \
 	}                                                                     \
 } while(0)
+#else
+#define INIT_CONTEXT_OBJECT(name) do {                                      \
+	ret = NVAccelInit##name(pScrn);                                         \
+	if (!ret) {                                                             \
+		bug("[nouveau] Failed to initialise context object: "#name          \
+			   " (%d)\n", ret);                                             \
+		return FALSE;                                                       \
+	}                                                                       \
+} while(0)
+#endif
 
 Bool
 NVAccelCommonInit(ScrnInfoPtr pScrn)
@@ -622,8 +661,10 @@
 	NVPtr pNv = NVPTR(pScrn);
 	Bool ret;
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return TRUE;
+#endif
 
 	/* General engine objects */
 	if (pNv->Architecture < NV_ARCH_C0)
@@ -632,32 +673,32 @@
 	/* 2D engine */
 	if (pNv->Architecture < NV_ARCH_50) {
 		INIT_CONTEXT_OBJECT(ContextSurfaces);
-		INIT_CONTEXT_OBJECT(ContextBeta1);
-		INIT_CONTEXT_OBJECT(ContextBeta4);
+//		INIT_CONTEXT_OBJECT(ContextBeta1);
+//		INIT_CONTEXT_OBJECT(ContextBeta4);
 		INIT_CONTEXT_OBJECT(ImagePattern);
 		INIT_CONTEXT_OBJECT(RasterOp);
 		INIT_CONTEXT_OBJECT(Rectangle);
 		INIT_CONTEXT_OBJECT(ImageBlit);
-		INIT_CONTEXT_OBJECT(ScaledImage);
-		INIT_CONTEXT_OBJECT(ClipRectangle);
-		INIT_CONTEXT_OBJECT(ImageFromCpu);
+//		INIT_CONTEXT_OBJECT(ScaledImage);
+//		INIT_CONTEXT_OBJECT(ClipRectangle);
+//		INIT_CONTEXT_OBJECT(ImageFromCpu);
 	} else
 	if (pNv->Architecture < NV_ARCH_C0) {
 		INIT_CONTEXT_OBJECT(2D_NV50);
 	} else {
-		INIT_CONTEXT_OBJECT(2D_NVC0);
+//		INIT_CONTEXT_OBJECT(2D_NVC0);
 	}
 
 	if (pNv->Architecture < NV_ARCH_C0)
 		INIT_CONTEXT_OBJECT(MemFormat);
-	else
-		INIT_CONTEXT_OBJECT(M2MF_NVC0);
+//	else
+//		INIT_CONTEXT_OBJECT(M2MF_NVC0);
 
 	/* 3D init */
 	switch (pNv->Architecture) {
-	case NV_ARCH_C0:
-		INIT_CONTEXT_OBJECT(3D_NVC0);
-		break;
+//	case NV_ARCH_C0:
+//		INIT_CONTEXT_OBJECT(3D_NVC0);
+//		break;
 	case NV_ARCH_50:
 		INIT_CONTEXT_OBJECT(NV50TCL);
 		break;
@@ -682,22 +723,24 @@
 {
 	NVPtr pNv = NVPTR(pScrn);
 
+#if !defined(__AROS__)
 	if (pNv->NoAccel)
 		return;
+#endif
 
 	nouveau_notifier_free(&pNv->notify0);
 	nouveau_notifier_free(&pNv->vblank_sem);
 
 	nouveau_grobj_free(&pNv->NvContextSurfaces);
-	nouveau_grobj_free(&pNv->NvContextBeta1);
-	nouveau_grobj_free(&pNv->NvContextBeta4);
+//	nouveau_grobj_free(&pNv->NvContextBeta1);
+//	nouveau_grobj_free(&pNv->NvContextBeta4);
 	nouveau_grobj_free(&pNv->NvImagePattern);
 	nouveau_grobj_free(&pNv->NvRop);
 	nouveau_grobj_free(&pNv->NvRectangle);
 	nouveau_grobj_free(&pNv->NvImageBlit);
-	nouveau_grobj_free(&pNv->NvScaledImage);
-	nouveau_grobj_free(&pNv->NvClipRectangle);
-	nouveau_grobj_free(&pNv->NvImageFromCpu);
+//	nouveau_grobj_free(&pNv->NvScaledImage);
+//	nouveau_grobj_free(&pNv->NvClipRectangle);
+//	nouveau_grobj_free(&pNv->NvImageFromCpu);
 	nouveau_grobj_free(&pNv->Nv2D);
 	nouveau_grobj_free(&pNv->NvMemFormat);
 	nouveau_grobj_free(&pNv->NvSW);
diff -ur ./xf86-video-nouveau-src/nv_include.h ./xf86-video-nouveau/nv_include.h
--- ./xf86-video-nouveau-src/nv_include.h	2011-03-23 09:14:36.000000000 +0100
+++ ./xf86-video-nouveau/nv_include.h	2011-05-07 20:25:36.000000000 +0200
@@ -1,84 +1,158 @@
 #ifndef __NV_INCLUDE_H__
 #define __NV_INCLUDE_H__
+/*
+    Copyright Â© 2011, The AROS Development Team. All rights reserved.
+    $Id$
+*/
 
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <string.h>
-#include <math.h>
-#include <errno.h>
-#include <unistd.h>
-#include <stdlib.h>
-
-/* All drivers should typically include these */
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#define PPC_MMIO_IS_BE
-#include "compiler.h"
-
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
-/* Drivers that need to access the PCI config space directly need this */
-#include "xf86Pci.h"
-
-/* All drivers initialising the SW cursor need this */
-#include "mipointer.h"
-
-/* All drivers implementing backing store need this */
-#include "mibstore.h"
-
-#include "micmap.h"
-
-#include "xf86DDC.h"
-
-#include "vbe.h"
-
-#include "xf86RandR12.h"
-
-#include "nv_const.h"
-
-#include "dixstruct.h"
-#include "scrnintstr.h"
-
-#include "fb.h"
-
-#include "xf86cmap.h"
-#include "shadowfb.h"
-
-#include "xf86xv.h"
-#include <X11/extensions/Xv.h>
-
-#include "xf86Cursor.h"
-#include "xf86DDC.h"
-
-#include "region.h"
-
-#include <X11/extensions/randr.h>
-
-#ifdef HAVE_XEXTPROTO_71
-#include <X11/extensions/dpmsconst.h>
-#else
-#define DPMS_SERVER
-#include <X11/extensions/dpms.h>
-#endif
-
-#define NV_DMA_DEBUG 0
-
-#include "nv_type.h"
-#include "nv_proto.h"
-#include "nv_dma.h"
+#include "nouveau_intern.h"
 #include "nouveau_class.h"
-#include "sarea.h"
 
-#include "nouveau_drmif.h"
-#include "nouveau_device.h"
-#include "nouveau_channel.h"
-#include "nouveau_bo.h"
-#include "nouveau_grobj.h"
-#include "nouveau_notifier.h"
 #include "nouveau_local.h"
-#include "nouveau_pushbuf.h"
+
+/* Some overriding defines for AROS */
+#define Bool                        BOOL
+#define ScrnInfoPtr                 struct CardData *
+#define NVPTR(x)                    x
+#define NVPtr                       struct CardData *
+#define Architecture                architecture
+#define PixmapPtr                   struct HIDDNouveauBitMapData *
+#define xf86DrvMsg(a, b, fmt, ...)  bug(fmt, ##__VA_ARGS__)
+#define ErrorF(msg, ...)            bug(msg, ##__VA_ARGS__)
+#define PictFormatShort             LONG
+#define PictTransformPtr            APTR
+
+struct Picture
+{
+    LONG format;
+    BOOL componentAlpha;
+    LONG filter;
+    BOOL repeat;
+    LONG repeatType;
+};
+
+typedef struct Picture * PicturePtr;
+
+#define PictFilterNearest   1
+#define PictFilterBilinear  2
+
+#define RepeatNone          0 /* This must be zero/FALSE, see nv10_exa for usage against ppict->repeat which is BOOL */
+#define RepeatNormal        1
+#define RepeatReflect       2
+#define RepeatPad           3
+
+#define PICT_UNKNOWN        0
+#define PICT_a8r8g8b8       1
+#define PICT_x8r8g8b8       2
+#define PICT_a8b8g8r8       3
+#define PICT_x8b8g8r8       4
+#define PICT_b8g8r8a8       5
+#define PICT_b8g8r8x8       6
+#define PICT_a2b10g10r10    7
+#define PICT_x2b10g10r10    8
+#define PICT_a2r10g10b10    9
+#define PICT_x2r10g10b10    10
+#define PICT_a1r5g5b5       11
+#define PICT_x1r5g5b5       12
+#define PICT_a1b5g5r5       13
+#define PICT_x1b5g5r5       14
+#define PICT_x4r4g4b4       15
+#define PICT_a4r4g4b4       16
+#define PICT_x4b4g4r4       17
+#define PICT_a4b4g4r4       18
+#define PICT_r5g6b5         19
+#define PICT_b5g6r5         20
+#define PICT_a8             21
+
+
+#define nouveau_pixmap_bo(x)    (x->bo)
+#define exaGetPixmapPitch(x)    (x->pitch)
+
+#define PictOpSaturate      14
+
+Bool NVAccelInitNV50TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV40TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV30TCL(ScrnInfoPtr pScrn);
+Bool NVAccelInitNV10TCL(ScrnInfoPtr pScrn);
+Bool nv50_style_tiled_pixmap(PixmapPtr ppix, ScrnInfoPtr pScrn);
+
+
+static inline BOOL PICT_FORMAT_A(int format)
+{
+    switch(format)
+    {
+    case(PICT_a8r8g8b8):
+    case(PICT_a8b8g8r8):
+    case(PICT_b8g8r8a8):
+    case(PICT_a2b10g10r10):
+    case(PICT_a2r10g10b10):
+    case(PICT_a1r5g5b5):
+    case(PICT_a1b5g5r5):
+    case(PICT_a4r4g4b4):
+    case(PICT_a4b4g4r4):
+    case(PICT_a8):
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+static inline BOOL PICT_FORMAT_RGB(int format)
+{
+    switch(format)
+    {
+    case(PICT_a8r8g8b8):
+    case(PICT_x8r8g8b8):
+    case(PICT_x8b8g8r8):
+    case(PICT_a8b8g8r8):
+    case(PICT_b8g8r8a8):
+    case(PICT_b8g8r8x8):
+    case(PICT_a2b10g10r10):
+    case(PICT_x2b10g10r10):
+    case(PICT_a2r10g10b10):
+    case(PICT_x2r10g10b10):
+    case(PICT_a1r5g5b5):
+    case(PICT_x1r5g5b5):
+    case(PICT_a1b5g5r5):
+    case(PICT_x1b5g5r5):
+    case(PICT_x4r4g4b4):
+    case(PICT_a4r4g4b4):
+    case(PICT_x4b4g4r4):
+    case(PICT_a4b4g4r4):
+    case(PICT_r5g6b5):
+    case(PICT_b5g6r5):
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+static inline VOID HIDDNouveauFillPictureFromBitMapData(struct Picture * pPict, 
+    struct HIDDNouveauBitMapData * bmdata)
+{
+    /* pPict->format */
+    if (bmdata->depth == 32)
+        pPict->format = PICT_a8r8g8b8;
+    else if (bmdata->depth == 24)
+        pPict->format = PICT_x8r8g8b8;
+    else if (bmdata->depth == 16)
+        pPict->format = PICT_r5g6b5;
+    else
+        pPict->format = PICT_UNKNOWN;
+
+    /* pPict->componentAlpha - keep this always as FALSE, used when mask
+       bitmap would be present (which is not the case in AROS */
+    pPict->componentAlpha = FALSE;
+    
+    /* pPict->filter - keep this always as PictFilterNearest, unless you want
+       bi-linear (probably slower and might give weird effects */
+    pPict->filter = PictFilterNearest;
+    
+    /* pPict->repeat - keep this always as FALSE */
+    pPict->repeat = FALSE;
+    /* pPict->repeatType - value does not matter as long as repeat is FALSE */
+    pPict->repeatType = RepeatNone;
+}
 
 #endif /* __NV_INCLUDE_H__ */
