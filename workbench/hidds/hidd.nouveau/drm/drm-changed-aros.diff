diff -ur -x .svn drm/drm_agpsupport.c drm-changed/drm_agpsupport.c
--- drm/drm_agpsupport.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_agpsupport.c	2010-06-27 21:28:48.000000000 +0200
@@ -32,12 +32,16 @@
  */
 
 #include "drmP.h"
+#if !defined(__AROS__)
 #include <linux/module.h>
 #include <linux/slab.h>
+#endif
 
 #if __OS_HAS_AGP
 
+#if !defined(__AROS__)
 #include <asm/agp.h>
+#endif
 
 /**
  * Get AGP information.
@@ -59,15 +63,15 @@
 		return -EINVAL;
 
 	kern = &dev->agp->agp_info;
-	info->agp_version_major = kern->version.major;
-	info->agp_version_minor = kern->version.minor;
+//FIXME	info->agp_version_major = kern->version.major;
+//FIXME	info->agp_version_minor = kern->version.minor;
 	info->mode = kern->mode;
 	info->aperture_base = kern->aper_base;
 	info->aperture_size = kern->aper_size * 1024 * 1024;
-	info->memory_allowed = kern->max_memory << PAGE_SHIFT;
-	info->memory_used = kern->current_memory << PAGE_SHIFT;
-	info->id_vendor = kern->device->vendor;
-	info->id_device = kern->device->device;
+//FIXME	info->memory_allowed = kern->max_memory << PAGE_SHIFT;
+//FIXME	info->memory_used = kern->current_memory << PAGE_SHIFT;
+//FIXME	info->id_vendor = kern->device->vendor;
+//FIXME	info->id_device = kern->device->device;
 
 	return 0;
 }
@@ -110,6 +114,7 @@
 
 EXPORT_SYMBOL(drm_agp_acquire);
 
+#if !defined(__AROS__)
 /**
  * Acquire the AGP device (ioctl).
  *
@@ -127,6 +132,7 @@
 {
 	return drm_agp_acquire((struct drm_device *) file_priv->minor->dev);
 }
+#endif
 
 /**
  * Release the AGP device.
@@ -183,6 +189,7 @@
 	return drm_agp_enable(dev, *mode);
 }
 
+#if !defined(__AROS__)
 /**
  * Allocate AGP memory.
  *
@@ -384,6 +391,7 @@
 
 	return drm_agp_free(dev, request);
 }
+#endif
 
 /**
  * Initialize the AGP resources.
@@ -504,4 +512,5 @@
 }
 EXPORT_SYMBOL(drm_agp_chipset_flush);
 
+
 #endif /* __OS_HAS_AGP */
diff -ur -x .svn drm/drm_cache.c drm-changed/drm_cache.c
--- drm/drm_cache.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_cache.c	2010-06-27 21:17:19.000000000 +0200
@@ -91,6 +91,12 @@
 				   (unsigned long)page_virtual + PAGE_SIZE);
 		kunmap_atomic(page_virtual, KM_USER0);
 	}
+#elif defined(__AROS__)
+    /* TODO: Detect if cpu has clflush. Use it if present */
+#if !defined(HOSTED_BUILD)
+    VOID HACK_Wbinvd(); /* Implemented in assembler */
+    Supervisor(HACK_Wbinvd);
+#endif
 #else
 	printk(KERN_ERR "Architecture has no drm_cache.c support\n");
 	WARN_ON_ONCE(1);
diff -ur -x .svn drm/drm_crtc.c drm-changed/drm_crtc.c
--- drm/drm_crtc.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_crtc.c	2010-06-27 21:37:09.000000000 +0200
@@ -29,8 +29,10 @@
  *      Dave Airlie <airlied@linux.ie>
  *      Jesse Barnes <jesse.barnes@intel.com>
  */
+#if !defined(__AROS__)
 #include <linux/list.h>
 #include <linux/slab.h>
+#endif
 #include "drm.h"
 #include "drmP.h"
 #include "drm_crtc.h"
@@ -813,6 +815,7 @@
 }
 EXPORT_SYMBOL(drm_mode_create_dithering_property);
 
+#if !defined(__AROS__)
 /**
  * drm_mode_create_dirty_property - create dirty property
  * @dev: DRM device
@@ -842,6 +845,7 @@
 	return 0;
 }
 EXPORT_SYMBOL(drm_mode_create_dirty_info_property);
+#endif
 
 /**
  * drm_mode_config_init - initialize DRM mode_configuration structure
@@ -878,6 +882,7 @@
 }
 EXPORT_SYMBOL(drm_mode_config_init);
 
+#if !defined(__AROS__)
 int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
 {
 	uint32_t total_objects = 0;
@@ -923,6 +928,7 @@
 
 	return 0;
 }
+#endif
 
 /**
  * drm_mode_config_cleanup - free up DRM mode_config info
@@ -1082,8 +1088,12 @@
 	list_for_each(lh, &file_priv->fbs)
 		fb_count++;
 
+#if !defined(__AROS__)
 	mode_group = &file_priv->master->minor->mode_group;
 	if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+    if (1) {
+#endif
 
 		list_for_each(lh, &dev->mode_config.crtc_list)
 			crtc_count++;
@@ -1124,7 +1134,11 @@
 	if (card_res->count_crtcs >= crtc_count) {
 		copied = 0;
 		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(crtc, &dev->mode_config.crtc_list,
 					    head) {
 				DRM_DEBUG_KMS("CRTC ID is %d\n", crtc->base.id);
@@ -1151,7 +1165,11 @@
 	if (card_res->count_encoders >= encoder_count) {
 		copied = 0;
 		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(encoder,
 					    &dev->mode_config.encoder_list,
 					    head) {
@@ -1182,7 +1200,11 @@
 	if (card_res->count_connectors >= connector_count) {
 		copied = 0;
 		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(connector,
 					    &dev->mode_config.connector_list,
 					    head) {
@@ -1749,6 +1771,7 @@
 	return ret;
 }
 
+#if !defined(__AROS__)
 /**
  * drm_mode_getfb - get FB info
  * @inode: inode from the ioctl
@@ -2048,6 +2071,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 					 const char *name, int num_values)
@@ -2166,6 +2190,7 @@
 }
 EXPORT_SYMBOL(drm_connector_property_set_value);
 
+#if !defined(__AROS__)
 int drm_connector_property_get_value(struct drm_connector *connector,
 				  struct drm_property *property, uint64_t *val)
 {
@@ -2283,6 +2308,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 static struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,
 							  void *data)
@@ -2315,6 +2341,7 @@
 	kfree(blob);
 }
 
+#if !defined(__AROS__)
 int drm_mode_getblob_ioctl(struct drm_device *dev,
 			   void *data, struct drm_file *file_priv)
 {
@@ -2345,6 +2372,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 					    struct edid *edid)
@@ -2372,6 +2400,7 @@
 }
 EXPORT_SYMBOL(drm_mode_connector_update_edid_property);
 
+#if !defined(__AROS__)
 int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
 				       void *data, struct drm_file *file_priv)
 {
@@ -2442,6 +2471,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 				      struct drm_encoder *encoder)
@@ -2458,6 +2488,7 @@
 }
 EXPORT_SYMBOL(drm_mode_connector_attach_encoder);
 
+#if !defined(__AROS__)
 void drm_mode_connector_detach_encoder(struct drm_connector *connector,
 				    struct drm_encoder *encoder)
 {
@@ -2472,6 +2503,7 @@
 	}
 }
 EXPORT_SYMBOL(drm_mode_connector_detach_encoder);
+#endif
 
 bool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 				  int gamma_size)
@@ -2488,6 +2520,7 @@
 }
 EXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);
 
+#if !defined(__AROS__)
 int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 			     void *data, struct drm_file *file_priv)
 {
@@ -2654,3 +2687,5 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
+
diff -ur -x .svn drm/drm_crtc.h drm-changed/drm_crtc.h
--- drm/drm_crtc.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_crtc.h	2010-06-27 21:17:19.000000000 +0200
@@ -25,12 +25,14 @@
 #ifndef __DRM_CRTC_H__
 #define __DRM_CRTC_H__
 
+#if !defined(__AROS__)
 #include <linux/i2c.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/idr.h>
 
 #include <linux/fb.h>
+#endif
 
 struct drm_device;
 struct drm_mode_set;
@@ -485,7 +487,7 @@
  */
 struct drm_connector {
 	struct drm_device *dev;
-	struct device kdev;
+//FIXME	struct device kdev;
 	struct device_attribute *attr;
 	struct list_head head;
 
@@ -666,8 +668,8 @@
 extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
 extern struct edid *drm_get_edid(struct drm_connector *connector,
 				 struct i2c_adapter *adapter);
-extern int drm_do_probe_ddc_edid(struct i2c_adapter *adapter,
-				 unsigned char *buf, int len);
+//FIXME extern int drm_do_probe_ddc_edid(struct i2c_adapter *adapter,
+//				 unsigned char *buf, int len);
 extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
 extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
 extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
@@ -790,7 +792,7 @@
 				    void *data, struct drm_file *file_priv);
 extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
-extern bool drm_detect_hdmi_monitor(struct edid *edid);
+//FIXME extern bool drm_detect_hdmi_monitor(struct edid *edid);
 extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
 				    void *data, struct drm_file *file_priv);
 extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
diff -ur -x .svn drm/drm_crtc_helper.h drm-changed/drm_crtc_helper.h
--- drm/drm_crtc_helper.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_crtc_helper.h	2010-06-27 21:17:19.000000000 +0200
@@ -33,11 +33,15 @@
 #ifndef __DRM_CRTC_HELPER_H__
 #define __DRM_CRTC_HELPER_H__
 
+#if !defined(__AROS__)
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/idr.h>
 
 #include <linux/fb.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 #include "drm_fb_helper.h"
 struct drm_crtc_helper_funcs {
diff -ur -x .svn drm/drm_edid.c drm-changed/drm_edid.c
--- drm/drm_edid.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_edid.c	2010-06-27 21:37:36.000000000 +0200
@@ -26,10 +26,12 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
+#if !defined(__AROS__)
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/i2c-algo-bit.h>
+#endif
 #include "drmP.h"
 #include "drm_edid.h"
 
@@ -109,7 +111,6 @@
 	{ "SAM", 638, EDID_QUIRK_PREFER_LARGE_60 },
 };
 
-
 /* Valid EDID header has these bytes */
 static const u8 edid_header[] = {
 	0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00
@@ -160,7 +161,9 @@
 bad:
 	if (raw_edid) {
 		DRM_ERROR("Raw EDID:\n");
+#if !defined(__AROS__)
 		print_hex_dump_bytes(KERN_ERR, DUMP_PREFIX_NONE, raw_edid, EDID_LENGTH);
+#endif
 		printk("\n");
 	}
 	return 0;
@@ -1261,6 +1264,7 @@
 }
 EXPORT_SYMBOL(drm_get_edid);
 
+#if !defined(__AROS__)
 #define HDMI_IDENTIFIER 0x000C03
 #define VENDOR_BLOCK    0x03
 /**
@@ -1322,6 +1326,7 @@
 	return is_hdmi;
 }
 EXPORT_SYMBOL(drm_detect_hdmi_monitor);
+#endif
 
 /**
  * drm_add_edid_modes - add modes from EDID data, if available
@@ -1425,3 +1430,4 @@
 	return num_modes;
 }
 EXPORT_SYMBOL(drm_add_modes_noedid);
+
diff -ur -x .svn drm/drm_edid.h drm-changed/drm_edid.h
--- drm/drm_edid.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_edid.h	2010-06-27 21:17:19.000000000 +0200
@@ -23,7 +23,11 @@
 #ifndef __DRM_EDID_H__
 #define __DRM_EDID_H__
 
+#if !defined(__AROS__)
 #include <linux/types.h>
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define EDID_LENGTH 128
 #define DDC_ADDR 0x50
diff -ur -x .svn drm/drm_encoder_slave.h drm-changed/drm_encoder_slave.h
--- drm/drm_encoder_slave.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_encoder_slave.h	2010-06-27 21:17:19.000000000 +0200
@@ -145,7 +145,9 @@
 static inline int drm_i2c_encoder_register(struct module *owner,
 					   struct drm_i2c_encoder_driver *driver)
 {
-	return i2c_register_driver(owner, &driver->i2c_driver);
+//FIXME	return i2c_register_driver(owner, &driver->i2c_driver);
+IMPLEMENT("\n");
+return 0;
 }
 
 /**
@@ -154,7 +156,8 @@
  */
 static inline void drm_i2c_encoder_unregister(struct drm_i2c_encoder_driver *driver)
 {
-	i2c_del_driver(&driver->i2c_driver);
+//FIXME	i2c_del_driver(&driver->i2c_driver);
+IMPLEMENT("\n");
 }
 
 void drm_i2c_encoder_destroy(struct drm_encoder *encoder);
diff -ur -x .svn drm/drm_fb_helper.c drm-changed/drm_fb_helper.c
--- drm/drm_fb_helper.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_fb_helper.c	2010-06-28 20:09:20.000000000 +0200
@@ -27,18 +27,22 @@
  *      Dave Airlie <airlied@linux.ie>
  *      Jesse Barnes <jesse.barnes@intel.com>
  */
+#if !defined(__AROS__)
 #include <linux/kernel.h>
 #include <linux/sysrq.h>
 #include <linux/slab.h>
 #include <linux/fb.h>
+#endif
 #include "drmP.h"
 #include "drm_crtc.h"
 #include "drm_fb_helper.h"
 #include "drm_crtc_helper.h"
 
+#if !defined(__AROS__)
 MODULE_AUTHOR("David Airlie, Jesse Barnes");
 MODULE_DESCRIPTION("DRM KMS helper");
 MODULE_LICENSE("GPL and additional rights");
+#endif
 
 static LIST_HEAD(kernel_fb_helper_list);
 
@@ -52,6 +56,7 @@
 }
 EXPORT_SYMBOL(drm_fb_helper_add_connector);
 
+#if !defined(__AROS__)
 /**
  * drm_fb_helper_connector_parse_command_line - parse command line for connector
  * @connector - connector to parse line for
@@ -203,9 +208,11 @@
 
 	return true;
 }
+#endif
 
 int drm_fb_helper_parse_command_line(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct drm_connector *connector;
 
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
@@ -217,9 +224,11 @@
 
 		drm_fb_helper_connector_parse_command_line(connector, option);
 	}
+#endif
 	return 0;
 }
 
+#if !defined(__AROS__)
 bool drm_fb_helper_force_kernel_mode(void)
 {
 	int i = 0;
@@ -745,6 +754,7 @@
 	return ret;
 }
 EXPORT_SYMBOL(drm_fb_helper_pan_display);
+#endif
 
 int drm_fb_helper_single_fb_probe(struct drm_device *dev,
 				  int preferred_bpp,
@@ -757,6 +767,7 @@
 						   uint32_t surface_bpp,
 						   struct drm_framebuffer **fb_ptr))
 {
+#if !defined(__AROS__)
 	struct drm_crtc *crtc;
 	struct drm_connector *connector;
 	unsigned int fb_width = (unsigned)-1, fb_height = (unsigned)-1;
@@ -919,9 +930,14 @@
 	}
 	list_add(&fb_helper->kernel_fb_list, &kernel_fb_helper_list);
 	return 0;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 EXPORT_SYMBOL(drm_fb_helper_single_fb_probe);
 
+#if !defined(__AROS__)
 void drm_fb_helper_free(struct drm_fb_helper *helper)
 {
 	list_del(&helper->kernel_fb_list);
@@ -1025,3 +1041,5 @@
 	info->var.yres = fb_height;
 }
 EXPORT_SYMBOL(drm_fb_helper_fill_var);
+#endif
+
diff -ur -x .svn drm/drm_gem.c drm-changed/drm_gem.c
--- drm/drm_gem.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_gem.c	2010-06-27 23:06:07.000000000 +0200
@@ -25,6 +25,7 @@
  *
  */
 
+#if !defined(__AROS__)
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
@@ -34,6 +35,7 @@
 #include <linux/module.h>
 #include <linux/mman.h>
 #include <linux/pagemap.h>
+#endif
 #include "drmP.h"
 
 /** @file drm_gem.c
@@ -78,7 +80,9 @@
 int
 drm_gem_init(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct drm_gem_mm *mm;
+#endif
 
 	spin_lock_init(&dev->object_name_lock);
 	idr_init(&dev->object_name_idr);
@@ -89,6 +93,7 @@
 	atomic_set(&dev->gtt_count, 0);
 	atomic_set(&dev->gtt_memory, 0);
 
+#if !defined(__AROS__)
 	mm = kzalloc(sizeof(struct drm_gem_mm), GFP_KERNEL);
 	if (!mm) {
 		DRM_ERROR("out of memory\n");
@@ -108,10 +113,12 @@
 		kfree(mm);
 		return -ENOMEM;
 	}
+#endif
 
 	return 0;
 }
 
+#if !defined(__AROS__)
 void
 drm_gem_destroy(struct drm_device *dev)
 {
@@ -122,6 +129,7 @@
 	kfree(mm);
 	dev->mm_private = NULL;
 }
+#endif
 
 /**
  * Allocate a GEM object of the specified size with shmfs backing store
@@ -138,9 +146,14 @@
 		goto free;
 
 	obj->dev = dev;
+#if !defined(__AROS__)
 	obj->filp = shmem_file_setup("drm mm object", size, VM_NORESERVE);
 	if (IS_ERR(obj->filp))
 		goto free;
+#else
+    /* No swapping under AROS. Set to NULL to detect any problems */
+    obj->filp = NULL;
+#endif
 
 	kref_init(&obj->refcount);
 	kref_init(&obj->handlecount);
@@ -151,9 +164,12 @@
 	}
 	atomic_inc(&dev->object_count);
 	atomic_add(obj->size, &dev->object_memory);
+
 	return obj;
 fput:
+#if !defined(__AROS__)
 	fput(obj->filp);
+#endif
 free:
 	kfree(obj);
 	return NULL;
@@ -364,6 +380,7 @@
 	return 0;
 }
 
+#if !defined(__AROS__)
 /**
  * Called at device open time, sets up the structure for handling refcounting
  * of mm objects.
@@ -402,12 +419,15 @@
 
 	idr_destroy(&file_private->object_idr);
 }
+#endif
 
 static void
 drm_gem_object_free_common(struct drm_gem_object *obj)
 {
 	struct drm_device *dev = obj->dev;
+#if !defined(__AROS__)
 	fput(obj->filp);
+#endif
 	atomic_dec(&dev->object_count);
 	atomic_sub(obj->size, &dev->object_memory);
 	kfree(obj);
@@ -425,7 +445,7 @@
 	struct drm_gem_object *obj = (struct drm_gem_object *) kref;
 	struct drm_device *dev = obj->dev;
 
-	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
+//FIXME	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
 
 	if (dev->driver->gem_free_object != NULL)
 		dev->driver->gem_free_object(obj);
@@ -497,6 +517,7 @@
 }
 EXPORT_SYMBOL(drm_gem_object_handle_free);
 
+#if !defined(__AROS__)
 void drm_gem_vm_open(struct vm_area_struct *vma)
 {
 	struct drm_gem_object *obj = vma->vm_private_data;
@@ -586,3 +607,4 @@
 	return ret;
 }
 EXPORT_SYMBOL(drm_gem_mmap);
+#endif
diff -ur -x .svn drm/drm.h drm-changed/drm.h
--- drm/drm.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm.h	2010-06-27 21:17:19.000000000 +0200
@@ -37,11 +37,15 @@
 #define _DRM_H_
 
 #if defined(__linux__)
-
 #include <linux/types.h>
 #include <asm/ioctl.h>
 typedef unsigned int drm_handle_t;
 
+#elif defined(__AROS__)
+#include <sys/ioctl.h>
+#include "drm_compat_types.h"
+typedef unsigned int drm_handle_t;
+
 #else /* One of the BSDs */
 
 #include <sys/ioccom.h>
diff -ur -x .svn drm/drm_hashtab.h drm-changed/drm_hashtab.h
--- drm/drm_hashtab.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_hashtab.h	2010-06-27 21:17:19.000000000 +0200
@@ -35,12 +35,16 @@
 #ifndef DRM_HASHTAB_H
 #define DRM_HASHTAB_H
 
+#if !defined(__AROS__)
 #include <linux/list.h>
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define drm_hash_entry(_ptr, _type, _member) container_of(_ptr, _type, _member)
 
 struct drm_hash_item {
-	struct hlist_node head;
+//FIXME:	struct hlist_node head;
 	unsigned long key;
 };
 
@@ -48,7 +52,7 @@
 	unsigned int size;
 	unsigned int order;
 	unsigned int fill;
-	struct hlist_head *table;
+//FIXME:	struct hlist_head *table;
 	int use_vmalloc;
 };
 
diff -ur -x .svn drm/drm_memory.c drm-changed/drm_memory.c
--- drm/drm_memory.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_memory.c	2010-06-27 21:17:19.000000000 +0200
@@ -33,7 +33,9 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#if !defined(__AROS__)
 #include <linux/highmem.h>
+#endif
 #include "drmP.h"
 
 /**
@@ -56,6 +58,7 @@
 }
 
 #if __OS_HAS_AGP
+#if !defined(__AROS__)
 static void *agp_remap(unsigned long offset, unsigned long size,
 		       struct drm_device * dev)
 {
@@ -104,6 +107,7 @@
 {
 	return drm_agp_allocate_memory(dev->agp->bridge, pages, type);
 }
+#endif
 
 /** Wrapper around agp_free_memory() */
 int drm_free_agp(DRM_AGP_MEM * handle, int pages)
@@ -112,11 +116,13 @@
 }
 EXPORT_SYMBOL(drm_free_agp);
 
+#if !defined(__AROS__)
 /** Wrapper around agp_bind_memory() */
 int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
 {
 	return drm_agp_bind_memory(handle, start);
 }
+#endif
 
 /** Wrapper around agp_unbind_memory() */
 int drm_unbind_agp(DRM_AGP_MEM * handle)
@@ -125,6 +131,13 @@
 }
 EXPORT_SYMBOL(drm_unbind_agp);
 
+static inline void *agp_remap(unsigned long offset, unsigned long size,
+			      struct drm_device * dev)
+{
+    IMPLEMENT("\n");
+	return NULL;
+}
+
 #else  /*  __OS_HAS_AGP  */
 static inline void *agp_remap(unsigned long offset, unsigned long size,
 			      struct drm_device * dev)
diff -ur -x .svn drm/drm_mm.c drm-changed/drm_mm.c
--- drm/drm_mm.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_mm.c	2010-06-27 21:17:19.000000000 +0200
@@ -43,8 +43,12 @@
 
 #include "drmP.h"
 #include "drm_mm.h"
+#if !defined(__AROS__)
 #include <linux/slab.h>
 #include <linux/seq_file.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 #define MM_UNUSED_TARGET 4
 
diff -ur -x .svn drm/drm_mm.h drm-changed/drm_mm.h
--- drm/drm_mm.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_mm.h	2010-06-27 21:17:19.000000000 +0200
@@ -36,10 +36,14 @@
 /*
  * Generic range manager structs
  */
+#if !defined(__AROS__)
 #include <linux/list.h>
 #ifdef CONFIG_DEBUG_FS
 #include <linux/seq_file.h>
 #endif
+#else
+#include "drm_compat_types.h"
+#endif
 
 struct drm_mm_node {
 	struct list_head fl_entry;
diff -ur -x .svn drm/drm_modes.c drm-changed/drm_modes.c
--- drm/drm_modes.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/drm_modes.c	2010-06-28 22:08:09.000000000 +0200
@@ -30,8 +30,10 @@
  * authorization from the copyright holder(s) and author(s).
  */
 
+#if !defined(__AROS__)
 #include <linux/list.h>
 #include <linux/list_sort.h>
+#endif
 #include "drmP.h"
 #include "drm.h"
 #include "drm_crtc.h"
@@ -871,6 +873,7 @@
 	struct drm_display_mode *b = list_entry(lh_b, struct drm_display_mode, head);
 	int diff;
 
+#if !defined(__AROS__)
 	diff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -
 		((a->type & DRM_MODE_TYPE_PREFERRED) != 0);
 	if (diff)
@@ -878,6 +881,16 @@
 	diff = b->hdisplay * b->vdisplay - a->hdisplay * a->vdisplay;
 	if (diff)
 		return diff;
+#else
+	diff = b->hdisplay - a->hdisplay;
+	if (diff)
+		return diff;
+
+	diff = b->vdisplay - a->vdisplay;
+	if (diff)
+		return diff;
+#endif
+
 	diff = b->clock - a->clock;
 	return diff;
 }
diff -ur -x .svn drm/nouveau/nouveau_bios.c drm-changed/nouveau/nouveau_bios.c
--- drm/nouveau/nouveau_bios.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_bios.c	2010-06-28 21:12:21.000000000 +0200
@@ -160,6 +160,7 @@
 
 static void load_vbios_pci(struct drm_device *dev, uint8_t *data)
 {
+#if !defined(__AROS__)
 	void __iomem *rom = NULL;
 	size_t rom_len;
 	int ret;
@@ -176,6 +177,9 @@
 
 out:
 	pci_disable_rom(dev->pdev);
+#else
+IMPLEMENT("\n");
+#endif
 }
 
 struct methods {
@@ -1447,16 +1451,23 @@
 	 * "mask n" and OR it with "data n" before writing it back to the device
 	 */
 
+#if !defined(__AROS__)
 	uint8_t i2c_index = bios->data[offset + 1];
 	uint8_t i2c_address = bios->data[offset + 2] >> 1;
+#endif
 	uint8_t count = bios->data[offset + 3];
+#if !defined(__AROS__)
 	struct nouveau_i2c_chan *chan;
+#endif
 	int len = 4 + count * 3;
+#if !defined(__AROS__)
 	int ret, i;
+#endif
 
 	if (!iexec->execute)
 		return len;
 
+#if !defined(__AROS__)
 	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
 		      "Count: 0x%02X\n",
 		offset, i2c_index, i2c_address, count);
@@ -1494,6 +1505,10 @@
 	}
 
 	return len;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
 static int
@@ -1515,16 +1530,23 @@
 	 * "DCB I2C table entry index", set the register to "data n"
 	 */
 
+#if !defined(__AROS__)
 	uint8_t i2c_index = bios->data[offset + 1];
 	uint8_t i2c_address = bios->data[offset + 2] >> 1;
+#endif
 	uint8_t count = bios->data[offset + 3];
+#if !defined(__AROS__)
 	struct nouveau_i2c_chan *chan;
+#endif
 	int len = 4 + count * 2;
+#if !defined(__AROS__)
 	int ret, i;
+#endif
 
 	if (!iexec->execute)
 		return len;
 
+#if !defined(__AROS__)
 	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
 		      "Count: 0x%02X\n",
 		offset, i2c_index, i2c_address, count);
@@ -1553,6 +1575,10 @@
 	}
 
 	return len;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
 static int
@@ -3875,6 +3901,7 @@
 		break;
 	}
 
+
 	/* Dell Latitude D620 reports a too-high value for the dual-link
 	 * transition freq, causing us to program the panel incorrectly.
 	 *
@@ -3884,11 +3911,17 @@
 	 *
 	 * For the moment, a quirk will do :)
 	 */
+#if !defined(__AROS__)
 	if ((dev->pdev->device == 0x01d7) &&
 	    (dev->pdev->subsystem_vendor == 0x1028) &&
 	    (dev->pdev->subsystem_device == 0x01c2)) {
 		bios->fp.duallink_transition_clk = 80000;
 	}
+#else
+    if (dev->pci_device == 0x01d7) {
+        IMPLEMENT("Quirk for Dell Latitude D620\n");
+    }
+#endif
 
 	/* set dual_link flag for EDID case */
 	if (pxclk && (chip_version < 0x25 || chip_version > 0x28))
@@ -5387,12 +5420,21 @@
 	struct drm_device *dev = bios->dev;
 
 	/* Gigabyte NX85T */
+#if !defined(__AROS__)
 	if ((dev->pdev->device == 0x0421) &&
 	    (dev->pdev->subsystem_vendor == 0x1458) &&
 	    (dev->pdev->subsystem_device == 0x344c)) {
 		if (cte->type == DCB_CONNECTOR_HDMI_1)
 			cte->type = DCB_CONNECTOR_DVI_I;
 	}
+#else
+    (void)cte;
+    if ((dev->pci_device == 0x0421)) {
+        IMPLEMENT("Gigabyte NX85T\n");
+    }
+#endif
+
+
 }
 
 static void
@@ -5508,6 +5550,7 @@
 	/* "or" mostly unused in early gen crt modesetting, 0 is fine */
 }
 
+#if !defined(__AROS__)
 static void fabricate_dvi_i_output(struct dcb_table *dcb, bool twoHeads)
 {
 	struct dcb_entry *entry = new_dcb_entry(dcb);
@@ -5544,6 +5587,7 @@
 	entry->heads = twoHeads ? 3 : 1;
 	entry->location = !DCB_LOC_ON_CHIP;	/* ie OFF CHIP */
 }
+#endif
 
 static bool
 parse_dcb20_entry(struct drm_device *dev, struct dcb_table *dcb,
@@ -5816,8 +5860,12 @@
 		NV_INFO(dev, "Assuming a CRT output exists\n");
 		fabricate_vga_output(dcb, LEGACY_I2C_CRT, 1);
 
+#if !defined(__AROS__)
 		if (nv04_tv_identify(dev, bios->legacy.i2c_indices.tv) >= 0)
 			fabricate_tv_output(dcb, twoHeads);
+#else
+IMPLEMENT("Checking nv04_tv_identify\n");
+#endif
 
 		return 0;
 	}
@@ -5885,6 +5933,7 @@
 		 * for the former is more accurate and it rules the
 		 * latter out.
 		 */
+#if !defined(__AROS__)
 		if (nv04_tv_identify(dev,
 				     bios->legacy.i2c_indices.tv) >= 0)
 			fabricate_tv_output(dcb, twoHeads);
@@ -5892,12 +5941,16 @@
 		else if (bios->tmds.output0_script_ptr ||
 			 bios->tmds.output1_script_ptr)
 			fabricate_dvi_i_output(dcb, twoHeads);
+#else
+IMPLEMENT("Calling nv04_tv_identify\n");
+#endif
 
 		return 0;
 	}
 
-	if (!i2ctabptr)
+	if (!i2ctabptr) {
 		NV_WARN(dev, "No pointer to DCB I2C port table\n");
+    }
 	else {
 		dcb->i2c_table = &bios->data[i2ctabptr];
 		if (dcb->version >= 0x30)
diff -ur -x .svn drm/nouveau/nouveau_bo_renamed.c drm-changed/nouveau/nouveau_bo_renamed.c
--- drm/nouveau/nouveau_bo_renamed.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_bo_renamed.c	2010-06-27 22:06:57.000000000 +0200
@@ -33,8 +33,10 @@
 #include "nouveau_drv.h"
 #include "nouveau_dma.h"
 
+#if !defined(__AROS__)
 #include <linux/log2.h>
 #include <linux/slab.h>
+#endif
 
 static void
 nouveau_bo_del_ttm(struct ttm_buffer_object *bo)
diff -ur -x .svn drm/nouveau/nouveau_calc.c drm-changed/nouveau/nouveau_calc.c
--- drm/nouveau/nouveau_calc.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_calc.c	2010-06-27 21:17:36.000000000 +0200
@@ -209,6 +209,7 @@
 	sim_data.two_heads = nv_two_heads(dev);
 	if ((dev->pci_device & 0xffff) == 0x01a0 /*CHIPSET_NFORCE*/ ||
 	    (dev->pci_device & 0xffff) == 0x01f0 /*CHIPSET_NFORCE2*/) {
+#if !defined(__AROS__)
 		uint32_t type;
 
 		pci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);
@@ -217,6 +218,9 @@
 		sim_data.memory_width = 64;
 		sim_data.mem_latency = 3;
 		sim_data.mem_page_miss = 10;
+#else
+IMPLEMENT("Support for NFORCE/NFORCE2 chipsets\n");
+#endif
 	} else {
 		sim_data.memory_type = nvReadFB(dev, NV_PFB_CFG0) & 0x1;
 		sim_data.memory_width = (nvReadEXTDEV(dev, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;
diff -ur -x .svn drm/nouveau/nouveau_connector.c drm-changed/nouveau/nouveau_connector.c
--- drm/nouveau/nouveau_connector.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_connector.c	2010-06-27 22:07:48.000000000 +0200
@@ -24,7 +24,9 @@
  *
  */
 
+#if !defined(__AROS__)
 #include <acpi/button.h>
+#endif
 
 #include "drmP.h"
 #include "drm_edid.h"
@@ -37,6 +39,7 @@
 #include "nouveau_connector.h"
 #include "nouveau_hw.h"
 
+
 static inline struct drm_encoder_slave_funcs *
 get_slave_funcs(struct nouveau_encoder *enc)
 {
@@ -82,7 +85,6 @@
 	return NULL;
 }
 
-
 static void
 nouveau_connector_destroy(struct drm_connector *drm_connector)
 {
@@ -97,7 +99,9 @@
 	NV_DEBUG_KMS(dev, "\n");
 
 	kfree(nv_connector->edid);
+#if !defined(__AROS__)
 	drm_sysfs_connector_remove(drm_connector);
+#endif
 	drm_connector_cleanup(drm_connector);
 	kfree(drm_connector);
 }
@@ -863,7 +867,9 @@
 		break;
 	}
 
+#if !defined(__AROS__)
 	drm_sysfs_connector_add(connector);
+#endif
 	return 0;
 
 fail:
@@ -872,3 +878,4 @@
 	return ret;
 
 }
+
diff -ur -x .svn drm/nouveau/nouveau_dp.c drm-changed/nouveau/nouveau_dp.c
--- drm/nouveau/nouveau_dp.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_dp.c	2010-06-27 21:17:36.000000000 +0200
@@ -539,6 +539,7 @@
 nouveau_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,
 		      uint8_t write_byte, uint8_t *read_byte)
 {
+#if !defined(__AROS__)
 	struct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;
 	struct nouveau_i2c_chan *auxch = (struct nouveau_i2c_chan *)adapter;
 	struct drm_device *dev = auxch->dev;
@@ -577,5 +578,9 @@
 			return -EREMOTEIO;
 		}
 	}
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
diff -ur -x .svn drm/nouveau/nouveau_drv.h drm-changed/nouveau/nouveau_drv.h
--- drm/nouveau/nouveau_drv.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_drv.h	2010-06-27 22:43:52.000000000 +0200
@@ -39,6 +39,14 @@
 #define NOUVEAU_FAMILY   0x0000FFFF
 #define NOUVEAU_FLAGS    0xFFFF0000
 
+#if defined(__AROS__)
+struct drm_encoder;
+struct drm_minor;
+struct drm_connector;
+#include "drm_compat_types.h"
+#include "drm_compat_funcs.h"
+#endif
+
 #include "ttm/ttm_bo_api.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
@@ -119,7 +127,7 @@
 	bool is_iomem;
 	void __iomem *ioptr = (void __force __iomem *)ttm_kmap_obj_virtual(
 						&nvbo->kmap, &is_iomem);
-	WARN_ON_ONCE(ioptr && !is_iomem);
+//FIXME:	WARN_ON_ONCE(ioptr && !is_iomem);
 	return ioptr;
 }
 
@@ -249,11 +257,11 @@
 		struct list_head vbl_wait;
 	} nvsw;
 
-	struct {
+/*FIXME:COMMENT	struct {
 		bool active;
 		char name[32];
 		struct drm_info_list info;
-	} debugfs;
+	} debugfs;*/
 };
 
 struct nouveau_instmem_engine {
@@ -511,8 +519,8 @@
 	struct nouveau_bo *vga_ram;
 
 	struct workqueue_struct *wq;
-	struct work_struct irq_work;
-	struct work_struct hpd_work;
+//FIXME	struct work_struct irq_work;
+//FIXME	struct work_struct hpd_work;
 
 	struct list_head vbl_waiting;
 
@@ -639,7 +647,6 @@
 
 	return 0;
 }
-
 #define NOUVEAU_CHECK_INITIALISED_WITH_RETURN do {            \
 	struct drm_nouveau_private *nv = dev->dev_private;    \
 	if (nv->init_state != NOUVEAU_CARD_INIT_DONE) {       \
@@ -676,8 +683,10 @@
 extern int nouveau_noaccel;
 extern int nouveau_override_conntype;
 
+#if !defined(__AROS__)
 extern int nouveau_pci_suspend(struct pci_dev *pdev, pm_message_t pm_state);
 extern int nouveau_pci_resume(struct pci_dev *pdev);
+#endif
 
 /* nouveau_state.c */
 extern void nouveau_preclose(struct drm_device *dev, struct drm_file *);
@@ -881,7 +890,7 @@
 /* nouveau_ttm.c */
 int nouveau_ttm_global_init(struct drm_nouveau_private *);
 void nouveau_ttm_global_release(struct drm_nouveau_private *);
-int nouveau_ttm_mmap(struct file *, struct vm_area_struct *);
+//FIXME:TTM int nouveau_ttm_mmap(struct file *, struct vm_area_struct *);
 
 /* nouveau_dp.c */
 int nouveau_dp_auxch(struct nouveau_i2c_chan *auxch, int cmd, int addr,
@@ -1158,6 +1167,10 @@
 int nv50_calc_pll2(struct drm_device *, struct pll_lims *,
 		   int clk, int *N, int *fN, int *M, int *P);
 
+/* nv50_gpio.c */
+int nv50_gpio_get(struct drm_device *dev, enum dcb_gpio_tag tag);
+int nv50_gpio_set(struct drm_device *dev, enum dcb_gpio_tag tag, int state);
+
 #ifndef ioread32_native
 #ifdef __BIG_ENDIAN
 #define ioread16_native ioread16be
@@ -1242,6 +1255,8 @@
  * Logging
  * Argument d is (struct drm_device *).
  */
+#if !defined(__AROS__)
+
 #define NV_PRINTK(level, d, fmt, arg...) \
 	printk(level "[" DRM_NAME "] " DRIVER_NAME " %s: " fmt, \
 					pci_name(d->pdev), ##arg)
@@ -1268,6 +1283,31 @@
 		NV_PRINTK(KERN_DEBUG, d, fmt, ##arg);                          \
 } while (0)
 #endif
+
+#else
+
+#define NV_PRINTK(level, d, fmt, arg...) \
+    { (void)d; bug("[" DRM_NAME "] " DRIVER_NAME " " fmt, ##arg); }
+#ifndef NV_DEBUG_NOTRACE
+#define NV_DEBUG(d, fmt, arg...) do {                                          \
+        D(NV_PRINTK(KERN_DEBUG, d, "%s:%d - " fmt, __func__,             \
+              __LINE__, ##arg));                                    \
+} while (0)
+#define NV_DEBUG_KMS(d, fmt, arg...) do {                                          \
+        D(NV_PRINTK(KERN_DEBUG, d, "%s:%d - " fmt, __func__,             \
+              __LINE__, ##arg));                                    \
+} while (0)
+#else
+#define NV_DEBUG(d, fmt, arg...) do {                                          \
+        D(NV_PRINTK(KERN_DEBUG, d, fmt, ##arg));                          \
+} while (0)
+#define NV_DEBUG_KMS(d, fmt, arg...) do {                                          \
+        D(NV_PRINTK(KERN_DEBUG, d, fmt, ##arg));                          \
+} while (0)
+#endif
+
+#endif
+
 #define NV_ERROR(d, fmt, arg...) NV_PRINTK(KERN_ERR, d, fmt, ##arg)
 #define NV_INFO(d, fmt, arg...) NV_PRINTK(KERN_INFO, d, fmt, ##arg)
 #define NV_TRACEWARN(d, fmt, arg...) NV_PRINTK(KERN_NOTICE, d, fmt, ##arg)
diff -ur -x .svn drm/nouveau/nouveau_fbcon.c drm-changed/nouveau/nouveau_fbcon.c
--- drm/nouveau/nouveau_fbcon.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_fbcon.c	2010-06-27 22:08:30.000000000 +0200
@@ -24,6 +24,7 @@
  *     David Airlie
  */
 
+#if !defined(__AROS__)
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
@@ -36,6 +37,7 @@
 #include <linux/init.h>
 #include <linux/screen_info.h>
 #include <linux/vga_switcheroo.h>
+#endif
 
 #include "drmP.h"
 #include "drm.h"
@@ -49,6 +51,7 @@
 #include "nouveau_fbcon.h"
 #include "nouveau_dma.h"
 
+#if !defined(__AROS__)
 static int
 nouveau_fbcon_sync(struct fb_info *info)
 {
@@ -216,6 +219,7 @@
 	rect.rop = ROP_COPY;
 	info->fbops->fb_fillrect(info, &rect);
 }
+#endif
 
 static int
 nouveau_fbcon_create(struct drm_device *dev, uint32_t fb_width,
@@ -223,6 +227,7 @@
 		     uint32_t surface_height, uint32_t surface_depth,
 		     uint32_t surface_bpp, struct drm_framebuffer **pfb)
 {
+#if !defined(__AROS__)
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct fb_info *info;
 	struct nouveau_fbcon_par *par;
@@ -377,6 +382,10 @@
 	mutex_unlock(&dev->struct_mutex);
 out:
 	return ret;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
 int
@@ -390,6 +399,7 @@
 int
 nouveau_fbcon_remove(struct drm_device *dev, struct drm_framebuffer *fb)
 {
+#if !defined(__AROS__)
 	struct nouveau_framebuffer *nouveau_fb = nouveau_framebuffer(fb);
 	struct fb_info *info;
 
@@ -410,8 +420,13 @@
 	}
 
 	return 0;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
+#if !defined(__AROS__)
 void nouveau_fbcon_gpu_lockup(struct fb_info *info)
 {
 	struct nouveau_fbcon_par *par = info->par;
@@ -420,3 +435,4 @@
 	NV_ERROR(dev, "GPU lockup - switching to software fbcon\n");
 	info->flags |= FBINFO_HWACCEL_DISABLED;
 }
+#endif
diff -ur -x .svn drm/nouveau/nouveau_fence.c drm-changed/nouveau/nouveau_fence.c
--- drm/nouveau/nouveau_fence.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_fence.c	2010-06-27 22:10:09.000000000 +0200
@@ -59,15 +59,22 @@
 void
 nouveau_fence_update(struct nouveau_channel *chan)
 {
+#if !defined(HOSTED_BUILD)
 	struct drm_nouveau_private *dev_priv = chan->dev->dev_private;
+#endif
 	struct list_head *entry, *tmp;
 	struct nouveau_fence *fence;
 	uint32_t sequence;
 
+#if defined(HOSTED_BUILD)
+    /* For purpose of simulation, assume all fences are signalled */
+    sequence = chan->fence.sequence;
+#else
 	if (USE_REFCNT)
 		sequence = nvchan_rd32(chan, 0x48);
 	else
 		sequence = atomic_read(&chan->fence.last_sequence_irq);
+#endif
 
 	if (chan->fence.sequence_ack == sequence)
 		return;
@@ -180,9 +187,11 @@
 	return fence->signalled;
 }
 
+
 int
 nouveau_fence_wait(void *sync_obj, void *sync_arg, bool lazy, bool intr)
 {
+#if !defined(__AROS__)
 	unsigned long timeout = jiffies + (3 * DRM_HZ);
 	int ret = 0;
 
@@ -209,6 +218,25 @@
 	__set_current_state(TASK_RUNNING);
 
 	return ret;
+#else
+    int ret = 0;
+    LONG counter = 0;
+    while (1) 
+    {
+        if (nouveau_fence_signalled(sync_obj, sync_arg))
+            break;
+
+        counter++;
+        if (counter > 100000)
+        {
+            NV_INFO(nouveau_fence(sync_obj)->channel->dev, "Waited too long!\n");
+            ret = -EBUSY;
+            break;
+        }
+            
+    }
+    return ret;
+#endif
 }
 
 int
@@ -240,4 +268,3 @@
 		kref_put(&fence->refcount, nouveau_fence_del);
 	}
 }
-
diff -ur -x .svn drm/nouveau/nouveau_grctx.c drm-changed/nouveau/nouveau_grctx.c
--- drm/nouveau/nouveau_grctx.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_grctx.c	2010-06-27 22:10:45.000000000 +0200
@@ -22,8 +22,10 @@
  * Authors: Ben Skeggs
  */
 
+#if !defined(__AROS__)
 #include <linux/firmware.h>
 #include <linux/slab.h>
+#endif
 
 #include "drmP.h"
 #include "nouveau_drv.h"
@@ -48,6 +50,7 @@
 int
 nouveau_grctx_prog_load(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_pgraph_engine *pgraph = &dev_priv->engine.graph;
 	const int chipset = dev_priv->chipset;
@@ -124,7 +127,9 @@
 	for (i = 0; i < le16_to_cpu(cp->length); i++)
 		nv_wr32(dev, NV40_PGRAPH_CTXCTL_UCODE_DATA,
 			le32_to_cpu(cp->data[i]));
-
+#else
+DRM_IMPL("\n");
+#endif
 	return 0;
 }
 
diff -ur -x .svn drm/nouveau/nouveau_hw.c drm-changed/nouveau/nouveau_hw.c
--- drm/nouveau/nouveau_hw.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_hw.c	2010-06-27 21:17:36.000000000 +0200
@@ -492,6 +492,7 @@
 {
 	struct nouveau_pll_vals pllvals;
 
+#if !defined(__AROS__)
 	if (plltype == MPLL && (dev->pci_device & 0x0ff0) == CHIPSET_NFORCE) {
 		uint32_t mpllP;
 
@@ -507,6 +508,9 @@
 		pci_read_config_dword(pci_get_bus_and_slot(0, 5), 0x4c, &clock);
 		return clock;
 	}
+#else
+IMPLEMENT("Support for NFORCE/NFORCE2 chipset\n");
+#endif
 
 	nouveau_hw_get_pllvals(dev, plltype, &pllvals);
 
diff -ur -x .svn drm/nouveau/nouveau_i2c.c drm-changed/nouveau/nouveau_i2c.c
--- drm/nouveau/nouveau_i2c.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_i2c.c	2010-06-27 21:17:36.000000000 +0200
@@ -27,6 +27,22 @@
 #include "nouveau_i2c.h"
 #include "nouveau_hw.h"
 
+#if defined(__AROS__)
+#include <proto/oop.h>
+#include <oop/oop.h>
+
+/* FIXME: Duplicate defines here. Don't include nouveau_intern.h */
+/* Ugly hack actually */
+#define CLID_Hidd_I2C_Nouveau       "hidd.i2c.nouveau"
+#define IID_Hidd_I2C_Nouveau        "hidd.i2c.nouveau"
+
+#define HiddI2CNouveauAttrBase      __IHidd_I2C_Nouveau
+#define aoHidd_I2C_Nouveau_Chan     0
+#define aHidd_I2C_Nouveau_Chan      (HiddI2CNouveauAttrBase + aoHidd_I2C_Nouveau_Chan)
+
+OOP_AttrBase HiddI2CNouveauAttrBase = 0;
+#endif
+
 static void
 nv04_i2c_setscl(void *data, int state)
 {
@@ -208,25 +224,55 @@
 		return -EINVAL;
 	}
 
+#if !defined(__AROS__)
 	snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
 		 "nouveau-%s-%d", pci_name(dev->pdev), index);
 	i2c->adapter.owner = THIS_MODULE;
 	i2c->adapter.dev.parent = &dev->pdev->dev;
+#endif
 	i2c->dev = dev;
+#if !defined(__AROS__)
 	i2c_set_adapdata(&i2c->adapter, i2c);
+#endif
 
 	if (entry->port_type < 6) {
+#if !defined(__AROS__)
 		i2c->adapter.algo_data = &i2c->algo.bit;
 		i2c->algo.bit.udelay = 40;
 		i2c->algo.bit.timeout = usecs_to_jiffies(5000);
 		i2c->algo.bit.data = i2c;
 		ret = i2c_bit_add_bus(&i2c->adapter);
+#else
+        ret = 0;
+
+	    if (HiddI2CNouveauAttrBase == 0)
+	        HiddI2CNouveauAttrBase = OOP_ObtainAttrBase((STRPTR)IID_Hidd_I2C_Nouveau);
+
+        struct TagItem i2c_attrs[] = 
+        {
+            { aHidd_I2C_Nouveau_Chan,   (IPTR)i2c },
+            { TAG_DONE, 0UL }
+        };
+        
+        i2c->adapter.i2cdriver = (IPTR)OOP_NewObject(NULL, CLID_Hidd_I2C_Nouveau, i2c_attrs);
+        if (i2c->adapter.i2cdriver == (IPTR)0)
+        {
+            NV_ERROR(dev, "Failed to create CLID_Hidd_I2C_Nouveau object\n");
+            kfree(i2c);
+            return -EINVAL;
+        }
+#endif
 	} else {
+#if !defined(__AROS__)
 		i2c->adapter.algo_data = &i2c->algo.dp;
 		i2c->algo.dp.running = false;
 		i2c->algo.dp.address = 0;
 		i2c->algo.dp.aux_ch = nouveau_dp_i2c_aux_ch;
 		ret = i2c_dp_aux_add_bus(&i2c->adapter);
+#else
+        ret = -EINVAL;
+IMPLEMENT("Handling for (entry->port_type >= 6)\n");
+#endif
 	}
 
 	if (ret) {
diff -ur -x .svn drm/nouveau/nouveau_i2c.h drm-changed/nouveau/nouveau_i2c.h
--- drm/nouveau/nouveau_i2c.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_i2c.h	2010-06-27 21:17:36.000000000 +0200
@@ -23,20 +23,22 @@
 #ifndef __NOUVEAU_I2C_H__
 #define __NOUVEAU_I2C_H__
 
-#include <linux/i2c.h>
-#include <linux/i2c-id.h>
-#include <linux/i2c-algo-bit.h>
+//FIXME #include <linux/i2c.h>
+//FIXME #include <linux/i2c-id.h>
+//FIXME #include <linux/i2c-algo-bit.h>
 #include "drm_dp_helper.h"
 
 struct dcb_i2c_entry;
 
 struct nouveau_i2c_chan {
-	struct i2c_adapter adapter;
+ 	struct i2c_adapter adapter;
 	struct drm_device *dev;
-	union {
-		struct i2c_algo_bit_data bit;
-		struct i2c_algo_dp_aux_data dp;
-	} algo;
+ 	union {
+ 		struct i2c_algo_bit_data bit;
+#if !defined(__AROS__)
+ 		struct i2c_algo_dp_aux_data dp;
+#endif
+ 	} algo;
 	unsigned rd;
 	unsigned wr;
 	unsigned data;
@@ -47,6 +49,6 @@
 struct nouveau_i2c_chan *nouveau_i2c_find(struct drm_device *, int index);
 
 int nouveau_dp_i2c_aux_ch(struct i2c_adapter *, int mode, uint8_t write_byte,
-			  uint8_t *read_byte);
+ 			  uint8_t *read_byte);
 
 #endif /* __NOUVEAU_I2C_H__ */
diff -ur -x .svn drm/nouveau/nouveau_irq.c drm-changed/nouveau/nouveau_irq.c
--- drm/nouveau/nouveau_irq.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_irq.c	2010-06-27 22:11:30.000000000 +0200
@@ -35,10 +35,12 @@
 #include "nouveau_drm.h"
 #include "nouveau_drv.h"
 #include "nouveau_reg.h"
+#if !defined(__AROS__)
 #include <linux/ratelimit.h>
 
 /* needed for hotplug irq */
 #include "nouveau_connector.h"
+#endif
 #include "nv50_display.h"
 
 void
@@ -50,8 +52,10 @@
 	nv_wr32(dev, NV03_PMC_INTR_EN_0, 0);
 
 	if (dev_priv->card_type == NV_50) {
+#if !defined(__AROS__) 
 		INIT_WORK(&dev_priv->irq_work, nv50_display_irq_handler_bh);
 		INIT_WORK(&dev_priv->hpd_work, nv50_display_irq_hotplug_bh);
+#endif
 		INIT_LIST_HEAD(&dev_priv->vbl_waiting);
 	}
 }
@@ -505,13 +509,19 @@
 		nouveau_graph_dump_trap_info(dev, "PGRAPH_NOTIFY", &trap);
 }
 
+#if !defined(__AROS__)
 static DEFINE_RATELIMIT_STATE(nouveau_ratelimit_state, 3 * HZ, 20);
 
 static int nouveau_ratelimit(void)
 {
 	return __ratelimit(&nouveau_ratelimit_state);
 }
-
+#else
+static int nouveau_ratelimit(void)
+{
+	return 1;
+}
+#endif
 
 static inline void
 nouveau_pgraph_intr_error(struct drm_device *dev, uint32_t nsource)
@@ -1204,7 +1214,11 @@
 {
 	struct drm_device *dev = (struct drm_device *)arg;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+#if !defined(__AROS__)
 	uint32_t status, fbdev_flags = 0;
+#else
+    uint32_t status;
+#endif
 	unsigned long flags;
 
 	status = nv_rd32(dev, NV03_PMC_INTR_0);
@@ -1213,10 +1227,12 @@
 
 	spin_lock_irqsave(&dev_priv->context_switch_lock, flags);
 
+#if !defined(__AROS__)
 	if (dev_priv->fbdev_info) {
 		fbdev_flags = dev_priv->fbdev_info->flags;
 		dev_priv->fbdev_info->flags |= FBINFO_HWACCEL_DISABLED;
 	}
+#endif
 
 	if (status & NV_PMC_INTR_0_PFIFO_PENDING) {
 		nouveau_fifo_irq_handler(dev);
@@ -1247,8 +1263,10 @@
 	if (status)
 		NV_ERROR(dev, "Unhandled PMC INTR status bits 0x%08x\n", status);
 
+#if !defined(__AROS__)
 	if (dev_priv->fbdev_info)
 		dev_priv->fbdev_info->flags = fbdev_flags;
+#endif
 
 	spin_unlock_irqrestore(&dev_priv->context_switch_lock, flags);
 
diff -ur -x .svn drm/nouveau/nouveau_mem.c drm-changed/nouveau/nouveau_mem.c
--- drm/nouveau/nouveau_mem.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_mem.c	2010-06-27 22:29:57.000000000 +0200
@@ -469,6 +469,7 @@
 	dev_priv->fb_phys = drm_get_resource_start(dev, 1);
 	dev_priv->gart_info.type = NOUVEAU_GART_NONE;
 
+#if !defined(__AROS__)
 	if (dev_priv->card_type >= NV_50 &&
 	    pci_dma_supported(dev->pdev, DMA_BIT_MASK(40)))
 		dma_bits = 40;
@@ -478,6 +479,7 @@
 		NV_ERROR(dev, "Error setting DMA mask: %d\n", ret);
 		return ret;
 	}
+#endif
 
 	ret = nouveau_ttm_global_init(dev_priv);
 	if (ret)
diff -ur -x .svn drm/nouveau/nouveau_sgdma.c drm-changed/nouveau/nouveau_sgdma.c
--- drm/nouveau/nouveau_sgdma.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_sgdma.c	2010-06-27 22:12:19.000000000 +0200
@@ -1,7 +1,9 @@
 #include "drmP.h"
 #include "nouveau_drv.h"
+#if !defined(__AROS__)
 #include <linux/pagemap.h>
 #include <linux/slab.h>
+#endif
 
 #define NV_CTXDMA_PAGE_SHIFT 12
 #define NV_CTXDMA_PAGE_SIZE  (1 << NV_CTXDMA_PAGE_SHIFT)
@@ -265,9 +267,13 @@
 		return ret;
 	}
 
+#if !defined(__AROS__)
 	dev_priv->gart_info.sg_dummy_page =
 		alloc_page(GFP_KERNEL|__GFP_DMA32);
 	set_bit(PG_locked, &dev_priv->gart_info.sg_dummy_page->flags);
+#else
+    dev_priv->gart_info.sg_dummy_page = create_page_helper();
+#endif
 	dev_priv->gart_info.sg_dummy_bus =
 		pci_map_page(dev->pdev, dev_priv->gart_info.sg_dummy_page, 0,
 			     PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
@@ -311,7 +317,9 @@
 	if (dev_priv->gart_info.sg_dummy_page) {
 		pci_unmap_page(dev->pdev, dev_priv->gart_info.sg_dummy_bus,
 			       NV_CTXDMA_PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
+#if !defined(__AROS__)
 		unlock_page(dev_priv->gart_info.sg_dummy_page);
+#endif
 		__free_page(dev_priv->gart_info.sg_dummy_page);
 		dev_priv->gart_info.sg_dummy_page = NULL;
 		dev_priv->gart_info.sg_dummy_bus = 0;
diff -ur -x .svn drm/nouveau/nouveau_state.c drm-changed/nouveau/nouveau_state.c
--- drm/nouveau/nouveau_state.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_state.c	2010-06-28 20:49:14.000000000 +0200
@@ -23,14 +23,18 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
+#if !defined(__AROS__)
 #include <linux/swab.h>
 #include <linux/slab.h>
+#endif
 #include "drmP.h"
 #include "drm.h"
 #include "drm_sarea.h"
 #include "drm_crtc_helper.h"
+#if !defined(__AROS__)
 #include <linux/vgaarb.h>
 #include <linux/vga_switcheroo.h>
+#endif
 
 #include "nouveau_drv.h"
 #include "nouveau_drm.h"
@@ -308,6 +312,7 @@
 	return 0;
 }
 
+#if !defined(__AROS__)
 static unsigned int
 nouveau_vga_set_decode(void *priv, bool state)
 {
@@ -325,6 +330,7 @@
 	else
 		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 }
+#endif
 
 static int
 nouveau_card_init_channel(struct drm_device *dev)
@@ -372,6 +378,7 @@
 	return ret;
 }
 
+#if !defined(__AROS__)
 static void nouveau_switcheroo_set_state(struct pci_dev *pdev,
 					 enum vga_switcheroo_state state)
 {
@@ -395,6 +402,7 @@
 	spin_unlock(&dev->count_lock);
 	return can_switch;
 }
+#endif
 
 int
 nouveau_card_init(struct drm_device *dev)
@@ -408,9 +416,11 @@
 	if (dev_priv->init_state == NOUVEAU_CARD_INIT_DONE)
 		return 0;
 
+#if !defined(__AROS__)
 	vga_client_register(dev->pdev, dev, NULL, nouveau_vga_set_decode);
 	vga_switcheroo_register_client(dev->pdev, nouveau_switcheroo_set_state,
 				       nouveau_switcheroo_can_switch);
+#endif
 
 	/* Initialise internal driver API hooks */
 	ret = nouveau_init_engine_ptrs(dev);
@@ -486,9 +496,11 @@
 	if (ret)
 		goto out_fifo;
 
+#if !defined(__AROS__)
 	ret = drm_vblank_init(dev, 0);
 	if (ret)
 		goto out_irq;
+#endif
 
 	/* what about PVIDEO/PCRTC/PRAMDAC etc? */
 
@@ -545,7 +557,9 @@
 out_bios:
 	nouveau_bios_takedown(dev);
 out:
+#if !defined(__AROS__)
 	vga_client_register(dev->pdev, NULL, NULL, NULL);
+#endif
 	return ret;
 }
 
@@ -563,7 +577,7 @@
 			nouveau_channel_free(dev_priv->channel);
 			dev_priv->channel = NULL;
 		}
-
+		
 		if (!nouveau_noaccel) {
 			engine->fifo.takedown(dev);
 			engine->graph.takedown(dev);
@@ -587,7 +601,11 @@
 		nouveau_gpuobj_late_takedown(dev);
 		nouveau_bios_takedown(dev);
 
+#if !defined(__AROS__)
 		vga_client_register(dev->pdev, NULL, NULL, NULL);
+#else
+DRM_IMPL("Calling vga_client_register\n");
+#endif
 
 		dev_priv->init_state = NOUVEAU_CARD_INIT_DOWN;
 	}
@@ -646,12 +664,19 @@
 	dev_priv->flags = flags & NOUVEAU_FLAGS;
 	dev_priv->init_state = NOUVEAU_CARD_INIT_DOWN;
 
+#if !defined(__AROS__)
 	NV_DEBUG(dev, "vendor: 0x%X device: 0x%X class: 0x%X\n",
 		 dev->pci_vendor, dev->pci_device, dev->pdev->class);
+#else
+	NV_DEBUG(dev, "vendor: 0x%X device: 0x%X\n",
+		 dev->pci_vendor, dev->pci_device);
+#endif
 
+#if !defined(__AROS__)
 	dev_priv->wq = create_workqueue("nouveau");
 	if (!dev_priv->wq)
 		return -EINVAL;
+#endif
 
 	/* resource 0 is mmio regs */
 	/* resource 1 is linear FB */
@@ -693,6 +718,10 @@
 	} else
 		dev_priv->chipset = 0xff;
 
+#if defined(HOSTED_BUILD)
+    dev_priv->chipset = HOSTED_BUILD_CHIPSET;
+#endif
+ 
 	switch (dev_priv->chipset & 0xf0) {
 	case 0x00:
 	case 0x10:
@@ -714,7 +743,7 @@
 		NV_INFO(dev, "Unsupported chipset 0x%08x\n", reg0);
 		return -EINVAL;
 	}
-
+  
 	NV_INFO(dev, "Detected an NV%2x generation card (0x%08x)\n",
 		dev_priv->card_type, reg0);
 
@@ -772,11 +801,14 @@
 		nv04_display_destroy(dev);
 	nouveau_card_takedown(dev);
 
-	iounmap(dev_priv->mmio);
-	iounmap(dev_priv->ramin);
-
-	kfree(dev_priv);
-	dev->dev_private = NULL;
+    if (dev_priv)
+    {
+	    iounmap(dev_priv->mmio);
+	    iounmap(dev_priv->ramin);
+        
+	    kfree(dev_priv);
+	    dev->dev_private = NULL;
+	}
 	return 0;
 }
 
@@ -813,9 +845,13 @@
 		getparam->value = dev_priv->gart_info.aper_base;
 		break;
 	case NOUVEAU_GETPARAM_PCI_PHYSICAL:
+#if !defined(__AROS__)
 		if (dev->sg) {
 			getparam->value = (unsigned long)dev->sg->virtual;
 		} else {
+#else
+        {
+#endif
 			NV_ERROR(dev, "Requested PCIGART address, "
 					"while no PCIGART was created\n");
 			return -EINVAL;
@@ -871,6 +907,7 @@
 bool nouveau_wait_until(struct drm_device *dev, uint64_t timeout,
 			uint32_t reg, uint32_t mask, uint32_t val)
 {
+#if !defined(HOSTED_BUILD)
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;
 	uint64_t start = ptimer->read(dev);
@@ -881,6 +918,9 @@
 	} while (ptimer->read(dev) - start < timeout);
 
 	return false;
+#else
+    return true;
+#endif
 }
 
 /* Waits for PGRAPH to go completely idle */
@@ -894,4 +934,3 @@
 
 	return true;
 }
-
diff -ur -x .svn drm/nouveau/nouveau_ttm.c drm-changed/nouveau/nouveau_ttm.c
--- drm/nouveau/nouveau_ttm.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nouveau_ttm.c	2010-06-27 21:17:36.000000000 +0200
@@ -28,6 +28,7 @@
 
 #include "nouveau_drv.h"
 
+#if !defined(__AROS__)
 int
 nouveau_ttm_mmap(struct file *filp, struct vm_area_struct *vma)
 {
@@ -40,6 +41,7 @@
 
 	return ttm_bo_mmap(filp, vma, &dev_priv->ttm.bdev);
 }
+#endif
 
 static int
 nouveau_ttm_mem_global_init(struct ttm_global_reference *ref)
@@ -58,6 +60,9 @@
 {
 	struct ttm_global_reference *global_ref;
 	int ret;
+#if defined(__AROS__)
+    ttm_global_init();
+#endif
 
 	global_ref = &dev_priv->ttm.mem_global_ref;
 	global_ref->global_type = TTM_GLOBAL_TTM_MEM;
@@ -99,5 +104,9 @@
 	ttm_global_item_unref(&dev_priv->ttm.bo_global_ref.ref);
 	ttm_global_item_unref(&dev_priv->ttm.mem_global_ref);
 	dev_priv->ttm.mem_global_ref.release = NULL;
+	
+#if defined(__AROS__)
+    ttm_global_release();
+#endif
 }
 
diff -ur -x .svn drm/nouveau/nv04_display.c drm-changed/nouveau/nv04_display.c
--- drm/nouveau/nv04_display.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nv04_display.c	2010-06-27 21:17:36.000000000 +0200
@@ -207,6 +207,7 @@
 	nouveau_hw_save_vga_fonts(dev, 0);
 }
 
+#if !defined(__AROS__)
 void
 nv04_display_restore(struct drm_device *dev)
 {
@@ -241,4 +242,6 @@
 
 	NVLockVgaCrtcs(dev, true);
 }
+#endif
+
 
diff -ur -x .svn drm/nouveau/nv04_tv.c drm-changed/nouveau/nv04_tv.c
--- drm/nouveau/nv04_tv.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nv04_tv.c	2010-06-27 21:17:36.000000000 +0200
@@ -32,6 +32,7 @@
 #include "nouveau_hw.h"
 #include "drm_crtc_helper.h"
 
+#if !defined(__AROS__)
 #include "i2c/ch7006.h"
 
 static struct {
@@ -222,9 +223,11 @@
 
 	kfree(nv_encoder);
 }
+#endif
 
 int nv04_tv_create(struct drm_device *dev, struct dcb_entry *entry)
 {
+#if !defined(__AROS__)
 	struct nouveau_encoder *nv_encoder;
 	struct drm_encoder *encoder;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
@@ -302,4 +305,9 @@
 
 	kfree(nv_encoder);
 	return ret;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
+
diff -ur -x .svn drm/nouveau/nv50_display.c drm-changed/nouveau/nv50_display.c
--- drm/nouveau/nv50_display.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nv50_display.c	2010-06-27 23:04:59.000000000 +0200
@@ -877,12 +877,18 @@
 	nv_wr32(dev, 0x619494, nv_rd32(dev, 0x619494) | 8);
 }
 
+#if !defined(__AROS__)
 void
 nv50_display_irq_handler_bh(struct work_struct *work)
 {
 	struct drm_nouveau_private *dev_priv =
 		container_of(work, struct drm_nouveau_private, irq_work);
 	struct drm_device *dev = dev_priv->dev;
+#else
+void
+nv50_display_irq_handler_bh(struct drm_device * dev)
+{
+#endif
 
 	for (;;) {
 		uint32_t intr0 = nv_rd32(dev, NV50_PDISPLAY_INTR_0);
@@ -920,12 +926,19 @@
 	nv_wr32(dev, NV50_PDISPLAY_TRAPPED_ADDR, 0x90000000);
 }
 
+#if !defined(__AROS__)
 void
 nv50_display_irq_hotplug_bh(struct work_struct *work)
 {
 	struct drm_nouveau_private *dev_priv =
 		container_of(work, struct drm_nouveau_private, hpd_work);
 	struct drm_device *dev = dev_priv->dev;
+#else
+void
+nv50_display_irq_hotplug_bh(struct drm_device * dev)
+{
+    struct drm_nouveau_private *dev_priv = dev->dev_private;
+#endif
 	struct drm_connector *connector;
 	const uint32_t gpio_reg[4] = { 0xe104, 0xe108, 0xe280, 0xe284 };
 	uint32_t unplug_mask, plug_mask, change_mask;
@@ -979,18 +992,27 @@
 	if (dev_priv->chipset >= 0x90)
 		nv_wr32(dev, 0xe074, nv_rd32(dev, 0xe074));
 
+#if !defined(__AROS__)
 	drm_sysfs_hotplug_event(dev);
+#endif
 }
 
 void
 nv50_display_irq_handler(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+#endif
 	uint32_t delayed = 0;
 
 	if (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_HOTPLUG) {
+#if !defined(__AROS__)
 		if (!work_pending(&dev_priv->hpd_work))
 			queue_work(dev_priv->wq, &dev_priv->hpd_work);
+#else
+        /* Kind of hackish call but it does its job. */
+        nv50_display_irq_hotplug_bh(dev);
+#endif
 	}
 
 	while (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_DISPLAY) {
@@ -1018,8 +1040,13 @@
 				  NV50_PDISPLAY_INTR_1_CLK_UNK40));
 		if (clock) {
 			nv_wr32(dev, NV03_PMC_INTR_EN_0, 0);
+#if !defined(__AROS__)
 			if (!work_pending(&dev_priv->irq_work))
 				queue_work(dev_priv->wq, &dev_priv->irq_work);
+#else
+            /* Kind of hackish call but it does its job. */
+            nv50_display_irq_handler_bh(dev);
+#endif
 			delayed |= clock;
 			intr1 &= ~clock;
 		}
diff -ur -x .svn drm/nouveau/nv50_display.h drm-changed/nouveau/nv50_display.h
--- drm/nouveau/nv50_display.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nv50_display.h	2010-06-27 22:19:03.000000000 +0200
@@ -36,8 +36,13 @@
 #include "nv50_evo.h"
 
 void nv50_display_irq_handler(struct drm_device *dev);
+#if !defined(__AROS__)
 void nv50_display_irq_handler_bh(struct work_struct *work);
 void nv50_display_irq_hotplug_bh(struct work_struct *work);
+#else
+void nv50_display_irq_handler_bh(struct drm_device *dev);
+void nv50_display_irq_hotplug_bh(struct drm_device *dev);
+#endif
 int nv50_display_init(struct drm_device *dev);
 int nv50_display_create(struct drm_device *dev);
 int nv50_display_destroy(struct drm_device *dev);
diff -ur -x .svn drm/nouveau/nv50_instmem.c drm-changed/nouveau/nv50_instmem.c
--- drm/nouveau/nv50_instmem.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/nouveau/nv50_instmem.c	2010-06-27 21:17:36.000000000 +0200
@@ -254,6 +254,10 @@
 					 NV50_PUNK_BAR_CFG_BASE_VALID);
 	nv_wr32(dev, NV50_PUNK_BAR1_CTXDMA, (priv->fb_bar->instance >> 4) |
 					NV50_PUNK_BAR1_CTXDMA_VALID);
+    /* NOTE: The following line somehow block the AROS VESA driver commands from
+    beeing executed by a card. This results in AROS screen not redrawing as long
+    as nouvea driver is active. Probably the only solution is to do things right
+    and integrate 3D nouveau with 2D driver */
 	nv_wr32(dev, NV50_PUNK_BAR3_CTXDMA, (priv->pramin_bar->instance >> 4) |
 					NV50_PUNK_BAR3_CTXDMA_VALID);
 
@@ -263,6 +267,7 @@
 	/* Assume that praying isn't enough, check that we can re-read the
 	 * entire fake channel back from the PRAMIN BAR */
 	dev_priv->engine.instmem.prepare_access(dev, false);
+#if !defined(HOSTED_BUILD)
 	for (i = 0; i < c_size; i += 4) {
 		if (nv_rd32(dev, NV_RAMIN + i) != nv_ri32(dev, i)) {
 			NV_ERROR(dev, "Error reading back PRAMIN at 0x%08x\n",
@@ -271,6 +276,7 @@
 			return -EINVAL;
 		}
 	}
+#endif
 	dev_priv->engine.instmem.finish_access(dev);
 
 	nv_wr32(dev, NV50_PUNK_BAR0_PRAMIN, save_nv001700);
diff -ur -x .svn drm/ttm/ttm_agp_backend.c drm-changed/ttm/ttm_agp_backend.c
--- drm/ttm/ttm_agp_backend.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_agp_backend.c	2010-06-27 22:02:01.000000000 +0200
@@ -33,11 +33,15 @@
 #include "ttm/ttm_bo_driver.h"
 #ifdef TTM_HAS_AGP
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/agp_backend.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <asm/agp.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 struct ttm_agp_backend {
 	struct ttm_backend backend;
@@ -67,6 +71,7 @@
 		mem->pages[mem->page_count++] = page;
 	}
 	agp_be->mem = mem;
+
 	return 0;
 }
 
diff -ur -x .svn drm/ttm/ttm_bo_api.h drm-changed/ttm/ttm_bo_api.h
--- drm/ttm/ttm_bo_api.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_bo_api.h	2010-06-27 21:17:29.000000000 +0200
@@ -32,6 +32,7 @@
 #define _TTM_BO_API_H_
 
 #include "drm_hashtab.h"
+#if !defined(__AROS__)
 #include <linux/kref.h>
 #include <linux/list.h>
 #include <linux/wait.h>
@@ -39,6 +40,9 @@
 #include <linux/mm.h>
 #include <linux/rbtree.h>
 #include <linux/bitmap.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 struct ttm_bo_device;
 
@@ -189,7 +193,7 @@
 
 	struct kref kref;
 	struct kref list_kref;
-	wait_queue_head_t event_queue;
+//FIXME:	wait_queue_head_t event_queue;
 	spinlock_t lock;
 
 	/**
@@ -237,7 +241,9 @@
 	 * Members protected by the bdev::vm_lock
 	 */
 
+#if !defined(__AROS__)
 	struct rb_node vm_rb;
+#endif
 	struct drm_mm_node *vm_node;
 
 
@@ -576,6 +582,7 @@
 #if 0
 #endif
 
+#if !defined(__AROS__)
 /**
  * ttm_fbdev_mmap - mmap fbdev memory backed by a ttm buffer object.
  *
@@ -628,6 +635,7 @@
 extern ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp,
 			 const char __user *wbuf, char __user *rbuf,
 			 size_t count, loff_t *f_pos, bool write);
+#endif
 
 extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev);
 
diff -ur -x .svn drm/ttm/ttm_bo.c drm-changed/ttm/ttm_bo.c
--- drm/ttm/ttm_bo.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_bo.c	2010-06-27 22:41:18.000000000 +0200
@@ -39,25 +39,31 @@
 #include "ttm/ttm_module.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/jiffies.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/file.h>
 #include <linux/module.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
+
 
 #define TTM_ASSERT_LOCKED(param)
 #define TTM_DEBUG(fmt, arg...)
 #define TTM_BO_HASH_ORDER 13
 
 static int ttm_bo_setup_vm(struct ttm_buffer_object *bo);
+#if !defined(__AROS__)
 static int ttm_bo_swapout(struct ttm_mem_shrink *shrink);
 static void ttm_bo_global_kobj_release(struct kobject *kobj);
-
 static struct attribute ttm_bo_count = {
 	.name = "bo_count",
 	.mode = S_IRUGO
 };
+#endif
 
 static inline int ttm_mem_type_from_flags(uint32_t flags, uint32_t *mem_type)
 {
@@ -112,6 +118,7 @@
 	}
 }
 
+#if !defined(__AROS__)
 static ssize_t ttm_bo_global_show(struct kobject *kobj,
 				  struct attribute *attr,
 				  char *buffer)
@@ -137,6 +144,7 @@
 	.sysfs_ops = &ttm_bo_global_ops,
 	.default_attrs = ttm_bo_global_attrs
 };
+#endif
 
 
 static inline uint32_t ttm_bo_type_flags(unsigned type)
@@ -148,7 +156,9 @@
 {
 	struct ttm_buffer_object *bo =
 	    container_of(list_kref, struct ttm_buffer_object, list_kref);
+#if !defined(__AROS__)
 	struct ttm_bo_device *bdev = bo->bdev;
+#endif
 
 	BUG_ON(atomic_read(&bo->list_kref.refcount));
 	BUG_ON(atomic_read(&bo->kref.refcount));
@@ -164,14 +174,17 @@
 	if (bo->destroy)
 		bo->destroy(bo);
 	else {
+#if !defined(__AROS__)
 		ttm_mem_global_free(bdev->glob->mem_glob, bo->acc_size);
+#endif
 		kfree(bo);
 	}
 }
 
+
 int ttm_bo_wait_unreserved(struct ttm_buffer_object *bo, bool interruptible)
 {
-
+#if !defined(__AROS__)
 	if (interruptible) {
 		int ret = 0;
 
@@ -182,10 +195,14 @@
 	} else {
 		wait_event(bo->event_queue, atomic_read(&bo->reserved) == 0);
 	}
+#else
+IMPLEMENT("\n");
+#endif    
 	return 0;
 }
 EXPORT_SYMBOL(ttm_bo_wait_unreserved);
 
+
 static void ttm_bo_add_to_lru(struct ttm_buffer_object *bo)
 {
 	struct ttm_bo_device *bdev = bo->bdev;
@@ -208,6 +225,7 @@
 	}
 }
 
+
 /**
  * Call with the lru_lock held.
  */
@@ -301,7 +319,7 @@
 	spin_lock(&glob->lru_lock);
 	ttm_bo_add_to_lru(bo);
 	atomic_set(&bo->reserved, 0);
-	wake_up_all(&bo->event_queue);
+//FIXME	wake_up_all(&bo->event_queue);
 	spin_unlock(&glob->lru_lock);
 }
 EXPORT_SYMBOL(ttm_bo_unreserve);
@@ -341,8 +359,12 @@
 			break;
 		}
 
+#if !defined(__AROS__)
 		ret = ttm_tt_set_user(bo->ttm, current,
 				      bo->buffer_start, bo->num_pages);
+#else
+IMPLEMENT("Calling ttm_tt_set_user\n");
+#endif
 		if (unlikely(ret != 0))
 			ttm_tt_destroy(bo->ttm);
 		break;
@@ -503,8 +525,16 @@
 
 		if (sync_obj)
 			driver->sync_obj_flush(sync_obj, sync_obj_arg);
+/* AROS NOTE: this call is supposed to start a work process which in some
+   time will try clean up refs again (ttm_bo_delayed_delete). This is needed
+   if ttm_bo_wait "fails" - meaning the fence is not signalled in time
+   Since currently ttm_bo_wait always waits until fence is signalled
+   this is not needed. If ttm_bo_wait is change not to skip no_wait parameter
+   then this call is needed, else the buffer objects might not be freed */
+#if !defined(__AROS__)
 		schedule_delayed_work(&bdev->wq,
 				      ((HZ / 100) < 1) ? 1 : HZ / 100);
+#endif
 		ret = 0;
 
 	} else {
@@ -565,6 +595,7 @@
 	return ret;
 }
 
+#if !defined(__AROS__)
 static void ttm_bo_delayed_workqueue(struct work_struct *work)
 {
 	struct ttm_bo_device *bdev =
@@ -575,6 +606,7 @@
 				      ((HZ / 100) < 1) ? 1 : HZ / 100);
 	}
 }
+#endif
 
 static void ttm_bo_release(struct kref *kref)
 {
@@ -583,7 +615,9 @@
 	struct ttm_bo_device *bdev = bo->bdev;
 
 	if (likely(bo->vm_node != NULL)) {
+#if !defined(__AROS__)        
 		rb_erase(&bo->vm_rb, &bdev->addr_space_rb);
+#endif
 		drm_mm_put_block(bo->vm_node);
 		bo->vm_node = NULL;
 	}
@@ -968,11 +1002,19 @@
 
 int ttm_bo_wait_cpu(struct ttm_buffer_object *bo, bool no_wait)
 {
+	int ret = 0;
+
+#if !defined(__AROS__)
 	if ((atomic_read(&bo->cpu_writers) > 0) && no_wait)
 		return -EBUSY;
 
 	return wait_event_interruptible(bo->event_queue,
 					atomic_read(&bo->cpu_writers) == 0);
+#else
+IMPLEMENT("\n");
+#endif
+
+	return ret;
 }
 EXPORT_SYMBOL(ttm_bo_wait_cpu);
 
@@ -1140,7 +1182,7 @@
 	kref_init(&bo->list_kref);
 	atomic_set(&bo->cpu_writers, 0);
 	atomic_set(&bo->reserved, 1);
-	init_waitqueue_head(&bo->event_queue);
+//FIXME	init_waitqueue_head(&bo->event_queue);
 	INIT_LIST_HEAD(&bo->lru);
 	INIT_LIST_HEAD(&bo->ddestroy);
 	INIT_LIST_HEAD(&bo->swap);
@@ -1190,6 +1232,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_init);
 
+#if !defined(__AROS__)
 static inline size_t ttm_bo_size(struct ttm_bo_global *glob,
 				 unsigned long num_pages)
 {
@@ -1234,6 +1277,7 @@
 
 	return ret;
 }
+#endif
 
 static int ttm_bo_force_list_clean(struct ttm_bo_device *bdev,
 					unsigned mem_type, bool allow_errors)
@@ -1302,6 +1346,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_clean_mm);
 
+#if !defined(__AROS__)
 int ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type)
 {
 	struct ttm_mem_type_manager *man = &bdev->man[mem_type];
@@ -1323,6 +1368,7 @@
 	return ttm_bo_force_list_clean(bdev, mem_type, true);
 }
 EXPORT_SYMBOL(ttm_bo_evict_mm);
+#endif
 
 int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
 			unsigned long p_size)
@@ -1369,6 +1415,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_init_mm);
 
+#if !defined(__AROS__)
 static void ttm_bo_global_kobj_release(struct kobject *kobj)
 {
 	struct ttm_bo_global *glob =
@@ -1378,27 +1425,34 @@
 	__free_page(glob->dummy_read_page);
 	kfree(glob);
 }
+#endif
 
 void ttm_bo_global_release(struct ttm_global_reference *ref)
 {
-	struct ttm_bo_global *glob = ref->object;
+//FIXME	struct ttm_bo_global *glob = ref->object;
 
-	kobject_del(&glob->kobj);
-	kobject_put(&glob->kobj);
+//FIXME	kobject_del(&glob->kobj);
+//FIXME	kobject_put(&glob->kobj);
 }
 EXPORT_SYMBOL(ttm_bo_global_release);
 
 int ttm_bo_global_init(struct ttm_global_reference *ref)
 {
+#if !defined(__AROS__)
 	struct ttm_bo_global_ref *bo_ref =
 		container_of(ref, struct ttm_bo_global_ref, ref);
+#endif
 	struct ttm_bo_global *glob = ref->object;
-	int ret;
+	int ret = 0;
 
 	mutex_init(&glob->device_list_mutex);
 	spin_lock_init(&glob->lru_lock);
+#if !defined(__AROS__)
 	glob->mem_glob = bo_ref->mem_glob;
 	glob->dummy_read_page = alloc_page(__GFP_ZERO | GFP_DMA32);
+#else
+    glob->dummy_read_page = create_page_helper();
+#endif
 
 	if (unlikely(glob->dummy_read_page == NULL)) {
 		ret = -ENOMEM;
@@ -1408,6 +1462,7 @@
 	INIT_LIST_HEAD(&glob->swap_lru);
 	INIT_LIST_HEAD(&glob->device_list);
 
+#if !defined(__AROS__)
 	ttm_mem_init_shrink(&glob->shrink, ttm_bo_swapout);
 	ret = ttm_mem_register_shrink(glob->mem_glob, &glob->shrink);
 	if (unlikely(ret != 0)) {
@@ -1415,6 +1470,7 @@
 		       "Could not register buffer object swapout.\n");
 		goto out_no_shrink;
 	}
+#endif
 
 	glob->ttm_bo_extra_size =
 		ttm_round_pot(sizeof(struct ttm_tt)) +
@@ -1425,13 +1481,16 @@
 
 	atomic_set(&glob->bo_count, 0);
 
-	ret = kobject_init_and_add(
-		&glob->kobj, &ttm_bo_glob_kobj_type, ttm_get_kobj(), "buffer_objects");
-	if (unlikely(ret != 0))
-		kobject_put(&glob->kobj);
+//FIXME	ret = kobject_init_and_add(
+//FIXME		&glob->kobj, &ttm_bo_glob_kobj_type, ttm_get_kobj(), "buffer_objects");
+//FIXME	if (unlikely(ret != 0))
+//FIXME		kobject_put(&glob->kobj);
+
 	return ret;
+#if !defined(__AROS__)
 out_no_shrink:
 	__free_page(glob->dummy_read_page);
+#endif
 out_no_drp:
 	kfree(glob);
 	return ret;
@@ -1464,8 +1523,11 @@
 	list_del(&bdev->device_list);
 	mutex_unlock(&glob->device_list_mutex);
 
+#if !defined(__AROS__)
+    /* Not needed as long as ttm_bo_wait is forced to always wait for fence signalling */
 	if (!cancel_delayed_work(&bdev->wq))
 		flush_scheduled_work();
+#endif
 
 	while (ttm_bo_delayed_delete(bdev, true))
 		;
@@ -1508,12 +1570,17 @@
 	if (unlikely(ret != 0))
 		goto out_no_sys;
 
+#if !defined(__AROS__)
 	bdev->addr_space_rb = RB_ROOT;
+#endif
 	ret = drm_mm_init(&bdev->addr_space_mm, file_page_offset, 0x10000000);
 	if (unlikely(ret != 0))
 		goto out_no_addr_mm;
 
+#if !defined(__AROS__)
+    /* Not needed as long as ttm_bo_wait is forced to always wait for fence signalling */
 	INIT_DELAYED_WORK(&bdev->wq, ttm_bo_delayed_workqueue);
+#endif
 	bdev->nice_mode = true;
 	INIT_LIST_HEAD(&bdev->ddestroy);
 	bdev->dev_mapping = NULL;
@@ -1575,6 +1642,7 @@
 
 void ttm_bo_unmap_virtual(struct ttm_buffer_object *bo)
 {
+#if !defined(__AROS__)
 	struct ttm_bo_device *bdev = bo->bdev;
 	loff_t offset = (loff_t) bo->addr_space_offset;
 	loff_t holelen = ((loff_t) bo->mem.num_pages) << PAGE_SHIFT;
@@ -1583,9 +1651,13 @@
 		return;
 
 	unmap_mapping_range(bdev->dev_mapping, offset, holelen, 1);
+#else
+    /* This is no-op under AROS */
+#endif
 }
 EXPORT_SYMBOL(ttm_bo_unmap_virtual);
 
+#if !defined(__AROS__)
 static void ttm_bo_vm_insert_rb(struct ttm_buffer_object *bo)
 {
 	struct ttm_bo_device *bdev = bo->bdev;
@@ -1610,6 +1682,7 @@
 	rb_link_node(&bo->vm_rb, parent, cur);
 	rb_insert_color(&bo->vm_rb, &bdev->addr_space_rb);
 }
+#endif
 
 /**
  * ttm_bo_setup_vm:
@@ -1649,7 +1722,9 @@
 		goto retry_pre_get;
 	}
 
+#if !defined(__AROS__)
 	ttm_bo_vm_insert_rb(bo);
+#endif
 	write_unlock(&bdev->vm_lock);
 	bo->addr_space_offset = ((uint64_t) bo->vm_node->start) << PAGE_SHIFT;
 
@@ -1669,9 +1744,13 @@
 
 	if (likely(bo->sync_obj == NULL))
 		return 0;
+#if defined(__AROS__)
+    /* Be sure always to wait until fence is signalled. A case when
+       fence is not signalled in time seems to happen to often. */
+    no_wait = false;
+#endif		
 
 	while (bo->sync_obj) {
-
 		if (driver->sync_obj_signaled(bo->sync_obj, bo->sync_obj_arg)) {
 			void *tmp_obj = bo->sync_obj;
 			bo->sync_obj = NULL;
@@ -1716,6 +1795,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_wait);
 
+#if !defined(__AROS__)
 void ttm_bo_unblock_reservation(struct ttm_buffer_object *bo)
 {
 	atomic_set(&bo->reserved, 0);
@@ -1742,6 +1822,7 @@
 	}
 	return 0;
 }
+#endif
 
 int ttm_bo_synccpu_write_grab(struct ttm_buffer_object *bo, bool no_wait)
 {
@@ -1754,7 +1835,9 @@
 
 	ret = ttm_bo_reserve(bo, true, no_wait, false, 0);
 	if (unlikely(ret != 0))
+    {
 		return ret;
+    }
 	spin_lock(&bo->lock);
 	ret = ttm_bo_wait(bo, false, true, no_wait);
 	spin_unlock(&bo->lock);
@@ -1765,13 +1848,20 @@
 }
 EXPORT_SYMBOL(ttm_bo_synccpu_write_grab);
 
+
 void ttm_bo_synccpu_write_release(struct ttm_buffer_object *bo)
 {
+#if !defined(__AROS__)
 	if (atomic_dec_and_test(&bo->cpu_writers))
 		wake_up_all(&bo->event_queue);
+#else
+    atomic_dec_and_test(&bo->cpu_writers);
+/* FIXME: implement "wake up" of queue */
+#endif    
 }
 EXPORT_SYMBOL(ttm_bo_synccpu_write_release);
 
+#if !defined(__AROS__)
 /**
  * A buffer object shrink method that tries to swap out the first
  * buffer object on the bo_global::swap_lru list.
@@ -1875,3 +1965,4 @@
 		;
 }
 EXPORT_SYMBOL(ttm_bo_swapout_all);
+#endif
diff -ur -x .svn drm/ttm/ttm_bo_driver.h drm-changed/ttm/ttm_bo_driver.h
--- drm/ttm/ttm_bo_driver.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_bo_driver.h	2010-06-27 22:37:24.000000000 +0200
@@ -34,9 +34,13 @@
 #include "ttm/ttm_memory.h"
 #include "ttm/ttm_module.h"
 #include "drm_mm.h"
+#if !defined(__AROS__)
 #include "linux/workqueue.h"
 #include "linux/fs.h"
 #include "linux/spinlock.h"
+#else
+#include "drm_compat_types.h"
+#endif
 
 struct ttm_backend;
 
@@ -118,8 +122,10 @@
 #define TTM_PAGE_FLAG_USER            (1 << 1)
 #define TTM_PAGE_FLAG_USER_DIRTY      (1 << 2)
 #define TTM_PAGE_FLAG_WRITE           (1 << 3)
+#if !defined(__AROS__)
 #define TTM_PAGE_FLAG_SWAPPED         (1 << 4)
 #define TTM_PAGE_FLAG_PERSISTANT_SWAP (1 << 5)
+#endif
 #define TTM_PAGE_FLAG_ZERO_ALLOC      (1 << 6)
 #define TTM_PAGE_FLAG_DMA32           (1 << 7)
 
@@ -160,12 +166,17 @@
 	long first_himem_page;
 	long last_lomem_page;
 	uint32_t page_flags;
+#if defined(__AROS__)
+    APTR allocated_buffer;
+#endif
 	unsigned long num_pages;
 	struct ttm_bo_global *glob;
 	struct ttm_backend *be;
 	struct task_struct *tsk;
 	unsigned long start;
+#if !defined(__AROS__)
 	struct file *swap_storage;
+#endif
 	enum ttm_caching_state caching_state;
 	enum {
 		tt_bound,
@@ -391,10 +402,14 @@
 	 * Constant after init.
 	 */
 
-	struct kobject kobj;
+//FIXME	struct kobject kobj;
+#if !defined(__AROS__)
 	struct ttm_mem_global *mem_glob;
 	struct page *dummy_read_page;
 	struct ttm_mem_shrink shrink;
+#else
+    struct page *dummy_read_page;
+#endif
 	size_t ttm_bo_extra_size;
 	size_t ttm_bo_size;
 	struct mutex device_list_mutex;
@@ -451,7 +466,9 @@
 	/*
 	 * Protected by the vm lock.
 	 */
+#if !defined(__AROS__)
 	struct rb_root addr_space_rb;
+#endif
 	struct drm_mm addr_space_mm;
 
 	/*
@@ -470,7 +487,10 @@
 	 * Internal protection.
 	 */
 
+#if !defined(__AROS__)
+    /* Not needed as long as ttm_bo_wait is forced to always wait for fence signalling */
 	struct delayed_work wq;
+#endif
 
 	bool need_dma32;
 };
@@ -898,6 +918,7 @@
 				     void *sync_obj_arg,
 				     bool evict, bool no_wait,
 				     struct ttm_mem_reg *new_mem);
+#if !defined(__AROS__)
 /**
  * ttm_io_prot
  *
@@ -908,10 +929,13 @@
  * setting up a PTE with the caching model indicated by @c_state.
  */
 extern pgprot_t ttm_io_prot(uint32_t caching_flags, pgprot_t tmp);
+#endif
 
-#if (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) && defined(MODULE)))
+#if (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) && defined(MODULE)) || defined(__AROS__))
 #define TTM_HAS_AGP
+#if !defined(__AROS__)
 #include <linux/agp_backend.h>
+#endif
 
 /**
  * ttm_agp_backend_init
diff -ur -x .svn drm/ttm/ttm_bo_util.c drm-changed/ttm/ttm_bo_util.c
--- drm/ttm/ttm_bo_util.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_bo_util.c	2010-06-27 22:03:02.000000000 +0200
@@ -30,12 +30,14 @@
 
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/io.h>
 #include <linux/highmem.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/module.h>
+#endif
 
 void ttm_bo_free_old_node(struct ttm_buffer_object *bo)
 {
@@ -146,6 +148,7 @@
 
 	src = (void *)((unsigned long)src + (page << PAGE_SHIFT));
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	dst = kmap_atomic_prot(d, KM_USER0, prot);
 #else
@@ -154,11 +157,15 @@
 	else
 		dst = kmap(d);
 #endif
+#else
+    dst = kmap(d);
+#endif
 	if (!dst)
 		return -ENOMEM;
 
 	memcpy_fromio(dst, src, PAGE_SIZE);
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	kunmap_atomic(dst, KM_USER0);
 #else
@@ -167,6 +174,9 @@
 	else
 		kunmap(d);
 #endif
+#else
+    kunmap(d);
+#endif
 
 	return 0;
 }
@@ -182,6 +192,7 @@
 		return -ENOMEM;
 
 	dst = (void *)((unsigned long)dst + (page << PAGE_SHIFT));
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	src = kmap_atomic_prot(s, KM_USER0, prot);
 #else
@@ -190,11 +201,15 @@
 	else
 		src = kmap(s);
 #endif
+#else
+    src = kmap(s);
+#endif
 	if (!src)
 		return -ENOMEM;
 
 	memcpy_toio(dst, src, PAGE_SIZE);
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	kunmap_atomic(src, KM_USER0);
 #else
@@ -203,6 +218,9 @@
 	else
 		kunmap(s);
 #endif
+#else
+    kunmap(s);
+#endif
 
 	return 0;
 }
@@ -248,13 +266,21 @@
 	for (i = 0; i < new_mem->num_pages; ++i) {
 		page = i * dir + add;
 		if (old_iomap == NULL) {
+#if !defined(__AROS__)
 			pgprot_t prot = ttm_io_prot(old_mem->placement,
 						    PAGE_KERNEL);
+#else
+            pgprot_t prot = 0;
+#endif
 			ret = ttm_copy_ttm_io_page(ttm, new_iomap, page,
 						   prot);
 		} else if (new_iomap == NULL) {
+#if !defined(__AROS__)
 			pgprot_t prot = ttm_io_prot(new_mem->placement,
 						    PAGE_KERNEL);
+#else
+            pgprot_t prot = 0;
+#endif
 			ret = ttm_copy_io_ttm_page(ttm, old_iomap, page,
 						   prot);
 		} else
@@ -322,7 +348,7 @@
 	 */
 
 	spin_lock_init(&fbo->lock);
-	init_waitqueue_head(&fbo->event_queue);
+//FIXME	init_waitqueue_head(&fbo->event_queue);
 	INIT_LIST_HEAD(&fbo->ddestroy);
 	INIT_LIST_HEAD(&fbo->lru);
 	INIT_LIST_HEAD(&fbo->swap);
@@ -339,6 +365,7 @@
 	return 0;
 }
 
+#if !defined(__AROS__)
 pgprot_t ttm_io_prot(uint32_t caching_flags, pgprot_t tmp)
 {
 #if defined(__i386__) || defined(__x86_64__)
@@ -367,6 +394,7 @@
 	return tmp;
 }
 EXPORT_SYMBOL(ttm_io_prot);
+#endif
 
 static int ttm_bo_ioremap(struct ttm_buffer_object *bo,
 			  unsigned long bus_base,
@@ -398,7 +426,10 @@
 			   unsigned long num_pages,
 			   struct ttm_bo_kmap_obj *map)
 {
-	struct ttm_mem_reg *mem = &bo->mem; pgprot_t prot;
+	struct ttm_mem_reg *mem = &bo->mem; 
+#if !defined(__AROS__)    
+    pgprot_t prot;
+#endif
 	struct ttm_tt *ttm = bo->ttm;
 	struct page *d;
 	int i;
@@ -427,9 +458,11 @@
 		 * We need to use vmap to get the desired page protection
 		 * or to make the buffer object look contiguous.
 		 */
+#if !defined(__AROS__)        
 		prot = (mem->placement & TTM_PL_FLAG_CACHED) ?
 			PAGE_KERNEL :
 			ttm_io_prot(mem->placement, PAGE_KERNEL);
+#endif
 		map->bo_kmap_type = ttm_bo_map_vmap;
 		map->virtual = vmap(ttm->pages + start_page, num_pages,
 				    0, prot);
@@ -494,6 +527,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_kunmap);
 
+#if !defined(__AROS__)
 int ttm_bo_pfn_prot(struct ttm_buffer_object *bo,
 		    unsigned long dst_offset,
 		    unsigned long *pfn, pgprot_t *prot)
@@ -522,6 +556,7 @@
 
 	return 0;
 }
+#endif
 
 int ttm_bo_move_accel_cleanup(struct ttm_buffer_object *bo,
 			      void *sync_obj,
diff -ur -x .svn drm/ttm/ttm_global.c drm-changed/ttm/ttm_global.c
--- drm/ttm/ttm_global.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_global.c	2010-06-27 21:17:29.000000000 +0200
@@ -29,9 +29,13 @@
  */
 
 #include "ttm/ttm_module.h"
+#if !defined(__AROS__)
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 struct ttm_global_item {
 	struct mutex mutex;
diff -ur -x .svn drm/ttm/ttm_module.h drm-changed/ttm/ttm_module.h
--- drm/ttm/ttm_module.h	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_module.h	2010-06-27 21:17:29.000000000 +0200
@@ -31,8 +31,12 @@
 #ifndef _TTM_MODULE_H_
 #define _TTM_MODULE_H_
 
+#if !defined(__AROS__)
 #include <linux/kernel.h>
 struct kobject;
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define TTM_PFX "[TTM] "
 
diff -ur -x .svn drm/ttm/ttm_tt.c drm-changed/ttm/ttm_tt.c
--- drm/ttm/ttm_tt.c	2010-06-20 18:44:23.000000000 +0200
+++ drm-changed/ttm/ttm_tt.c	2010-06-27 22:05:55.000000000 +0200
@@ -28,19 +28,25 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#if !defined(__AROS__)
 #include <linux/sched.h>
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
 #include <linux/file.h>
 #include <linux/swap.h>
 #include <linux/slab.h>
+#else
+#include "drm_compat_types.h"
+#endif
 #include "drm_cache.h"
 #include "drm_mem_util.h"
 #include "ttm/ttm_module.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
 
+#if !defined(__AROS__)
 static int ttm_tt_swapin(struct ttm_tt *ttm);
+#endif
 
 /**
  * Allocates storage for pointers to the pages that back the ttm.
@@ -48,14 +54,22 @@
 static void ttm_tt_alloc_page_directory(struct ttm_tt *ttm)
 {
 	ttm->pages = drm_calloc_large(ttm->num_pages, sizeof(*ttm->pages));
+#if defined(__AROS__)
+    ttm->allocated_buffer = AllocVec((ttm->num_pages * PAGE_SIZE) + PAGE_SIZE - 1, MEMF_PUBLIC | MEMF_CLEAR);
+#endif
 }
 
 static void ttm_tt_free_page_directory(struct ttm_tt *ttm)
 {
 	drm_free_large(ttm->pages);
 	ttm->pages = NULL;
+#if defined(__AROS__)
+    FreeVec(ttm->allocated_buffer);
+    ttm->allocated_buffer = NULL;
+#endif
 }
 
+#if !defined(__AROS__)
 static struct page *ttm_tt_alloc_page(unsigned page_flags)
 {
 	gfp_t gfp_flags = GFP_USER;
@@ -70,6 +84,7 @@
 
 	return alloc_page(gfp_flags);
 }
+#endif
 
 static void ttm_tt_free_user_pages(struct ttm_tt *ttm)
 {
@@ -96,11 +111,15 @@
 			continue;
 		}
 
+#if !defined(__AROS__)
 		if (write && dirty && !PageReserved(page))
 			set_page_dirty_lock(page);
+#endif
 
 		ttm->pages[i] = NULL;
+#if !defined(__AROS__)
 		ttm_mem_global_free(ttm->glob->mem_glob, PAGE_SIZE);
+#endif
 		put_page(page);
 	}
 	ttm->state = tt_unpopulated;
@@ -111,18 +130,28 @@
 static struct page *__ttm_tt_get_page(struct ttm_tt *ttm, int index)
 {
 	struct page *p;
+#if !defined(__AROS__)
 	struct ttm_mem_global *mem_glob = ttm->glob->mem_glob;
 	int ret;
+#endif
 
 	while (NULL == (p = ttm->pages[index])) {
+#if !defined(__AROS__)
 		p = ttm_tt_alloc_page(ttm->page_flags);
+#else
+        p = AllocVec(sizeof(*p), MEMF_PUBLIC | MEMF_CLEAR);
+        p->allocated_buffer = NULL;
+        p->address = (APTR)((IPTR)PAGE_ALIGN(ttm->allocated_buffer) + (IPTR)(PAGE_SIZE * index));
+#endif
 
 		if (!p)
 			return NULL;
 
+#if !defined(__AROS__)
 		ret = ttm_mem_global_alloc_page(mem_glob, p, false, false);
 		if (unlikely(ret != 0))
 			goto out_err;
+#endif
 
 		if (PageHighMem(p))
 			ttm->pages[--ttm->first_himem_page] = p;
@@ -130,13 +159,16 @@
 			ttm->pages[++ttm->last_lomem_page] = p;
 	}
 	return p;
+#if !defined(__AROS__)
 out_err:
 	put_page(p);
 	return NULL;
+#endif
 }
 
 struct page *ttm_tt_get_page(struct ttm_tt *ttm, int index)
 {
+#if !defined(__AROS__)
 	int ret;
 
 	if (unlikely(ttm->page_flags & TTM_PAGE_FLAG_SWAPPED)) {
@@ -144,6 +176,7 @@
 		if (unlikely(ret != 0))
 			return NULL;
 	}
+#endif
 	return __ttm_tt_get_page(ttm, index);
 }
 
@@ -152,16 +185,20 @@
 	struct page *page;
 	unsigned long i;
 	struct ttm_backend *be;
+#if !defined(__AROS__)
 	int ret;
+#endif
 
 	if (ttm->state != tt_unpopulated)
 		return 0;
 
+#if !defined(__AROS__)
 	if (unlikely(ttm->page_flags & TTM_PAGE_FLAG_SWAPPED)) {
 		ret = ttm_tt_swapin(ttm);
 		if (unlikely(ret != 0))
 			return ret;
 	}
+#endif
 
 	be = ttm->be;
 
@@ -218,6 +255,7 @@
  * for range of pages in a ttm.
  */
 
+
 static int ttm_tt_set_caching(struct ttm_tt *ttm,
 			      enum ttm_caching_state c_state)
 {
@@ -292,12 +330,14 @@
 		cur_page = ttm->pages[i];
 		ttm->pages[i] = NULL;
 		if (cur_page) {
+#if !defined(__AROS__)
 			if (page_count(cur_page) != 1)
 				printk(KERN_ERR TTM_PFX
 				       "Erroneous page count. "
 				       "Leaking pages.\n");
 			ttm_mem_global_free_page(ttm->glob->mem_glob,
 						 cur_page);
+#endif
 			__free_page(cur_page);
 		}
 	}
@@ -328,13 +368,16 @@
 		ttm_tt_free_page_directory(ttm);
 	}
 
+#if !defined(__AROS__)
 	if (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTANT_SWAP) &&
 	    ttm->swap_storage)
 		fput(ttm->swap_storage);
+#endif
 
 	kfree(ttm);
 }
 
+#if !defined(__AROS__)
 int ttm_tt_set_user(struct ttm_tt *ttm,
 		    struct task_struct *tsk,
 		    unsigned long start, unsigned long num_pages)
@@ -373,6 +416,7 @@
 
 	return 0;
 }
+#endif
 
 struct ttm_tt *ttm_tt_create(struct ttm_bo_device *bdev, unsigned long size,
 			     uint32_t page_flags, struct page *dummy_read_page)
@@ -389,6 +433,7 @@
 
 	ttm->glob = bdev->glob;
 	ttm->num_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+
 	ttm->first_himem_page = ttm->num_pages;
 	ttm->last_lomem_page = -1;
 	ttm->caching_state = tt_cached;
@@ -402,6 +447,7 @@
 		printk(KERN_ERR TTM_PFX "Failed allocating page table\n");
 		return NULL;
 	}
+    
 	ttm->be = bo_driver->create_ttm_backend_entry(bdev);
 	if (!ttm->be) {
 		ttm_tt_destroy(ttm);
@@ -455,6 +501,7 @@
 }
 EXPORT_SYMBOL(ttm_tt_bind);
 
+#if !defined(__AROS__)
 static int ttm_tt_swapin(struct ttm_tt *ttm)
 {
 	struct address_space *swap_space;
@@ -585,3 +632,4 @@
 
 	return ret;
 }
+#endif
