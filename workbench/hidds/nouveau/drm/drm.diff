diff -ur /data/deadwood/source/drm-orig/drm_agpsupport.c drm/drm_agpsupport.c
--- /data/deadwood/source/drm-orig/drm_agpsupport.c	2011-02-13 19:09:47.000000000 +0100
+++ drm/drm_agpsupport.c	2011-09-18 12:14:00.000000000 +0200
@@ -32,12 +32,16 @@
  */
 
 #include "drmP.h"
+#if !defined(__AROS__)
 #include <linux/module.h>
 #include <linux/slab.h>
+#endif
 
 #if __OS_HAS_AGP
 
+#if !defined(__AROS__)
 #include <asm/agp.h>
+#endif
 
 /**
  * Get AGP information.
@@ -59,15 +63,19 @@
 		return -EINVAL;
 
 	kern = &dev->agp->agp_info;
+#if !defined(__AROS__)
 	info->agp_version_major = kern->version.major;
 	info->agp_version_minor = kern->version.minor;
+#endif
 	info->mode = kern->mode;
 	info->aperture_base = kern->aper_base;
 	info->aperture_size = kern->aper_size * 1024 * 1024;
+#if !defined(__AROS__)
 	info->memory_allowed = kern->max_memory << PAGE_SHIFT;
 	info->memory_used = kern->current_memory << PAGE_SHIFT;
 	info->id_vendor = kern->device->vendor;
 	info->id_device = kern->device->device;
+#endif
 
 	return 0;
 }
@@ -110,6 +118,7 @@
 
 EXPORT_SYMBOL(drm_agp_acquire);
 
+#if !defined(__AROS__)
 /**
  * Acquire the AGP device (ioctl).
  *
@@ -127,6 +136,7 @@
 {
 	return drm_agp_acquire((struct drm_device *) file_priv->minor->dev);
 }
+#endif
 
 /**
  * Release the AGP device.
@@ -183,6 +193,7 @@
 	return drm_agp_enable(dev, *mode);
 }
 
+#if !defined(__AROS__)
 /**
  * Allocate AGP memory.
  *
@@ -384,6 +395,7 @@
 
 	return drm_agp_free(dev, request);
 }
+#endif
 
 /**
  * Initialize the AGP resources.
diff -ur /data/deadwood/source/drm-orig/drm_cache.c drm/drm_cache.c
--- /data/deadwood/source/drm-orig/drm_cache.c	2011-02-13 19:09:47.000000000 +0100
+++ drm/drm_cache.c	2011-09-18 10:54:20.000000000 +0200
@@ -91,6 +91,9 @@
 				   (unsigned long)page_virtual + PAGE_SIZE);
 		kunmap_atomic(page_virtual, KM_USER0);
 	}
+#elif defined(__AROS__)
+	/* TODO: Detect if cpu has clflush. If yes, use ClearCacheE on each page */
+	CacheClearU();
 #else
 	printk(KERN_ERR "Architecture has no drm_cache.c support\n");
 	WARN_ON_ONCE(1);
diff -ur /data/deadwood/source/drm-orig/drm_crtc.c drm/drm_crtc.c
--- /data/deadwood/source/drm-orig/drm_crtc.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_crtc.c	2011-09-17 08:03:13.000000000 +0200
@@ -29,8 +29,10 @@
  *      Dave Airlie <airlied@linux.ie>
  *      Jesse Barnes <jesse.barnes@intel.com>
  */
+#if !defined(__AROS__)
 #include <linux/list.h>
 #include <linux/slab.h>
+#endif
 #include "drm.h"
 #include "drmP.h"
 #include "drm_crtc.h"
@@ -814,6 +816,7 @@
 }
 EXPORT_SYMBOL(drm_mode_create_dithering_property);
 
+#if !defined(__AROS__)
 /**
  * drm_mode_create_dirty_property - create dirty property
  * @dev: DRM device
@@ -843,6 +846,7 @@
 	return 0;
 }
 EXPORT_SYMBOL(drm_mode_create_dirty_info_property);
+#endif
 
 /**
  * drm_mode_config_init - initialize DRM mode_configuration structure
@@ -878,6 +882,7 @@
 }
 EXPORT_SYMBOL(drm_mode_config_init);
 
+#if !defined(__AROS__)
 int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
 {
 	uint32_t total_objects = 0;
@@ -920,6 +925,7 @@
 
 	return 0;
 }
+#endif
 
 /**
  * drm_mode_config_cleanup - free up DRM mode_config info
@@ -1082,8 +1088,12 @@
 	list_for_each(lh, &file_priv->fbs)
 		fb_count++;
 
+#if !defined(__AROS__)
 	mode_group = &file_priv->master->minor->mode_group;
 	if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+    if (1) {
+#endif
 
 		list_for_each(lh, &dev->mode_config.crtc_list)
 			crtc_count++;
@@ -1124,7 +1134,11 @@
 	if (card_res->count_crtcs >= crtc_count) {
 		copied = 0;
 		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(crtc, &dev->mode_config.crtc_list,
 					    head) {
 				DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);
@@ -1151,7 +1165,11 @@
 	if (card_res->count_encoders >= encoder_count) {
 		copied = 0;
 		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(encoder,
 					    &dev->mode_config.encoder_list,
 					    head) {
@@ -1182,7 +1200,11 @@
 	if (card_res->count_connectors >= connector_count) {
 		copied = 0;
 		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
+#if !defined(__AROS__)
 		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
+#else
+        if (1) {
+#endif
 			list_for_each_entry(connector,
 					    &dev->mode_config.connector_list,
 					    head) {
@@ -1776,6 +1798,7 @@
 	return ret;
 }
 
+#if !defined(__AROS__)
 /**
  * drm_mode_getfb - get FB info
  * @inode: inode from the ioctl
@@ -2090,6 +2113,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 struct drm_property *drm_property_create(struct drm_device *dev, int flags,
 					 const char *name, int num_values)
@@ -2208,6 +2232,7 @@
 }
 EXPORT_SYMBOL(drm_connector_property_set_value);
 
+#if !defined(__AROS__)
 int drm_connector_property_get_value(struct drm_connector *connector,
 				  struct drm_property *property, uint64_t *val)
 {
@@ -2328,6 +2353,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 static struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,
 							  void *data)
@@ -2360,6 +2386,7 @@
 	kfree(blob);
 }
 
+#if !defined(__AROS__)
 int drm_mode_getblob_ioctl(struct drm_device *dev,
 			   void *data, struct drm_file *file_priv)
 {
@@ -2393,6 +2420,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 int drm_mode_connector_update_edid_property(struct drm_connector *connector,
 					    struct edid *edid)
@@ -2422,6 +2450,7 @@
 }
 EXPORT_SYMBOL(drm_mode_connector_update_edid_property);
 
+#if !defined(__AROS__)
 int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
 				       void *data, struct drm_file *file_priv)
 {
@@ -2495,6 +2524,7 @@
 	mutex_unlock(&dev->mode_config.mutex);
 	return ret;
 }
+#endif
 
 int drm_mode_connector_attach_encoder(struct drm_connector *connector,
 				      struct drm_encoder *encoder)
@@ -2511,6 +2541,7 @@
 }
 EXPORT_SYMBOL(drm_mode_connector_attach_encoder);
 
+#if !defined(__AROS__)
 void drm_mode_connector_detach_encoder(struct drm_connector *connector,
 				    struct drm_encoder *encoder)
 {
@@ -2525,6 +2556,7 @@
 	}
 }
 EXPORT_SYMBOL(drm_mode_connector_detach_encoder);
+#endif
 
 bool drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
 				  int gamma_size)
@@ -2541,6 +2573,7 @@
 }
 EXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);
 
+#if !defined(__AROS__)
 int drm_mode_gamma_set_ioctl(struct drm_device *dev,
 			     void *data, struct drm_file *file_priv)
 {
@@ -2775,3 +2808,4 @@
 
 	return dev->driver->dumb_destroy(file_priv, dev, args->handle);
 }
+#endif
diff -ur /data/deadwood/source/drm-orig/drm_crtc.h drm/drm_crtc.h
--- /data/deadwood/source/drm-orig/drm_crtc.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm_crtc.h	2011-09-17 08:03:13.000000000 +0200
@@ -25,12 +25,16 @@
 #ifndef __DRM_CRTC_H__
 #define __DRM_CRTC_H__
 
+#if !defined(__AROS__)
 #include <linux/i2c.h>
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/idr.h>
 
 #include <linux/fb.h>
+#else
+#include "drm_linux_list.h"
+#endif
 
 struct drm_device;
 struct drm_mode_set;
@@ -484,7 +488,9 @@
  */
 struct drm_connector {
 	struct drm_device *dev;
+#if !defined(__AROS__)
 	struct device kdev;
+#endif
 	struct device_attribute *attr;
 	struct list_head head;
 
@@ -593,7 +599,9 @@
 
 	/* output poll support */
 	bool poll_enabled;
+#if !defined(__AROS__)
 	struct delayed_work output_poll_work;
+#endif
 
 	/* pointers to standard properties */
 	struct list_head property_blob_list;
diff -ur /data/deadwood/source/drm-orig/drm_crtc_helper.c drm/drm_crtc_helper.c
--- /data/deadwood/source/drm-orig/drm_crtc_helper.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_crtc_helper.c	2011-09-17 08:03:13.000000000 +0200
@@ -32,10 +32,12 @@
 #include "drmP.h"
 #include "drm_crtc.h"
 #include "drm_crtc_helper.h"
+#if !defined(__AROS__)
 #include "drm_fb_helper.h"
 
 static bool drm_kms_helper_poll = true;
 module_param_named(poll, drm_kms_helper_poll, bool, 0600);
+#endif
 
 static void drm_mode_validate_flag(struct drm_connector *connector,
 				   int flags)
@@ -104,7 +106,9 @@
 			connector->funcs->force(connector);
 	} else {
 		connector->status = connector->funcs->detect(connector, true);
+#if !defined(__AROS__)
 		drm_kms_helper_poll_enable(dev);
+#endif
 	}
 
 	if (connector->status == connector_status_disconnected) {
@@ -217,6 +221,7 @@
 		(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);
 }
 
+#if !defined(__AROS__)
 /**
  * drm_helper_disable_unused_functions - disable unused objects
  * @dev: DRM device
@@ -261,6 +266,7 @@
 	}
 }
 EXPORT_SYMBOL(drm_helper_disable_unused_functions);
+#endif
 
 /**
  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
@@ -430,11 +436,13 @@
 	/* Store real post-adjustment hardware mode. */
 	crtc->hwmode = *adjusted_mode;
 
+#if !defined(__AROS__)
 	/* Calculate and store various constants which
 	 * are later needed by vblank and swap-completion
 	 * timestamping. They are derived from true hwmode.
 	 */
 	drm_calc_timestamping_constants(crtc);
+#endif
 
 	/* FIXME: add subpixel order */
 done:
@@ -678,7 +686,9 @@
 				set->connectors[i]->dpms = DRM_MODE_DPMS_ON;
 			}
 		}
+#if !defined(__AROS__)
 		drm_helper_disable_unused_functions(dev);
+#endif
 	} else if (fb_changed) {
 		set->crtc->x = set->x;
 		set->crtc->y = set->y;
@@ -818,6 +828,7 @@
 }
 EXPORT_SYMBOL(drm_helper_mode_fill_fb_struct);
 
+#if !defined(__AROS__)
 int drm_helper_resume_force_mode(struct drm_device *dev)
 {
 	struct drm_crtc *crtc;
@@ -967,3 +978,4 @@
 		queue_delayed_work(system_nrt_wq, &dev->mode_config.output_poll_work, 0);
 }
 EXPORT_SYMBOL(drm_helper_hpd_irq_event);
+#endif
diff -ur /data/deadwood/source/drm-orig/drm_crtc_helper.h drm/drm_crtc_helper.h
--- /data/deadwood/source/drm-orig/drm_crtc_helper.h	2011-02-13 19:09:51.000000000 +0100
+++ drm/drm_crtc_helper.h	2011-09-12 20:46:05.000000000 +0200
@@ -33,11 +33,15 @@
 #ifndef __DRM_CRTC_HELPER_H__
 #define __DRM_CRTC_HELPER_H__
 
+#if !defined(__AROS__)
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/idr.h>
 
 #include <linux/fb.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 enum mode_set_atomic {
 	LEAVE_ATOMIC_MODE_SET,
diff -ur /data/deadwood/source/drm-orig/drm_dp_helper.h drm/drm_dp_helper.h
--- /data/deadwood/source/drm-orig/drm_dp_helper.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm_dp_helper.h	2011-09-17 08:03:13.000000000 +0200
@@ -23,8 +23,12 @@
 #ifndef _DRM_DP_HELPER_H_
 #define _DRM_DP_HELPER_H_
 
+#if !defined(__AROS__)
 #include <linux/types.h>
 #include <linux/i2c.h>
+#else
+#include "drm_compat_types.h"
+#endif
 
 /* From the VESA DisplayPort spec */
 
diff -ur /data/deadwood/source/drm-orig/drm_edid.c drm/drm_edid.c
--- /data/deadwood/source/drm-orig/drm_edid.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_edid.c	2011-09-17 08:03:13.000000000 +0200
@@ -27,9 +27,11 @@
  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  * DEALINGS IN THE SOFTWARE.
  */
+#if !defined(__AROS__)
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/i2c.h>
+#endif
 #include "drmP.h"
 #include "drm_edid.h"
 #include "drm_edid_modes.h"
@@ -197,8 +199,10 @@
 bad:
 	if (raw_edid) {
 		printk(KERN_ERR "Raw EDID:\n");
+#if !defined(__AROS__)
 		print_hex_dump(KERN_ERR, " \t", DUMP_PREFIX_NONE, 16, 1,
 			       raw_edid, EDID_LENGTH, false);
+#endif
 	}
 	return 0;
 }
@@ -286,6 +290,9 @@
 {
 	int i, j = 0, valid_extensions = 0;
 	u8 *block, *new;
+#if defined(__AROS__)
+    int allocsize = EDID_LENGTH;
+#endif
 
 	if ((block = kmalloc(EDID_LENGTH, GFP_KERNEL)) == NULL)
 		return NULL;
@@ -308,7 +315,14 @@
 	if (block[0x7e] == 0)
 		return block;
 
+#if !defined(__AROS__)
 	new = krealloc(block, (block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);
+#else
+    new = kzalloc((block[0x7e] + 1) * EDID_LENGTH, GFP_KERNEL);
+    memcpy(new, block, allocsize);
+    allocsize = (block[0x7e] + 1) * EDID_LENGTH;
+    kfree(block);
+#endif
 	if (!new)
 		goto out;
 	block = new;
@@ -333,7 +347,14 @@
 	if (valid_extensions != block[0x7e]) {
 		block[EDID_LENGTH-1] += block[0x7e] - valid_extensions;
 		block[0x7e] = valid_extensions;
+#if !defined(__AROS__)
 		new = krealloc(block, (valid_extensions + 1) * EDID_LENGTH, GFP_KERNEL);
+#else
+        new = kzalloc((valid_extensions + 1) * EDID_LENGTH, GFP_KERNEL);
+        memcpy(new, block, allocsize);
+        allocsize = (valid_extensions + 1) * EDID_LENGTH;
+        kfree(block);
+#endif
 		if (!new)
 			goto out;
 		block = new;
@@ -1607,3 +1628,4 @@
 	return num_modes;
 }
 EXPORT_SYMBOL(drm_add_modes_noedid);
+
diff -ur /data/deadwood/source/drm-orig/drm_edid.h drm/drm_edid.h
--- /data/deadwood/source/drm-orig/drm_edid.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm_edid.h	2011-09-17 08:03:13.000000000 +0200
@@ -23,7 +23,11 @@
 #ifndef __DRM_EDID_H__
 #define __DRM_EDID_H__
 
+#if !defined(__AROS__)
 #include <linux/types.h>
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define EDID_LENGTH 128
 #define DDC_ADDR 0x50
diff -ur /data/deadwood/source/drm-orig/drm_edid_modes.h drm/drm_edid_modes.h
--- /data/deadwood/source/drm-orig/drm_edid_modes.h	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_edid_modes.h	2011-09-17 08:03:13.000000000 +0200
@@ -23,7 +23,9 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
+#if !defined(__AROS__)
 #include <linux/kernel.h>
+#endif
 #include "drmP.h"
 #include "drm_edid.h"
 
diff -ur /data/deadwood/source/drm-orig/drm_encoder_slave.h drm/drm_encoder_slave.h
--- /data/deadwood/source/drm-orig/drm_encoder_slave.h	2011-02-13 19:09:51.000000000 +0100
+++ drm/drm_encoder_slave.h	2011-09-12 20:46:05.000000000 +0200
@@ -145,7 +145,9 @@
 static inline int drm_i2c_encoder_register(struct module *owner,
 					   struct drm_i2c_encoder_driver *driver)
 {
-	return i2c_register_driver(owner, &driver->i2c_driver);
+//FIXME	return i2c_register_driver(owner, &driver->i2c_driver);
+IMPLEMENT("\n");
+return 0;
 }
 
 /**
@@ -154,7 +156,8 @@
  */
 static inline void drm_i2c_encoder_unregister(struct drm_i2c_encoder_driver *driver)
 {
-	i2c_del_driver(&driver->i2c_driver);
+//FIXME	i2c_del_driver(&driver->i2c_driver);
+IMPLEMENT("\n");
 }
 
 void drm_i2c_encoder_destroy(struct drm_encoder *encoder);
diff -ur /data/deadwood/source/drm-orig/drm_gem.c drm/drm_gem.c
--- /data/deadwood/source/drm-orig/drm_gem.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_gem.c	2011-09-17 08:03:13.000000000 +0200
@@ -25,6 +25,7 @@
  *
  */
 
+#if !defined(__AROS__)
 #include <linux/types.h>
 #include <linux/slab.h>
 #include <linux/mm.h>
@@ -35,6 +36,7 @@
 #include <linux/mman.h>
 #include <linux/pagemap.h>
 #include <linux/shmem_fs.h>
+#endif
 #include "drmP.h"
 
 /** @file drm_gem.c
@@ -89,11 +91,14 @@
 int
 drm_gem_init(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct drm_gem_mm *mm;
+#endif
 
 	spin_lock_init(&dev->object_name_lock);
 	idr_init(&dev->object_name_idr);
 
+#if !defined(__AROS__)
 	mm = kzalloc(sizeof(struct drm_gem_mm), GFP_KERNEL);
 	if (!mm) {
 		DRM_ERROR("out of memory\n");
@@ -113,10 +118,12 @@
 		kfree(mm);
 		return -ENOMEM;
 	}
+#endif
 
 	return 0;
 }
 
+#if !defined(__AROS__)
 void
 drm_gem_destroy(struct drm_device *dev)
 {
@@ -127,6 +134,7 @@
 	kfree(mm);
 	dev->mm_private = NULL;
 }
+#endif
 
 /**
  * Initialize an already allocated GEM object of the specified size with
@@ -138,9 +146,14 @@
 	BUG_ON((size & (PAGE_SIZE - 1)) != 0);
 
 	obj->dev = dev;
+#if !defined(__AROS__)
 	obj->filp = shmem_file_setup("drm mm object", size, VM_NORESERVE);
 	if (IS_ERR(obj->filp))
 		return -ENOMEM;
+#else
+    /* No swapping under AROS. Set to NULL to detect any problems */
+    obj->filp = NULL;
+#endif
 
 	kref_init(&obj->refcount);
 	atomic_set(&obj->handle_count, 0);
@@ -192,8 +205,10 @@
 	}
 	return obj;
 fput:
+#if !defined(__AROS__)
 	/* Object_init mangles the global counters - readjust them. */
 	fput(obj->filp);
+#endif
 free:
 	kfree(obj);
 	return NULL;
@@ -417,6 +432,7 @@
 	return 0;
 }
 
+#if !defined(__AROS__)
 /**
  * Called at device open time, sets up the structure for handling refcounting
  * of mm objects.
@@ -461,12 +477,15 @@
 	idr_remove_all(&file_private->object_idr);
 	idr_destroy(&file_private->object_idr);
 }
+#endif
 
 void
 drm_gem_object_release(struct drm_gem_object *obj)
 {
+#if !defined(__AROS__)
 	if (obj->filp)
 	    fput(obj->filp);
+#endif
 }
 EXPORT_SYMBOL(drm_gem_object_release);
 
@@ -482,7 +501,7 @@
 	struct drm_gem_object *obj = (struct drm_gem_object *) kref;
 	struct drm_device *dev = obj->dev;
 
-	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
+//FIXME	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
 
 	if (dev->driver->gem_free_object != NULL)
 		dev->driver->gem_free_object(obj);
@@ -524,6 +543,7 @@
 }
 EXPORT_SYMBOL(drm_gem_object_handle_free);
 
+#if !defined(__AROS__)
 void drm_gem_vm_open(struct vm_area_struct *vma)
 {
 	struct drm_gem_object *obj = vma->vm_private_data;
@@ -621,3 +641,4 @@
 	return ret;
 }
 EXPORT_SYMBOL(drm_gem_mmap);
+#endif
diff -ur /data/deadwood/source/drm-orig/drm_global.c drm/drm_global.c
--- /data/deadwood/source/drm-orig/drm_global.c	2011-02-13 19:09:47.000000000 +0100
+++ drm/drm_global.c	2011-09-17 08:03:13.000000000 +0200
@@ -28,9 +28,13 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#if !defined(__AROS__)
 #include <linux/mutex.h>
 #include <linux/slab.h>
 #include <linux/module.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 #include "drm_global.h"
 
 struct drm_global_item {
@@ -67,7 +71,6 @@
 {
 	int ret;
 	struct drm_global_item *item = &glob[ref->global_type];
-	void *object;
 
 	mutex_lock(&item->mutex);
 	if (item->refcount == 0) {
@@ -85,7 +88,6 @@
 	}
 	++item->refcount;
 	ref->object = item->object;
-	object = item->object;
 	mutex_unlock(&item->mutex);
 	return 0;
 out_err:
diff -ur /data/deadwood/source/drm-orig/drm.h drm/drm.h
--- /data/deadwood/source/drm-orig/drm.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm.h	2011-09-17 08:03:13.000000000 +0200
@@ -37,11 +37,15 @@
 #define _DRM_H_
 
 #if defined(__linux__)
-
 #include <linux/types.h>
 #include <asm/ioctl.h>
 typedef unsigned int drm_handle_t;
 
+#elif defined(__AROS__)
+#include <sys/ioctl.h>
+#include "drm_compat_types.h"
+typedef unsigned int drm_handle_t;
+
 #else /* One of the BSDs */
 
 #include <sys/ioccom.h>
diff -ur /data/deadwood/source/drm-orig/drm_hashtab.h drm/drm_hashtab.h
--- /data/deadwood/source/drm-orig/drm_hashtab.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm_hashtab.h	2011-09-17 08:03:13.000000000 +0200
@@ -35,17 +35,21 @@
 #ifndef DRM_HASHTAB_H
 #define DRM_HASHTAB_H
 
+#if !defined(__AROS__)
 #include <linux/list.h>
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define drm_hash_entry(_ptr, _type, _member) container_of(_ptr, _type, _member)
 
 struct drm_hash_item {
-	struct hlist_node head;
+//FIXME:	struct hlist_node head;
 	unsigned long key;
 };
 
 struct drm_open_hash {
-	struct hlist_head *table;
+//FIXME:	struct hlist_head *table;
 	u8 order;
 };
 
diff -ur /data/deadwood/source/drm-orig/drm_irq.c drm/drm_irq.c
--- /data/deadwood/source/drm-orig/drm_irq.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_irq.c	2011-09-23 18:31:47.000000000 +0200
@@ -34,13 +34,21 @@
  */
 
 #include "drmP.h"
+#if !defined(__AROS__)
 #include "drm_trace.h"
 
 #include <linux/interrupt.h>	/* For task queue support */
 #include <linux/slab.h>
 
 #include <linux/vgaarb.h>
+#else
+#include "drm_aros.h"
 
+#include <proto/oop.h>
+#include <hidd/pci.h>
+#endif
+
+#if !defined(__AROS__)
 /* Access macro for slots in vblank timestamp ringbuffer. */
 #define vblanktimestamp(dev, crtc, count) ( \
 	(dev)->_vblank_time[(crtc) * DRM_VBLANKTIME_RBSIZE + \
@@ -301,6 +309,7 @@
 			dev->driver->irq_postinstall(dev);
 	}
 }
+#endif
 
 /**
  * Install IRQ handler.
@@ -311,6 +320,7 @@
  * \c drm_driver_irq_preinstall() and \c drm_driver_irq_postinstall() functions
  * before and after the installation.
  */
+#if !defined(__AROS__)
 int drm_irq_install(struct drm_device *dev)
 {
 	int ret = 0;
@@ -382,7 +392,59 @@
 	return ret;
 }
 EXPORT_SYMBOL(drm_irq_install);
+#else
+static AROS_INTH1(interrupt_handler, struct drm_device *, dev)
+{
+    AROS_INTFUNC_INIT
+    if (dev->driver->irq_handler)
+        dev->driver->irq_handler(dev);
+    return FALSE;
+    AROS_INTFUNC_EXIT
+}
+
+int drm_irq_install(struct drm_device *dev)
+{
+    IPTR INTLine = 0;
+    int retval = 0;
+    
+    ObtainSemaphore(&dev->struct_mutex.semaphore);
+    if (dev->irq_enabled) {
+        ReleaseSemaphore(&dev->struct_mutex.semaphore);
+        return -EBUSY;
+    }
+    dev->irq_enabled = 1;
+    ReleaseSemaphore(&dev->struct_mutex.semaphore);
+    
+    if (dev->driver->irq_preinstall)
+        dev->driver->irq_preinstall(dev);
+
+    dev->IntHandler.is_Node.ln_Type = NT_INTERRUPT;
+    dev->IntHandler.is_Node.ln_Pri = 10;
+    dev->IntHandler.is_Node.ln_Name = "Gallium3D INT Handler";
+    dev->IntHandler.is_Code = (VOID_FUNC)interrupt_handler;
+    dev->IntHandler.is_Data = dev;
+
+    OOP_GetAttr((OOP_Object *)dev->pdev->oopdev, aHidd_PCIDevice_INTLine, &INTLine);
+    DRM_DEBUG("INTLine: %d\n", INTLine);
+
+    AddIntServer(INTB_KERNEL + INTLine, &dev->IntHandler);
+
+    if (dev->driver->irq_postinstall)
+    {
+        retval = dev->driver->irq_postinstall(dev);
+        if (retval < 0)
+        {
+            ObtainSemaphore(&dev->struct_mutex.semaphore);
+            dev->irq_enabled = 0;
+            ReleaseSemaphore(&dev->struct_mutex.semaphore);            
+        }
+    }
+    
+    return retval;
+}
+#endif
 
+#if !defined(__AROS__)
 /**
  * Uninstall the IRQ handler.
  *
@@ -433,7 +495,34 @@
 	return 0;
 }
 EXPORT_SYMBOL(drm_irq_uninstall);
+#else
+int drm_irq_uninstall(struct drm_device *dev)
+{
+    int irq_enabled;
+    int retval = -EINVAL;
+    IPTR INTLine;
+
+    ObtainSemaphore(&dev->struct_mutex.semaphore);
+    irq_enabled = dev->irq_enabled;
+    dev->irq_enabled = 0;
+    ReleaseSemaphore(&dev->struct_mutex.semaphore);
+
+    if (!irq_enabled)
+        return retval;
+
+    if (dev->driver->irq_uninstall)
+        dev->driver->irq_uninstall(dev);
+
+    OOP_GetAttr((OOP_Object *)dev->pdev->oopdev, aHidd_PCIDevice_INTLine, &INTLine);
+    DRM_DEBUG("INTLine: %d\n", INTLine);
+
+    RemIntServer(INTB_KERNEL + INTLine, &dev->IntHandler);
+
+    return 0;
+}
+#endif
 
+#if !defined(__AROS__)
 /**
  * IRQ control ioctl.
  *
@@ -1349,3 +1438,4 @@
 	return true;
 }
 EXPORT_SYMBOL(drm_handle_vblank);
+#endif
diff -ur /data/deadwood/source/drm-orig/drm_memory.c drm/drm_memory.c
--- /data/deadwood/source/drm-orig/drm_memory.c	2011-02-13 19:09:47.000000000 +0100
+++ drm/drm_memory.c	2011-09-17 08:03:13.000000000 +0200
@@ -33,7 +33,9 @@
  * OTHER DEALINGS IN THE SOFTWARE.
  */
 
+#if !defined(__AROS__)
 #include <linux/highmem.h>
+#endif
 #include "drmP.h"
 
 /**
@@ -56,6 +58,7 @@
 }
 
 #if __OS_HAS_AGP
+#if !defined(__AROS__)
 static void *agp_remap(unsigned long offset, unsigned long size,
 		       struct drm_device * dev)
 {
@@ -98,6 +101,7 @@
 
 	return addr;
 }
+#endif
 
 /** Wrapper around agp_free_memory() */
 void drm_free_agp(DRM_AGP_MEM * handle, int pages)
@@ -106,11 +110,13 @@
 }
 EXPORT_SYMBOL(drm_free_agp);
 
+#if !defined(__AROS__)
 /** Wrapper around agp_bind_memory() */
 int drm_bind_agp(DRM_AGP_MEM * handle, unsigned int start)
 {
 	return agp_bind_memory(handle, start);
 }
+#endif
 
 /** Wrapper around agp_unbind_memory() */
 int drm_unbind_agp(DRM_AGP_MEM * handle)
@@ -119,6 +125,13 @@
 }
 EXPORT_SYMBOL(drm_unbind_agp);
 
+static inline void *agp_remap(unsigned long offset, unsigned long size,
+			      struct drm_device * dev)
+{
+    IMPLEMENT("\n");
+	return NULL;
+}
+
 #else  /*  __OS_HAS_AGP  */
 static inline void *agp_remap(unsigned long offset, unsigned long size,
 			      struct drm_device * dev)
diff -ur /data/deadwood/source/drm-orig/drm_mm.c drm/drm_mm.c
--- /data/deadwood/source/drm-orig/drm_mm.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_mm.c	2011-09-18 15:10:34.000000000 +0200
@@ -43,8 +43,12 @@
 
 #include "drmP.h"
 #include "drm_mm.h"
+#if !defined(__AROS__)
 #include <linux/slab.h>
 #include <linux/seq_file.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 #define MM_UNUSED_TARGET 4
 
@@ -714,3 +718,19 @@
 }
 EXPORT_SYMBOL(drm_mm_dump_table);
 #endif
+
+#if defined(__AROS__)
+int drm_mm_get_free_space_size(const struct drm_mm *mm)
+{
+	struct drm_mm_node *entry;
+	int total_free = 0;
+
+	list_for_each_entry(entry, &mm->hole_stack, hole_stack) {
+		BUG_ON(!entry->hole_follows);
+		total_free += drm_mm_hole_node_end(entry) - drm_mm_hole_node_start(entry);
+	}
+
+	return total_free;
+}
+EXPORT_SYMBOL(drm_mm_get_free_space);
+#endif
diff -ur /data/deadwood/source/drm-orig/drm_mm.h drm/drm_mm.h
--- /data/deadwood/source/drm-orig/drm_mm.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/drm_mm.h	2011-09-18 15:10:41.000000000 +0200
@@ -36,10 +36,15 @@
 /*
  * Generic range manager structs
  */
+#if !defined(__AROS__)
 #include <linux/list.h>
 #ifdef CONFIG_DEBUG_FS
 #include <linux/seq_file.h>
 #endif
+#else
+#include "drm_compat_types.h"
+#include "drm_linux_list.h"
+#endif
 
 struct drm_mm_node {
 	struct list_head node_list;
@@ -185,4 +190,8 @@
 int drm_mm_dump_table(struct seq_file *m, struct drm_mm *mm);
 #endif
 
+#if defined(__AROS__)
+int drm_mm_get_free_space_size(const struct drm_mm *mm);
+#endif
+
 #endif
diff -ur /data/deadwood/source/drm-orig/drm_modes.c drm/drm_modes.c
--- /data/deadwood/source/drm-orig/drm_modes.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/drm_modes.c	2011-09-17 08:03:13.000000000 +0200
@@ -30,8 +30,10 @@
  * authorization from the copyright holder(s) and author(s).
  */
 
+#if !defined(__AROS__)
 #include <linux/list.h>
 #include <linux/list_sort.h>
+#endif
 #include "drmP.h"
 #include "drm.h"
 #include "drm_crtc.h"
@@ -907,6 +909,7 @@
 	struct drm_display_mode *b = list_entry(lh_b, struct drm_display_mode, head);
 	int diff;
 
+#if !defined(__AROS__)
 	diff = ((b->type & DRM_MODE_TYPE_PREFERRED) != 0) -
 		((a->type & DRM_MODE_TYPE_PREFERRED) != 0);
 	if (diff)
@@ -914,6 +917,16 @@
 	diff = b->hdisplay * b->vdisplay - a->hdisplay * a->vdisplay;
 	if (diff)
 		return diff;
+#else
+	diff = b->hdisplay - a->hdisplay;
+	if (diff)
+		return diff;
+
+	diff = b->vdisplay - a->vdisplay;
+	if (diff)
+		return diff;
+#endif
+
 	diff = b->clock - a->clock;
 	return diff;
 }
@@ -975,6 +988,7 @@
 }
 EXPORT_SYMBOL(drm_mode_connector_list_update);
 
+#if !defined(__AROS__)
 /**
  * drm_mode_parse_command_line_for_connector - parse command line for connector
  * @mode_option - per connector mode option
@@ -1163,3 +1177,4 @@
 	return mode;
 }
 EXPORT_SYMBOL(drm_mode_create_from_cmdline_mode);
+#endif
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_bios.c drm/nouveau/nouveau_bios.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_bios.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_bios.c	2011-09-18 12:14:49.000000000 +0200
@@ -28,7 +28,9 @@
 #include "nouveau_hw.h"
 #include "nouveau_encoder.h"
 
+#if !defined(__AROS__)
 #include <linux/io-mapping.h>
+#endif
 
 /* these defines are made up */
 #define NV_CIO_CRE_44_HEADA 0x0
@@ -160,6 +162,7 @@
 
 static void load_vbios_pci(struct drm_device *dev, uint8_t *data)
 {
+#if !defined(__AROS__)
 	void __iomem *rom = NULL;
 	size_t rom_len;
 	int ret;
@@ -176,10 +179,14 @@
 
 out:
 	pci_disable_rom(dev->pdev);
+#else
+IMPLEMENT("\n");
+#endif
 }
 
 static void load_vbios_acpi(struct drm_device *dev, uint8_t *data)
 {
+#if !defined(__AROS__)
 	int i;
 	int ret;
 	int size = 64 * 1024;
@@ -195,6 +202,9 @@
 			break;
 	}
 	return;
+#else
+IMPLEMENT("\n");
+#endif
 }
 
 struct methods {
@@ -1452,17 +1462,24 @@
 	 * "mask n" and OR it with "data n" before writing it back to the device
 	 */
 
+#if !defined(__AROS__)
 	struct drm_device *dev = bios->dev;
 	uint8_t i2c_index = bios->data[offset + 1];
 	uint8_t i2c_address = bios->data[offset + 2] >> 1;
+#endif
 	uint8_t count = bios->data[offset + 3];
+#if !defined(__AROS__)
 	struct nouveau_i2c_chan *chan;
+#endif
 	int len = 4 + count * 3;
+#if !defined(__AROS__)
 	int ret, i;
+#endif
 
 	if (!iexec->execute)
 		return len;
 
+#if !defined(__AROS__)
 	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
 		      "Count: 0x%02X\n",
 		offset, i2c_index, i2c_address, count);
@@ -1506,6 +1523,10 @@
 	}
 
 	return len;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
 static int
@@ -1527,17 +1548,24 @@
 	 * "DCB I2C table entry index", set the register to "data n"
 	 */
 
+#if !defined(__AROS__)
 	struct drm_device *dev = bios->dev;
 	uint8_t i2c_index = bios->data[offset + 1];
 	uint8_t i2c_address = bios->data[offset + 2] >> 1;
+#endif
 	uint8_t count = bios->data[offset + 3];
+#if !defined(__AROS__)
 	struct nouveau_i2c_chan *chan;
+#endif
 	int len = 4 + count * 2;
+#if !defined(__AROS__)
 	int ret, i;
+#endif
 
 	if (!iexec->execute)
 		return len;
 
+#if !defined(__AROS__)
 	BIOSLOG(bios, "0x%04X: DCBI2CIndex: 0x%02X, I2CAddress: 0x%02X, "
 		      "Count: 0x%02X\n",
 		offset, i2c_index, i2c_address, count);
@@ -1570,6 +1598,10 @@
 	}
 
 	return len;
+#else
+IMPLEMENT("\n");
+return 0;
+#endif
 }
 
 static int
@@ -2037,6 +2069,7 @@
 static int
 init_i2c_if(struct nvbios *bios, uint16_t offset, struct init_exec *iexec)
 {
+#if !defined(__AROS__)
 	/*
 	 * INIT_I2C_IF   opcode: 0x5E ('^')
 	 *
@@ -2088,6 +2121,9 @@
 		offset, reg, val.byte, mask, data);
 
 	iexec->execute = ((val.byte & mask) == data);
+#else
+IMPLEMENT("\n");
+#endif
 
 	return 6;
 }
@@ -6918,11 +6954,16 @@
 	int ret;
 
 	if (!NVInitVBIOS(dev))
+#if !defined(MOCK_HARDWARE)
 		return -ENODEV;
 
 	ret = nouveau_parse_vbios_struct(dev);
 	if (ret)
 		return ret;
+#else
+	;
+	bios->major_version = 6;
+#endif
 
 	ret = parse_dcb_table(dev, bios);
 	if (ret)
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_bo_renamed.c drm/nouveau/nouveau_bo_renamed.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_bo_renamed.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_bo_renamed.c	2011-09-18 16:36:19.000000000 +0200
@@ -32,11 +32,13 @@
 #include "nouveau_drm.h"
 #include "nouveau_drv.h"
 #include "nouveau_dma.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 #include "nouveau_vm.h"
 
+#if !defined(__AROS__)
 #include <linux/log2.h>
 #include <linux/slab.h>
+#endif
 
 static void
 nouveau_bo_del_ttm(struct ttm_buffer_object *bo)
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_calc.c drm/nouveau/nouveau_calc.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_calc.c	2011-02-13 19:09:48.000000000 +0100
+++ drm/nouveau/nouveau_calc.c	2011-09-17 08:03:13.000000000 +0200
@@ -53,8 +53,8 @@
 static void
 nv04_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)
 {
-	int pagemiss, cas, width, bpp;
-	int nvclks, mclks, pclks, crtpagemiss;
+	int pagemiss, cas, bpp;
+	int nvclks, mclks, crtpagemiss;
 	int found, mclk_extra, mclk_loop, cbs, m1, p1;
 	int mclk_freq, pclk_freq, nvclk_freq;
 	int us_m, us_n, us_p, crtc_drain_rate;
@@ -65,11 +65,9 @@
 	nvclk_freq = arb->nvclk_khz;
 	pagemiss = arb->mem_page_miss;
 	cas = arb->mem_latency;
-	width = arb->memory_width >> 6;
 	bpp = arb->bpp;
 	cbs = 128;
 
-	pclks = 2;
 	nvclks = 10;
 	mclks = 13 + cas;
 	mclk_extra = 3;
@@ -211,7 +209,7 @@
 	    (dev->pci_device & 0xffff) == 0x01f0 /*CHIPSET_NFORCE2*/) {
 		uint32_t type;
 
-		pci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);
+		pci_read_config_dword(pci_get_bus_and_slot(0, PCI_DEVFN(0, 1)), 0x7c, &type);
 
 		sim_data.memory_type = (type >> 12) & 1;
 		sim_data.memory_width = 64;
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_connector.c drm/nouveau/nouveau_connector.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_connector.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_connector.c	2011-09-17 08:03:16.000000000 +0200
@@ -24,7 +24,9 @@
  *
  */
 
+#if !defined(__AROS__)
 #include <acpi/button.h>
+#endif
 
 #include "drmP.h"
 #include "drm_edid.h"
@@ -117,7 +119,9 @@
 	}
 
 	kfree(nv_connector->edid);
+#if !defined(__AROS__)
 	drm_sysfs_connector_remove(connector);
+#endif
 	drm_connector_cleanup(connector);
 	kfree(connector);
 }
@@ -296,6 +300,7 @@
 	if (!nv_encoder && !nouveau_tv_disable)
 		nv_encoder = find_encoder(connector, OUTPUT_TV);
 	if (nv_encoder && force) {
+#if !defined(MOCK_HARDWARE)
 		struct drm_encoder *encoder = to_drm_encoder(nv_encoder);
 		struct drm_encoder_helper_funcs *helper =
 						encoder->helper_private;
@@ -305,6 +310,10 @@
 			nouveau_connector_set_encoder(connector, nv_encoder);
 			return connector_status_connected;
 		}
+#else
+        nouveau_connector_set_encoder(connector, nv_encoder);
+        return connector_status_connected;
+#endif
 
 	}
 
@@ -892,7 +901,9 @@
 		connector->polled = DRM_CONNECTOR_POLL_CONNECT;
 	}
 
+#if !defined(__AROS__)
 	drm_sysfs_connector_add(connector);
+#endif
 
 	dcb->drm = connector;
 	return dcb->drm;
@@ -918,5 +929,8 @@
 	else
 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 
+#if !defined(__AROS__)
 	drm_helper_hpd_irq_event(dev);
+#endif
 }
+
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_display.c drm/nouveau/nouveau_display.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_display.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_display.c	2011-09-17 08:03:13.000000000 +0200
@@ -28,7 +28,9 @@
 #include "drm_crtc_helper.h"
 #include "nouveau_drv.h"
 #include "nouveau_fb.h"
+#if !defined(__AROS__)
 #include "nouveau_fbcon.h"
+#endif
 #include "nouveau_hw.h"
 #include "nouveau_crtc.h"
 #include "nouveau_dma.h"
@@ -147,6 +149,14 @@
 	return &nouveau_fb->base;
 }
 
+#if defined(__AROS__)
+void
+nouveau_fbcon_output_poll_changed(struct drm_device *dev)
+{
+    IMPLEMENT("\n");
+}
+#endif
+
 const struct drm_mode_config_funcs nouveau_mode_config_funcs = {
 	.fb_create = nouveau_user_framebuffer_create,
 	.output_poll_changed = nouveau_fbcon_output_poll_changed,
@@ -179,6 +189,7 @@
 		NVWriteCRTC(dev, crtc, NV_PCRTC_INTR_EN_0, 0);
 }
 
+#if !defined(__AROS__)
 static int
 nouveau_page_flip_reserve(struct nouveau_bo *old_bo,
 			  struct nouveau_bo *new_bo)
@@ -265,11 +276,13 @@
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 	return ret;
 }
+#endif
 
 int
 nouveau_crtc_page_flip(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 		       struct drm_pending_vblank_event *event)
 {
+#if !defined(__AROS__)
 	struct drm_device *dev = crtc->dev;
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_bo *old_bo = nouveau_framebuffer(crtc->fb)->nvbo;
@@ -329,8 +342,13 @@
 fail_free:
 	kfree(s);
 	return ret;
+#else
+    /* No-op under AROS */
+    return 0;
+#endif
 }
 
+#if !defined(__AROS__)
 int
 nouveau_finish_page_flip(struct nouveau_channel *chan,
 			 struct nouveau_page_flip_state *ps)
@@ -369,3 +387,4 @@
 	spin_unlock_irqrestore(&dev->event_lock, flags);
 	return 0;
 }
+#endif
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_dma.c drm/nouveau/nouveau_dma.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_dma.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_dma.c	2011-09-22 20:17:09.000000000 +0200
@@ -195,6 +195,7 @@
 	uint32_t cnt = 0, prev_get = 0;
 
 	while (chan->dma.ib_free < count) {
+#if !defined(MOCK_HARDWARE)
 		uint32_t get = nvchan_rd32(chan, 0x88);
 		if (get != prev_get) {
 			prev_get = get;
@@ -210,6 +211,11 @@
 		chan->dma.ib_free = get - chan->dma.ib_put;
 		if (chan->dma.ib_free <= 0)
 			chan->dma.ib_free += chan->dma.ib_max;
+#else
+		(void)cnt;(void)prev_get;
+		chan->dma.ib_put = 0;
+		chan->dma.ib_free = chan->dma.ib_max - chan->dma.ib_put;
+#endif
 	}
 
 	return 0;
@@ -226,6 +232,7 @@
 		return ret;
 
 	while (chan->dma.free < count) {
+#if !defined(MOCK_HARDWARE)
 		int get = READ_GET(chan, &prev_get, &cnt);
 		if (unlikely(get < 0)) {
 			if (get == -EINVAL)
@@ -253,6 +260,12 @@
 		}
 
 		chan->dma.free = get - chan->dma.cur - 1;
+#else
+		(void)cnt;(void)prev_get;
+		chan->dma.cur = 0;
+		chan->dma.put = 0;
+		chan->dma.free = chan->dma.max - chan->dma.cur - 1;
+#endif
 	}
 
 	return 0;
@@ -268,6 +281,7 @@
 		return nv50_dma_wait(chan, slots, size);
 
 	while (chan->dma.free < size) {
+#if !defined(MOCK_HARDWARE)
 		get = READ_GET(chan, &prev_get, &cnt);
 		if (unlikely(get == -EBUSY))
 			return -EBUSY;
@@ -336,6 +350,13 @@
 		 * here, so this is safe.
 		 */
 		chan->dma.free = get - chan->dma.cur - 1;
+#else
+		(void)get;(void)cnt;(void)prev_get;
+		chan->dma.cur  =
+		chan->dma.put  = NOUVEAU_DMA_SKIPS;
+
+		chan->dma.free = chan->dma.max - chan->dma.cur - 1;
+#endif
 	}
 
 	return 0;
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_dp.c drm/nouveau/nouveau_dp.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_dp.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_dp.c	2011-09-17 08:03:13.000000000 +0200
@@ -687,6 +687,7 @@
 	return auxch_tx(auxch->dev, auxch->rd, cmd, addr, data, data_nr);
 }
 
+#if !defined(__AROS__)
 static int
 nouveau_dp_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
@@ -734,3 +735,4 @@
 	.master_xfer = nouveau_dp_i2c_xfer,
 	.functionality = nouveau_dp_i2c_func
 };
+#endif
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_drv.h drm/nouveau/nouveau_drv.h
--- /data/deadwood/source/drm-orig/nouveau/nouveau_drv.h	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_drv.h	2011-09-18 12:09:51.000000000 +0200
@@ -39,10 +39,20 @@
 #define NOUVEAU_FAMILY   0x0000FFFF
 #define NOUVEAU_FLAGS    0xFFFF0000
 
+#if defined(__AROS__)
+struct drm_encoder;
+struct drm_minor;
+struct drm_connector;
+#include "drm_compat_types.h"
+#include "drm_compat_funcs.h"
+#endif
+
 #include "ttm/ttm_bo_api.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include "ttm/ttm_memory.h"
+#endif
 #include "ttm/ttm_module.h"
 
 struct nouveau_fpriv {
@@ -148,7 +158,7 @@
 	bool is_iomem;
 	void __iomem *ioptr = (void __force __iomem *)ttm_kmap_obj_virtual(
 						&nvbo->kmap, &is_iomem);
-	WARN_ON_ONCE(ioptr && !is_iomem);
+//FIXME:	WARN_ON_ONCE(ioptr && !is_iomem);
 	return ioptr;
 }
 
@@ -305,11 +315,11 @@
 		struct list_head flip;
 	} nvsw;
 
-	struct {
+/*FIXME:COMMENT	struct {
 		bool active;
 		char name[32];
 		struct drm_info_list info;
-	} debugfs;
+	} debugfs;*/
 };
 
 struct nouveau_exec_engine {
@@ -476,7 +486,7 @@
 
 #define NOUVEAU_PM_MAX_LEVEL 8
 struct nouveau_pm_level {
-	struct device_attribute dev_attr;
+//FIXME	struct device_attribute dev_attr;
 	char name[32];
 	int id;
 
@@ -541,7 +551,7 @@
 	struct nouveau_pm_level *cur;
 
 	struct device *hwmon;
-	struct notifier_block acpi_nb;
+//FIXME	struct notifier_block acpi_nb;
 
 	int (*clock_get)(struct drm_device *, u32 id);
 	void *(*clock_pre)(struct drm_device *, struct nouveau_pm_level *,
@@ -862,8 +872,10 @@
 extern int nouveau_msi;
 extern int nouveau_ctxfw;
 
+#if !defined(__AROS__)
 extern int nouveau_pci_suspend(struct pci_dev *pdev, pm_message_t pm_state);
 extern int nouveau_pci_resume(struct pci_dev *pdev);
+#endif
 
 /* nouveau_state.c */
 extern int  nouveau_open(struct drm_device *, struct drm_file *);
@@ -1058,7 +1070,7 @@
 #else
 static inline void nouveau_register_dsm_handler(void) {}
 static inline void nouveau_unregister_dsm_handler(void) {}
-static inline bool nouveau_acpi_rom_supported(struct pci_dev *pdev) { return false; }
+//FIXME static inline bool nouveau_acpi_rom_supported(struct pci_dev *pdev) { return false; }
 static inline int nouveau_acpi_get_bios_chunk(uint8_t *bios, int offset, int len) { return -EINVAL; }
 static inline int nouveau_acpi_edid(struct drm_device *dev, struct drm_connector *connector) { return -EINVAL; }
 #endif
@@ -1105,7 +1117,7 @@
 /* nouveau_ttm.c */
 int nouveau_ttm_global_init(struct drm_nouveau_private *);
 void nouveau_ttm_global_release(struct drm_nouveau_private *);
-int nouveau_ttm_mmap(struct file *, struct vm_area_struct *);
+//FIXME:TTM int nouveau_ttm_mmap(struct file *, struct vm_area_struct *);
 
 /* nouveau_dp.c */
 int nouveau_dp_auxch(struct nouveau_i2c_chan *auxch, int cmd, int addr,
@@ -1467,6 +1479,10 @@
 int nva3_calc_pll(struct drm_device *, struct pll_lims *,
 		  int clk, int *N, int *fN, int *M, int *P);
 
+/* nv50_gpio.c */
+int nv50_gpio_get(struct drm_device *dev, enum dcb_gpio_tag tag);
+int nv50_gpio_set(struct drm_device *dev, enum dcb_gpio_tag tag, int state);
+
 #ifndef ioread32_native
 #ifdef __BIG_ENDIAN
 #define ioread16_native ioread16be
@@ -1553,6 +1569,7 @@
  * Logging
  * Argument d is (struct drm_device *).
  */
+
 #define NV_PRINTK(level, d, fmt, arg...) \
 	printk(level "[" DRM_NAME "] " DRIVER_NAME " %s: " fmt, \
 					pci_name(d->pdev), ##arg)
@@ -1639,9 +1656,15 @@
 nv_match_device(struct drm_device *dev, unsigned device,
 		unsigned sub_vendor, unsigned sub_device)
 {
+#if !defined(__AROS__)
 	return dev->pdev->device == device &&
 		dev->pdev->subsystem_vendor == sub_vendor &&
 		dev->pdev->subsystem_device == sub_device;
+#else
+    return dev->driver->ProductID == device &&
+        dev->driver->SubSystemVendorID == sub_vendor &&
+        dev->driver->SubSystemProductID == sub_device;
+#endif
 }
 
 static inline void *
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_fence_renamed.c drm/nouveau/nouveau_fence_renamed.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_fence_renamed.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_fence_renamed.c	2011-09-22 19:03:27.000000000 +0200
@@ -27,8 +27,10 @@
 #include "drmP.h"
 #include "drm.h"
 
+#if !defined(__AROS__)
 #include <linux/ktime.h>
 #include <linux/hrtimer.h>
+#endif
 
 #include "nouveau_drv.h"
 #include "nouveau_ramht.h"
@@ -82,10 +84,16 @@
 
 	/* Fetch the last sequence if the channel is still up and running */
 	if (likely(!list_empty(&chan->fence.pending))) {
+#if defined(MOCK_HARDWARE)
+		/* For purpose of simulation, assume all fences are signalled */
+		(void)dev;
+		sequence = chan->fence.sequence;
+#else
 		if (USE_REFCNT(dev))
 			sequence = nvchan_rd32(chan, 0x48);
 		else
 			sequence = atomic_read(&chan->fence.last_sequence_irq);
+#endif
 
 		if (chan->fence.sequence_ack == sequence)
 			goto out;
@@ -231,6 +239,7 @@
 int
 __nouveau_fence_wait(void *sync_obj, void *sync_arg, bool lazy, bool intr)
 {
+#if !defined(__AROS__)
 	unsigned long timeout = jiffies + (3 * DRM_HZ);
 	unsigned long sleep_time = NSEC_PER_MSEC / 1000;
 	ktime_t t;
@@ -264,6 +273,26 @@
 	__set_current_state(TASK_RUNNING);
 
 	return ret;
+#else
+    int ret = 0;
+    LONG counter = 0;
+    while (1) 
+    {
+        if (__nouveau_fence_signalled(sync_obj, sync_arg))
+            break;
+        
+        udelay(100);
+        counter++;
+        if (counter > 10000)
+        {
+            NV_INFO(nouveau_fence(sync_obj)->channel->dev, "Waited too long!\n");
+            ret = -EBUSY;
+            break;
+        }
+            
+    }
+    return ret;
+#endif
 }
 
 static struct nouveau_semaphore *
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_hw.c drm/nouveau/nouveau_hw.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_hw.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_hw.c	2011-09-18 12:09:51.000000000 +0200
@@ -487,7 +487,7 @@
 	    (dev->pci_device & 0x0ff0) == CHIPSET_NFORCE) {
 		uint32_t mpllP;
 
-		pci_read_config_dword(pci_get_bus_and_slot(0, 3), 0x6c, &mpllP);
+		pci_read_config_dword(pci_get_bus_and_slot(0, PCI_DEVFN(0, 3)), 0x6c, &mpllP);
 		if (!mpllP)
 			mpllP = 4;
 
@@ -497,7 +497,7 @@
 	    (dev->pci_device & 0xff0) == CHIPSET_NFORCE2) {
 		uint32_t clock;
 
-		pci_read_config_dword(pci_get_bus_and_slot(0, 5), 0x4c, &clock);
+		pci_read_config_dword(pci_get_bus_and_slot(0, PCI_DEVFN(0, 5)), 0x4c, &clock);
 		return clock;
 	}
 
@@ -1019,10 +1019,12 @@
 
 	NVWriteCRTC(dev, head, NV_PCRTC_START, regp->fb_start);
 
+#if !defined(__AROS__)
 	/* Enable vblank interrupts. */
 	NVWriteCRTC(dev, head, NV_PCRTC_INTR_EN_0,
 		    (dev->vblank_enabled[head] ? 1 : 0));
 	NVWriteCRTC(dev, head, NV_PCRTC_INTR_0, NV_PCRTC_INTR_0_VBLANK);
+#endif
 }
 
 static void
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_i2c.c drm/nouveau/nouveau_i2c.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_i2c.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_i2c.c	2011-09-17 08:03:13.000000000 +0200
@@ -27,6 +27,22 @@
 #include "nouveau_i2c.h"
 #include "nouveau_hw.h"
 
+#if defined(__AROS__)
+#include <proto/oop.h>
+#include <oop/oop.h>
+
+/* FIXME: Duplicate defines here. Don't include nouveau_intern.h */
+/* Ugly hack actually */
+#define CLID_Hidd_I2C_Nouveau       "hidd.i2c.nouveau"
+#define IID_Hidd_I2C_Nouveau        "hidd.i2c.nouveau"
+
+#define HiddI2CNouveauAttrBase      __IHidd_I2C_Nouveau
+#define aoHidd_I2C_Nouveau_Chan     0
+#define aHidd_I2C_Nouveau_Chan      (HiddI2CNouveauAttrBase + aoHidd_I2C_Nouveau_Chan)
+
+OOP_AttrBase HiddI2CNouveauAttrBase = 0;
+#endif
+
 static void
 nv04_i2c_setscl(void *data, int state)
 {
@@ -227,22 +243,52 @@
 		return -EINVAL;
 	}
 
+#if !defined(__AROS__)
 	snprintf(i2c->adapter.name, sizeof(i2c->adapter.name),
 		 "nouveau-%s-%d", pci_name(dev->pdev), index);
 	i2c->adapter.owner = THIS_MODULE;
 	i2c->adapter.dev.parent = &dev->pdev->dev;
+#endif
 	i2c->dev = dev;
+#if !defined(__AROS__)
 	i2c_set_adapdata(&i2c->adapter, i2c);
+#endif
 
 	if (entry->port_type < 6) {
+#if !defined(__AROS__)
 		i2c->adapter.algo_data = &i2c->bit;
 		i2c->bit.udelay = 40;
 		i2c->bit.timeout = usecs_to_jiffies(5000);
 		i2c->bit.data = i2c;
 		ret = i2c_bit_add_bus(&i2c->adapter);
+#else
+        ret = 0;
+
+	    if (HiddI2CNouveauAttrBase == 0)
+	        HiddI2CNouveauAttrBase = OOP_ObtainAttrBase((STRPTR)IID_Hidd_I2C_Nouveau);
+
+        struct TagItem i2c_attrs[] = 
+        {
+            { aHidd_I2C_Nouveau_Chan,   (IPTR)i2c },
+            { TAG_DONE, 0UL }
+        };
+        
+        i2c->adapter.i2cdriver = (IPTR)OOP_NewObject(NULL, CLID_Hidd_I2C_Nouveau, i2c_attrs);
+        if (i2c->adapter.i2cdriver == (IPTR)0)
+        {
+            NV_ERROR(dev, "Failed to create CLID_Hidd_I2C_Nouveau object\n");
+            kfree(i2c);
+            return -EINVAL;
+        }
+#endif
 	} else {
+#if !defined(__AROS__)
 		i2c->adapter.algo = &nouveau_dp_i2c_algo;
 		ret = i2c_add_adapter(&i2c->adapter);
+#else
+        ret = -EINVAL;
+IMPLEMENT("Handling for (entry->port_type >= 6)\n");
+#endif
 	}
 
 	if (ret) {
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_i2c.h drm/nouveau/nouveau_i2c.h
--- /data/deadwood/source/drm-orig/nouveau/nouveau_i2c.h	2011-02-13 19:09:48.000000000 +0100
+++ drm/nouveau/nouveau_i2c.h	2011-09-12 20:46:05.000000000 +0200
@@ -23,8 +23,10 @@
 #ifndef __NOUVEAU_I2C_H__
 #define __NOUVEAU_I2C_H__
 
+#if !defined(__AROS__)
 #include <linux/i2c.h>
 #include <linux/i2c-algo-bit.h>
+#endif
 #include "drm_dp_helper.h"
 
 struct dcb_i2c_entry;
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_irq.c drm/nouveau/nouveau_irq.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_irq.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_irq.c	2011-09-17 08:03:13.000000000 +0200
@@ -104,14 +104,20 @@
 nouveau_irq_init(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
+#if !defined(__AROS__)
 	int ret;
+#endif
 
 	if (nouveau_msi != 0 && dev_priv->card_type >= NV_50) {
+#if !defined(__AROS__)
 		ret = pci_enable_msi(dev->pdev);
 		if (ret == 0) {
 			NV_INFO(dev, "enabled MSI\n");
 			dev_priv->msi_enabled = true;
 		}
+#else
+IMPLEMENT("Enabling MSI\n");
+#endif
 	}
 
 	return drm_irq_install(dev);
@@ -124,7 +130,11 @@
 
 	drm_irq_uninstall(dev);
 	if (dev_priv->msi_enabled)
+#if !defined(__AROS__)
 		pci_disable_msi(dev->pdev);
+#else
+IMPLEMENT("Disabling MSI\n");
+#endif
 }
 
 void
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_mem.c drm/nouveau/nouveau_mem.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_mem.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_mem.c	2011-09-19 22:57:21.000000000 +0200
@@ -36,9 +36,13 @@
 
 #include "nouveau_drv.h"
 #include "nouveau_pm.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 #include "nouveau_vm.h"
 
+#if defined(__AROS__)
+#define PCI_AGP_COMMAND_FW  0x0010
+#endif
+
 /*
  * NV10-NV40 tiling helpers
  */
@@ -393,6 +397,7 @@
 	int ret, dma_bits;
 
 	dma_bits = 32;
+#if !defined(__AROS__)
 	if (dev_priv->card_type >= NV_50) {
 		if (pci_dma_supported(dev->pdev, DMA_BIT_MASK(40)))
 			dma_bits = 40;
@@ -407,6 +412,7 @@
 	ret = pci_set_dma_mask(dev->pdev, DMA_BIT_MASK(dma_bits));
 	if (ret)
 		return ret;
+#endif
 
 	ret = nouveau_ttm_global_init(dev_priv);
 	if (ret)
@@ -811,12 +817,32 @@
 	       prefix, mm->block_size << 12);
 }
 
+#if defined(__AROS__)
+static int 
+nouveau_vram_manager_free_space(struct ttm_mem_type_manager *man)
+{
+	struct drm_nouveau_private *dev_priv = nouveau_bdev(man->bdev);
+	struct nouveau_mm *mm = &dev_priv->engine.vram.mm;
+	int size;
+
+	mutex_lock(&mm->mutex);
+	size = nouveau_mm_get_free_space_size(mm);
+	mutex_unlock(&mm->mutex);
+
+	return size;
+}
+#endif
+
 const struct ttm_mem_type_manager_func nouveau_vram_manager = {
 	nouveau_vram_manager_init,
 	nouveau_vram_manager_fini,
 	nouveau_vram_manager_new,
 	nouveau_vram_manager_del,
 	nouveau_vram_manager_debug
+#if defined(__AROS__)
+	,
+	nouveau_vram_manager_free_space
+#endif
 };
 
 static int
@@ -868,10 +894,22 @@
 {
 }
 
+#if defined(__AROS__)
+static int 
+nouveau_gart_manager_free_space(struct ttm_mem_type_manager *man)
+{
+    return 0;
+}
+#endif
+
 const struct ttm_mem_type_manager_func nouveau_gart_manager = {
 	nouveau_gart_manager_init,
 	nouveau_gart_manager_fini,
 	nouveau_gart_manager_new,
 	nouveau_gart_manager_del,
 	nouveau_gart_manager_debug
+#if defined(__AROS__)
+	,
+	nouveau_gart_manager_free_space
+#endif
 };
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_mm_renamed.c drm/nouveau/nouveau_mm_renamed.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_mm_renamed.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_mm_renamed.c	2011-09-19 22:58:04.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 static inline void
 region_put(struct nouveau_mm *mm, struct nouveau_mm_node *a)
@@ -173,3 +173,18 @@
 	kfree(heap);
 	return 0;
 }
+
+#if defined(__AROS__)
+int
+nouveau_mm_get_free_space_size(struct nouveau_mm *mm)
+{
+	struct nouveau_mm_node *this;
+	int size = 0;
+
+	list_for_each_entry(this, &mm->free, fl_entry) {
+		size += this->length;
+	}
+
+	return size;
+}
+#endif
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_mm_renamed.h drm/nouveau/nouveau_mm_renamed.h
--- /data/deadwood/source/drm-orig/nouveau/nouveau_mm_renamed.h	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_mm_renamed.h	2011-09-19 22:18:19.000000000 +0200
@@ -51,6 +51,9 @@
 int  nouveau_mm_get(struct nouveau_mm *, int type, u32 size, u32 size_nc,
 		    u32 align, struct nouveau_mm_node **);
 void nouveau_mm_put(struct nouveau_mm *, struct nouveau_mm_node *);
+#if defined(__AROS__)
+int  nouveau_mm_get_free_space_size(struct nouveau_mm *);
+#endif
 
 int  nv50_vram_init(struct drm_device *);
 void nv50_vram_fini(struct drm_device *);
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_sgdma.c drm/nouveau/nouveau_sgdma.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_sgdma.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_sgdma.c	2011-09-18 12:09:51.000000000 +0200
@@ -1,7 +1,9 @@
 #include "drmP.h"
 #include "nouveau_drv.h"
+#if !defined(__AROS__)
 #include <linux/pagemap.h>
 #include <linux/slab.h>
+#endif
 
 #define NV_CTXDMA_PAGE_SHIFT 12
 #define NV_CTXDMA_PAGE_SIZE  (1 << NV_CTXDMA_PAGE_SHIFT)
@@ -417,7 +419,11 @@
 	 * christmas.  The cards before it have them, the cards after
 	 * it have them, why is NV44 so unloved?
 	 */
+#if !defined(__AROS__)
 	dev_priv->gart_info.dummy.page = alloc_page(GFP_DMA32 | GFP_KERNEL);
+#else
+	dev_priv->gart_info.dummy.page = create_page_helper();
+#endif
 	if (!dev_priv->gart_info.dummy.page)
 		return -ENOMEM;
 
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_state.c drm/nouveau/nouveau_state.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_state.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_state.c	2011-09-24 10:31:41.000000000 +0200
@@ -23,18 +23,26 @@
  * DEALINGS IN THE SOFTWARE.
  */
 
+#if !defined(__AROS__)
 #include <linux/swab.h>
 #include <linux/slab.h>
+#endif
 #include "drmP.h"
 #include "drm.h"
 #include "drm_sarea.h"
 #include "drm_crtc_helper.h"
+#if !defined(__AROS__)
 #include <linux/vgaarb.h>
 #include <linux/vga_switcheroo.h>
+#endif
 
 #include "nouveau_drv.h"
 #include "nouveau_drm.h"
+#if !defined(__AROS__)
 #include "nouveau_fbcon.h"
+#else
+#include "nouveau_fb.h"
+#endif
 #include "nouveau_ramht.h"
 #include "nouveau_pm.h"
 #include "nv50_display.h"
@@ -500,6 +508,7 @@
 		return 1;
 	}
 
+#if !defined(__AROS__)
 	/* headless mode */
 	if (nouveau_modeset == 2) {
 		engine->display.early_init = nouveau_stub_init;
@@ -508,10 +517,12 @@
 		engine->display.init = nouveau_stub_init;
 		engine->display.destroy = nouveau_stub_takedown;
 	}
+#endif
 
 	return 0;
 }
 
+#if !defined(__AROS__)
 static unsigned int
 nouveau_vga_set_decode(void *priv, bool state)
 {
@@ -529,7 +540,9 @@
 	else
 		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 }
+#endif
 
+#if !defined(__AROS__)
 static void nouveau_switcheroo_set_state(struct pci_dev *pdev,
 					 enum vga_switcheroo_state state)
 {
@@ -566,6 +579,7 @@
 	spin_unlock(&dev->count_lock);
 	return can_switch;
 }
+#endif
 
 int
 nouveau_card_init(struct drm_device *dev)
@@ -574,10 +588,12 @@
 	struct nouveau_engine *engine;
 	int ret, e = 0;
 
+#if !defined(__AROS__)
 	vga_client_register(dev->pdev, dev, NULL, nouveau_vga_set_decode);
 	vga_switcheroo_register_client(dev->pdev, nouveau_switcheroo_set_state,
 				       nouveau_switcheroo_reprobe,
 				       nouveau_switcheroo_can_switch);
+#endif
 
 	/* Initialise internal driver API hooks */
 	ret = nouveau_init_engine_ptrs(dev);
@@ -599,7 +615,9 @@
 	if (ret)
 		goto out_display_early;
 
+#if !defined(__AROS__)
 	nouveau_pm_init(dev);
+#endif
 
 	ret = engine->vram.init(dev);
 	if (ret)
@@ -778,6 +796,7 @@
 		mutex_unlock(&dev_priv->channel->mutex);
 	}
 
+#if !defined(__AROS__)
 	if (dev->mode_config.num_crtc) {
 		ret = drm_vblank_init(dev, dev->mode_config.num_crtc);
 		if (ret)
@@ -786,11 +805,14 @@
 		nouveau_fbcon_init(dev);
 		drm_kms_helper_poll_init(dev);
 	}
+#endif
 
 	return 0;
 
+#if !defined(__AROS__)
 out_chan:
 	nouveau_channel_put_unlocked(&dev_priv->channel);
+#endif
 out_fence:
 	nouveau_fence_fini(dev);
 out_disp:
@@ -829,12 +851,16 @@
 out_vram:
 	engine->vram.takedown(dev);
 out_bios:
+#if !defined(__AROS__)
 	nouveau_pm_fini(dev);
+#endif
 	nouveau_bios_takedown(dev);
 out_display_early:
 	engine->display.late_takedown(dev);
 out:
+#if !defined(__AROS__)
 	vga_client_register(dev->pdev, NULL, NULL, NULL);
+#endif
 	return ret;
 }
 
@@ -844,11 +870,13 @@
 	struct nouveau_engine *engine = &dev_priv->engine;
 	int e;
 
+#if !defined(__AROS__)
 	if (dev->mode_config.num_crtc) {
 		drm_kms_helper_poll_fini(dev);
 		nouveau_fbcon_fini(dev);
 		drm_vblank_cleanup(dev);
 	}
+#endif
 
 	if (dev_priv->channel) {
 		nouveau_channel_put_unlocked(&dev_priv->channel);
@@ -892,10 +920,14 @@
 
 	nouveau_irq_fini(dev);
 
+#if !defined(__AROS__)
 	nouveau_pm_fini(dev);
+#endif
 	nouveau_bios_takedown(dev);
 
+#if !defined(__AROS__)
 	vga_client_register(dev->pdev, NULL, NULL, NULL);
+#endif
 }
 
 int
@@ -978,6 +1010,7 @@
 #endif
 }
 
+#if !defined(__AROS__)
 static struct apertures_struct *nouveau_get_apertures(struct drm_device *dev)
 {
 	struct pci_dev *pdev = dev->pdev;
@@ -1019,6 +1052,7 @@
 	remove_conflicting_framebuffers(dev_priv->apertures, "nouveaufb", primary);
 	return 0;
 }
+#endif
 
 int nouveau_load(struct drm_device *dev, unsigned long flags)
 {
@@ -1149,9 +1183,11 @@
 		}
 	}
 
+#if !defined(__AROS__)
 	ret = nouveau_remove_conflicting_drivers(dev);
 	if (ret)
 		goto err_mmio;
+#endif
 
 	/* Map PRAMIN BAR, or on older cards, the aperture within BAR0 */
 	if (dev_priv->card_type >= NV_40) {
@@ -1207,13 +1243,16 @@
 
 void nouveau_lastclose(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	vga_switcheroo_process_delayed_switch();
+#endif
 }
 
 int nouveau_unload(struct drm_device *dev)
 {
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 
+#if !defined(__AROS__)
 	nouveau_card_takedown(dev);
 
 	iounmap(dev_priv->mmio);
@@ -1221,6 +1260,18 @@
 
 	kfree(dev_priv);
 	dev->dev_private = NULL;
+#else
+	if (dev_priv)
+	{
+		nouveau_card_takedown(dev);
+
+		iounmap(dev_priv->mmio);
+		iounmap(dev_priv->ramin);
+
+		kfree(dev_priv);
+		dev->dev_private = NULL;
+	}
+#endif
 	return 0;
 }
 
@@ -1266,6 +1317,40 @@
 	case NOUVEAU_GETPARAM_HAS_PAGEFLIP:
 		getparam->value = dev_priv->card_type < NV_D0;
 		break;
+#if defined(__AROS__)
+    case NOUVEAU_GETPARAM_VRAM_SIZE:
+        {
+            struct ttm_mem_type_manager * man = &dev_priv->ttm.bdev.man[TTM_PL_VRAM];
+            getparam->value = 0;
+            if (man && man->func)
+                getparam->value = man->size * 4096;
+        }
+        break;
+    case NOUVEAU_GETPARAM_GART_SIZE:
+        {
+            struct ttm_mem_type_manager * man = &dev_priv->ttm.bdev.man[TTM_PL_TT];
+            getparam->value = 0;
+            if (man)
+                getparam->value = man->size * 4096;
+        }
+        break;
+    case NOUVEAU_GETPARAM_VRAM_FREE:
+        {
+            struct ttm_mem_type_manager * man = &dev_priv->ttm.bdev.man[TTM_PL_VRAM];
+            getparam->value = 0;
+            if (man && man->func)
+                getparam->value = man->func->get_free_space_size(man) * 4096;
+        }
+        break;
+    case NOUVEAU_GETPARAM_GART_FREE:
+        {
+            struct ttm_mem_type_manager * man = &dev_priv->ttm.bdev.man[TTM_PL_TT];
+            getparam->value = 0;
+            if (man && man->func)
+                getparam->value = man->func->get_free_space_size(man) * 4096;
+        }
+        break;
+#endif
 	case NOUVEAU_GETPARAM_GRAPH_UNITS:
 		/* NV40 and NV50 versions are quite different, but register
 		 * address is the same. User is supposed to know the card
@@ -1303,6 +1388,7 @@
 nouveau_wait_eq(struct drm_device *dev, uint64_t timeout,
 		uint32_t reg, uint32_t mask, uint32_t val)
 {
+#if !defined(MOCK_HARDWARE) /* Needed by NV50 and up */
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;
 	uint64_t start = ptimer->read(dev);
@@ -1313,6 +1399,9 @@
 	} while (ptimer->read(dev) - start < timeout);
 
 	return false;
+#else
+	return true;
+#endif
 }
 
 /* Wait until (value(reg) & mask) != val, up until timeout has hit */
@@ -1320,6 +1409,7 @@
 nouveau_wait_ne(struct drm_device *dev, uint64_t timeout,
 		uint32_t reg, uint32_t mask, uint32_t val)
 {
+#if !defined(MOCK_HARDWARE) /* Needed by NV50 and up */
 	struct drm_nouveau_private *dev_priv = dev->dev_private;
 	struct nouveau_timer_engine *ptimer = &dev_priv->engine.timer;
 	uint64_t start = ptimer->read(dev);
@@ -1330,6 +1420,9 @@
 	} while (ptimer->read(dev) - start < timeout);
 
 	return false;
+#else
+	return true;
+#endif
 }
 
 /* Wait until cond(data) == true, up until timeout has hit */
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_temp.c drm/nouveau/nouveau_temp.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_temp.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_temp.c	2011-09-17 08:03:13.000000000 +0200
@@ -261,6 +261,7 @@
 		temps->fan_boost = 40;
 }
 
+#if !defined(__AROS__)
 static bool
 probe_monitoring_device(struct nouveau_i2c_chan *i2c,
 			struct i2c_board_info *info)
@@ -300,6 +301,7 @@
 	nouveau_i2c_identify(dev, "monitoring device", info,
 			     probe_monitoring_device, idx);
 }
+#endif
 
 void
 nouveau_temp_init(struct drm_device *dev)
@@ -323,7 +325,11 @@
 		nouveau_temp_vbios_parse(dev, temp);
 	}
 
+#if !defined(__AROS__)
 	nouveau_temp_probe_i2c(dev);
+#else
+IMPLEMENT("Calling nouveau_temp_probe_i2c(dev);\n");
+#endif
 }
 
 void
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_ttm.c drm/nouveau/nouveau_ttm.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_ttm.c	2011-02-13 19:09:48.000000000 +0100
+++ drm/nouveau/nouveau_ttm.c	2011-09-12 20:46:05.000000000 +0200
@@ -28,6 +28,7 @@
 
 #include "nouveau_drv.h"
 
+#if !defined(__AROS__)
 int
 nouveau_ttm_mmap(struct file *filp, struct vm_area_struct *vma)
 {
@@ -40,19 +41,32 @@
 
 	return ttm_bo_mmap(filp, vma, &dev_priv->ttm.bdev);
 }
+#endif
 
 static int
 nouveau_ttm_mem_global_init(struct drm_global_reference *ref)
 {
+#if !defined(__AROS__)
 	return ttm_mem_global_init(ref->object);
+#else
+    return 0;
+#endif
 }
 
 static void
 nouveau_ttm_mem_global_release(struct drm_global_reference *ref)
 {
+#if !defined(__AROS__)
 	ttm_mem_global_release(ref->object);
+#endif
 }
 
+#if defined(__AROS__)
+struct ttm_mem_global
+{
+    ULONG dummy;
+};
+#endif
+
 int
 nouveau_ttm_global_init(struct drm_nouveau_private *dev_priv)
 {
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_util.c drm/nouveau/nouveau_util.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_util.c	2011-03-22 19:10:26.000000000 +0100
+++ drm/nouveau/nouveau_util.c	2011-09-12 20:46:05.000000000 +0200
@@ -25,11 +25,17 @@
  *
  */
 
+#if !defined(__AROS__)
 #include <linux/ratelimit.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 #include "nouveau_util.h"
 
+#if !defined(__AROS__)
 static DEFINE_RATELIMIT_STATE(nouveau_ratelimit_state, 3 * HZ, 20);
+#endif
 
 void
 nouveau_bitfield_print(const struct nouveau_bitfield *bf, u32 value)
@@ -74,5 +80,10 @@
 int
 nouveau_ratelimit(void)
 {
+#if !defined(__AROS__)
 	return __ratelimit(&nouveau_ratelimit_state);
+#else
+static unsigned int counter = 0;
+return !(counter++ % 50);
+#endif
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_vm.c drm/nouveau/nouveau_vm.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_vm.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_vm.c	2011-09-17 08:03:13.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 #include "nouveau_vm.h"
 
 void
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_vm.h drm/nouveau/nouveau_vm.h
--- /data/deadwood/source/drm-orig/nouveau/nouveau_vm.h	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_vm.h	2011-09-17 08:03:13.000000000 +0200
@@ -28,7 +28,7 @@
 #include "drmP.h"
 
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 struct nouveau_vm_pgt {
 	struct nouveau_gpuobj *obj[2];
diff -ur /data/deadwood/source/drm-orig/nouveau/nouveau_volt.c drm/nouveau/nouveau_volt.c
--- /data/deadwood/source/drm-orig/nouveau/nouveau_volt.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nouveau_volt.c	2011-09-17 08:03:13.000000000 +0200
@@ -101,6 +101,7 @@
 	return -ENOENT;
 }
 
+#if !defined(__AROS__)
 void
 nouveau_volt_init(struct drm_device *dev)
 {
@@ -237,6 +238,7 @@
 
 	voltage->supported = true;
 }
+#endif
 
 void
 nouveau_volt_fini(struct drm_device *dev)
diff -ur /data/deadwood/source/drm-orig/nouveau/nv04_crtc.c drm/nouveau/nv04_crtc.c
--- /data/deadwood/source/drm-orig/nouveau/nv04_crtc.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv04_crtc.c	2011-09-17 08:03:13.000000000 +0200
@@ -33,7 +33,9 @@
 #include "nouveau_fb.h"
 #include "nouveau_hw.h"
 #include "nvreg.h"
+#if !defined(__AROS__)
 #include "nouveau_fbcon.h"
+#endif
 
 static int
 nv04_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
@@ -675,7 +677,9 @@
 	if (nv_two_heads(dev))
 		NVSetOwner(dev, nv_crtc->index);
 
+#if !defined(__AROS__)
 	drm_vblank_pre_modeset(dev, nv_crtc->index);
+#endif
 	funcs->dpms(crtc, DRM_MODE_DPMS_OFF);
 
 	NVBlankScreen(dev, nv_crtc->index, true);
@@ -708,7 +712,9 @@
 #endif
 
 	funcs->dpms(crtc, DRM_MODE_DPMS_ON);
+#if !defined(__AROS__)
 	drm_vblank_post_modeset(dev, nv_crtc->index);
+#endif
 }
 
 static void nv_crtc_destroy(struct drm_crtc *crtc)
@@ -878,6 +884,7 @@
 			       struct drm_framebuffer *fb,
 			       int x, int y, enum mode_set_atomic state)
 {
+#if !defined(__AROS__)
 	struct drm_nouveau_private *dev_priv = crtc->dev->dev_private;
 	struct drm_device *dev = dev_priv->dev;
 
@@ -885,6 +892,7 @@
 		nouveau_fbcon_save_disable_accel(dev);
 	else
 		nouveau_fbcon_restore_accel(dev);
+#endif
 
 	return nv04_crtc_do_mode_set_base(crtc, fb, x, y, true);
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv04_dfp.c drm/nouveau/nv04_dfp.c
--- /data/deadwood/source/drm-orig/nouveau/nv04_dfp.c	2011-03-22 19:10:26.000000000 +0100
+++ drm/nouveau/nv04_dfp.c	2011-09-12 20:46:05.000000000 +0200
@@ -34,7 +34,9 @@
 #include "nouveau_hw.h"
 #include "nvreg.h"
 
+#if !defined(__AROS__)
 #include "i2c/sil164.h"
+#endif
 
 #define FP_TG_CONTROL_ON  (NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS |	\
 			   NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS |		\
@@ -614,6 +616,7 @@
 
 static void nv04_tmds_slave_init(struct drm_encoder *encoder)
 {
+#if !defined(__AROS__)
 	struct drm_device *dev = encoder->dev;
 	struct dcb_entry *dcb = nouveau_encoder(encoder)->dcb;
 	struct nouveau_i2c_chan *i2c = nouveau_i2c_find(dev, 2);
@@ -639,6 +642,9 @@
 
 	drm_i2c_encoder_init(dev, to_encoder_slave(encoder),
 			     &i2c->adapter, &info[type]);
+#else
+IMPLEMENT("\n");
+#endif
 }
 
 static const struct drm_encoder_helper_funcs nv04_lvds_helper_funcs = {
diff -ur /data/deadwood/source/drm-orig/nouveau/nv04_display.c drm/nouveau/nv04_display.c
--- /data/deadwood/source/drm-orig/nouveau/nv04_display.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv04_display.c	2011-09-17 08:03:13.000000000 +0200
@@ -247,12 +247,16 @@
 nv04_vblank_crtc0_isr(struct drm_device *dev)
 {
 	nv_wr32(dev, NV_CRTC0_INTSTAT, NV_CRTC_INTR_VBLANK);
+#if !defined(__AROS__)
 	drm_handle_vblank(dev, 0);
+#endif
 }
 
 static void
 nv04_vblank_crtc1_isr(struct drm_device *dev)
 {
 	nv_wr32(dev, NV_CRTC1_INTSTAT, NV_CRTC_INTR_VBLANK);
+#if !defined(__AROS__)
 	drm_handle_vblank(dev, 1);
+#endif
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv04_graph.c drm/nouveau/nv04_graph.c
--- /data/deadwood/source/drm-orig/nouveau/nv04_graph.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv04_graph.c	2011-09-17 08:03:13.000000000 +0200
@@ -562,12 +562,14 @@
 nv04_graph_mthd_page_flip(struct nouveau_channel *chan,
 			  u32 class, u32 mthd, u32 data)
 {
+#if !defined(__AROS__)
 	struct drm_device *dev = chan->dev;
 	struct nouveau_page_flip_state s;
 
 	if (!nouveau_finish_page_flip(chan, &s))
 		nv_set_crtc_base(dev, s.crtc,
 				 s.offset + s.y * s.pitch + s.x * s.bpp / 8);
+#endif
 
 	return 0;
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv04_tv.c drm/nouveau/nv04_tv.c
--- /data/deadwood/source/drm-orig/nouveau/nv04_tv.c	2011-02-13 19:09:48.000000000 +0100
+++ drm/nouveau/nv04_tv.c	2011-09-17 08:03:17.000000000 +0200
@@ -32,6 +32,7 @@
 #include "nouveau_hw.h"
 #include "drm_crtc_helper.h"
 
+#if !defined(__AROS__)
 #include "i2c/ch7006.h"
 
 static struct i2c_board_info nv04_tv_encoder_info[] = {
@@ -46,6 +47,12 @@
 	},
 	{ }
 };
+#else
+static struct i2c_board_info nv04_tv_encoder_info[] = {
+    { .type = "ch7006", .addr = 0x75 },
+	{ }
+};
+#endif
 
 int nv04_tv_identify(struct drm_device *dev, int i2c_index)
 {
@@ -61,6 +68,7 @@
 	(NV_PRAMDAC_PLL_COEFF_SELECT_TV_VSCLK2		\
 	 | NV_PRAMDAC_PLL_COEFF_SELECT_TV_PCLK2)
 
+#if !defined(__AROS__)
 static void nv04_tv_dpms(struct drm_encoder *encoder, int mode)
 {
 	struct drm_device *dev = encoder->dev;
@@ -179,10 +187,12 @@
 static const struct drm_encoder_funcs nv04_tv_funcs = {
 	.destroy = nv04_tv_destroy,
 };
+#endif
 
 int
 nv04_tv_create(struct drm_connector *connector, struct dcb_entry *entry)
 {
+#if !defined(__AROS__)
 	struct nouveau_encoder *nv_encoder;
 	struct drm_encoder *encoder;
 	struct drm_device *dev = connector->dev;
@@ -251,4 +261,8 @@
 fail_free:
 	kfree(nv_encoder);
 	return ret;
+#else
+    IMPLEMENT("\n");
+    return 0;
+#endif
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv31_mpeg.c drm/nouveau/nv31_mpeg.c
--- /data/deadwood/source/drm-orig/nouveau/nv31_mpeg.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv31_mpeg.c	2011-09-17 08:03:13.000000000 +0200
@@ -37,8 +37,8 @@
 {
 	struct nv31_mpeg_engine *pmpeg = nv_engine(chan->dev, engine);
 
-	if (!atomic_add_unless(&pmpeg->refcount, 1, 1))
-		return -EBUSY;
+//FIXME	if (!atomic_add_unless(&pmpeg->refcount, 1, 1))
+//FIXME		return -EBUSY;
 
 	chan->engctx[engine] = (void *)0xdeadcafe;
 	return 0;
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_crtc.c drm/nouveau/nv50_crtc.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_crtc.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_crtc.c	2011-09-19 21:55:53.000000000 +0200
@@ -467,8 +467,12 @@
 
 	start = ptimer->read(dev);
 	do {
+#if !defined(MOCK_HARDWARE)
 		if (nv_ro32(disp->ntfy, 0x000))
 			return 0;
+#else
+		return 0;
+#endif
 	} while (ptimer->read(dev) - start < 2000000000ULL);
 
 	return -EBUSY;
@@ -483,7 +487,9 @@
 	NV_DEBUG_KMS(dev, "index %d\n", nv_crtc->index);
 
 	nv50_display_flip_stop(crtc);
+#if !defined(__AROS__)
 	drm_vblank_pre_modeset(dev, nv_crtc->index);
+#endif
 	nv50_crtc_blank(nv_crtc, true);
 }
 
@@ -496,7 +502,9 @@
 	NV_DEBUG_KMS(dev, "index %d\n", nv_crtc->index);
 
 	nv50_crtc_blank(nv_crtc, false);
+#if !defined(__AROS__)
 	drm_vblank_post_modeset(dev, nv_crtc->index);
+#endif
 	nv50_crtc_wait_complete(crtc);
 	nv50_display_flip_next(crtc, crtc->fb, NULL);
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_display.c drm/nouveau/nv50_display.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_display.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_display.c	2011-09-17 08:03:13.000000000 +0200
@@ -30,7 +30,9 @@
 #include "nouveau_encoder.h"
 #include "nouveau_connector.h"
 #include "nouveau_fb.h"
+#if !defined(__AROS__)
 #include "nouveau_fbcon.h"
+#endif
 #include "nouveau_ramht.h"
 #include "drm_crtc_helper.h"
 
@@ -338,7 +340,9 @@
 		}
 	}
 
+#if !defined(__AROS__)
 	tasklet_init(&priv->tasklet, nv50_display_bh, (unsigned long)dev);
+#endif
 	nouveau_irq_register(dev, 26, nv50_display_isr);
 
 	ret = nv50_display_init(dev);
@@ -365,6 +369,7 @@
 void
 nv50_display_flip_stop(struct drm_crtc *crtc)
 {
+#if !defined(__AROS__)
 	struct nv50_display *disp = nv50_display(crtc->dev);
 	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
 	struct nv50_display_crtc *dispc = &disp->crtc[nv_crtc->index];
@@ -386,12 +391,16 @@
 	BEGIN_RING(evo, 0, 0x0080, 1);
 	OUT_RING  (evo, 0x00000000);
 	FIRE_RING (evo);
+#else
+    /* No-op under AROS */
+#endif
 }
 
 int
 nv50_display_flip_next(struct drm_crtc *crtc, struct drm_framebuffer *fb,
 		       struct nouveau_channel *chan)
 {
+#if !defined(__AROS__)
 	struct drm_nouveau_private *dev_priv = crtc->dev->dev_private;
 	struct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);
 	struct nv50_display *disp = nv50_display(crtc->dev);
@@ -486,6 +495,9 @@
 
 	dispc->sem.offset ^= 0x10;
 	dispc->sem.value++;
+#else
+    /* No-op under AROS */
+#endif
 	return 0;
 }
 
@@ -592,10 +604,14 @@
 		nouveau_bo_wr32(chan->notifier_bo, chan->nvsw.vblsem_offset,
 						chan->nvsw.vblsem_rval);
 		list_del(&chan->nvsw.vbl_wait);
+#if !defined(__AROS__)
 		drm_vblank_put(dev, crtc);
+#endif
 	}
 
+#if !defined(__AROS__)
 	drm_handle_vblank(dev, crtc);
+#endif
 }
 
 static void
@@ -930,7 +946,9 @@
 static void
 nv50_display_isr(struct drm_device *dev)
 {
+#if !defined(__AROS__)
 	struct nv50_display *disp = nv50_display(dev);
+#endif
 	uint32_t delayed = 0;
 
 	while (nv_rd32(dev, NV50_PMC_INTR_0) & NV50_PMC_INTR_0_DISPLAY) {
@@ -958,7 +976,12 @@
 				  NV50_PDISPLAY_INTR_1_CLK_UNK40));
 		if (clock) {
 			nv_wr32(dev, NV03_PMC_INTR_EN_0, 0);
+#if !defined(__AROS__)
 			tasklet_schedule(&disp->tasklet);
+#else
+            /* Kind of hackish call but it does its job. */
+            nv50_display_bh((unsigned long)dev);
+#endif
 			delayed |= clock;
 			intr1 &= ~clock;
 		}
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_display.h drm/nouveau/nv50_display.h
--- /data/deadwood/source/drm-orig/nouveau/nv50_display.h	2011-02-13 19:09:48.000000000 +0100
+++ drm/nouveau/nv50_display.h	2011-09-12 20:46:05.000000000 +0200
@@ -50,7 +50,9 @@
 
 	struct nv50_display_crtc crtc[2];
 
+#if !defined(__AROS__)
 	struct tasklet_struct tasklet;
+#endif
 	struct {
 		struct dcb_entry *dcb;
 		u16 script;
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_fb.c drm/nouveau/nv50_fb.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_fb.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_fb.c	2011-09-17 08:03:13.000000000 +0200
@@ -42,7 +42,11 @@
 		return -ENOMEM;
 	pfb->priv = priv;
 
+#if !defined(__AROS__)
 	priv->r100c08_page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+#else
+	priv->r100c08_page = create_page_helper();
+#endif
 	if (!priv->r100c08_page) {
 		nv50_fb_destroy(dev);
 		return -ENOMEM;
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_gpio.c drm/nouveau/nv50_gpio.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_gpio.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_gpio.c	2011-09-17 08:03:13.000000000 +0200
@@ -29,7 +29,12 @@
 #include "nv50_display.h"
 
 static void nv50_gpio_isr(struct drm_device *dev);
+#if !defined(__AROS__)
 static void nv50_gpio_isr_bh(struct work_struct *work);
+#else
+struct nv50_gpio_handler;
+static void nv50_gpio_isr_bh(struct nv50_gpio_handler *gpioh);
+#endif
 
 struct nv50_gpio_priv {
 	struct list_head handlers;
@@ -39,7 +44,9 @@
 struct nv50_gpio_handler {
 	struct drm_device *dev;
 	struct list_head head;
+#if !defined(__AROS__)
 	struct work_struct work;
+#endif
 	bool inhibit;
 
 	struct dcb_gpio_entry *gpio;
@@ -147,7 +154,9 @@
 	if (!gpioh)
 		return -ENOMEM;
 
+#if !defined(__AROS__)
 	INIT_WORK(&gpioh->work, nv50_gpio_isr_bh);
+#endif
 	gpioh->dev  = dev;
 	gpioh->gpio = gpio;
 	gpioh->handler = handler;
@@ -181,14 +190,18 @@
 		    gpioh->handler != handler ||
 		    gpioh->data != data)
 			continue;
+#if !defined(__AROS__)
 		list_move(&gpioh->head, &tofree);
+#endif
 	}
 	spin_unlock_irqrestore(&priv->lock, flags);
 
+#if !defined(__AROS__)
 	list_for_each_entry_safe(gpioh, tmp, &tofree, head) {
 		flush_work_sync(&gpioh->work);
 		kfree(gpioh);
 	}
+#endif
 }
 
 bool
@@ -274,11 +287,17 @@
 	nv50_gpio_destroy(dev);
 }
 
+#if !defined(__AROS__)
 static void
 nv50_gpio_isr_bh(struct work_struct *work)
 {
 	struct nv50_gpio_handler *gpioh =
 		container_of(work, struct nv50_gpio_handler, work);
+#else
+static void
+nv50_gpio_isr_bh(struct nv50_gpio_handler *gpioh)
+{
+#endif
 	struct drm_nouveau_private *dev_priv = gpioh->dev->dev_private;
 	struct nouveau_gpio_engine *pgpio = &dev_priv->engine.gpio;
 	struct nv50_gpio_priv *priv = pgpio->priv;
@@ -327,7 +346,12 @@
 			continue;
 		gpioh->inhibit = true;
 
+#if !defined(__AROS__)
 		schedule_work(&gpioh->work);
+#else
+        /* Kind of hackish call but it does its job. */
+        nv50_gpio_isr_bh(gpioh);
+#endif
 	}
 	spin_unlock(&priv->lock);
 }
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_graph.c drm/nouveau/nv50_graph.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_graph.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_graph.c	2011-09-17 08:03:13.000000000 +0200
@@ -386,7 +386,9 @@
 	if (!chan->nvsw.vblsem || chan->nvsw.vblsem_offset == ~0 || data > 1)
 		return -EINVAL;
 
+#if !defined(__AROS__)
 	drm_vblank_get(dev, data);
+#endif
 
 	chan->nvsw.vblsem_head = data;
 	list_add(&chan->nvsw.vbl_wait, &dev_priv->vbl_waiting);
@@ -398,7 +400,9 @@
 nv50_graph_nvsw_mthd_page_flip(struct nouveau_channel *chan,
 			       u32 class, u32 mthd, u32 data)
 {
+#if !defined(__AROS__)
 	nouveau_finish_page_flip(chan, NULL);
+#endif
 	return 0;
 }
 
diff -ur /data/deadwood/source/drm-orig/nouveau/nv50_vram.c drm/nouveau/nv50_vram.c
--- /data/deadwood/source/drm-orig/nouveau/nv50_vram.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nv50_vram.c	2013-09-28 19:35:37.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 static int types[0x80] = {
 	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
@@ -95,6 +95,15 @@
 	align >>= 12;
 	size_nc >>= 12;
 
+#ifdef __AROS__
+    /* Workaround which forces allocation to be contiguous in VRAM.
+       Without this some gfx cards cause display corruption, because
+       displaying of non contiguous bitmap does not work for whatever
+       reason. */
+       
+    if (size_nc < size) size_nc = size;
+#endif
+
 	mem = kzalloc(sizeof(*mem), GFP_KERNEL);
 	if (!mem)
 		return -ENOMEM;
diff -ur /data/deadwood/source/drm-orig/nouveau/nva3_copy.c drm/nouveau/nva3_copy.c
--- /data/deadwood/source/drm-orig/nouveau/nva3_copy.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nva3_copy.c	2011-09-17 08:03:13.000000000 +0200
@@ -22,7 +22,9 @@
  * Authors: Ben Skeggs
  */
 
+#if !defined(__AROS__)
 #include <linux/firmware.h>
+#endif
 #include "drmP.h"
 #include "nouveau_drv.h"
 #include "nouveau_util.h"
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_copy.c drm/nouveau/nvc0_copy.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_copy.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_copy.c	2011-09-17 08:03:13.000000000 +0200
@@ -22,7 +22,9 @@
  * Authors: Ben Skeggs
  */
 
+#if !defined(__AROS__)
 #include <linux/firmware.h>
+#endif
 #include "drmP.h"
 #include "nouveau_drv.h"
 #include "nouveau_util.h"
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_fb.c drm/nouveau/nvc0_fb.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_fb.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_fb.c	2011-09-17 08:03:13.000000000 +0200
@@ -87,7 +87,11 @@
 		return -ENOMEM;
 	pfb->priv = priv;
 
+#if !defined(__AROS__)
 	priv->r100c10_page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+#else
+	priv->r100c10_page = create_page_helper();
+#endif
 	if (!priv->r100c10_page) {
 		nvc0_fb_destroy(dev);
 		return -ENOMEM;
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_fifo.c drm/nouveau/nvc0_fifo.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_fifo.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_fifo.c	2011-09-18 12:09:35.000000000 +0200
@@ -25,7 +25,7 @@
 #include "drmP.h"
 
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 static void nvc0_fifo_isr(struct drm_device *);
 
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_graph.c drm/nouveau/nvc0_graph.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_graph.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_graph.c	2011-09-24 10:51:14.000000000 +0200
@@ -22,12 +22,14 @@
  * Authors: Ben Skeggs
  */
 
+#if !defined(__AROS__)
 #include <linux/firmware.h>
+#endif
 
 #include "drmP.h"
 
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 #include "nvc0_graph.h"
 #include "nvc0_grhub.fuc.h"
@@ -313,7 +315,9 @@
 nvc0_graph_mthd_page_flip(struct nouveau_channel *chan,
 			  u32 class, u32 mthd, u32 data)
 {
+#if !defined(__AROS__)
 	nouveau_finish_page_flip(chan, NULL);
+#endif
 	return 0;
 }
 
@@ -700,6 +704,7 @@
 	nv_wr32(dev, 0x400500, 0x00010001);
 }
 
+#if !defined(__AROS__)
 static int
 nvc0_graph_create_fw(struct drm_device *dev, const char *fwname,
 		     struct nvc0_graph_fuc *fuc)
@@ -734,18 +739,21 @@
 		fuc->data = NULL;
 	}
 }
+#endif
 
 static void
 nvc0_graph_destroy(struct drm_device *dev, int engine)
 {
 	struct nvc0_graph_priv *priv = nv_engine(dev, engine);
 
+#if !defined(__AROS__)
 	if (nouveau_ctxfw) {
 		nvc0_graph_destroy_fw(&priv->fuc409c);
 		nvc0_graph_destroy_fw(&priv->fuc409d);
 		nvc0_graph_destroy_fw(&priv->fuc41ac);
 		nvc0_graph_destroy_fw(&priv->fuc41ad);
 	}
+#endif
 
 	nouveau_irq_unregister(dev, 12);
 
@@ -787,6 +795,7 @@
 	NVOBJ_ENGINE_ADD(dev, GR, &priv->base);
 	nouveau_irq_register(dev, 12, nvc0_graph_isr);
 
+#if !defined(__AROS__)
 	if (nouveau_ctxfw) {
 		NV_INFO(dev, "PGRAPH: using external firmware\n");
 		if (nvc0_graph_create_fw(dev, "fuc409c", &priv->fuc409c) ||
@@ -797,6 +806,7 @@
 			goto error;
 		}
 	}
+#endif
 
 	ret = nouveau_gpuobj_new(dev, NULL, 0x1000, 256, 0, &priv->unk4188b4);
 	if (ret)
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_grctx.c drm/nouveau/nvc0_grctx.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_grctx.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_grctx.c	2011-09-17 08:03:13.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 #include "nvc0_graph.h"
 
 static void
diff -ur /data/deadwood/source/drm-orig/nouveau/nvc0_vram.c drm/nouveau/nvc0_vram.c
--- /data/deadwood/source/drm-orig/nouveau/nvc0_vram.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvc0_vram.c	2013-09-28 19:35:37.000000000 +0200
@@ -24,7 +24,7 @@
 
 #include "drmP.h"
 #include "nouveau_drv.h"
-#include "nouveau_mm.h"
+#include "nouveau_mm_renamed.h"
 
 /* 0 = unsupported
  * 1 = non-compressed
@@ -70,6 +70,14 @@
 	align >>= 12;
 	ncmin >>= 12;
 
+#ifdef __AROS__
+    /* Workaround which forces allocation to be contiguous in VRAM.
+       Without this some gfx cards cause display corruption, because
+       displaying of non contiguous bitmap does not work for whatever
+       reason. */
+
+    if (ncmin < size) ncmin = size;
+#endif
 	mem = kzalloc(sizeof(*mem), GFP_KERNEL);
 	if (!mem)
 		return -ENOMEM;
diff -ur /data/deadwood/source/drm-orig/nouveau/nvd0_display.c drm/nouveau/nvd0_display.c
--- /data/deadwood/source/drm-orig/nouveau/nvd0_display.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/nouveau/nvd0_display.c	2011-09-17 08:03:13.000000000 +0200
@@ -22,7 +22,9 @@
  * Authors: Ben Skeggs
  */
 
+#if !defined(__AROS__)
 #include <linux/dma-mapping.h>
+#endif
 
 #include "drmP.h"
 #include "drm_crtc_helper.h"
@@ -42,7 +44,7 @@
 		u32 *ptr;
 	} evo[1];
 
-	struct tasklet_struct tasklet;
+//FIXME	struct tasklet_struct tasklet;
 	u32 modeset;
 };
 
@@ -1182,7 +1184,7 @@
 
 		if (stat & 0x00000007) {
 			disp->modeset = stat;
-			tasklet_schedule(&disp->tasklet);
+//FIXME			tasklet_schedule(&disp->tasklet);
 
 			nv_wr32(dev, 0x6100ac, (stat & 0x00000007));
 			stat &= ~0x00000007;
@@ -1337,7 +1339,7 @@
 
 	nvd0_display_fini(dev);
 
-	pci_free_consistent(pdev, PAGE_SIZE, disp->evo[0].ptr, disp->evo[0].handle);
+//FIXME	pci_free_consistent(pdev, PAGE_SIZE, disp->evo[0].ptr, disp->evo[0].handle);
 	nouveau_gpuobj_ref(NULL, &disp->mem);
 	nouveau_irq_unregister(dev, 26);
 
@@ -1407,7 +1409,7 @@
 	}
 
 	/* setup interrupt handling */
-	tasklet_init(&disp->tasklet, nvd0_display_bh, (unsigned long)dev);
+//FIXME	tasklet_init(&disp->tasklet, nvd0_display_bh, (unsigned long)dev);
 	nouveau_irq_register(dev, 26, nvd0_display_intr);
 
 	/* hash table and dma objects for the memory areas we care about */
@@ -1454,6 +1456,7 @@
 
 	pinstmem->flush(dev);
 
+#if 0 //FIXME
 	/* push buffers for evo channels */
 	disp->evo[0].ptr =
 		pci_alloc_consistent(pdev, PAGE_SIZE, &disp->evo[0].handle);
@@ -1461,6 +1464,7 @@
 		ret = -ENOMEM;
 		goto out;
 	}
+#endif
 
 	ret = nvd0_display_init(dev);
 	if (ret)
diff -ur /data/deadwood/source/drm-orig/nouveau_drm.h drm/nouveau_drm.h
--- /data/deadwood/source/drm-orig/nouveau_drm.h	2011-02-25 17:58:10.000000000 +0100
+++ drm/nouveau_drm.h	2011-09-19 21:03:02.000000000 +0200
@@ -79,6 +79,12 @@
 #define NOUVEAU_GETPARAM_PTIMER_TIME     14
 #define NOUVEAU_GETPARAM_HAS_BO_USAGE    15
 #define NOUVEAU_GETPARAM_HAS_PAGEFLIP    16
+#if defined(__AROS__)
+#define NOUVEAU_GETPARAM_VRAM_SIZE       128
+#define NOUVEAU_GETPARAM_GART_SIZE       129
+#define NOUVEAU_GETPARAM_VRAM_FREE       130
+#define NOUVEAU_GETPARAM_GART_FREE       131
+#endif
 struct drm_nouveau_getparam {
 	uint64_t param;
 	uint64_t value;
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_agp_backend.c drm/ttm/ttm_agp_backend.c
--- /data/deadwood/source/drm-orig/ttm/ttm_agp_backend.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/ttm/ttm_agp_backend.c	2011-09-17 08:03:13.000000000 +0200
@@ -33,11 +33,15 @@
 #include "ttm/ttm_bo_driver.h"
 #ifdef TTM_HAS_AGP
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/agp_backend.h>
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <asm/agp.h>
+#else
+#include "drm_compat_funcs.h"
+#endif
 
 struct ttm_agp_backend {
 	struct ttm_backend backend;
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_bo_api.h drm/ttm/ttm_bo_api.h
--- /data/deadwood/source/drm-orig/ttm/ttm_bo_api.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/ttm/ttm_bo_api.h	2011-09-17 08:03:13.000000000 +0200
@@ -32,6 +32,7 @@
 #define _TTM_BO_API_H_
 
 #include "drm_hashtab.h"
+#if !defined(__AROS__)
 #include <linux/kref.h>
 #include <linux/list.h>
 #include <linux/wait.h>
@@ -39,6 +40,10 @@
 #include <linux/mm.h>
 #include <linux/rbtree.h>
 #include <linux/bitmap.h>
+#else
+#include "drm_linux_list.h"
+#include "drm_compat_funcs.h"
+#endif
 
 struct ttm_bo_device;
 
@@ -264,7 +269,9 @@
 	 * Members protected by the bdev::vm_lock
 	 */
 
+#if !defined(__AROS__)
 	struct rb_node vm_rb;
+#endif
 	struct drm_mm_node *vm_node;
 
 
@@ -662,6 +669,7 @@
 
 extern void ttm_bo_kunmap(struct ttm_bo_kmap_obj *map);
 
+#if !defined(__AROS__)
 /**
  * ttm_fbdev_mmap - mmap fbdev memory backed by a ttm buffer object.
  *
@@ -714,6 +722,7 @@
 extern ssize_t ttm_bo_io(struct ttm_bo_device *bdev, struct file *filp,
 			 const char __user *wbuf, char __user *rbuf,
 			 size_t count, loff_t *f_pos, bool write);
+#endif
 
 extern void ttm_bo_swapout_all(struct ttm_bo_device *bdev);
 
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_bo.c drm/ttm/ttm_bo.c
--- /data/deadwood/source/drm-orig/ttm/ttm_bo.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/ttm/ttm_bo.c	2011-09-22 19:14:46.000000000 +0200
@@ -31,6 +31,7 @@
 #include "ttm/ttm_module.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/jiffies.h>
 #include <linux/slab.h>
 #include <linux/sched.h>
@@ -38,12 +39,14 @@
 #include <linux/file.h>
 #include <linux/module.h>
 #include <linux/atomic.h>
+#endif
 
 #define TTM_ASSERT_LOCKED(param)
 #define TTM_DEBUG(fmt, arg...)
 #define TTM_BO_HASH_ORDER 13
 
 static int ttm_bo_setup_vm(struct ttm_buffer_object *bo);
+#if !defined(__AROS__)
 static int ttm_bo_swapout(struct ttm_mem_shrink *shrink);
 static void ttm_bo_global_kobj_release(struct kobject *kobj);
 
@@ -51,6 +54,7 @@
 	.name = "bo_count",
 	.mode = S_IRUGO
 };
+#endif
 
 static inline int ttm_mem_type_from_flags(uint32_t flags, uint32_t *mem_type)
 {
@@ -100,6 +104,7 @@
 	}
 }
 
+#if !defined(__AROS__)
 static ssize_t ttm_bo_global_show(struct kobject *kobj,
 				  struct attribute *attr,
 				  char *buffer)
@@ -125,6 +130,7 @@
 	.sysfs_ops = &ttm_bo_global_ops,
 	.default_attrs = ttm_bo_global_attrs
 };
+#endif
 
 
 static inline uint32_t ttm_bo_type_flags(unsigned type)
@@ -136,7 +142,9 @@
 {
 	struct ttm_buffer_object *bo =
 	    container_of(list_kref, struct ttm_buffer_object, list_kref);
+#if !defined(__AROS__)
 	struct ttm_bo_device *bdev = bo->bdev;
+#endif
 
 	BUG_ON(atomic_read(&bo->list_kref.refcount));
 	BUG_ON(atomic_read(&bo->kref.refcount));
@@ -152,7 +160,9 @@
 	if (bo->destroy)
 		bo->destroy(bo);
 	else {
+#if !defined(__AROS__)
 		ttm_mem_global_free(bdev->glob->mem_glob, bo->acc_size);
+#endif
 		kfree(bo);
 	}
 }
@@ -351,8 +361,12 @@
 			break;
 		}
 
+#if !defined(__AROS__)
 		ret = ttm_tt_set_user(bo->ttm, current,
 				      bo->buffer_start, bo->num_pages);
+#else
+IMPLEMENT("Calling ttm_tt_set_user\n");
+#endif
 		if (unlikely(ret != 0))
 			ttm_tt_destroy(bo->ttm);
 		break;
@@ -476,13 +490,19 @@
 
 	atomic_set(&bo->reserved, 0);
 
+#if !defined(__AROS__)
 	/*
 	 * Make processes trying to reserve really pick it up.
 	 */
 	smp_mb__after_atomic_dec();
+#endif
 	wake_up_all(&bo->event_queue);
 }
 
+#if defined(__AROS__)
+static int ttm_bo_delayed_delete(struct ttm_bo_device *bdev, bool remove_all);
+#endif
+
 static void ttm_bo_cleanup_refs_or_queue(struct ttm_buffer_object *bo)
 {
 	struct ttm_bo_device *bdev = bo->bdev;
@@ -536,8 +556,18 @@
 		driver->sync_obj_flush(sync_obj, sync_obj_arg);
 		driver->sync_obj_unref(&sync_obj);
 	}
+/* NOTE: this call is supposed to start a work process which in some
+   time will try clean up refs again (ttm_bo_delayed_delete). This is needed
+   if ttm_bo_wait "fails" - meaning the fence is not signalled in time
+   In AROS version, the function is called immediatelly. This is not compatible,
+   but seems to do the job. The other option is to force ttm_bo_wait to always 
+   wait until fence is signalled. */
+#if !defined(__AROS__)
 	schedule_delayed_work(&bdev->wq,
 			      ((HZ / 100) < 1) ? 1 : HZ / 100);
+#else
+    ttm_bo_delayed_delete(bdev, false);
+#endif
 }
 
 /**
@@ -654,6 +684,7 @@
 	return ret;
 }
 
+#if !defined(__AROS__)
 static void ttm_bo_delayed_workqueue(struct work_struct *work)
 {
 	struct ttm_bo_device *bdev =
@@ -664,6 +695,7 @@
 				      ((HZ / 100) < 1) ? 1 : HZ / 100);
 	}
 }
+#endif
 
 static void ttm_bo_release(struct kref *kref)
 {
@@ -673,7 +705,9 @@
 	struct ttm_mem_type_manager *man = &bdev->man[bo->mem.mem_type];
 
 	if (likely(bo->vm_node != NULL)) {
+#if !defined(__AROS__)        
 		rb_erase(&bo->vm_rb, &bdev->addr_space_rb);
+#endif
 		drm_mm_put_block(bo->vm_node);
 		bo->vm_node = NULL;
 	}
@@ -698,6 +732,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_unref);
 
+#if !defined(__AROS__)
 int ttm_bo_lock_delayed_workqueue(struct ttm_bo_device *bdev)
 {
 	return cancel_delayed_work_sync(&bdev->wq);
@@ -711,6 +746,7 @@
 				      ((HZ / 100) < 1) ? 1 : HZ / 100);
 }
 EXPORT_SYMBOL(ttm_bo_unlock_delayed_workqueue);
+#endif
 
 static int ttm_bo_evict(struct ttm_buffer_object *bo, bool interruptible,
 			bool no_wait_reserve, bool no_wait_gpu)
@@ -1244,6 +1280,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_init);
 
+#if !defined(__AROS__)
 static inline size_t ttm_bo_size(struct ttm_bo_global *glob,
 				 unsigned long num_pages)
 {
@@ -1288,6 +1325,7 @@
 
 	return ret;
 }
+#endif
 
 static int ttm_bo_force_list_clean(struct ttm_bo_device *bdev,
 					unsigned mem_type, bool allow_errors)
@@ -1349,6 +1387,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_clean_mm);
 
+#if !defined(__AROS__)
 int ttm_bo_evict_mm(struct ttm_bo_device *bdev, unsigned mem_type)
 {
 	struct ttm_mem_type_manager *man = &bdev->man[mem_type];
@@ -1370,6 +1409,7 @@
 	return ttm_bo_force_list_clean(bdev, mem_type, true);
 }
 EXPORT_SYMBOL(ttm_bo_evict_mm);
+#endif
 
 int ttm_bo_init_mm(struct ttm_bo_device *bdev, unsigned type,
 			unsigned long p_size)
@@ -1406,6 +1446,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_init_mm);
 
+#if !defined(__AROS__)
 static void ttm_bo_global_kobj_release(struct kobject *kobj)
 {
 	struct ttm_bo_global *glob =
@@ -1415,27 +1456,53 @@
 	__free_page(glob->dummy_read_page);
 	kfree(glob);
 }
+#endif
+
+#if defined(__AROS__)
+size_t ttm_round_pot(size_t size)
+{
+	if ((size & (size - 1)) == 0)
+		return size;
+	else if (size > PAGE_SIZE)
+		return (size_t)PAGE_ALIGN(size);
+	else {
+		size_t tmp_size = 4;
+
+		while (tmp_size < size)
+			tmp_size <<= 1;
+
+		return tmp_size;
+	}
+	return 0;
+}
+#endif
 
 void ttm_bo_global_release(struct drm_global_reference *ref)
 {
-	struct ttm_bo_global *glob = ref->object;
+//FIXME	struct ttm_bo_global *glob = ref->object;
 
-	kobject_del(&glob->kobj);
-	kobject_put(&glob->kobj);
+//FIXME	kobject_del(&glob->kobj);
+//FIXME	kobject_put(&glob->kobj);
 }
 EXPORT_SYMBOL(ttm_bo_global_release);
 
 int ttm_bo_global_init(struct drm_global_reference *ref)
 {
+#if !defined(__AROS__)
 	struct ttm_bo_global_ref *bo_ref =
 		container_of(ref, struct ttm_bo_global_ref, ref);
+#endif
 	struct ttm_bo_global *glob = ref->object;
-	int ret;
+	int ret = 0;
 
 	mutex_init(&glob->device_list_mutex);
 	spin_lock_init(&glob->lru_lock);
+#if !defined(__AROS__)
 	glob->mem_glob = bo_ref->mem_glob;
 	glob->dummy_read_page = alloc_page(__GFP_ZERO | GFP_DMA32);
+#else
+    glob->dummy_read_page = create_page_helper();
+#endif
 
 	if (unlikely(glob->dummy_read_page == NULL)) {
 		ret = -ENOMEM;
@@ -1445,6 +1512,7 @@
 	INIT_LIST_HEAD(&glob->swap_lru);
 	INIT_LIST_HEAD(&glob->device_list);
 
+#if !defined(__AROS__)
 	ttm_mem_init_shrink(&glob->shrink, ttm_bo_swapout);
 	ret = ttm_mem_register_shrink(glob->mem_glob, &glob->shrink);
 	if (unlikely(ret != 0)) {
@@ -1452,6 +1520,7 @@
 		       "Could not register buffer object swapout.\n");
 		goto out_no_shrink;
 	}
+#endif
 
 	glob->ttm_bo_extra_size =
 		ttm_round_pot(sizeof(struct ttm_tt)) +
@@ -1462,13 +1531,16 @@
 
 	atomic_set(&glob->bo_count, 0);
 
-	ret = kobject_init_and_add(
-		&glob->kobj, &ttm_bo_glob_kobj_type, ttm_get_kobj(), "buffer_objects");
-	if (unlikely(ret != 0))
-		kobject_put(&glob->kobj);
+//FIXME	ret = kobject_init_and_add(
+//FIXME		&glob->kobj, &ttm_bo_glob_kobj_type, ttm_get_kobj(), "buffer_objects");
+//FIXME	if (unlikely(ret != 0))
+//FIXME		kobject_put(&glob->kobj);
+
 	return ret;
+#if !defined(__AROS__)
 out_no_shrink:
 	__free_page(glob->dummy_read_page);
+#endif
 out_no_drp:
 	kfree(glob);
 	return ret;
@@ -1501,7 +1573,9 @@
 	list_del(&bdev->device_list);
 	mutex_unlock(&glob->device_list_mutex);
 
+#if !defined(__AROS__)
 	cancel_delayed_work_sync(&bdev->wq);
+#endif
 
 	while (ttm_bo_delayed_delete(bdev, true))
 		;
@@ -1544,12 +1618,16 @@
 	if (unlikely(ret != 0))
 		goto out_no_sys;
 
+#if !defined(__AROS__)
 	bdev->addr_space_rb = RB_ROOT;
+#endif
 	ret = drm_mm_init(&bdev->addr_space_mm, file_page_offset, 0x10000000);
 	if (unlikely(ret != 0))
 		goto out_no_addr_mm;
 
+#if !defined(__AROS__)
 	INIT_DELAYED_WORK(&bdev->wq, ttm_bo_delayed_workqueue);
+#endif
 	bdev->nice_mode = true;
 	INIT_LIST_HEAD(&bdev->ddestroy);
 	bdev->dev_mapping = NULL;
@@ -1592,6 +1670,7 @@
 
 void ttm_bo_unmap_virtual_locked(struct ttm_buffer_object *bo)
 {
+#if !defined(__AROS__)
 	struct ttm_bo_device *bdev = bo->bdev;
 	loff_t offset = (loff_t) bo->addr_space_offset;
 	loff_t holelen = ((loff_t) bo->mem.num_pages) << PAGE_SHIFT;
@@ -1599,6 +1678,9 @@
 	if (!bdev->dev_mapping)
 		return;
 	unmap_mapping_range(bdev->dev_mapping, offset, holelen, 1);
+#else
+    /* This is no-op under AROS */
+#endif
 	ttm_mem_io_free_vm(bo);
 }
 
@@ -1615,6 +1697,7 @@
 
 EXPORT_SYMBOL(ttm_bo_unmap_virtual);
 
+#if !defined(__AROS__)
 static void ttm_bo_vm_insert_rb(struct ttm_buffer_object *bo)
 {
 	struct ttm_bo_device *bdev = bo->bdev;
@@ -1639,6 +1722,7 @@
 	rb_link_node(&bo->vm_rb, parent, cur);
 	rb_insert_color(&bo->vm_rb, &bdev->addr_space_rb);
 }
+#endif
 
 /**
  * ttm_bo_setup_vm:
@@ -1678,7 +1762,9 @@
 		goto retry_pre_get;
 	}
 
+#if !defined(__AROS__)
 	ttm_bo_vm_insert_rb(bo);
+#endif
 	write_unlock(&bdev->vm_lock);
 	bo->addr_space_offset = ((uint64_t) bo->vm_node->start) << PAGE_SHIFT;
 
@@ -1775,6 +1861,7 @@
 }
 EXPORT_SYMBOL(ttm_bo_synccpu_write_release);
 
+#if !defined(__AROS__)
 /**
  * A buffer object shrink method that tries to swap out the first
  * buffer object on the bo_global::swap_lru list.
@@ -1884,3 +1971,4 @@
 		;
 }
 EXPORT_SYMBOL(ttm_bo_swapout_all);
+#endif
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_bo_driver.h drm/ttm/ttm_bo_driver.h
--- /data/deadwood/source/drm-orig/ttm/ttm_bo_driver.h	2011-09-08 21:08:06.000000000 +0200
+++ drm/ttm/ttm_bo_driver.h	2011-09-18 15:13:08.000000000 +0200
@@ -31,13 +31,19 @@
 #define _TTM_BO_DRIVER_H_
 
 #include "ttm/ttm_bo_api.h"
+#if !defined(__AROS__)
 #include "ttm/ttm_memory.h"
+#endif
 #include "ttm/ttm_module.h"
 #include "drm_mm.h"
 #include "drm_global.h"
+#if !defined(__AROS__)
 #include "linux/workqueue.h"
 #include "linux/fs.h"
 #include "linux/spinlock.h"
+#else
+#include "drm_compat_types.h"
+#endif
 
 struct ttm_backend;
 
@@ -121,8 +127,10 @@
 #define TTM_PAGE_FLAG_USER            (1 << 1)
 #define TTM_PAGE_FLAG_USER_DIRTY      (1 << 2)
 #define TTM_PAGE_FLAG_WRITE           (1 << 3)
+#if !defined(__AROS__)
 #define TTM_PAGE_FLAG_SWAPPED         (1 << 4)
 #define TTM_PAGE_FLAG_PERSISTENT_SWAP (1 << 5)
+#endif
 #define TTM_PAGE_FLAG_ZERO_ALLOC      (1 << 6)
 #define TTM_PAGE_FLAG_DMA32           (1 << 7)
 
@@ -164,12 +172,17 @@
 	long first_himem_page;
 	long last_lomem_page;
 	uint32_t page_flags;
+#if defined(__AROS__)
+    APTR allocated_buffer;
+#endif
 	unsigned long num_pages;
 	struct ttm_bo_global *glob;
 	struct ttm_backend *be;
 	struct task_struct *tsk;
 	unsigned long start;
+#if !defined(__AROS__)
 	struct file *swap_storage;
+#endif
 	enum ttm_caching_state caching_state;
 	enum {
 		tt_bound,
@@ -265,6 +278,10 @@
 	 * It may not be called from within atomic context.
 	 */
 	void (*debug)(struct ttm_mem_type_manager *man, const char *prefix);
+
+#if defined(__AROS__)
+	int (*get_free_space_size)(struct ttm_mem_type_manager *man);
+#endif
 };
 
 /**
@@ -493,10 +510,14 @@
 	 * Constant after init.
 	 */
 
-	struct kobject kobj;
+//FIXME	struct kobject kobj;
+#if !defined(__AROS__)
 	struct ttm_mem_global *mem_glob;
 	struct page *dummy_read_page;
 	struct ttm_mem_shrink shrink;
+#else
+    struct page *dummy_read_page;
+#endif
 	size_t ttm_bo_extra_size;
 	size_t ttm_bo_size;
 	struct mutex device_list_mutex;
@@ -557,7 +578,9 @@
 	/*
 	 * Protected by the vm lock.
 	 */
+#if !defined(__AROS__)
 	struct rb_root addr_space_rb;
+#endif
 	struct drm_mm addr_space_mm;
 
 	/*
@@ -577,7 +600,9 @@
 	 * Internal protection.
 	 */
 
+#if !defined(__AROS__)
 	struct delayed_work wq;
+#endif
 
 	bool need_dma32;
 };
@@ -1028,6 +1053,7 @@
 				     bool evict, bool no_wait_reserve,
 				     bool no_wait_gpu,
 				     struct ttm_mem_reg *new_mem);
+#if !defined(__AROS__)
 /**
  * ttm_io_prot
  *
@@ -1038,12 +1064,15 @@
  * setting up a PTE with the caching model indicated by @c_state.
  */
 extern pgprot_t ttm_io_prot(uint32_t caching_flags, pgprot_t tmp);
+#endif
 
 extern const struct ttm_mem_type_manager_func ttm_bo_manager_func;
 
-#if (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) && defined(MODULE)))
+#if (defined(CONFIG_AGP) || (defined(CONFIG_AGP_MODULE) && defined(MODULE)) || defined(__AROS__))
 #define TTM_HAS_AGP
+#if !defined(__AROS__)
 #include <linux/agp_backend.h>
+#endif
 
 /**
  * ttm_agp_backend_init
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_bo_manager.c drm/ttm/ttm_bo_manager.c
--- /data/deadwood/source/drm-orig/ttm/ttm_bo_manager.c	2011-02-13 19:09:48.000000000 +0100
+++ drm/ttm/ttm_bo_manager.c	2011-09-19 22:57:56.000000000 +0200
@@ -32,9 +32,11 @@
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
 #include "drm_mm.h"
+#if !defined(__AROS__)
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <linux/module.h>
+#endif
 
 /**
  * Currently we use a spinlock for the lock, but a mutex *may* be
@@ -147,11 +149,30 @@
 	spin_unlock(&rman->lock);
 }
 
+#if defined(__AROS__)
+static int ttm_bo_man_free_space(struct ttm_mem_type_manager *man)
+{
+	struct ttm_range_manager *rman = (struct ttm_range_manager *) man->priv;
+	struct drm_mm *mm = &rman->mm;
+	int size;
+
+	spin_lock(&rman->lock);
+	size = drm_mm_get_free_space_size(mm);
+	spin_unlock(&rman->lock);
+
+	return size;
+}
+#endif
+
 const struct ttm_mem_type_manager_func ttm_bo_manager_func = {
 	ttm_bo_man_init,
 	ttm_bo_man_takedown,
 	ttm_bo_man_get_node,
 	ttm_bo_man_put_node,
 	ttm_bo_man_debug
+#if defined(__AROS__)
+	,
+	ttm_bo_man_free_space
+#endif
 };
 EXPORT_SYMBOL(ttm_bo_manager_func);
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_bo_util.c drm/ttm/ttm_bo_util.c
--- /data/deadwood/source/drm-orig/ttm/ttm_bo_util.c	2011-02-13 19:09:48.000000000 +0100
+++ drm/ttm/ttm_bo_util.c	2011-09-23 19:58:46.000000000 +0200
@@ -30,12 +30,14 @@
 
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include <linux/io.h>
 #include <linux/highmem.h>
 #include <linux/wait.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/module.h>
+#endif
 
 void ttm_bo_free_old_node(struct ttm_buffer_object *bo)
 {
@@ -80,8 +82,10 @@
 	if (likely(man->io_reserve_fastpath))
 		return 0;
 
+#if !defined(__AROS__)
 	if (interruptible)
 		return mutex_lock_interruptible(&man->io_reserve_mutex);
+#endif
 
 	mutex_lock(&man->io_reserve_mutex);
 	return 0;
@@ -252,6 +256,7 @@
 
 	src = (void *)((unsigned long)src + (page << PAGE_SHIFT));
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	dst = kmap_atomic_prot(d, prot);
 #else
@@ -260,11 +265,15 @@
 	else
 		dst = kmap(d);
 #endif
+#else
+    dst = kmap(d);
+#endif
 	if (!dst)
 		return -ENOMEM;
 
 	memcpy_fromio(dst, src, PAGE_SIZE);
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	kunmap_atomic(dst);
 #else
@@ -273,6 +282,9 @@
 	else
 		kunmap(d);
 #endif
+#else
+    kunmap(d);
+#endif
 
 	return 0;
 }
@@ -288,6 +300,7 @@
 		return -ENOMEM;
 
 	dst = (void *)((unsigned long)dst + (page << PAGE_SHIFT));
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	src = kmap_atomic_prot(s, prot);
 #else
@@ -296,11 +309,15 @@
 	else
 		src = kmap(s);
 #endif
+#else
+    src = kmap(s);
+#endif
 	if (!src)
 		return -ENOMEM;
 
 	memcpy_toio(dst, src, PAGE_SIZE);
 
+#if !defined(__AROS__)
 #ifdef CONFIG_X86
 	kunmap_atomic(src);
 #else
@@ -309,6 +326,9 @@
 	else
 		kunmap(s);
 #endif
+#else
+    kunmap(s);
+#endif
 
 	return 0;
 }
@@ -354,13 +374,21 @@
 	for (i = 0; i < new_mem->num_pages; ++i) {
 		page = i * dir + add;
 		if (old_iomap == NULL) {
+#if !defined(__AROS__)
 			pgprot_t prot = ttm_io_prot(old_mem->placement,
 						    PAGE_KERNEL);
+#else
+            pgprot_t prot = 0;
+#endif
 			ret = ttm_copy_ttm_io_page(ttm, new_iomap, page,
 						   prot);
 		} else if (new_iomap == NULL) {
+#if !defined(__AROS__)
 			pgprot_t prot = ttm_io_prot(new_mem->placement,
 						    PAGE_KERNEL);
+#else
+            pgprot_t prot = 0;
+#endif
 			ret = ttm_copy_io_ttm_page(ttm, old_iomap, page,
 						   prot);
 		} else
@@ -444,6 +472,7 @@
 	return 0;
 }
 
+#if !defined(__AROS__)
 pgprot_t ttm_io_prot(uint32_t caching_flags, pgprot_t tmp)
 {
 #if defined(__i386__) || defined(__x86_64__)
@@ -472,6 +501,7 @@
 	return tmp;
 }
 EXPORT_SYMBOL(ttm_io_prot);
+#endif
 
 static int ttm_bo_ioremap(struct ttm_buffer_object *bo,
 			  unsigned long offset,
@@ -500,7 +530,10 @@
 			   unsigned long num_pages,
 			   struct ttm_bo_kmap_obj *map)
 {
-	struct ttm_mem_reg *mem = &bo->mem; pgprot_t prot;
+	struct ttm_mem_reg *mem = &bo->mem; 
+#if !defined(__AROS__)    
+    pgprot_t prot;
+#endif
 	struct ttm_tt *ttm = bo->ttm;
 	struct page *d;
 	int i;
@@ -529,9 +562,11 @@
 		 * We need to use vmap to get the desired page protection
 		 * or to make the buffer object look contiguous.
 		 */
+#if !defined(__AROS__)        
 		prot = (mem->placement & TTM_PL_FLAG_CACHED) ?
 			PAGE_KERNEL :
 			ttm_io_prot(mem->placement, PAGE_KERNEL);
+#endif
 		map->bo_kmap_type = ttm_bo_map_vmap;
 		map->virtual = vmap(ttm->pages + start_page, num_pages,
 				    0, prot);
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_module.h drm/ttm/ttm_module.h
--- /data/deadwood/source/drm-orig/ttm/ttm_module.h	2011-02-13 19:09:51.000000000 +0100
+++ drm/ttm/ttm_module.h	2011-09-12 20:46:05.000000000 +0200
@@ -31,8 +31,12 @@
 #ifndef _TTM_MODULE_H_
 #define _TTM_MODULE_H_
 
+#if !defined(__AROS__)
 #include <linux/kernel.h>
 struct kobject;
+#else
+#include "drm_compat_types.h"
+#endif
 
 #define TTM_PFX "[TTM] "
 extern struct kobject *ttm_get_kobj(void);
diff -ur /data/deadwood/source/drm-orig/ttm/ttm_tt.c drm/ttm/ttm_tt.c
--- /data/deadwood/source/drm-orig/ttm/ttm_tt.c	2011-09-08 21:07:54.000000000 +0200
+++ drm/ttm/ttm_tt.c	2011-09-23 18:33:43.000000000 +0200
@@ -28,6 +28,7 @@
  * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
  */
 
+#if !defined(__AROS__)
 #include <linux/sched.h>
 #include <linux/highmem.h>
 #include <linux/pagemap.h>
@@ -35,14 +36,19 @@
 #include <linux/file.h>
 #include <linux/swap.h>
 #include <linux/slab.h>
+#else
+#include "drm_compat_types.h"
+#endif
 #include "drm_cache.h"
 #include "drm_mem_util.h"
 #include "ttm/ttm_module.h"
 #include "ttm/ttm_bo_driver.h"
 #include "ttm/ttm_placement.h"
+#if !defined(__AROS__)
 #include "ttm/ttm_page_alloc.h"
 
 static int ttm_tt_swapin(struct ttm_tt *ttm);
+#endif
 
 /**
  * Allocates storage for pointers to the pages that back the ttm.
@@ -52,6 +58,9 @@
 	ttm->pages = drm_calloc_large(ttm->num_pages, sizeof(*ttm->pages));
 	ttm->dma_address = drm_calloc_large(ttm->num_pages,
 					    sizeof(*ttm->dma_address));
+#if defined(__AROS__)
+	ttm->allocated_buffer = HIDDNouveauAlloc((ttm->num_pages * PAGE_SIZE) + PAGE_SIZE - 1);
+#endif
 }
 
 static void ttm_tt_free_page_directory(struct ttm_tt *ttm)
@@ -60,6 +69,10 @@
 	ttm->pages = NULL;
 	drm_free_large(ttm->dma_address);
 	ttm->dma_address = NULL;
+#if defined(__AROS__)
+	HIDDNouveauFree(ttm->allocated_buffer);
+	ttm->allocated_buffer = NULL;
+#endif
 }
 
 static void ttm_tt_free_user_pages(struct ttm_tt *ttm)
@@ -87,11 +100,17 @@
 			continue;
 		}
 
+#if !defined(__AROS__)
 		if (write && dirty && !PageReserved(page))
 			set_page_dirty_lock(page);
+#else
+		(void)write; (void)dirty;
+#endif
 
 		ttm->pages[i] = NULL;
+#if !defined(__AROS__)
 		ttm_mem_global_free(ttm->glob->mem_glob, PAGE_SIZE);
+#endif
 		put_page(page);
 	}
 	ttm->state = tt_unpopulated;
@@ -101,6 +120,7 @@
 
 static struct page *__ttm_tt_get_page(struct ttm_tt *ttm, int index)
 {
+#if !defined(__AROS__)
 	struct page *p;
 	struct list_head h;
 	struct ttm_mem_global *mem_glob = ttm->glob->mem_glob;
@@ -131,10 +151,29 @@
 out_err:
 	put_page(p);
 	return NULL;
+#else
+	struct page *p;
+
+	while (NULL == (p = ttm->pages[index])) {
+        p = HIDDNouveauAlloc(sizeof(*p));
+        p->allocated_buffer = NULL;
+        p->address = (APTR)((IPTR)PAGE_ALIGN(ttm->allocated_buffer) + (IPTR)(PAGE_SIZE * index));
+
+		if (!p)
+			return NULL;
+
+		if (PageHighMem(p))
+			ttm->pages[--ttm->first_himem_page] = p;
+		else
+			ttm->pages[++ttm->last_lomem_page] = p;
+	}
+	return p;
+#endif
 }
 
 struct page *ttm_tt_get_page(struct ttm_tt *ttm, int index)
 {
+#if !defined(__AROS__)
 	int ret;
 
 	if (unlikely(ttm->page_flags & TTM_PAGE_FLAG_SWAPPED)) {
@@ -142,6 +181,7 @@
 		if (unlikely(ret != 0))
 			return NULL;
 	}
+#endif
 	return __ttm_tt_get_page(ttm, index);
 }
 
@@ -150,16 +190,20 @@
 	struct page *page;
 	unsigned long i;
 	struct ttm_backend *be;
+#if !defined(__AROS__)
 	int ret;
+#endif
 
 	if (ttm->state != tt_unpopulated)
 		return 0;
 
+#if !defined(__AROS__)
 	if (unlikely(ttm->page_flags & TTM_PAGE_FLAG_SWAPPED)) {
 		ret = ttm_tt_swapin(ttm);
 		if (unlikely(ret != 0))
 			return ret;
 	}
+#endif
 
 	be = ttm->be;
 
@@ -279,6 +323,7 @@
 
 static void ttm_tt_free_alloced_pages(struct ttm_tt *ttm)
 {
+#if !defined(__AROS__)
 	int i;
 	unsigned count = 0;
 	struct list_head h;
@@ -309,6 +354,25 @@
 	ttm->state = tt_unpopulated;
 	ttm->first_himem_page = ttm->num_pages;
 	ttm->last_lomem_page = -1;
+#else
+	int i;
+	struct page *cur_page;
+	struct ttm_backend *be = ttm->be;
+
+	if (be)
+		be->func->clear(be);
+	(void)ttm_tt_set_caching(ttm, tt_cached);
+	for (i = 0; i < ttm->num_pages; ++i) {
+		cur_page = ttm->pages[i];
+		ttm->pages[i] = NULL;
+		if (cur_page) {
+			__free_page(cur_page);
+		}
+	}
+	ttm->state = tt_unpopulated;
+	ttm->first_himem_page = ttm->num_pages;
+	ttm->last_lomem_page = -1;
+#endif
 }
 
 void ttm_tt_destroy(struct ttm_tt *ttm)
@@ -333,13 +397,16 @@
 		ttm_tt_free_page_directory(ttm);
 	}
 
+#if !defined(__AROS__)
 	if (!(ttm->page_flags & TTM_PAGE_FLAG_PERSISTENT_SWAP) &&
 	    ttm->swap_storage)
 		fput(ttm->swap_storage);
+#endif
 
 	kfree(ttm);
 }
 
+#if !defined(__AROS__)
 int ttm_tt_set_user(struct ttm_tt *ttm,
 		    struct task_struct *tsk,
 		    unsigned long start, unsigned long num_pages)
@@ -378,6 +445,7 @@
 
 	return 0;
 }
+#endif
 
 struct ttm_tt *ttm_tt_create(struct ttm_bo_device *bdev, unsigned long size,
 			     uint32_t page_flags, struct page *dummy_read_page)
@@ -458,6 +526,7 @@
 }
 EXPORT_SYMBOL(ttm_tt_bind);
 
+#if !defined(__AROS__)
 static int ttm_tt_swapin(struct ttm_tt *ttm)
 {
 	struct address_space *swap_space;
@@ -588,3 +657,4 @@
 
 	return ret;
 }
+#endif
