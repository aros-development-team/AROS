#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used as commands in the body    ##
## of a make rule.                                                         ##
## They are used to help the portability of mmakefile to different         ##
## platforms and also will handle the error handling in a standard way.    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt).
%define compile_q cmd=$(TARGET_CC) opt=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Compiling $(notdir %(from))"
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "%(from): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Compile failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd=$(AS) opt=$(AFLAGS) from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "$(notdir %(from)): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Assemble failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link a specified number of objects to an executable
%define link_q cmd=$(AROS_LD) opt=$(LDFLAGS) from=$< to=$@ libs=$(LIBS)
	@$(ECHO) "Linking %(to)..."
	@$(IF) %(cmd) %(opt) %(from) -o %(to) %(libs) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "%(to): %(cmd) %(opt) %(from) -o %(to) %(libs)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	   	else \
			$(NOP) ; \
    		fi ; \
	else \
	    $(ECHO) "Link failed: %(cmd) %(opt) %(from) -o %(to) %(libs)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi; \
	$(STRIP) %(to)
%end

#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building $(notdir $@) ..."
	@if $(AROS_LD) $(NOSTARTUP_LDFLAGS) %(ldflags) \
	    $(GENMAP) %(objdir)/%(module).map \
	    %(objs) %(libs) %(endtag) \
	    -o $@ 2>&1 > %(objdir)/%(err); \
	then \
	    cat %(objdir)/%(err); \
	else \
	    cat %(objdir)/%(err); \
	    exit 1; \
	fi

	@if $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(STRIP) $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags=$(CFLAGS) from=$< to=$@ cc=$(AROS_CC)
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	@AROS_CC="%(cc)" $(MKDEPEND) %(flags) %(from) -o %(to)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the function reference file %(to) to %(from)
%define mkref_q cc=$(AROS_CC) cppflags="-E -C -dD" cflags=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Generating ref for $(notdir %(from))..."
	@if $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to) 2>$(GENDIR)/cerrors; \
	then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
	        $(ECHO) "%(from): $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" >> $(GENDIR)/errors ; \
	        tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    fi ; \
	else \
	    $(ECHO) "Reference generation failed: $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    $(RM) %(to) ; \
	    exit 1 ; \
	fi
%end

#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used to do certain tasks in a   ##
## mmakefile. They consist of one or more full makefile rules.             ##
## In general the files generated in these macro's are also defined as     ##
## make targets so that they can be used as a dependency in other rules    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $(BD_REFFILES$(BDID)) >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# include when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

# Only add a rule for a directory for which there is no rule yet.

TOCREATE_TMP := $(filter-out $(CREATED_DIRS_GLOB),%(dirs))

ifdef TOCREATE_TMP
$(TOCREATE_TMP) :
	@$(ECHO) "Creating directory $@"
	%mkdir_q dir=$@

  ifdef CREATED_DIRS_GLOB
    CREATED_DIRS_GLOB += $(TOCREATE_TMP)
  else
    CREATED_DIRS_GLOB := $(TOCREATE_TMP)
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rule to generate a functable
#
%define rule_genfunctable name=functable files=/A dir=. libdefs=libdefs.h

%(dir)/%(name).c : $(addsuffix .c,%(files)) $(SCRIPTDIR)/genfunctable.awk %(libdefs)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
ifneq (%(files),)
	$(AWK) -v file=%(libdefs) -f $(SCRIPTDIR)/genfunctable.awk $(addsuffix .c,%(files)) > $@
else
	$(ARCHTOOL) -t
	$(MV) functable.c $@
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile basename=/A cflags=$(CFLAGS) dflags= targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).o : TMP_CMD:=$(TARGET_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).o : TMP_CMD:=$(HOST_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).o : %(basename).c
	%compile_q opt="%(cflags)" cmd=$(TMP_CMD)

ifeq (%(dflags),)
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(cflags)
else
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(dflags)
endif
$(TMP_TARGETBASE).d : %(basename).c
	%mkdepend_q cc=$(TMP_CMD) flags=$(TMP_DFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Make an alias from one arch specific build to another arch.
# arguments:
# - mainmmake: the mmake of the module in the main tree
# - arch: the current arch
# - alias: the alias to which this should point
%define rule_archalias mainmmake=\A arch=\A alias=\A

#MM- %(mainmmake)-%(arch) : %(mainmmake)-%(alias)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an shared object file with a
# .so suffix. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_shared basename=/A cflags=$(CFLAGS) targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).so : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).so : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)" cmd=$(TMP_CMD)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A flags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : %(basename).s
	%assemble_q opt=%(flags)

else
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q opt=%(flags)

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(objs) to %(prog) using the libraries in %(uselibs)
%define rule_link_prog prog=/A objs=/A ldflags=$(LDFLAGS) uselibs= \
    usehostlibs= usestartup=yes detach=no nix=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif
%(prog) : EXTRA_LDFLAGS:=$(TMP_EXTRA_LDFLAGS)

%(prog) : %(objs) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from="%(objs)" opt="%(ldflags) $(EXTRA_LDFLAGS)" \
	    libs="$(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(progs) from object in %(objdir) to executables in %(targetdir) using
# the AROS libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_link_progs progs=/A targetdir=$(AROSDIR)/$(CURDIR) \
    objdir=$(GENDIR)/$(CURDIR) ldflags=$(LDFLAGS) uselibs= usehostlibs= \
    usestartup=yes detach=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif
$(addprefix %(targetdir)/,%(progs)) : EXTRA_LDFLAGS:=$(TMP_EXTRA_LDFLAGS)

$(addprefix %(targetdir)/,%(progs)) : %(targetdir)/% : %(objdir)/%.o \
    $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from=$< opt="%(ldflags) $(EXTRA_LDFLAGS)" \
	    libs="$(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a in
%define rule_link_linklib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).so in
%define rule_link_shlib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).so : %(objs)
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A uselibs= usehostlibs=

%(module) : %(objs) %(endobj) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_module_q err="%(err)" endtag="%(endobj)" objs="%(objs)" \
		       libs="$(addprefix -l,%(uselibs)) -lautoinit -llibinit -L/usr/lib $(addprefix -l,%(usehostlibs))"

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file.
# - includefile: This file will be included at the head of the source file
%define rule_ref basename=/A cflags=$(CFLAGS) targetdir= includefile= compiler=target

ifeq (%(targetdir),)
GENFILE_TMP := %(basename).ref
else
GENFILE_TMP := %(targetdir)/$(notdir %(basename)).ref
endif

ifeq ($(filter %(compiler),target host),)
$(error use of %rule_ref: compiler has to be 'host' or 'target')
endif

ifeq (%(compiler),target)
$(GENFILE_TMP) : CC:=$(TARGET_CC)
else
$(GENFILE_TMP) : CC:=$(HOST_CC)
endif

$(GENFILE_TMP) : %(basename).c $(CXREF) %(includefile)
ifeq (%(includefile),)
	%mkref_q cc=$(CC) cflags="%(cflags)"
else
	%mkref_q cc=$(CC) cflags="%(cflags) -include %(includefile)"
endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genlibdefs modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/%(modname)_libdefs.h : %(conffile) $(GENLIBDEFS)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENLIBDEFS) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate dummy support files so cxref when used on the a module source file
# will find something to include.
%define rule_genmodule_dummy modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/clib/%(modname)_protos.h %(targetdir)/defines/%(modname).h \
%(targetdir)/proto/%(modname).h : %(conffile) $(GENMODULEDUMMY)
	@$(ECHO) "Generating $(notdir $@)"
	%mkdirs_q dirs="%(targetdir) %(targetdir)/clib %(targetdir)/defines %(targetdir)/proto"
	@$(GENMODULEDUMMY) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule modname=/A modtype=/A objdir=/A conffile=/A reffile=/A

GENFILES_TMP := %(objdir)/%(modname)_start.c %(objdir)/%(modname)_end.c

# Some of the generated files are dependent on the module type.
ifeq (%(modtype),library)
GENFILES_TMP += %(objdir)/%(modname)_autoinit.c %(objdir)/%(modname)_stubs.c \
                $(GENINCDIR)/clib/%(modname)_protos.h \
                $(GENINCDIR)/defines/%(modname).h \
                $(GENINCDIR)/proto/%(modname).h
endif

ifneq ($(findstring %(modtype),mcc mui mcp),)
GENFILES_TMP += %(objdir)/%(modname)_stubs.c \
                %(objdir)/%(modname)_mcc_query.c \
                %(objdir)/%(modname)_mcc_init.c
endif

$(GENFILES_TMP) : %(conffile) $(GENMODULE) %(reffile)
	@$(ECHO) "Generating functable and includes for module $(BD_MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) %(modname) %(modtype) %(conffile) %(objdir) $(GENINCDIR) %(reffile)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(TOP)/config/make.tail

BDID := $(BDTARGETID)
%end
#------------------------------------------------------------------------------
      

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile build macro's. These are macro's that takes care ##
## of everything to go from the sources to the generated target. Also all  ##
## intermediate files and directories that are needed are created by these ##
## rules.                                                                  ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Build an imported source tree which uses the configure script from the
# autoconf package.  This rule will try to "integrate" the produced files as
# much as possible in the AROS build, for exampley by putting libraries in the
# standard library directory, includes in the standard include directory, and
# so on. You can however override this behaviour.
#
# As a special "bonus" for you, the PROGDIR environment variable is defined to
# be %(bindir) (or its deduced value) when running "make install", and
# "PROGDIR:" when running "make" alone; you can use this feature to pass the
# configure script some more parameters whose value depends upon the PROGDIR
# env var, so that the program gets all its stuff installed in the proper place
# when building it, but when running it from inside AROS it can also find that
# stuff by simply opening PROGDIR:, which it will do automatically if it uses
# the configuration parameters set when running ./configure
#
# *NOTICE*: DO NOT put a trailing '/' (slash) after $PROGDIR, as the variable
# already contains either a '/' (slash) or a ':' (colon), thus simply attach it
# to the name which has to follow it.

%define build_with_configure mmake=/A srcdir=$(TOP)/$(CURDIR) prefix= \
    aros_prefix= bindir= libdir= includedir= extraoptions= nix=no host=no \
    install_target=install

ifeq (%(nix),yes)
    %(mmake)-nix := -nix
endif
ifneq (%(bindir),)
    %(mmake)-bindir := --bindir=%(bindir)
    %(mmake)-PROGDIR := %(bindir)
endif
ifneq (%(includedir),)
    %(mmake)-includedir := --includedir=%(includedir)
endif
ifneq (%(libdir),)
    %(mmake)-libdir := --libdir=%(libdir)
endif
ifneq (%(prefix),)
    %(mmake)-install_prefix      := prefix=%(prefix)
    %(mmake)-install_exec-prefix := exec_prefix=%(prefix)
else
    %(mmake)-install_prefix      := prefix=$(CONTRIBDIR)
    %(mmake)-install_exec-prefix := exec_prefix=$(CONTRIBDIR)
    
    ifeq ($(%(mmake)-bindir),)
        %(mmake)-bindir  := --bindir=$(CONTRIBDIR)
        %(mmake)-PROGDIR := $(CONTRIBDIR)
    endif
    ifeq ($(%(mmake)-libdir),)
        %(mmake)-libdir := --libdir=$(LIBDIR)
    endif
    ifeq ($(%(mmake)-includedir),)
        %(mmake)-includedir := --includedir=$(AROS_INCLUDES)
    endif
endif

ifneq (%(aros_prefix),)
    %(mmake)-compile_prefix := --prefix=%(aros_prefix)
else
    %(mmake)-compile_prefix := --$(%(mmake)-install_prefix)
endif

ifeq ($(%(mmake)-PROGDIR),)
    %(mmake)-PROGDIR := %(prefix)/bin
endif

.PHONY : %(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick

#MM- %(mmake) : setup includes linklibs-core %(mmake)-quick

ifneq (%(install_target),)
    %(mmake)-install_command := \
    if ! test -e $(GENDIR)/$(CURDIR)/.installed; then \
        $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_exec-prefix) \
        $(%(mmake)-install_prefix) -C $(GENDIR)/$(CURDIR) %(install_target); \
        $(TOUCH) $(GENDIR)/$(CURDIR)/.installed; \
    fi

    %(mmake)-uninstall_command := \
    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_exec-prefix) \
    $(%(mmake)-install_prefix) -C $(GENDIR)/$(CURDIR) uninstall; \
    $(RM) $(GENDIR)/$(CURDIR)/.installed
else
    %(mmake)-install_command   := $(TRUE)
    %(mmake)-uninstall_command := $(TRUE)
endif

#MM
%(mmake)-quick : $(GENDIR)/$(CURDIR)/.configured
	if ! $(MAKE) PROGDIR="PROGDIR:" -q -C $(GENDIR)/$(CURDIR); then \
            $(RM) $(GENDIR)/$(CURDIR)/.installed; \
	    $(MAKE) PROGDIR="PROGDIR:" -C $(GENDIR)/$(CURDIR); \
	    ret=$$?; \
	    if [ $$ret -ne 0 ]; then \
	        exit $$ret; \
	    fi; \
	fi; \
        $(%(mmake)-install_command)

$(TOP)/$(CURDIR)/.files-touched:
	find %(srcdir) -name \*.in -or -name \*.am -or -name \*.m4 -exec \
	    $(TOUCH) -r %(srcdir)/configure '{}' \; && $(TOUCH) $@

#MM
%(mmake)-uninstall :
	$(%(mmake)-uninstall_command)

ifneq ($(DEBUG),yes)
    %(mmake)-s_flag = -s
endif

ifeq (%(host),yes)
$(GENDIR)/$(CURDIR)/.configured : $(TOP)/$(CURDIR)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(HOST_CC)" \
	    %(srcdir)/configure $(%(mmake)-compile_prefix) $(%(mmake)-bindir) $(%(mmake)-libdir) \
	    $(%(mmake)-includedir) %(extraoptions) && \
	    $(TOUCH) $@
else
$(GENDIR)/$(CURDIR)/.configured : $(TOP)/$(CURDIR)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(TARGET_CC) -nix $(%(mmake)-s_flag)" CC_FOR_BUILD="$(HOST_CC)" \
	    %(srcdir)/configure $(%(mmake)-compile_prefix) $(%(mmake)-bindir) $(%(mmake)-libdir) \
	    $(%(mmake)-includedir) %(extraoptions) --host=$(AROS_TARGET_CPU)-aros \
	    --target=$(AROS_TARGET_CPU)-aros --build=local --disable-nls && \
	    $(TOUCH) $@
endif
	
#MM
%(mmake)-clean :
	-@if [ -e $(GENDIR)/$(CURDIR)/Makefile ]; then \
	    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" -C $(GENDIR)/$(CURDIR) uninstall; \
        fi
	@$(RM) $(GENDIR)/$(CURDIR)
%end

#------------------------------------------------------------------------------
# Build a program
%define build_prog mmake=/A progname=/A files=$(BD_PROGNAME$(BDID)) asmfiles= \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    aflags=$(AFLAFS) uselibs= usehostlibs= usestartup=yes detach=no nix=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_PROGNAME$(BDID)  := %(progname)
BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_ASMFILES$(BDID)  := %(asmfiles)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))

BD_CFLAGS$(BDID)    := %(cflags)
BD_AFLAGS$(BDID)    := %(aflags)
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))

%rule_link_prog prog=$(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID)) \
    objs=$(BD_OBJS$(BDID)) ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" nix="%(nix)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build programs, for every C file an executable will be built with the same
# 
%define build_progs mmake=/A files=/A \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    uselibs= usehostlibs= usestartup=yes detach=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_EXES$(BDID)      := $(addprefix $(BD_TARGETDIR$(BDID))/,$(BD_FILES$(BDID)))

BD_CFLAGS$(BDID)    := %(cflags)
ifneq ($(strip $(filter arosc_shared,%(uselibs))),)
BD_CFLAGS$(BDID)    += -D_CLIB_LIBRARY_ -I$(TOP)/rom/exec
endif
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_EXES$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))

%rule_link_progs progs=$(BD_FILES$(BDID)) \
    targetdir=$(BD_TARGETDIR$(BDID)) objdir=$(BD_OBJDIR$(BDID)) \
    ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A \
  conffile=$(BD_MODNAME$(BDID)).conf files="$(basename $(wildcard *.c))" \
  linklibfiles= cflags=$(CFLAGS) dflags= objdir=$(OBJDIR) prefix=$(AROSDIR)\
  reffile=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_ALL.ref noref= \
  linklibname=$(BD_MODNAME$(BDID)) uselibs= \
  compiler=target

%buildid targets="%(mmake) %(mmake)-includes %(mmake)-setup %(mmake)-clean %(mmake)-quick %(mmake)-kobj"

.PHONY : setup-module$(BDID) %(mmake) %(mmake)-includes %(mmake)-setup %(mmake)-clean %(mmake)-quick %(mmake)-kobj

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)
BD_PREFIX$(BDID)     := %(prefix)
BD_INCLUDE$(BDID)    := $(BD_PREFIX$(BDID))/$(AROS_DIR_INCLUDE)

BD_FILES$(BDID)      := %(files)
BD_LIBFILES$(BDID)   := %(linklibfiles)
BD_STARTFILE$(BDID)  := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end

BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)))))
BD_STARTOBJ$(BDID)   := $(addsuffix .o,$(BD_STARTFILE$(BDID)))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)) $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID)))

ifeq (%(noref),)
BD_REFFILES$(BDID)   := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .ref, $(notdir $(BD_FILES$(BDID)))))
else
BD_REFFILES$(BDID)   := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .ref, $(notdir $(filter-out %(noref),$(BD_FILES$(BDID))))))
endif
BD_REFFILE$(BDID)    := %(reffile)

ifeq ($(BD_MODTYPE$(BDID)),library)
BD_GENINCS$(BDID)    := clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
endif
BD_LIBDEFSINC$(BDID) := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_INCLUDE$(BDID)) -I$(BD_OBJDIR$(BDID)) -idirafter $(TOP)/$(CURDIR) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_INCLUDE$(BDID)) -I$(BD_OBJDIR$(BDID)) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library mcc mui mcp),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_MODDIR$(BDID)         := $(BD_PREFIX$(BDID))/$(AROS_DIR_LIBS)
  BD_LINKLIBFILES$(BDID)   := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.c 
  BD_LINKLIBOBJS$(BDID)    := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .o,$(BD_LIBFILES$(BDID)))) \
                              $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.o 
  BD_LINKLIBGENFILES$(BDID):= $(BD_PREFIX$(BDID))/$(AROS_DIR_LIB)/lib%(linklibname).a
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),mcc mui mcp),)
  BD_MODDIR$(BDID)       := $(BD_PREFIX$(BDID))/$(AROS_DIR_CLASSES)/Zune
  BD_OBJS$(BDID)         += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query.o \
                            $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init.o
  BD_LINKLIBGENFILES$(BDID):= 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),library mcc mcp),)
  BD_LINKLIBFILES$(BDID)   += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.c
  BD_LINKLIBOBJS$(BDID)    += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.o
  BD_LINKLIBDEPS$(BDID)    := $(patsubst %.o,%.d,$(BD_LINKLIBOBJS$(BDID))) 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID)) $(BD_LINKLIBGENFILES$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

# What are the files that need to be generated before the .d and .ref files
# can be generated ?
BD_REFFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_REFFILE_DEPS$(BDID) += $(addprefix $(BD_OBJDIR$(BDID))/dummyinc/,$(BD_GENINCS$(BDID)))
endif
BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_DFILE_DEPS$(BDID) += $(addprefix $(BD_INCLUDE$(BDID))/,$(BD_GENINCS$(BDID)))
endif

#MM- includes : %(mmake)-includes
#MM %(mmake) : %(mmake)-includes
#MM %(mmake)-kobj : %(mmake)-includes
#MM %(mmake)-includes : %(mmake)-setup includes-generate-deps

#MM
%(mmake)-quick : %(mmake)

#MM
%(mmake) : $(BD_GENFILES$(BDID))

#MM
%(mmake)-includes : $(addprefix $(BD_INCLUDE$(BDID))/,$(BD_GENINCS$(BDID)))

#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(BD_INCLUDE$(BDID))/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(addsuffix .c,$(BD_STARTFILE$(BDID)) $(BD_ENDFILE$(BDID))) \
	    $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_ref     basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags="-I$(dir $(GENMODULE))/genmod_inc -I$(BD_OBJDIR$(BDID))/dummyinc $(strip $(BD_CFLAGS$(BDID)))" \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end targetdir=$(BD_OBJDIR$(BDID)) \
 	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
endif

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Only for this target these deps are wanted
$(BD_REFFILES$(BDID)) : $(BD_REFFILE_DEPS$(BDID)) $(dir $(GENMODULE))/genmod_inc/aros/libcall.h
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
%rule_genmodule modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		objdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID)) \
		reffile=$(BD_REFFILE$(BDID))

%rule_genmodule_dummy modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		      targetdir=$(BD_OBJDIR$(BDID))/dummyinc conffile=$(BD_CONFFILE$(BDID))

%rule_genlibdefs modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		 targetdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID))

$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(BD_LIBDEFSINC$(BDID))\"" >$@

# The module ref file is the joint of all individual .ref files
%rule_join from=$(BD_REFFILES$(BDID)) to=$(BD_REFFILE$(BDID)) \
	   text="Collecting function references for module $(BD_MODNAME$(BDID))"

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_STARTOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)"

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_makedirs dirs="$(addprefix $(BD_INCLUDE$(BDID))/, clib defines pragmas proto)" setuptarget=setup-module$(BDID)
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(BD_INCLUDE$(BDID))/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(BD_INCLUDE$(BDID))/defines/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(BD_INCLUDE$(BDID))/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(BD_INCLUDE$(BDID))/proto/$(BD_MODNAME$(BDID)).h
endif

# For a shared library also build a static link lib
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_makedirs dirs=$(BD_PREFIX$(BDID))/$(AROS_DIR_LIB) setuptarget=setup-module$(BDID)
%rule_link_linklib libname=%(linklibname) objs=$(BD_LINKLIBOBJS$(BDID)) libdir=$(BD_PREFIX$(BDID))/$(AROS_DIR_LIB)
endif

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_OBJDIR$(BDID))/dummyinc/defines $(BD_OBJDIR$(BDID))/dummyinc/proto $(BD_OBJDIR$(BDID))/dummyinc/clib $(BD_MODDIR$(BDID)) $(KOBJSDIR)" \
	       setuptarget=setup-module$(BDID)

%(mmake)-kobj : $(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o

$(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o : \
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start.o \
$(BD_OBJS$(BDID)) \
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end.o
	@$(LD) -r -o $@ $^

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module using the deprecated macro's to define the functions in the
# library. Explanation of this macro is done in the developer's manual
%define build_module_macro mmake=/A modname=/A modtype=/A dir= \
  conffile=$(BD_MODNAME$(BDID)).conf initfile=$(BD_MODNAME$(BDID))_init \
  funcs= files= linklibfiles= cflags=$(CFLAGS) dflags= \
  objdir=$(OBJDIR) uselibs= usehostlibs= \
  genfunctable= genincludes= compiler=target

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-includes %(mmake)-linklib %(mmake)-quick %(mmake)-kobj"

.PHONY : setup-module$(BDID)

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_MODDIR$(BDID)     := %(dir)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_ARCHOBJS$(BDID)   := $(wildcard $(BD_OBJDIR$(BDID))/arch/*.o)
BD_ARCHFILES$(BDID)  := $(basename $(notdir $(BD_ARCHOBJS$(BDID))))

BD_INITFILE$(BDID)   := %(initfile)
BD_FUNCS$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(funcs))
BD_FILES$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(files))
BD_LIBFILES$(BDID)   := %(linklibfiles)
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end
else
BD_ENDFILE$(BDID)    := 
endif

BD_FUNCSRCS$(BDID)   := $(addsuffix .c,%(funcs))
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
ifeq ($(filter $(BD_INITFILE$(BDID)), $(BD_ARCHFILES$(BDID))),)
  BD_INITOBJ$(BDID)  := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_INITFILE$(BDID)))))
else
  TMP_INITREPLACE    := $(filter $(notdir $(BD_INITFILE$(BDID))), $(BD_ARCHFILES$(BDID)))
  TMP_INITKEEP       := $(filter-out $(TMP_INITREPLACE),$(notdir $(BD_INITFILE$(BDID))))
  BD_INITOBJ$(BDID)  := $(addsuffix .o, \
  		     	    $(addprefix $(BD_OBJDIR$(BDID))/arch/,$(TMP_INITREPLACE)) \
			    $(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_INITKEEP)) \
			 )
  BD_ARCHOBJS$(BDID) := $(filter-out $(BD_INITOBJ$(BDID)),$(BD_ARCHOBJS$(BDID)))
endif

TMP_FILES            := $(notdir $(BD_FILES$(BDID)))
ifeq (%(genfunctable),yes)
  TMP_FILES          := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifeq (%(genfunctable),)
      ifneq ($(BD_MODTYPE$(BDID)),resource)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    else
      ifneq (%(genfunctable),no)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    endif
    TMP_FILES        += $(BD_FUNCS$(BDID))
  endif
endif
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_FILES))) $(BD_ARCHOBJS$(BDID))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_INITFILE$(BDID)) $(TMP_FILES)))

BD_GENINCS$(BDID)    :=
ifneq (%(genincludes),)
  ifeq (%(genincludes),yes)
    BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
  endif
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifneq ($(findstring $(BD_MODTYPE$(BDID)),library gadget device),)
      BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
    endif
  endif
endif
# Only generate libdefs.h if the config file exists
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
  BD_LIBDEFSINC$(BDID):= $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h
else
  BD_LIBDEFSINC$(BDID):=
endif

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library gadget datatype handler device resource mui mcc mcp hidd),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODDIR$(BDID)),)
  ifeq ($(BD_MODTYPE$(BDID)),library)
    BD_MODDIR$(BDID)  := $(AROS_LIBS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),gadget)
    BD_MODDIR$(BDID)  := $(AROS_GADGETS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),datatype)
    BD_MODDIR$(BDID)  := $(AROS_DATATYPES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),handler)
    BD_MODDIR$(BDID)  := $(AROS_FS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),device)
    BD_MODDIR$(BDID)  := $(AROS_DEVS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),resource)
    BD_MODDIR$(BDID)  := $(AROS_RESOURCES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mui)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mcc)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mcp)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),hidd)
    BD_MODDIR$(BDID)  := $(AROS_DRIVERS)
  endif
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

#MM- includes : %(mmake)-includes
#MM %(mmake) : %(mmake)-includes %(mmake)-setup
#MM %(mmake)-includes : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_GENFILES$(BDID))

#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(BD_ENDFILE$(BDID)).c $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

#MM %(mmake)-includes : setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-includes : $(TMP_DEPS)
  
$(TMP_DEPS) : $(BD_LIBDEFSINC$(BDID))

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-linklib %(mmake)-quick %(mmake)-kobj),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FUNCS$(BDID)) $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_ENDFILE$(BDID)) targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_functable targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
endif

BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick %(mmake)-linklib) %(mmake)-kobj,) # Only for this target these deps are wanted
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(notdir $(BD_LIBDEFSINC$(BDID)))\"" >$@

%libdefs_rule conffile=$(BD_CONFFILE$(BDID)) dest=$(BD_LIBDEFSINC$(BDID))

ifneq ($(BD_ENDFILE$(BDID)),)
$(BD_ENDFILE$(BDID)).c :
	@$(ECHO) "generating $@"
	@$(ECHO) "#include <libcore/libtail.c>" >$@
endif

%rule_genfunctable name=$(BD_MODNAME$(BDID))_functable files=$(BD_FUNCS$(BDID)) dir=$(BD_OBJDIR$(BDID)) \
  libdefs=$(BD_LIBDEFSINC$(BDID))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)" \
		 usehostlibs="%(usehostlibs)"

BD_HEADER_DEPS$(BDID) := $(wildcard headers.tmpl) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_FUNCSRCS$(BDID)) \
	    $(SCRIPTDIR)/genshared \
	    $(SCRIPTDIR)/genclib.awk $(SCRIPTDIR)/genpclib.awk \
	    $(SCRIPTDIR)/gendefines.awk $(SCRIPTDIR)/genpdefines.awk

# Regenerate the includes when some of the dependencies are changed
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp : $(BD_HEADER_DEPS$(BDID))
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -defines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $@

# Generate includes the first time they are needed
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_private_protos.h \
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h \
$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h \
$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h :
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(AROS_INCLUDES)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/defines/$(BD_MODNAME$(BDID)).h
#%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/proto/$(BD_MODNAME$(BDID)).h

MYDIRS$(BDID) := $(BD_OBJDIR$(BDID)) $(GENINCDIR) $(GENINCDIR)/clib \
  $(GENINCDIR)/proto $(GENINCDIR)/defines \
  $(GENINCDIR)/pragmas $(AROS_INCLUDES) $(AROS_INCLUDES)/clib $(AROS_INCLUDES)/proto \
  $(AROS_INCLUDES)/defines $(AROS_INCLUDES)/pragmas \
  $(BD_MODDIR$(BDID)) $(KOBJSDIR)

%rule_makedirs dirs=$(MYDIRS$(BDID)) setuptarget=setup-module$(BDID)

#MM %(mmake)-linklib : %(mmake)-setup setup-clib
#MM %(mmake)-kobj : %(mmake)-setup setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
  $(BD_LIBDEFSINC$(BDID))
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-linklib : $(TMP_DEPS)
%(mmake)-kobj : $(TMP_DEPS)

# Link only when target %(mmake)-linklib otherwise for example jpeg.datatype
# that depend on the jpeg library can cause to get this rule executed unwanted
ifneq ($(filter $(TARGET),%(mmake)-linklib %(mmake)-kobj),)
%(mmake)-linklib : $(LIBDIR)/lib$(BD_MODNAME$(BDID)).a
%(mmake)-kobj : $(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o

%rule_link_linklib libname=$(BD_MODNAME$(BDID)) libdir=$(LIBDIR) \
  objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))"

$(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o : $(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))
	@$(LD) -r -o $@ $^

endif

%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-linklib %(mmake)-kobj" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given with the .s suffix
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags use during makedepend (default equal to cflags)
# - aflags are the flags use during assembling (default $(AFLAGS))
# - objdir is where the .o are generated
# - libdir is the directory where the linklib will be placed (default $(LIBDIR))
%define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c))" \
  asmfiles= cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) objdir=$(OBJDIR) libdir=$(LIBDIR)

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

# assign and generate the local variables used in this macro
BD_LIBNAME$(BDID)    := %(libname)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)
BD_LIBDIR$(BDID)     := %(libdir)

BD_FILES$(BDID)      := %(files)
BD_ASMFILES$(BDID)   := %(asmfiles)
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID)))))
BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)))

BD_CFLAGS$(BDID)     := %(cflags)
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags)
endif
BD_AFLAGS$(BDID)     := %(aflags)

BD_LINKLIB$(BDID)    := $(BD_LIBDIR$(BDID))/lib$(BD_LIBNAME$(BDID)).a

.PHONY : setup-linklib$(BDID)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_LINKLIB$(BDID))

#MM
%(mmake)-setup : setup-linklib$(BDID)

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID))

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_LIBDIR$(BDID))" \
	       setuptarget=setup-linklib$(BDID)

ifeq ($(TARGET),%(mmake))
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))
endif

%rule_link_linklib libname=%(libname) objs=$(BD_OBJS$(BDID)) libdir=$(BD_LIBDIR$(BDID))

%include_deps depstargets=%(mmake) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd) (default *.cd)
# - subdir is the destination subdir of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - source is the path to the generated source code file
# - dir is the base destination directory (default $(AROS_CATALOGS))
# - sourcedescription is the path to the FlexCat's source description file, without the .sd suffix

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs="$(basename $(wildcard *.ct))" source="../strings.h" \
 description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS) \
 sourcedescription="$(TOOLDIR)/C_h_orig"

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_SRCS$(BDID) := $(foreach name, %(catalogs), $(name).ct)
BD_OBJS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir)/%(name).catalog)
BD_DIRS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir))

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID)) %(source)

#MM %(mmake)-setup
%rule_makedirs dirs=$(BD_DIRS$(BDID)) setuptarget=%(mmake)-setup

%(dir)/%/%(subdir)/%(name).catalog : %.ct %(description).cd
	@$(ECHO) "Creating %(name) catalog for language $*."
	@$(IF) $(FLEXCAT) %(description).cd $*.ct CATALOG=%(dir)/$*/%(subdir)/%(name).catalog ; then $(NOP) ; else $(NOP) ; fi ;

ifneq (%(source),)
%(source) : %(description).cd
	@$(ECHO) "Creating %(name) catalog source file %(source)"
	@$(FLEXCAT) %(description).cd %(source)=%(sourcedescription).sd
endif

#MM
%(mmake)-clean ::
	$(RM) $(BD_OBJS$(BDID)) %(source)

.PHONY: %(mmake) %(mmake-setup) %(mmake-clean)

%end

#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Build icons.
# - mmake is the mmaketarget
# - icons is a list of icon base names (ie. without the .info suffix)
# - dir is the destination directory
#-----------------------------------------------------------------------------

%define build_icons mmake=/A icons=/A dir=/A

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_OBJS$(BDID) := $(foreach icon, %(icons), %(dir)/$(icon).info)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID))

%(dir)/%.info : %.info.src %.png
	@$(ECHO) Creating $(notdir $@)...
	@$(ILBMTOICON) $+ $@

#MM %(mmake)-setup
%rule_makedirs dirs=%(dir) setuptarget=%(mmake)-setup

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID))

.PHONY: %(mmake)

%end

#-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Compile files for a arch specific replacement of code for a module
# - files: the basename of the C files to compile.
# - asmfiles: the basename of the asm file to assemble.
# - mainmmake: the mmake of the module in the main directory to compile these
#   arch specific files for.
# - maindir: the object directory for the main module
# - arch: the arch for which to compile these files. It can has to have the form
#   of ARCH, CPU or ARCH-CPU, e.g. linux, i386 or linux-i386
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - aflags: the flags used during assembling
# - compiler: (host or target) specifies which compiler to use. By default
#   the target compiler is used
%define build_archspecific files= asmfiles= mainmmake=/A maindir=/A arch=/A \
cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) compiler=target

ifeq (%(files) %(asmfiles),)
  $(error no files or asmfiles given)
endif

%buildid targets="%(mainmmake)-%(arch) %(mainmmake)-%(arch)-setup"

#MM- %(mainmmake) : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-linklib : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)

#MM %(mainmmake)-%(arch) : %(mainmmake)-%(arch)-setup

ifeq (%(arch),)
  $(error argument arch has to be non empty for the rule_compile_archspecific macro)
endif

BD_OBJDIR$(BDID)  := $(GENDIR)/%(maindir)/arch
BD_COBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))
BD_ASMOBJS$(BDID) := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(asmfiles))))
BD_OBJS$(BDID)    := $(BD_COBJS$(BDID)) $(BD_ASMOBJS$(BDID))
BD_DEPS$(BDID)    := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))

ifeq ($(TARGET),%(mainmmake)-%(arch))
vpath %.c $(filter-out ./,$(dir %(files)))
vpath %.s $(filter-out ./,$(dir %(asmfiles)))
vpath %.S $(filter-out ./,$(dir %(asmfiles)))
endif

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

#MM
%(mainmmake)-%(arch) :: $(BD_OBJS$(BDID))

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(HOST_CC)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.c
	%compile_q opt=%(cflags) cmd=$(TMP_CMD)
endif

ifeq (%(dflags),)
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(cflags)
else
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(dflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.d : %.c
	%mkdepend_q flags=$(TMP_DFLAGS)
endif

$(BD_ASMOBJS$(BDID)) : AFLAGS:=%(aflags)

ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.s
	%assemble_q opt=$(AFLAGS)
$(BD_OBJDIR$(BDID))/%.o : %.S
	%assemble_q opt=$(AFLAGS)
endif

%include_deps depstargets=%(mainmmake)-%(arch) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------







# ======================
# Old stuff, will probably be removed in the future




# GNU Make automatic variables
# $@ current target
# $< First dependency
# $? All newer dependencies
# $^ All dependencies
# $* The stem (ie. target is dir/a.foo.b and the pattern is
#    a.%.b, then the stem is dir/foo)

#------------------------------------------------------------------------------
# rule to generate libdefs.h with archtool (options may go away!)
%define libdefs_rule conffile=lib.conf genlibdefstool=$(ARCHTOOL) dest=libdefs.h
%(dest) : %(conffile) %(genlibdefstool)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@%(genlibdefstool) -c -o $@ %(conffile)
%end


#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) -S $(CFLAGS) $< -c -o $@
%end

#------------------------------------------------------------------------------
# Convert two png images to an Amiga icon file based on the description
# file %(from), with outputfile going to %(to).
%define makeicon2 from=$< to=$@ img1="$(basename $(basename $<))_N.png" img2="$(basename $(basename $<))_S.png"
	@$(ECHO) "Creating icon %(to)..."
	@$(PNGTOPNM) %(img1) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon1.iff
	@$(PNGTOPNM) %(img2) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon2.iff
	@$(ILBMTOICON) %(from) $(GENDIR)/genicon1.iff $(GENDIR)/genicon2.iff %(to)
%end

#------------------------------------------------------------------------------
# NOTE: The following are all part of Iain's build changes, please don't use
# or change anything below this line until you know what you are doing. This
# is so that I don't conflict with the semantics of any of the above macros.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q files=$(FILES) src=. dst=/A maketarget=files-copy

SRC_FILES := $(foreach f, %(files), %(src)/$(f))
DST_FILES := $(foreach f, %(files), %(dst)/$(f))

%(maketarget) : setup $(DST_FILES)

$(DST_FILES) : %(dst)/% : %(src)/%
	@$(CP) $< $@
	
setup ::
	%mkdirs_q %(dst)

%end


#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake= includes=$(INCLUDE_FILES) path=. dir=include

ifneq (%(dir),)
INCL_FILES_1 := $(subst %(dir),$(AROS_INCLUDES)/%(path),%(includes))
INCL_FILES_2 := $(subst %(dir),$(GENINCDIR)/%(path),%(includes))
_INC_PATH := %(dir)/
else
INCL_FILES_1 := $(foreach f,%(includes),$(AROS_INCLUDES)/%(path)/$(f))
INCL_FILES_2 := $(foreach f,%(includes),$(GENINCDIR)/%(path)/$(f))
_INC_PATH :=
endif

ifneq (%(mmake),)
#MM 
includes-copy : %(mmake)

#MM
%(mmake) : %(mmake)-includes-setup $(INCL_FILES_1) $(INCL_FILES_2)

.PHONY: %(mmake)

else
#MM
includes-copy : includes-setup $(INCL_FILES_1) $(INCL_FILES_2)
endif


$(AROS_INCLUDES)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

$(GENINCDIR)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

ifneq (%(mmake),)
%(mmake)-includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)

.PHONY: %(mmake)-includes-setup
else
includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)
endif

$(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path) :
	%mkdir_q dir=$@

,PHONY: includes-copy includes-setup

%end

%define make_hidd_stubs hidd=/A cflags=$(CFLAGS) dflags=$(CFLAGS) parenttarget=linklibs
STUBS_SRC := $(foreach f,$(STUBS),$(f).c)
STUBS_OBJ := $(foreach f,$(STUBS),$(OBJDIR)/$(f).o)
STUBS_MEM := $(foreach f,$(STUBS),$(f).o)
STUBS_DEP := $(foreach f,$(STUBS),$(OBJDIR)/$(f).d)
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs : hidd-%(hidd)-stubs
#MM- %(parenttarget): hidd-%(hidd)-stubs
#MM hidd-%(hidd)-stubs : includes includes-copy
hidd-%(hidd)-stubs : setup $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC) 
	%compile_q cmd=$(TARGET_CC) opt=%(cflags)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags=%(dflags)

setup ::
	%mkdirs_q $(OBJDIR) $(LIBDIR)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end
      
#############################################################################
#############################################################################
##                                                                         ##
## Misciellanous macros. Everying that doesn't fin above should be put     ##
## here.                                                                   ##
##                                                                         ##
#############################################################################
#############################################################################

#----------------------------------------------------------------------------------
# Given an archive name, patches names and locations where to find them, fetch
# the archive and the patches from any of those locations, unpack the archive
# and then apply the patches.
#
# Locations currently supported are http and ftp sites, plus local filesystem
# directories. Supported archives are .tar.bz2 and .tar.gz. To modify this,
# the fetch.sh script needs to be modified, since this macro relies on that script.
#
# Arguments:
#
#     - archive_origins = list of locations where to find the archive. They are tried
#                         in sequence, until the archive is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - archive         = the archive name. Mandatory.
#     - destination     = the local directory where to put the archive and patches.
#                         If not specified, the current directory is assumed.
#     - patches_origins = list of locations where to find the patches. They are tried
#                         in sequence, until a patch is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - patches_specs   = list of "patch specs". A patch spec is of the form
#                         patch_name[:[patch_subdir][:patch_opt]].
#			  
#			      - patch_name   = the name of the patch file
#			      - patch_subdir = the directory within \destination\ where to
#			                       apply the patch.
#			      - patch_opt    = any options to pass to the `patch' command
#			                       when applying the patch.
#                         
#                         The patch_subdir and patch_opt fields are optional.

%define fetch archive_origins=. archive=/A suffixes= destination=. patches_origins=. patches_specs=::
	$(FETCH) -ao "%(archive_origins)" -a %(archive) -as "%(suffixes)" -d %(destination) -po "%(patches_origins)" \
	         -p %(patches_specs)
%end

#-----------------------------------------------------------------------------------------
# Joins the features of %fetch and %build_with_configure, taking advantage of
# the naming scheme of GNU packages. GNU packages names are in the form
#
#     <package name>-<version number>.<archive format suffix>
#
# If a patch is provided, it *must* be named the following way:
#
#    <package name>-<version number>-aros.diff
#
# Moreover, it *must* be appliable with the -p1 option of the `patch' command after
# CD'ing into the archive's extracted directory.
#
# Note that whilst the %fetch macro accepts a list of patches for any given archive,
# the %fetch_and_build macro only accept *one* patch for each package. It's up to you
# to make that patch fully comprehensive.
#
# NOTE: GNU packages are always compiled with *nix semantics turned on.
#
# Arguments:
#
#    - mmake        = the meta make target, as would be supplied to the %build_with_configure
#                     macro.
#    - package      = the GNU package name, sans version and archive format suffixes.
#    - version      = the package's version number, or otherwise any other version string.
#                     It gets appended to the package name to form the basename of the archive.
#    - suffixes     = a list of suffixes to apped to the the package name plus the
#                     version. Each one of them is tried until a matching archive is found.
#                     Defaults to "tat.bz2 tar.gz".
#    - destination  = same meaning as the one for the %fetch macro
#    - package_repo = same meaning as the one of the %fetch macro's %(archive_origins) argument
#    - patch        = "yes" or "no", depending on whether a patch for this package needs to be
#                     fetched or not
#    - patch_repo   = same meaning as the one of the %fetch macro's %(patches_origins) argument
#    - prefix       = same meaning as the one for the %build_with_configure macro. Defaults to
#                     $(GNUDIR).
#    - aros_prefix  = same meaning as the one for the %build_with_configure macro. Defaults to
#                     /GNU.
#    - extraoptions = same meaning as the one for the %build_with_configure macro.

%define fetch_and_build_gnu mmake=/A package=/A version=/A suffixes="tar.bz2 tar.gz" \
    destination=$(PORTSDIR) package_repo= patch=no patch_repo= prefix=$(GNUDIR) \
    aros_prefix=/GNU extraoptions= 

#MM %(mmake)-quick : %(mmake)-fetch

%(mmake)-archbase  := %(package)-%(version)

ifeq (%(patch),yes)
    %(mmake)-patches_specs := %(package)-%(version)-aros.diff:%(package)-%(version):-p1    
else
    %(mmake)-patches_specs := ::
endif

GNU_REPOSITORY := http://ftp.gnu.org/pub/gnu

#MM
%(mmake)-fetch :
	%fetch archive=$(%(mmake)-archbase) suffixes="%(suffixes)" destination=%(destination)/%(package) \
	    archive_origins=". %(package_repo) $(GNU_REPOSITORY)/%(package)" \
	    patches_specs="$(%(mmake)-patches_specs)" patches_origins=". %(patch_repo)"

%build_with_configure mmake=%(mmake) srcdir=$(PORTSDIR)/%(package)/$(%(mmake)-archbase) \
     nix=yes prefix=%(prefix) aros_prefix=%(aros_prefix) extraoptions="%(extraoptions)"
     
%end


#-----------------------------------------------------------------------------------------
# Same job as the one of %fetch_and_build_gnu, except that this one assumes
# that the package is a "Development" package, and as such it needs to be placed
# under the $(AROS_DEVELOPMENT) directory, as a default. 
#
# All the arguments have the same meaning as the ones of the %fetch_and_build_gnu 
# macro, but notice that %fetch_and_build_gnu_development *doesn't* have a
# "mmake" argument, because the metatarget is implicitely defined as
#
#     #MM- development-%(package)

%define fetch_and_build_gnu_development package=/A version=/A suffixes="tar.bz2 tar.gz" \
    destination=$(PORTSDIR) package_repo= patch=no patch_repo= prefix=$(AROS_DEVELOPMENT) \
    aros_prefix=/Development extraoptions= 

#MM- development : development-%(package)


%fetch_and_build_gnu mmake=development-%(package) package=%(package) version=%(version) \
   suffixes="%(suffixes)" destination=%(destination) package_repo="%(package_repo)" \
   patch="%(patch)" patch_repo="%(patch_repo)" prefix=%(prefix) \
   aros_prefix=%(aros_prefix) extraoptions="%(extraoptions)"   
%end