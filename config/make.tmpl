#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macros that are used as commands in the body     ##
## of a make rule.                                                         ##
## They are used to help the portability of mmakefiles to different        ##
## platforms and also will handle the error handling in a standard way.    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Convert the ISO-8859-1 string in %(string) to the host's locale (if necessary)
%define localisestr string= var=
ifeq (,$(findstring "ISO-8859-1",$(LOCALE)))
%(var) := $(shell echo %(string) | iconv -f iso-8859-1 )
else
%(var) := %(string)
endif
%end

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt). Use %(iquote) and %(iquote_end) for supplying -iquote or -I- flags
%define compile_q cmd="$(strip $(TARGET_CC) $(TARGET_SYSROOT))" opt="$(strip $(CFLAGS) $(CPPFLAGS))" from=$< to=$@ iquote=$(CFLAGS_IQUOTE) iquote_end=$(CFLAGS_IQUOTE_END)
	@$(ECHO) "Compiling  $(if $(filter /%,%(from)),$(if $(filter $(SRCDIR)/%,$(abspath %(from))),$(patsubst $(SRCDIR)/%,%,$(abspath %(from))),$(patsubst $(TOP)/%,%,$(abspath %(from)))),$(patsubst $(SRCDIR)/%,%,$(abspath $(SRCDIR)/$(CURDIR)/%(from))))"
	@$(IF) %(cmd) %(iquote) $(dir %(from)) %(iquote) $(SRCDIR)/$(CURDIR) %(iquote) . %(iquote_end) %(opt) -D__SRCFILENAME__="\"$(subst $(TOP)/,,$(subst $(SRCDIR)/,,$(abspath %(from))))"\" -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
			$(ECHO) "%(from): %(cmd) %(iquote) $(dir %(from)) %(iquote) $(SRCDIR)/$(CURDIR) %(iquote) . %(iquote_end) %(opt) -D__SRCFILENAME__=\"$(subst $(TOP)/,,$(subst $(SRCDIR)/,,$(abspath %(from))))\" -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
			tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
		else \
			$(NOP) ; \
		fi ; \
	else \
		$(ECHO) "Compile failed: %(cmd) %(iquote) $(dir %(from)) %(iquote) $(SRCDIR)/$(CURDIR) %(iquote) . %(iquote_end) %(opt) -D__SRCFILENAME__=\"$(subst $(TOP)/,,$(subst $(SRCDIR)/,,$(abspath %(from))))\" -c %(from) -o %(to)" 1>&2 ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
		exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd="$(strip $(CC) $(TARGET_SYSROOT))" opt="$(strip $(AFLAGS) $(CPPFLAGS))" from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
			$(ECHO) "$(notdir %(from)): %(cmd) %(opt) %(from) -o %(to)" >> $(GENDIR)/errors ; \
			$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
		else \
			$(NOP) ; \
		fi ; \
	else \
		$(ECHO) "Assemble failed: %(cmd) %(opt) %(from) -o %(to)" 1>&2 ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
		exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link a specified number of objects to an executable
%define link_q cmd="$(strip $(AROS_CC) $(TARGET_SYSROOT))" opt=$(LDFLAGS) from=$< to=$@ libs=$(LIBS) strip=$(STRIP) objdir=$(GENDIR)/$(CURDIR) coverageinstr=
	@$(eval LINKTARGET=%(to))
	@$(ECHO) "Linking    $(subst $(TARGETDIR)/,,$(LINKTARGET))..."
	@$(eval LINKTMPFILE=%(objdir)/$(notdir $(LINKTARGET)))
	@$(IF) %(cmd) %(from) -o $(LINKTMPFILE) %(opt) %(libs) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "$(LINKTARGET): %(cmd) %(from) -o $(LINKTARGET) %(opt) %(libs)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
		else \
			$(NOP) ; \
		fi ; \
		$(CP) $(LINKTMPFILE) $(LINKTARGET) ; \
	else \
		$(ECHO) "Link failed: %(cmd) %(from) -o $(LINKTARGET) %(opt) %(libs)" 1>&2 ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
		exit 1 ; \
	fi
	@$(IF) [ "$(DEBUG)" = "yes" ]; then \
		%(strip) $(LINKTARGET) --only-keep-debug -o $(LINKTARGET).dbg ; \
	fi
	@%(strip) $(LINKTARGET)
	@$(IF) [ "$(DEBUG)" = "yes" ]; then \
		$(IF) $(TEST) -s $(LINKTARGET).dbg ; then \
			$(OBJCOPY) --add-gnu-debuglink=$(LINKTARGET).dbg $(LINKTARGET) ; \
		fi ; \
	fi
	@$(IF) [ "%(coverageinstr)" = "yes" ]; then \
		LINKBASEFILES="$(strip $(notdir $(basename %(from))))" ; \
		$(FOR) covext in $(TARGET_COVERAGEINSTR_EXTS) ; do \
			$(FOR) file in $$LINKBASEFILES ; do \
				COVERAGEFILE=`echo $$file$$covext` ; \
				$(IF) $(TEST) -s %(objdir)/$$COVERAGEFILE ; then \
					$(CP) %(objdir)/$$COVERAGEFILE $(dir $(LINKTARGET))$$COVERAGEFILE ; \
				fi ; \
			done ; \
		done ; \
	fi
%end
#------------------------------------------------------------------------------


#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q cmd="$(strip $(AROS_CC) $(TARGET_SYSROOT))" err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building   $(subst $(TARGETDIR)/,,$@) ..."
	@$(IF) %(cmd) $(NOSTARTUP_LDFLAGS) \
		$(GENMAP) %(objdir)/%(module).map \
		%(objs) %(libs) %(ldflags) %(endtag) \
		-o $@ 2>&1 > %(objdir)/%(err); \
	then \
		cat %(objdir)/%(err); \
	else \
		echo "%(cmd) $(NOSTARTUP_LDFLAGS) $(GENMAP) %(objdir)/%(module).map %(objs) %(libs) %(ldflags) %(endtag) -o $@"; \
		cat %(objdir)/%(err); \
		exit 1; \
	fi
	@$(IF) $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(IF) [ "$(DEBUG)" = "yes" ]; then \
		$(STRIP) $@ --only-keep-debug -o $@.dbg; \
	fi
	@$(STRIP) $@
	@$(IF) [ "$(DEBUG)" = "yes" ]; then \
		$(IF) $(TEST) -s $@.dbg ; then \
			$(OBJCOPY) --add-gnu-debuglink=$@.dbg $@; \
		fi ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating   $(subst $(TARGETDIR)/,,%(to))..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags="$(strip $(CFLAGS) $(CPPFLAGS))" from=$< to=$@ cc="$(strip $(AROS_CC) $(TARGET_SYSROOT))"
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(if $(filter /%,%(from)),$(if $(filter $(SRCDIR)/%,$(abspath %(from))),$(patsubst $(SRCDIR)/%,%,$(abspath %(from))),$(patsubst $(TOP)/%,%,$(abspath %(from)))),$(patsubst $(SRCDIR)/%,%,$(abspath $(SRCDIR)/$(CURDIR)/%(from))))..."
	@AROS_CC="%(cc)" $(MKDEPEND) %(flags) -I$(TOP)/$(CURDIR) -I$(SRCDIR)/$(CURDIR) %(from) -o %(to)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
		$(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end
#------------------------------------------------------------------------------


#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macros that are used to do certain tasks in a    ##
## mmakefile. They consist of one or more full makefile rules.             ##
## In general the files generated in these macros are also defined as      ##
## make targets so that they can be used as a dependency in other rules    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy the files %(files) to %(targetdir). For each file in %(files),
# %(srcdir)/file is copied to %(targetdir)/file. The targetdir and the
# appropriate subdirs are not generated by this rule so they have to be
# present.
%define rule_copy_multi files=/A targetdir=/A srcdir=.

$(addprefix %(targetdir)/,%(files)) : %(targetdir)/% : %(srcdir)/%
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy the files %(files) to %(targetdir). For each file in %(files),
# %(srcdir)/file is copied to %(targetdir)/file if these files are different.
# %(stampfile) is used to keep track of when the last time the comparison has
# been done. The targetdir and the appropriate subdirs are not generated by 
# this rule so they have to be present.
%define rule_copy_diff_multi files=/A targetdir=/A srcdir=. \
    stampfile=$(TMP_SRCDIR)/.copy_stamp

TMP_SRCDIR := %(srcdir)

$(addprefix %(targetdir)/,%(files)) : | %(stampfile)

%(stampfile) : COPYSRCDIR := %(srcdir)
%(stampfile) : TGTDIR := %(targetdir)
%(stampfile) : FILES := %(files)
%(stampfile) : $(addprefix %(srcdir)/,%(files))
	@for f in $(FILES); do \
	     $(IF) ! $(CMP) -s $(COPYSRCDIR)/$$f $(TGTDIR)/$$f ; then \
	         $(CP) $(COPYSRCDIR)/$$f $(TGTDIR)/$$f ; \
	     fi ; \
	done
	@$(TOUCH) $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $^ >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# included when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

GLOB_MKDIRS += %(dirs)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile mmake=TMP basename=/A cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= targetdir= compiler=target

%(mmake)_NIXFLAG ?= -nix

ifeq (%(targetdir),)
  %(mmake)_TARGETBASE := %(basename)
else
  %(mmake)_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

# Adjust compiler flags to suit C
%(mmake)_C_CPPFLAGS := %(cppflags)
%(mmake)_CFLAGS := %(cflags)
%(mmake)_CFLAGS := $(subst -fpermissive,, $(%(mmake)_CFLAGS))
ifeq (%(dflags),)
  %(mmake)_DFLAGS := $(%(mmake)_CFLAGS)
else
  %(mmake)_DFLAGS := %(dflags)
endif
 
ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
%(mmake)_LINK ?= $(strip $(TARGET_CC) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
%(mmake)_STRIP ?= $(TARGET_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(TARGET_CC) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(TARGET_CC) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_C_CPPFLAGS:=$(%(mmake)_C_CPPFLAGS)
$(%(mmake)_TARGETBASE).d : %(mmake)_C_CPPFLAGS:=$(%(mmake)_C_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_CFLAGS:=$(strip $(%(mmake)_CFLAGS) $(SAFETY_CFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DFLAGS:=$(%(mmake)_DFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
%(mmake)_LINK ?= $(strip $(HOST_CC) $(HOST_LDFLAGS))
%(mmake)_STRIP ?= $(HOST_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(HOST_CC)
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(HOST_CC)
$(%(mmake)_TARGETBASE).o : %(mmake)_C_CPPFLAGS:=$(strip $(HOST_C_CPPFLAGS) $(%(mmake)_C_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_C_CPPFLAGS:=$(strip $(HOST_C_CPPFLAGS) $(%(mmake)_C_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_CFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_CFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_DFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
%(mmake)_LINK ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
%(mmake)_STRIP ?= $(ECHO) >/dev/null
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_C_CPPFLAGS:=$(strip $(KERNEL_C_CPPFLAGS) $(%(mmake)_C_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_C_CPPFLAGS:=$(strip $(KERNEL_C_CPPFLAGS) $(%(mmake)_C_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_CFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_CFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_DFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

$(%(mmake)_TARGETBASE).o : CPPFLAGS := $(%(mmake)_C_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : CFLAGS := $(%(mmake)_CFLAGS)
$(%(mmake)_TARGETBASE).o : %(basename).c
	%compile_q cmd=$(%(mmake)_CMD) iquote=$(%(mmake)_IQUOTE) iquote_end=$(%(mmake)_IQUOTE_END)

ifeq (%(nix),yes)
  $(%(mmake)_TARGETBASE).d : %(mmake)_DFLAGS:=$(strip $(%(mmake)_NIXFLAG) $(%(mmake)_DFLAGS))
endif
$(%(mmake)_TARGETBASE).d : %(basename).c
	%mkdepend_q cc=$(%(mmake)_CMD) flags="$(strip $(%(mmake)_DFLAGS) $(%(mmake)_C_CPPFLAGS))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C++ source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_cxx mmake=TMP basename=/A cppflags=$(CPPFLAGS) cxxflags=$(CXXFLAGS) dxxflags= targetdir= compiler=target

ifneq (%(basename),)
%(mmake)_NIXFLAG ?= -nix
ifeq (%(targetdir),)
  %(mmake)_TARGETBASE := %(basename)
else
  %(mmake)_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

# Adjust compiler flags to suit C++
%(mmake)_CXX_CPPFLAGS := %(cppflags)
%(mmake)_CXXFLAGS := %(cxxflags) 
ifeq (%(dxxflags),)
  %(mmake)_DXXFLAGS := %(cxxflags)
else
  %(mmake)_DXXFLAGS := %(dxxflags)
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
%(mmake)_LINK ?= $(strip $(AROS_CXX) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
%(mmake)_STRIP ?= $(TARGET_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(AROS_CXX) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(AROS_CXX) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_CXX_CPPFLAGS:=$(%(mmake)_CXX_CPPFLAGS)
$(%(mmake)_TARGETBASE).d : %(mmake)_CXX_CPPFLAGS:=$(%(mmake)_CXX_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_CXXFLAGS:=$(strip $(%(mmake)_CXXFLAGS) $(SAFETY_CFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DXXFLAGS:=$(%(mmake)_DXXFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
%(mmake)_LINK ?= $(strip $(HOST_CXX) $(HOST_LDFLAGS))
%(mmake)_STRIP ?= $(HOST_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(HOST_CXX)
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(HOST_CXX)
$(%(mmake)_TARGETBASE).o : %(mmake)_CXX_CPPFLAGS:=$(strip $(HOST_CXX_CPPFLAGS) $(%(mmake)_CXX_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_CXX_CPPFLAGS:=$(strip $(HOST_CXX_CPPFLAGS) $(%(mmake)_CXX_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_CXXFLAGS:=$(strip $(HOST_CXXFLAGS) $(%(mmake)_CXXFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DXXFLAGS:=$(strip $(HOST_CXXFLAGS) $(%(mmake)_DXXFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
KERNEL_CXX ?= $(KERNEL_CC)
%(mmake)_LINK ?= $(strip $(KERNEL_CXX) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
%(mmake)_STRIP ?= $(ECHO) >/dev/null
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_CXX_CPPFLAGS:=$(strip $(KERNEL_CXX_CPPFLAGS) $(%(mmake)_CXX_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_CXX_CPPFLAGS:=$(strip $(KERNEL_CXX_CPPFLAGS) $(%(mmake)_CXX_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_CXXFLAGS:=$(strip $(KERNEL_CXXFLAGS) $(%(mmake)_CXXFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_DXXFLAGS:=$(strip $(KERNEL_CXXFLAGS) $(%(mmake)_DXXFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

$(%(mmake)_TARGETBASE).o : CPPFLAGS := $(%(mmake)_CXX_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : CXXFLAGS := $(%(mmake)_CXXFLAGS)
$(%(mmake)_TARGETBASE).o : %(basename).cpp
	%compile_q cmd=$(%(mmake)_CMD) opt="$(strip $(CXXFLAGS) $(CPPFLAGS))" iquote=$(%(mmake)_IQUOTE) iquote_end=$(%(mmake)_IQUOTE_END)

ifeq (%(nix),yes)
  $(%(mmake)_TARGETBASE).d : %(mmake)_DXXFLAGS:=$(strip $(%(mmake)_NIXFLAG) $(%(mmake)_DXXFLAGS))
endif
$(%(mmake)_TARGETBASE).d : %(basename).cpp
	%mkdepend_q cc=$(%(mmake)_CMD) flags="$(strip $(%(mmake)_DXXFLAGS) $(%(mmake)_CXX_CPPFLAGS))"

endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile an ObjC source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .m file
%define rule_compile_objc mmake=TMP basename=/A cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= targetdir= compiler=target

ifneq (%(basename),)
%(mmake)_NIXFLAG ?= -nix
ifeq (%(targetdir),)
  %(mmake)_TARGETBASE := %(basename)
else
  %(mmake)_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

# Adjust compiler flags to suit ObjC
%(mmake)_OBJC_CPPFLAGS :=  %(cppflags)
%(mmake)_OBJCFLAGS := %(cflags)
%(mmake)_OBJCFLAGS := $(%(mmake)_OBJCFLAGS) -isystem $(AROS_DEVELOPER)/include
%(mmake)_OBJCFLAGS := $(subst -Wno-pointer-sign,, $(subst -Werror-implicit-function-declaration,, $(%(mmake)_OBJCFLAGS)))
ifeq (%(dflags),)
  %(mmake)_OBJCDFLAGS := %(cflags)
else
  %(mmake)_OBJCDFLAGS := %(dflags)
endif

# Define the use of cross compiler
ifeq ($(TARGET_OBJC),)
  %(mmake)_CC := $(TARGET_CC)
else
  %(mmake)_CC := $(TARGET_OBJC)
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
%(mmake)_LINK ?= $(strip $(%(mmake)_CC) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
%(mmake)_STRIP ?= $(TARGET_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(%(mmake)_CC) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(%(mmake)_CC) $(TARGET_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJC_CPPFLAGS:=$(%(mmake)_OBJC_CPPFLAGS)
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJC_CPPFLAGS:=$(%(mmake)_OBJC_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJCFLAGS:=$(strip $(%(mmake)_OBJCFLAGS) $(SAFETY_CFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJCDFLAGS:=$(%(mmake)_OBJCDFLAGS)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
%(mmake)_LINK ?= $(strip $(HOST_CC) $(HOST_LDFLAGS))
%(mmake)_STRIP ?= $(HOST_STRIP)
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(HOST_CC)
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(HOST_CC)
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJC_CPPFLAGS:=$(strip $(HOST_OBJC_CPPFLAGS) $(%(mmake)_OBJC_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJC_CPPFLAGS:=$(strip $(HOST_OBJC_CPPFLAGS) $(%(mmake)_OBJC_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJCFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_OBJCFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJCDFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_OBJCDFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
%(mmake)_LINK ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
%(mmake)_STRIP ?= $(ECHO) >/dev/null
$(%(mmake)_TARGETBASE).o : %(mmake)_CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).d : %(mmake)_CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJC_CPPFLAGS:=$(strip $(KERNEL_OBJC_CPPFLAGS) $(%(mmake)_OBJC_CPPFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJC_CPPFLAGS:=$(strip $(KERNEL_OBJC_CPPFLAGS) $(%(mmake)_OBJC_CPPFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_OBJCFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_OBJCFLAGS))
$(%(mmake)_TARGETBASE).d : %(mmake)_OBJCDFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_OBJCDFLAGS))
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_TARGETBASE).o : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
$(%(mmake)_TARGETBASE).d : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

$(%(mmake)_TARGETBASE).o : CPPFLAGS := $(%(mmake)_OBJC_CPPFLAGS)
$(%(mmake)_TARGETBASE).o : CFLAGS := $(%(mmake)_OBJCFLAGS)
$(%(mmake)_TARGETBASE).o : %(basename).m
	%compile_q cmd=$(%(mmake)_CMD) iquote=$(%(mmake)_IQUOTE) iquote_end=$(%(mmake)_IQUOTE_END)

ifeq (%(nix),yes)
  $(%(mmake)_TARGETBASE).d : %(mmake)_OBJCDFLAGS:=$(strip $(%(mmake)_NIXFLAG) $(%(mmake)_OBJCDFLAGS))
endif
$(%(mmake)_TARGETBASE).d : %(basename).m
	%mkdepend_q cc=$(%(mmake)_CMD) flags="$(strip $(%(mmake)_OBJCDFLAGS) $(%(mmake)_OBJC_CPPFLAGS))"

endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile multiple C source files to an object file and
# generate the corresponding dependency files. The generated file will be put
# in the object directory without the directory part of the source file.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
# - compiler (default target): compiler to use, target, kernel or host
%define rule_compile_multi mmake=TMP basenames=/A cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= srcdir= targetdir= \
    compiler=target

ifeq (%(srcdir),)
%(mmake)_MC_SRCWILDCARD := %
else
%(mmake)_MC_SRCWILDCARD := %(srcdir)/%
endif

ifeq (%(targetdir),)
%(mmake)_MC_TARGETS := $(addsuffix .o,%(basenames))
%(mmake)_MC_DTARGETS := $(addsuffix .d,%(basenames))
%(mmake)_MC_TGTWILDCARD := %
else
%(mmake)_MC_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,$(notdir %(basenames))))
%(mmake)_MC_DTARGETS := $(addsuffix .d,$(addprefix %(targetdir)/,$(notdir %(basenames))))
%(mmake)_MC_TGTWILDCARD := %(targetdir)/%

# Be sure that all .c files are generated
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : | $(addsuffix .c,%(basenames))

# Be sure that all .c files are found
%(mmake)_MC_SRCDIR := $(shell echo $(SRCDIR) | sed 's/^\(.\):\//\/\1\//')
%(mmake)_MC_BASEDIRS := $(shell echo $(sort $(dir %(basenames))) | sed 's/\(.\):\//\/\1\//g')
%(mmake)_MC_DIRS := $(foreach dir, $(%(mmake)_MC_BASEDIRS), $(if $(filter /%,$(dir)),$(dir),$(%(mmake)_MC_SRCDIR)/$(CURDIR)/$(dir)))
ifneq ($(%(mmake)_MC_DIRS),)
    %(mmake)_MC_DIRS := $(shell echo $(%(mmake)_MC_DIRS) | sed 's/\(.\):\//\/\1\//g')
    vpath %.c $(%(mmake)_MC_DIRS)
endif

endif

%(mmake)_MC_CPPFLAGS := %(cppflags)
%(mmake)_CFLAGS := %(cflags)
ifeq (%(dflags),)
  %(mmake)_DFLAGS := %(cflags)
else
  %(mmake)_DFLAGS := %(dflags)
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
%(mmake)_LINK ?= $(strip $(TARGET_CC) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
%(mmake)_STRIP ?= $(TARGET_STRIP)
%(mmake)_ASSEMBLER ?= $(strip $(TARGET_CC) $(TARGET_SYSROOT))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : CMD:=$(strip $(TARGET_CC) $(TARGET_SYSROOT))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_MC_CPPFLAGS:=$(%(mmake)_MC_CPPFLAGS)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_CFLAGS:=$(strip $(%(mmake)_CFLAGS) $(SAFETY_CFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_DFLAGS:=$(%(mmake)_DFLAGS)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
%(mmake)_LINK ?= $(strip $(HOST_CC) $(HOST_LDFLAGS))
%(mmake)_STRIP ?= $(HOST_STRIP)
%(mmake)_ASSEMBLER ?= $(strip $HOST_CC) $(HOST_SYSROOT))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : CMD:=$(HOST_CC)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_MC_CPPFLAGS:=$(strip $(HOST_MC_CPPFLAGS) $(%(mmake)_MC_CPPFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_CFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_CFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_DFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_DFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
%(mmake)_LINK ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
%(mmake)_STRIP ?= $(ECHO) >/dev/null
%(mmake)_ASSEMBLER ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_MC_CPPFLAGS:=$(strip $(KERNEL_MC_CPPFLAGS) $(%(mmake)_MC_CPPFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_CFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_CFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_DFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_DFLAGS))
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
$(%(mmake)_MC_TARGETS) $(%(mmake)_MC_DTARGETS) : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

$(%(mmake)_MC_TARGETS) : CPPFLAGS := $(%(mmake)_MC_CPPFLAGS)
$(%(mmake)_MC_TARGETS) : CFLAGS := $(%(mmake)_CFLAGS)
$(%(mmake)_MC_TARGETS) : $(%(mmake)_MC_TGTWILDCARD).o : $(%(mmake)_MC_SRCWILDCARD).c
	%compile_q cmd=$(CMD) iquote=$(%(mmake)_IQUOTE) iquote_end=$(%(mmake)_IQUOTE_END)

$(%(mmake)_MC_DTARGETS) : $(%(mmake)_MC_TGTWILDCARD).d : $(%(mmake)_MC_SRCWILDCARD).c
	%mkdepend_q cc=$(CMD) flags="$(strip $(%(mmake)_DFLAGS) $(%(mmake)_MC_CPPFLAGS))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile multiple C++ source files to an object file and
# generate the corresponding dependency files. The generated file will be put
# in the object directory without the directory part of the source file.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed. basenames will be 
#   matched to supported AROS_CXXEXTS.
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
# - compiler (default target): compiler to use, target, kernel or host
%define rule_compile_cxx_multi mmake=TMP basenames=/A cppflags=$(CPPFLAGS) cxxflags=$(CXXFLAGS) dxxflags= \
    targetdir= compiler=target

%(mmake)_CXXABSBASENAMES := $(foreach %(mmake)_CXXBASE,%(basenames),$(if $(filter /%,$(%(mmake)_CXXBASE)),$(%(mmake)_CXXBASE),$(abspath $(SRCDIR)/$(CURDIR)/$(%(mmake)_CXXBASE))))

ifneq ($(%(mmake)_CXXABSBASENAMES),)

%(mmake)_CXXBASENAMES := $(basename $(%(mmake)_CXXABSBASENAMES))

# Identify the "real" c++ files from the passed in basenames
%(mmake)_MCXX_FILES  := $(strip $(foreach %(mmake)_CXXBASE,$(%(mmake)_CXXABSBASENAMES), $(firstword $(wildcard $(foreach %(mmake)_EXT, $(AROS_CXXEXTS),$(addsuffix .$(%(mmake)_EXT),$(%(mmake)_CXXBASE)))))))

ifeq (%(targetdir),)
  %(mmake)_CXXTARGETS := $(notdir $(%(mmake)_CXXBASENAMES:=.o))
  %(mmake)_CXXDTARGETS := $(notdir $(%(mmake)_CXXBASENAMES:=.d))
  %(mmake)_MCXX_WILDCARD := %
else
  %(mmake)_CXXTARGETS := $(addprefix %(targetdir)/,$(notdir $(%(mmake)_CXXBASENAMES:=.o)))
  %(mmake)_CXXDTARGETS := $(addprefix %(targetdir)/,$(notdir $(%(mmake)_CXXBASENAMES:=.d)))
  %(mmake)_MCXX_WILDCARD := %(targetdir)/%

  # Be sure that all source files are generated
  $(%(mmake)_CXXTARGETS) $(%(mmake)_CXXDTARGETS) : | $(%(mmake)_MCXX_FILES)
endif

# Adjust compiler flags to suit C++
%(mmake)_MCXX_CPPFLAGS := %(cppflags)
%(mmake)_CXXFLAGS := %(cxxflags)
ifeq (%(dxxflags),)
  %(mmake)_DXXFLAGS := %(cxxflags)
else
  %(mmake)_DXXFLAGS := %(dxxflags)
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),host)
  %(mmake)_LINK ?= $(strip $(HOST_CXX) $(HOST_LDFLAGS))
  %(mmake)_STRIP ?= $(HOST_STRIP)
  %(mmake)_ASSEMBLER ?= $(strip $(HOST_CC) $(HOST_SYSROOT))
  %(mmake)_CXXCMD:=$(HOST_CXX)
  %(mmake)_MCXX_CPPFLAGS := $(strip $(HOST_MCXX_CPPFLAGS) $(%(mmake)_MCXX_CPPFLAGS))
  %(mmake)_CXXFLAGS := $(strip $(HOST_CXXFLAGS) $(%(mmake)_CXXFLAGS))
  %(mmake)_DXXFLAGS := $(strip $(HOST_CXXFLAGS) $(%(mmake)_DXXFLAGS))
  %(mmake)_CXXIQUOTE:=$(HOST_IQUOTE)
  %(mmake)_CXXIQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),target)
  %(mmake)_LINK ?= $(strip $(AROS_CXX) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
  %(mmake)_STRIP ?= $(TARGET_STRIP)
  %(mmake)_ASSEMBLER ?= $(strip $(TARGET_CC) $(TARGET_SYSROOT))
  %(mmake)_CXXCMD:=$(strip $(AROS_CXX) $(TARGET_SYSROOT))
  %(mmake)_MCXX_CPPFLAGS := $(%(mmake)_MCXX_CPPFLAGS)
  %(mmake)_CXXFLAGS := $(strip $(%(mmake)_CXXFLAGS) $(SAFETY_CFLAGS))
  %(mmake)_DXXFLAGS := $(%(mmake)_DXXFLAGS)
  %(mmake)_CXXIQUOTE:=$(CFLAGS_IQUOTE)
  %(mmake)_CXXIQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
  KERNEL_CXX ?= $(KERNEL_CC)
  %(mmake)_LINK ?= $(strip $(KERNEL_CXX) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
  %(mmake)_STRIP ?= $(ECHO) >/dev/null
  %(mmake)_ASSEMBLER ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
  %(mmake)_CXXCMD:=$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))
  %(mmake)_CXXFLAGS := $(strip $(KERNEL_MCXX_CPPFLAGS) $(%(mmake)_MCXX_CPPFLAGS))
  %(mmake)_CXXFLAGS := $(strip $(KERNEL_CXXFLAGS) $(%(mmake)_CXXFLAGS))
  %(mmake)_DXXFLAGS := $(strip $(KERNEL_CXXFLAGS) $(%(mmake)_DXXFLAGS))
  %(mmake)_CXXIQUOTE:=$(KERNEL_IQUOTE)
  %(mmake)_CXXIQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

define cxx_multi_recipe_template
 $(1).o : $(2)
 	%compile_q cmd=$(%(mmake)_CXXCMD) opt="$(strip $(%(mmake)_CXXFLAGS) $(%(mmake)_MCXX_CPPFLAGS))" iquote=$(%(mmake)_CXXIQUOTE) iquote_end=$(%(mmake)_CXXIQUOTE_END) from=$(2) to=$(1).o

 $(1).d : $(2)
 	%mkdepend_q cc=$(%(mmake)_CXXCMD) flags="$(strip $(%(mmake)_DXXFLAGS) $(%(mmake)_MCXX_CPPFLAGS))" from=$(2) to=$(1).d
endef
ifeq (%(targetdir),)
  $(foreach %(mmake)_CXXFILE,$(%(mmake)_MCXX_FILES),$(eval $(call cxx_multi_recipe_template,$(notdir $(basename $(%(mmake)_CXXFILE))),$(%(mmake)_CXXFILE))))
else
  $(foreach %(mmake)_CXXFILE,$(%(mmake)_MCXX_FILES),$(eval $(call cxx_multi_recipe_template,$(addprefix %(targetdir)/,$(notdir $(basename $(%(mmake)_CXXFILE)))),$(%(mmake)_CXXFILE))))
endif

endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile multiple ObjC source files to an object file and
# generate the corresponding dependency files. The generated file will be put
# in the object directory without the directory part of the source file.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .m file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
# - compiler (default target): compiler to use, target, kernel or host
%define rule_compile_objc_multi mmake=TMP basenames=/A cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= \
    targetdir= compiler=target

ifneq (%(basenames),)

ifeq (%(targetdir),)
  %(mmake)_MOBJC_TARGETS := $(addsuffix .o,%(basenames))
  %(mmake)_MOBJC_DTARGETS := $(addsuffix .d,%(basenames))
  %(mmake)_MOBJC_WILDCARD := %
else
  %(mmake)_MOBJC_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,%(basenames)))
  %(mmake)_MOBJC_DTARGETS := $(addsuffix .d,$(addprefix %(targetdir)/,%(basenames)))
  %(mmake)_MOBJC_WILDCARD := %(targetdir)/%

  # Be sure that all .m files are generated
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : | $(addsuffix .m,%(basenames))

  # Be sure that all .m files are found
  %(mmake)_MOBJC_SRCDIR := $(shell echo $(SRCDIR) | sed 's/^\(.\):\//\/\1\//')
  %(mmake)_MOBJC_BASEDIRS := $(shell echo $(sort $(dir %(basenames))) | sed 's/\(.\):\//\/\1\//g')
  %(mmake)_MOBJC_DIRS := $(foreach dir, $(%(mmake)_MOBJC_BASEDIRS), $(if $(filter /%,$(dir)),$(dir),$(%(mmake)_MOBJC_SRCDIR)/$(CURDIR)/$(dir)))
  ifneq ($(%(mmake)_MOBJC_DIRS),)
    %(mmake)_MOBJC_DIRS := $(shell echo $(%(mmake)_MOBJC_DIRS) | sed 's/\(.\):\//\/\1\//g')
    vpath %.m $(%(mmake)_MOBJC_DIRS)
  endif
endif

# Define the use of cross compiler
ifeq ($(TARGET_OBJC),)
  %(mmake)_CC := $(TARGET_CC)
else
  %(mmake)_CC := $(TARGET_OBJC)
endif

# Adjust compiler flags to suit ObjC
%(mmake)_MOBJC_CPPFLAGS := %(cppflags)
%(mmake)_OBJCFLAGS := %(cflags)
%(mmake)_OBJCFLAGS := $(%(mmake)_OBJCFLAGS) -isystem $(AROS_DEVELOPER)/include
%(mmake)_OBJCFLAGS := $(subst -Wno-pointer-sign,, $(subst -Werror-implicit-function-declaration,, $(%(mmake)_OBJCFLAGS)))
ifeq (%(dflags),)
  %(mmake)_OBJCDFLAGS := %(cflags)
else
  %(mmake)_OBJCDFLAGS := %(dflags)
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
  %(mmake)_LINK ?= $(strip $(%(mmake)_CC) $(TARGET_SYSROOT) $(TARGET_LDFLAGS))
  %(mmake)_STRIP ?= $(TARGET_STRIP)
  %(mmake)_ASSEMBLER ?= $(strip $(TARGET_CC) $(TARGET_SYSROOT))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : CMD:=$(strip $(%(mmake)_CC) $(TARGET_SYSROOT))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_MOBJC_CPPFLAGS:=$(%(mmake)_MOBJC_CPPFLAGS)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCFLAGS:=$(strip $(%(mmake)_OBJCFLAGS) $(SAFETY_CFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCDFLAGS:=$(%(mmake)_OBJCDFLAGS)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE:=$(CFLAGS_IQUOTE)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
  %(mmake)_LINK ?= $(strip $(HOST_OBJC) $(HOST_LDFLAGS))
  %(mmake)_STRIP ?= $(HOST_STRIP)
  %(mmake)_ASSEMBLER ?= $(strip $(HOST_CC) $(HOST_SYSROOT))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : CMD:=$(HOST_OBJC)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_MOBJC_CPPFLAGS:=$(strip $(HOST_MOBJC_CPPFLAGS) $(%(mmake)_MOBJC_CPPFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_OBJCFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCDFLAGS:=$(strip $(HOST_CFLAGS) $(%(mmake)_OBJCDFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE:=$(HOST_IQUOTE)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
  KERNEL_OBJC ?= $(KERNEL_CC)
  %(mmake)_LINK ?= $(strip $(KERNEL_OBJC) $(KERNEL_SYSROOT) $(KERNEL_LDFLAGS))
  %(mmake)_STRIP ?= $(ECHO) >/dev/null
  %(mmake)_ASSEMBLER ?= $(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : CMD:=$(strip $(KERNEL_OBJC) $(KERNEL_SYSROOT))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_MOBJC_CPPFLAGS:=$(strip $(KERNEL_MOBJC_CPPFLAGS) $(%(mmake)_MOBJC_CPPFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_OBJCFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_OBJCDFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(%(mmake)_OBJCDFLAGS))
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE:=$(KERNEL_IQUOTE)
  $(%(mmake)_MOBJC_TARGETS) $(%(mmake)_MOBJC_DTARGETS) : %(mmake)_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

$(%(mmake)_MOBJC_TARGETS) : CPPFLAGS := $(%(mmake)_MOBJC_CPPFLAGS)
$(%(mmake)_MOBJC_TARGETS) : CFLAGS := $(%(mmake)_OBJCFLAGS)
$(%(mmake)_MOBJC_TARGETS) : $(%(mmake)_MOBJC_WILDCARD).o : %.m
	%compile_q cmd=$(CMD) iquote=$(%(mmake)_IQUOTE) iquote_end=$(%(mmake)_IQUOTE_END)

$(%(mmake)_MOBJC_DTARGETS) : $(%(mmake)_MOBJC_WILDCARD).d : %.m
	%mkdepend_q cc=$(CMD) flags="$(strip $(%(mmake)_OBJCDFLAGS) $(%(mmake)_MOBJC_CPPFLAGS))"

endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Make an alias from one arch specific build to another arch.
# arguments:
# - mainmmake: the mmake of the module in the main tree
# - arch: the current arch
# - alias: the alias to which this should point
%define rule_archalias mainmmake=\A arch=\A alias=\A

#MM- %(mainmmake)-%(arch) : %(mainmmake)-%(alias)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file in. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A cppflags=$(CPPFLAGS) aflags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : CPPFLAGS := %(cppflags)
%(basename).o : AFLAGS := %(aflags)
%(basename).o : %(basename).s
	%assemble_q
%(basename).o : %(basename).S
	%assemble_q

else
%(targetdir)/$(notdir %(basename)).o : CPPFLAGS := %(cppflags)
%(targetdir)/$(notdir %(basename)).o : AFLAGS := %(aflags)
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q
%(targetdir)/$(notdir %(basename)).o : %(basename).S
	%assemble_q

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble multiple source files to an object file. The
# generated file will be put in the object directory with the directory part
# of the source file stripped off.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - aflags (default $(AFLAGS)): the flags to use for assembly
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
%define rule_assemble_multi mmake=TMP cmd="$(strip $(CC) $(TARGET_SYSROOT))"  basenames=/A cppflags=$(CPPFLAGS) aflags=$(AFLAGS) targetdir= suffix=.s

ifeq (%(targetdir),)
%(mmake)-MA_TARGETS := $(addsuffix .o,%(basenames))
%(mmake)-MA_WILDCARD := %
else
%(mmake)-MA_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,$(notdir %(basenames))))
%(mmake)-MA_WILDCARD := %(targetdir)/%

# Be sure that all .s files are generated
$(%(mmake)-MA_TARGETS) : | $(addsuffix %(suffix),%(basenames))

# Be sure that all .c files are found
%(mmake)-MA_SRCDIR := $(shell echo $(SRCDIR) | sed 's/^\(.\):\//\/\1\//')
%(mmake)-MA_BASEDIRS := $(shell echo $(sort $(dir %(basenames))) | sed 's/\(.\):\//\/\1\//g')
%(mmake)-MA_DIRS := $(foreach dir, $(%(mmake)-MA_BASEDIRS), $(if $(filter /%,$(dir)),$(dir),$(%(mmake)-MA_SRCDIR)/$(CURDIR)/$(dir)))
ifneq ($(%(mmake)-MA_DIRS),)
    %(mmake)-MA_DIRS := $(shell echo $(%(mmake)-MA_DIRS) | sed 's/\(.\):\//\/\1\//g')
    vpath %%(suffix) $(%(mmake)-MA_DIRS)
endif

endif

%(mmake)-MA_ASSEMBLER ?= %(cmd)

$(%(mmake)-MA_TARGETS) : %(mmake)-MA_CMD:= $(%(mmake)-MA_ASSEMBLER)

$(%(mmake)-MA_TARGETS) : CPPFLAGS := %(cppflags)
$(%(mmake)-MA_TARGETS) : AFLAGS := %(aflags)
$(%(mmake)-MA_TARGETS) : $(%(mmake)-MA_WILDCARD).o : %%(suffix)
	%assemble_q cmd=$(%(mmake)-MA_CMD)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(objs) to %(prog) using the libraries in %(uselibs)
%define rule_link_prog mmake=TMP prog=/A objs=/A ldflags=$(LDFLAGS) uselibs= \
    usehostlibs= usestartup=yes detach=no nix=no cmd="$(strip $(AROS_CC) $(TARGET_SYSROOT))" strip=$(TARGET_STRIP) objdir=$(GENDIR)/$(CURDIR) coverageinstr=$(TARGET_COVERAGEINSTR)

%(mmake)-link_EXTRA_LDFLAGS := 
%(mmake)-link_EXTRA_LIBS :=
ifeq (%(nix),yes)
    %(mmake)-link_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    %(mmake)-link_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    %(mmake)-link_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif

# Make a list of the lib files this program depends on.
# In LDFLAGS remove white space between -L and directory
%(mmake)-link_DIRS := $(subst -L ,-L,$(strip %(ldflags)))
# Filter out only the libdirs and remove -L
%(mmake)-link_DIRS := $(patsubst -L%,%,$(filter -L%,$(%(mmake)-link_DIRS)))
# Add trailing /
%(mmake)-link_DIRS := $(subst //,/,$(addsuffix /,$(%(mmake)-link_DIRS)))
# Add normal linklib path
%(mmake)-link_DIRS += $(AROS_LIB)/
# add lib and .a to static linklib names
%(mmake)-link_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs) $(%(mmake)-link_EXTRA_LIBS)))
ifeq (%(usestartup),yes)
    %(mmake)-link_LIBS += startup.o
endif
ifeq (%(detach),yes)
    %(mmake)-link_LIBS += detach.o
endif
# search for the linklibs in the given path, ignore ones not found
%(mmake)-link_DEPLIBS := $(foreach lib,$(%(mmake)-link_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(%(mmake)-link_DIRS)))) \
)

%(prog) : OBJDIR := %(objdir)
%(prog) : OBJS := %(objs)
%(prog) : LDFLAGS := $(strip %(ldflags) $(%(mmake)-link_EXTRA_LDFLAGS))
%(prog) : LIBS := $(addprefix -l,%(uselibs) $(%(mmake)-link_EXTRA_LIBS) %(usehostlibs))
%(prog) : %(objs) $(%(mmake)-link_DEPLIBS)
	%link_q cmd="%(cmd)" strip="%(strip)" from=$(OBJS) opt=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR) coverageinstr=%(coverageinstr)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(progs) from object in %(objdir) to executables in %(targetdir) using
# the AROS libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_link_progs mmake=TMP progs=/A targetdir=$(AROSDIR)/$(CURDIR) nix=%(nix) \
    objdir=$(GENDIR)/$(CURDIR) ldflags=$(LDFLAGS) uselibs= usehostlibs= \
    usestartup=yes detach=no cmd="$(strip $(AROS_CC) $(TARGET_SYSROOT))" strip=$(TARGET_STRIP) coverageinstr=$(TARGET_COVERAGEINSTR)

%(mmake)-link_EXTRA_LDFLAGS := 
%(mmake)-link_EXTRA_LIBS :=
ifeq (%(nix),yes)
    %(mmake)-link_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    %(mmake)-link_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    %(mmake)-link_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif

# Make a list of the lib files the programs depend on.
# In LDFLAGS remove white space between -L and directory
%(mmake)-link_DIRS := $(subst -L ,-L,$(strip %(ldflags)))
# Filter out only the libdirs and remove -L
%(mmake)-link_DIRS := $(patsubst -L%,%,$(filter -L%,$(%(mmake)-link_DIRS)))
# Add trailing /
%(mmake)-link_DIRS := $(subst //,/,$(addsuffix /,$(%(mmake)-link_DIRS)))
# Add normal linklib path
%(mmake)-link_DIRS += $(AROS_LIB)/
# add lib and .a to static linklib names
%(mmake)-link_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs) $(%(mmake)-link_EXTRA_LIBS)))
# search for the linklibs in the given path, ignore ones not found
%(mmake)-link_DEPLIBS := $(foreach lib,$(%(mmake)-link_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(%(mmake)-link_DIRS)))) \
)
%(mmake)-link_PROGS := $(addprefix %(targetdir)/,%(progs))

$(%(mmake)-link_PROGS) : OBJDIR := %(objdir)
$(%(mmake)-link_PROGS) : LDFLAGS := $(strip %(ldflags) $(%(mmake)-link_EXTRA_LDFLAGS))
$(%(mmake)-link_PROGS) : LIBS := $(addprefix -l,%(uselibs) $(%(mmake)-link_EXTRA_LIBS) %(usehostlibs))
$(%(mmake)-link_PROGS) : %(targetdir)/% : %(objdir)/%.o $(%(mmake)-link_DEPLIBS)
	%link_q cmd="%(cmd)" strip="%(strip)" from=$< opt=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR) coverageinstr=%(coverageinstr)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a
%define rule_link_linklib mmake=TMP libname=/A objs=/A libdir=$(AROS_LIB) linker=target

ifeq (%(linker),target)
%(libdir)/lib%(libname).a : %(mmake)_AR:=$(AR)
%(libdir)/lib%(libname).a : %(mmake)_RANLIB:=$(RANLIB)
endif
ifeq (%(linker),host)
%(libdir)/lib%(libname).a : %(mmake)_AR:=$(HOST_AR)
%(libdir)/lib%(libname).a : %(mmake)_RANLIB:=$(HOST_RANLIB)
endif
ifeq (%(linker),kernel)
%(libdir)/lib%(libname).a : %(mmake)_AR:=$(KERNEL_AR)
%(libdir)/lib%(libname).a : %(mmake)_RANLIB:=$(KERNEL_RANLIB)
endif

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^ ar=$(%(mmake)_AR) ranlib=$(%(mmake)_RANLIB)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A objdir=$(OBJDIR) \
    cmd="$(strip $(AROS_CC) $(TARGET_SYSROOT))" ldflags=$(LDFLAGS) uselibs= usehostlibs=

TMP_LDFLAGS  := %(ldflags)
# Make a list of the lib files the programs depend on.
# In LDFLAGS remove white space between -L and directory
TMP_DIRS := $(subst -L ,-L,$(strip $(TMP_LDFLAGS)))
# Filter out only the libdirs and remove -L
TMP_DIRS := $(patsubst -L%,%,$(filter -L%,$(TMP_DIRS)))
# Add trailing /
TMP_DIRS := $(subst //,/,$(addsuffix /,$(TMP_DIRS)))
# Add normal linklib path
TMP_DIRS += $(AROS_LIB)/
# add lib and .a to static linklib names
TMP_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs)))
# search for the linklibs in the given path, ignore ones not found
TMP_DEPLIBS := $(foreach lib,$(TMP_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(TMP_DIRS)))) \
)

%(module) : LIB_NAMES := %(uselibs)
%(module) : OBJS := %(objs)
%(module) : ENDTAG := %(endobj)
%(module) : ERR := %(err)
%(module) : OBJDIR := %(objdir)
%(module) : LDFLAGS := $(TMP_LDFLAGS)
ifeq (%(usehostlibs),)
%(module) : LIBS := $(addprefix -l,$(LIB_NAMES))
else
# Warning: the -L/usr/lib here can result in modules
# linking against host libs instead of AROS libs (e.g stdc++) !!
%(module) : LIBS := $(addprefix -l,$(LIB_NAMES)) \
                    -L/usr/lib $(addprefix -l,%(usehostlibs))
endif 
%(module) : %(objs) %(endobj) $(TMP_DEPLIBS) $(USER_DEPLIBS)
	%link_module_q cmd="%(cmd)" err=$(ERR) endtag=$(ENDTAG) objs=$(OBJS) libs=$(LIBS) objdir=$(OBJDIR) ldflags=$(LDFLAGS)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genmodule_genlibdefs modname=/A version= flavour= modtype=/A modsuffix= conffile= targetdir=

TMP_OPTS := 
ifneq (%(flavour),)
    TMP_OPTS += -f %(flavour)
    TMP_MODNAME := %(modname)_%(flavour)
else
    TMP_MODNAME := %(modname)
endif
TMP_TARGET := $(TMP_MODNAME)_libdefs.h
TMP_DEPS := $(GENMODULE)
ifneq (%(conffile),)
    ifeq ($(dir %(conffile)),./)
        TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(conffile)
        TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(conffile)
    else
        TMP_OPTS += -c %(conffile)
        TMP_DEPS += %(conffile)
    endif 
else
    TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(modname).conf
    TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif
ifneq (%(version),)
    TMP_OPTS += -v %(version)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(ECHO) "Generating $(subst $(TARGETDIR)/,,$@)"
	@$(GENMODULE) $(OPTS) writelibdefs $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate the _lib.fd file for a module.
%define rule_genmodule_fd modname=/A modtype=/A modsuffix= conffile= targetdir=

TMP_TARGET := %(modname)_lib.fd
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    ifeq ($(dir %(conffile)),./)
        TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(conffile)
        TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(conffile)
    else
        TMP_OPTS += -c %(conffile)
        TMP_DEPS += %(conffile)
    endif 
else
    TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(modname).conf
    TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(ECHO) "Generating $(subst $(TARGETDIR)/,,$@)"
	@$(GENMODULE) $(OPTS) writefd $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate a Makefile.%(modname)%(modtype) with the genmodule program and include this
# generated file in this Makefile
%define rule_genmodule_makefile modname=/A flavour= modtype=/A modsuffix= conffile= \
    targetdir=

TMP_OPTS := 
ifneq (%(flavour),)
    TMP_OPTS += -f %(flavour)
    TMP_MODNAME := %(modname)_%(flavour)
else
    TMP_MODNAME := %(modname)
endif
TMP_TARGET := Makefile.$(TMP_MODNAME)%(modtype)
TMP_DEPS := $(GENMODULE)
ifneq (%(conffile),)
    ifeq ($(dir %(conffile)),./)
        TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(conffile)
        TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(conffile)
    else
        TMP_OPTS += -c %(conffile)
        TMP_DEPS += %(conffile)
    endif 
else
    TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(modname).conf
    TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(GENMODULE) $(OPTS) writemakefile $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files. This rule has to be preceeded by
# %rule_genmodule_makefile
%define rule_genmodule_files modname=/A flavour= modtype=/A modsuffix= targetdir= stubdir= \
    conffile=

TMP_OPTS :=
ifneq (%(flavour),)
    TMP_OPTS += -f %(flavour)
    TMP_MODNAME := %(modname)_%(flavour)
else
    TMP_MODNAME := %(modname)
endif
TMP_GENTARGETS := $($(TMP_MODNAME)_STARTFILES) $($(TMP_MODNAME)_ENDFILES)
TMP_STUBTARGETS := $($(TMP_MODNAME)_LINKLIBFILES) $($(TMP_MODNAME)_RELLINKLIBFILES)
TMP_GENTARGETS := $(addsuffix .c,$(TMP_GENTARGETS))
TMP_STUBTARGETS := $(addsuffix .c,$(TMP_STUBTARGETS)) \
               $(addsuffix .S, $($(TMP_MODNAME)_LINKLIBAFILES) $($(TMP_MODNAME)_RELLINKLIBAFILES))

TMP_DEPS := $(GENMODULE)
ifneq (%(conffile),)
    ifeq ($(dir %(conffile)),./)
        TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(conffile)
        TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(conffile)
    else
        TMP_OPTS += -c %(conffile)
        TMP_DEPS += %(conffile)
    endif 
else
    TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(modname).conf
    TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETDIR := $(shell echo %(targetdir) | sed 's/^\(.\):\//\/\1\//')
    TMP_GENTARGETS := $(addprefix $(TMP_TARGETDIR)/,$(TMP_GENTARGETS))
    TMP_GENFILEFLAG=$(TMP_TARGETDIR)/.%(modname).%(modtype)-genfiles
else
    TMP_GENFILEFLAG=$(GENDIR)/$(CURDIR)/.%(modname).%(modtype)-genfiles
endif
ifneq (%(stubdir),)
    TMP_OPTS += -l %(stubdir)
    TMP_STUBTARGETDIR := $(shell echo %(stubdir) | sed 's/^\(.\):\//\/\1\//')
    TMP_STUBTARGETS := $(addprefix $(TMP_STUBTARGETDIR)/,$(TMP_STUBTARGETS))
    TMP_TARGETDIRS += %(stubdir)
else
ifneq (%(targetdir),)
    TMP_STUBTARGETS := $(addprefix $(TMP_TARGETDIR)/,$(TMP_STUBTARGETS))
endif
endif

TMP_TARGETS := $(TMP_GENTARGETS) $(TMP_STUBTARGETS)
ifneq ($(TMP_TARGETDIRS),)
$(TMP_TARGETS) : | $(TMP_TARGETDIRS)
endif

$(TMP_TARGETS) : $(TMP_DEPS) $(TMP_GENFILEFLAG)

$(TMP_GENFILEFLAG) : OPTS := $(TMP_OPTS)
$(TMP_GENFILEFLAG) : MODNAME := %(modname)
$(TMP_GENFILEFLAG) : MODTYPE := %(modtype)
$(TMP_GENFILEFLAG) : $(TMP_DEPS)
	@$(ECHO) "Generating support files for module $(MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) $(OPTS) writefiles $(MODNAME) $(MODTYPE)
	@$(TOUCH) $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule_includes modname=/A flavour= modtype=/A modsuffix= \
    targetdir= conffile=

ifneq (%(flavour),)
    TMP_MODNAME := %(modname)_%(flavour)
else
    TMP_MODNAME := %(modname)
endif

ifneq ($($(TMP_MODNAME)_INCLUDES),)

TMP_TARGETS := $($(TMP_MODNAME)_INCLUDES)

TMP_DEPS := $(GENMODULE)
TMP_OPTS :=

ifneq (%(conffile),)
    ifeq ($(dir %(conffile)),./)
        TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(conffile)
        TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(conffile)
    else
        TMP_OPTS += -c %(conffile)
        TMP_DEPS += %(conffile)
    endif 
else
    TMP_OPTS += -c $(SRCDIR)/$(CURDIR)/%(modname).conf
    TMP_DEPS += $(SRCDIR)/$(CURDIR)/%(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
    TMP_GENINCFLAG=%(targetdir)/.%(modname).%(modtype)-includes
else
    TMP_GENINCFLAG=$(GENDIR)/$(CURDIR)/.%(modname).%(modtype)-includes
endif

$(TMP_TARGETS) : $(TMP_DEPS) $(TMP_GENINCFLAG)

$(TMP_GENINCFLAG) : OPTS := $(TMP_OPTS)
$(TMP_GENINCFLAG) : MODNAME := %(modname)
$(TMP_GENINCFLAG) : MODTYPE := %(modtype)
$(TMP_GENINCFLAG) : $(TMP_DEPS)
	@$(ECHO) "Generating $(MODNAME).$(MODTYPE) includes"
	@$(GENMODULE) $(OPTS) writeincludes $(MODNAME) $(MODTYPE)
	@$(TOUCH) $@
endif
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Link %(objs) to binary blob in %(file) using %(name) as name of embedded binary object
# 'start' is an optional starting address
# 'ldflags' is optional additional flags for the linker
%define rule_link_binary mmake=BD file=/A name=/A objs= files= start=0 ldflags=

%(mmake)_OUTDIR := $(dir %(file))
# This trick removes the trailing '/', otherwise findstring below fails, causing a warning
%(mmake)_OUTDIR := $(subst /*,,$(addsuffix *,$(%(mmake)_OUTDIR)))
%(mmake)_TMPDIR := $(GENDIR)/$(CURDIR)
%(mmake)_OBJS := $(addsuffix .o,$(addprefix $(%(mmake)_OBJDIR)/,$(notdir %(files))))
%(mmake)_DEPS := $(addsuffix .d,$(addprefix $(%(mmake)_OBJDIR)/,$(notdir %(files))))
%(mmake)_OBJS += %(objs)

%rule_compile_multi basenames="%(files)" targetdir=$(%(mmake)_OBJDIR)

%(file) : $(%(mmake)_OBJS) $(%(mmake)_DEPS) $(%(mmake)_OUTDIR)
	@$(ECHO) "Linking    $(subst $(TARGETDIR)/,,$@)..."
	@$(KERNEL_LD) %(ldflags) --entry=%(start) --oformat=binary -Ttext=%(start) -o $(%(mmake)_TMPDIR)/%(name) $(%(mmake)_OBJS)
	@cd $(%(mmake)_TMPDIR) && $(AROS_LD) %(ldflags) -r --format binary %(name) -o $@

ifeq ($(findstring $(%(mmake)_OUTDIR),$(GLOB_MKDIRS)),)
    GLOB_MKDIRS += $(%(mmake)_OUTDIR)
endif

%end

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(SRCDIR)/config/make.tail

BDID := $(BDTARGETID)
%end
#------------------------------------------------------------------------------
      

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile build macros. These are macros that takes care   ##
## of everything to go from the sources to the generated target. Also all  ##
## intermediate files and directories that are needed are created by these ##
## rules.                                                                  ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Build a program
%define build_prog mmake=/A progname=/A files= cxxfiles= \
    objcfiles= \
    asmfiles= objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= cxxflags=$(CXXFLAGS) dxxflags= ldflags=$(LDFLAGS) \
    aflags=$(AFLAGS) uselibs= usehostlibs= usestartup=yes detach=no nix=no \
    includedir= libdir= \
    compiler=target linker= \
    coverageinstr=$(TARGET_COVERAGEINSTR) lto=$(TARGET_LTO)

.PHONY : %(mmake)

%(mmake)_PROGNAME  := %(progname)
%(mmake)_OBJDIR    := %(objdir)
%(mmake)_TARGETDIR := %(targetdir)
%(mmake)_LINKER    := %(linker)
%(mmake)_LIBS := %(uselibs)
# If not supplied, linker is equal to compiler
ifeq ($(%(mmake)_LINKER),)
    %(mmake)_LINKER := %(compiler)
endif

ifneq ("$(strip %(files) %(cxxfiles) %(objcfiles) %(asmfiles))","")
    %(mmake)_FILES     := %(files)
    %(mmake)_OBJCFILES := %(objcfiles)
    %(mmake)_ASMFILES  := %(asmfiles)
    %(mmake)_CXXFILES := %(cxxfiles)
else
    %(mmake)_FILES     := $(%(mmake)_PROGNAME)
    %(mmake)_OBJCFILES :=
    %(mmake)_ASMFILES  :=
    %(mmake)_CXXFILES :=
endif

%(mmake)_ARCHOBJS   := $(wildcard $(%(mmake)_OBJDIR)/arch/*.o)
%(mmake)_ARCHFILES  := $(basename $(notdir $(%(mmake)_ARCHOBJS)))
%(mmake)_C_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_FILES))
%(mmake)_CXX_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_CXXFILES))
%(mmake)_OBJC_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_OBJCFILES))

TMP_FILES := $(%(mmake)_C_NARCHFILES) $(%(mmake)_CXX_NARCHFILES) $(%(mmake)_ASMFILES) $(%(mmake)_OBJC_NARCHFILES)
%(mmake)_OBJS := $(addsuffix .o,$(addprefix $(%(mmake)_OBJDIR)/,$(notdir $(TMP_FILES))))
%(mmake)_DEPS := $(addsuffix .d,$(addprefix $(%(mmake)_OBJDIR)/,$(notdir $(TMP_FILES))))

%(mmake)_CPPFLAGS :=  %(cppflags)
ifneq (%(includedir),)
%(mmake)_CPPFLAGS    += -I%(includedir)
endif
%(mmake)_CFLAGS    := %(cflags)
%(mmake)_CXXFLAGS := %(cxxflags)
%(mmake)_COVERAGE := no
ifeq (%(compiler),target)
ifeq (%(usestartup),yes)
ifeq (%(coverageinstr),yes)
%(mmake)_COVERAGE := yes
%(mmake)_CFLAGS    := $(strip $(COVERAGEINSTR_FLAGS) $(%(mmake)_CFLAGS))
%(mmake)_CXXFLAGS := $(strip $(COVERAGEINSTR_FLAGS) $(%(mmake)_CXXFLAGS))
%(mmake)_LIBS += gcov
endif
endif
ifeq (%(lto),yes)
%(mmake)_CFLAGS    := $(strip $(LTO_BINARY_CFLAGS) $(%(mmake)_CFLAGS))
%(mmake)_CXXFLAGS := $(strip $(LTO_BINARY_CFLAGS) $(%(mmake)_CXXFLAGS))
endif
endif
%(mmake)_AFLAGS    := %(aflags)
ifneq (%(dflags),)
    %(mmake)_DFLAGS     := %(dflags)
else
    %(mmake)_DFLAGS     := $(%(mmake)_CFLAGS)
endif
ifneq (%(dxxflags),)
    %(mmake)_DXXFLAGS     := %(dxxflags)
else
    %(mmake)_DXXFLAGS     := $(%(mmake)_CXXFLAGS)
endif
%(mmake)_LDFLAGS   := %(ldflags)
ifneq (%(libdir),)
%(mmake)_LDFLAGS   += -L%(libdir)
endif

#MM
%(mmake)-quick : %(mmake)

#MM %(mmake) : includes-generate-deps core-linklibs
%(mmake) : $(%(mmake)_TARGETDIR)/$(%(mmake)_PROGNAME)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick %(mmake)-gz-quick),)
%rule_compile_cxx_multi mmake=%(mmake) \
    basenames=$(%(mmake)_CXX_NARCHFILES) targetdir=$(%(mmake)_OBJDIR) \
    cppflags=$(%(mmake)_CPPFLAGS) cxxflags=$(%(mmake)_CXXFLAGS) dxxflags=$(%(mmake)_DXXFLAGS) \
    compiler="%(compiler)"
%rule_compile_objc_multi mmake=%(mmake) \
    basenames=$(%(mmake)_OBJC_NARCHFILES) targetdir=$(%(mmake)_OBJDIR) \
    cppflags=$(%(mmake)_CPPFLAGS) cflags=$(%(mmake)_CFLAGS) dflags=$(%(mmake)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake) \
    basenames=$(%(mmake)_C_NARCHFILES) targetdir=$(%(mmake)_OBJDIR) \
    cppflags=$(%(mmake)_CPPFLAGS) cflags=$(%(mmake)_CFLAGS) dflags=$(%(mmake)_DFLAGS) \
    compiler="%(compiler)"
%rule_assemble_multi mmake=%(mmake) \
    cmd=$(%(mmake)_ASSEMBLER) basenames=$(%(mmake)_ASMFILES) targetdir=$(%(mmake)_OBJDIR) \
    cppflags=$(%(mmake)_CPPFLAGS) aflags=$(%(mmake)_AFLAGS)

%rule_link_prog mmake=%(mmake) prog=$(%(mmake)_TARGETDIR)/$(%(mmake)_PROGNAME) \
    objs="$(%(mmake)_OBJS) $(%(mmake)_ARCHOBJS) $(USER_OBJS)" ldflags=$(%(mmake)_LDFLAGS) \
    uselibs="$(%(mmake)_LIBS)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" nix="%(nix)" \
    cmd=$(%(mmake)_LINK) strip=$(%(mmake)_STRIP) objdir=$(%(mmake)_OBJDIR) coverageinstr=$(%(mmake)_COVERAGE) 

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(%(mmake)_DEPS)

$(%(mmake)_OBJS) $(%(mmake)_DEPS) : | $(%(mmake)_OBJDIR)
$(%(mmake)_TARGETDIR)/$(%(mmake)_PROGNAME) : | $(%(mmake)_TARGETDIR)
GLOB_MKDIRS += $(%(mmake)_OBJDIR) $(%(mmake)_TARGETDIR)

%(mmake)-clean : FILES := $(%(mmake)_OBJS) $(%(mmake)_TARGETDIR)/$(%(mmake)_PROGNAME) $(%(mmake)_DEPS)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build programs, for every C file an executable will be built with the same
# name as the C file
%define build_progs mmake=/A files=/A nix=no \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= ldflags=$(LDFLAGS) \
    includedir= libdir= \
    compiler=target \
    uselibs= usehostlibs= usestartup=yes detach=no \
    coverageinstr=$(TARGET_COVERAGEINSTR) lto=$(TARGET_LTO)

.PHONY : %(mmake)

%(mmake)_OBJDIR    := %(objdir)
%(mmake)_TARGETDIR := %(targetdir)
%(mmake)_LIBS := %(uselibs)

%(mmake)_FILES     := %(files)
%(mmake)_OBJS      := $(addsuffix .o,$(addprefix $(%(mmake)_OBJDIR)/,$(%(mmake)_FILES)))
%(mmake)_DEPS      := $(addsuffix .d,$(addprefix $(%(mmake)_OBJDIR)/,$(%(mmake)_FILES)))
%(mmake)_EXES      := $(addprefix $(%(mmake)_TARGETDIR)/,$(%(mmake)_FILES))

%(mmake)_CPPFLAGS := %(cppflags)
ifneq (%(includedir),)
    %(mmake)_CPPFLAGS += -I%(includedir)
endif
%(mmake)_CFLAGS    := %(cflags)
%(mmake)_COVERAGE := no
ifeq (%(compiler),target)
ifeq (%(usestartup),yes)
ifeq (%(coverageinstr),yes)
%(mmake)_COVERAGE := yes
%(mmake)_CFLAGS    := $(strip $(COVERAGEINSTR_FLAGS) $(%(mmake)_CFLAGS))
%(mmake)_LIBS += gcov
endif
endif
ifeq (%(lto),yes)
%(mmake)_CFLAGS    := $(strip $(LTO_BINARY_CFLAGS) $(%(mmake)_CFLAGS))
endif
endif
ifneq (%(dflags),)
    %(mmake)_DFLAGS := %(dflags)
else
    %(mmake)_DFLAGS := $(%(mmake)_CFLAGS)
endif
%(mmake)_LDFLAGS   := %(ldflags)
ifneq (%(libdir),)
    %(mmake)_LDFLAGS += -L%(libdir)
endif

#MM
%(mmake)-quick : %(mmake)

#MM %(mmake) : includes-generate-deps core-linklibs
%(mmake) : $(%(mmake)_EXES)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile_multi mmake=%(mmake) basenames=$(%(mmake)_FILES) targetdir=$(%(mmake)_OBJDIR) \
    cflags=$(%(mmake)_CFLAGS) cppflags=$(%(mmake)_CPPFLAGS) dflags=$(%(mmake)_DFLAGS) compiler="%(compiler)"

%rule_link_progs mmake=%(mmake) progs=$(%(mmake)_FILES) nix="%(nix)" \
    targetdir=$(%(mmake)_TARGETDIR) objdir=$(%(mmake)_OBJDIR) \
    ldflags=$(%(mmake)_LDFLAGS) \
    uselibs="$(%(mmake)_LIBS)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" \
    cmd=$(%(mmake)_LINK) strip=$(%(mmake)_STRIP) objdir=$(%(mmake)_OBJDIR) coverageinstr=$(%(mmake)_COVERAGE)

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(%(mmake)_DEPS)

$(addprefix $(%(mmake)_TARGETDIR)/,$(%(mmake)_FILES)) : | $(%(mmake)_TARGETDIR)
$(%(mmake)_DEPS) $(%(mmake)_OBJS) : | $(%(mmake)_OBJDIR)
GLOB_MKDIRS += $(%(mmake)_TARGETDIR) $(%(mmake)_OBJDIR)

%(mmake)-clean : FILES := $(%(mmake)_OBJS) $(%(mmake)_EXES) $(%(mmake)_DEPS)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module.
# This is a bare version: It just compiles and links the given files. It is
# assumed that all needed boiler plate code is in the files. This should only
# be used for compiling external code. For AROS code use %build_module
%define build_module_simple mmake=/A modname=/A modtype=/A \
    files="$(basename $(call WILDCARD, *.c))" \
    objcfiles= \
    cxxfiles="$(basename $(call WILDCARD $(foreach CXX_EXT, $(AROS_CXXEXTS), *.$(CXX_EXT))))" \
    cppflags=$(CPPFLAGS) \
    cflags=$(CFLAGS) dflags= \
    cxxflags=$(CXXFLAGS) dxxflags= \
    objdir=$(OBJDIR) moduledir= \
    uselibs= usehostlibs= compiler=target lto=$(TARGET_LTO)

# Define metamake targets and their dependencies
#MM %(mmake) : core-linklibs includes-generate-deps
#MM %(mmake)-kobj : core-linklibs includes-generate-deps
#MM %(mmake)-kobj-quick
#MM %(mmake)-quick
#MM %(mmake)-clean

%(mmake)_ALLTARGETS := %(mmake) %(mmake)-clean %(mmake)-quick %(mmake)-kobj

.PHONY : $(%(mmake)_ALLTARGETS)

ifeq (%(modname),)
$(error using %build_module_simple: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module_simple: $(MODTYPE) has to be defined with the type of the module)
endif

# Default values for variables and arguments
%(mmake)_DEFLINKLIBNAME := %(modname)
%(mmake)_CFLAGS := %(cflags)
%(mmake)_CXXFLAGS := %(cxxflags)
ifeq (%(compiler),target)
ifeq (%(lto),yes)
%(mmake)_CFLAGS    := $(strip $(LTO_BINARY_CFLAGS) $(CFLAGS_NO_STRICT_ALIASING) $(%(mmake)_CFLAGS))
endif
endif
ifneq (%(dflags),)
    %(mmake)_DFLAGS := %(dflags)
else
    %(mmake)_DFLAGS := $(%(mmake)_CFLAGS)
endif
%(mmake)_DEFDXXFLAGS := %(dxxflags)
OBJDIR ?= $(GENDIR)/$(CURDIR)
%(mmake)_MODDIR := %(moduledir)
ifeq ($(%(mmake)_MODDIR),)
  ifeq (%(modtype),library)
    %(mmake)_MODDIR  := $(AROS_LIBRARIES)
  endif
  ifeq (%(modtype),gadget)
    %(mmake)_MODDIR  := $(AROS_GADGETS)
  endif
  ifeq (%(modtype),datatype)
    %(mmake)_MODDIR  := $(AROS_DATATYPES)
  endif
  ifeq (%(modtype),handler)
    %(mmake)_MODDIR  := $(AROS_FS)
  endif
  ifeq (%(modtype),device)
    %(mmake)_MODDIR  := $(AROS_DEVS)
  endif
  ifeq (%(modtype),resource)
    %(mmake)_MODDIR  := $(AROS_RESOURCES)
  endif
  ifeq (%(modtype),hook)
    %(mmake)_MODDIR  := $(AROS_RESOURCES)
  endif
  ifeq (%(modtype),mui)
    %(mmake)_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),mcc)
    %(mmake)_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),mcp)
    %(mmake)_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),usbclass)
    %(mmake)_MODDIR  := $(AROS_CLASSES)/USB
  endif
  ifeq (%(modtype),hidd)
    %(mmake)_MODDIR  := $(AROS_DRIVERS)
  endif
  ifeq (%(modtype),printer)
    %(mmake)_MODDIR  := $(AROS_PRINTERS)
  endif
endif
ifeq ($(%(mmake)_MODDIR),)
  $(error Don't know where to put the file for modtype %(modtype). Specify moduledir=)
endif

%(mmake)_ARCHOBJS   := $(wildcard %(objdir)/arch/*.o)
%(mmake)_ARCHFILES  := $(basename $(notdir $(%(mmake)_ARCHOBJS)))
%(mmake)_C_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),%(files))
%(mmake)_CXX_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),%(cxxfiles))
%(mmake)_OBJC_NARCHFILES := $(filter-out $(%(mmake)_ARCHFILES),%(objcfiles))

%rule_compile_cxx_multi mmake=%(mmake) \
    basenames=$(%(mmake)_CXX_NARCHFILES) targetdir="%(objdir)" \
    cppflags="%(cppflags)" cxxflags=$(%(mmake)_CXXFLAGS) dxxflags=$(%(mmake)_DXXFLAGS) \
    compiler="%(compiler)"
%rule_compile_objc_multi mmake=%(mmake) \
    basenames=$(%(mmake)_OBJC_NARCHFILES) targetdir="%(objdir)" \
    cppflags="%(cppflags)" cflags=$(%(mmake)_CFLAGS) dflags=$(%(mmake)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake) \
    basenames=$(%(mmake)_C_NARCHFILES) targetdir="%(objdir)" \
    cppflags="%(cppflags)" cflags="$(%(mmake)_CFLAGS)" dflags="$(%(mmake)_DFLAGS)" \
    compiler="%(compiler)"

# Handlers use dash instead of dot in their names
ifeq (%(modtype),handler)
%(mmake)_MODULE := $(%(mmake)_MODDIR)/%(modname)-%(modtype)
else
ifeq (%(modtype),printer)
%(mmake)_MODULE := $(%(mmake)_MODDIR)/%(modname)
else
%(mmake)_MODULE := $(%(mmake)_MODDIR)/%(modname).%(modtype)
endif
endif
%(mmake)_KOBJ   := $(KOBJSDIR)/%(modname)_%(modtype).o

%(mmake)-quick : %(mmake)
%(mmake)-kobj-quick : $(%(mmake)_KOBJ)
%(mmake)       : $(%(mmake)_MODULE)
%(mmake)-kobj  : $(%(mmake)_KOBJ)

# The module is linked from all the compiled .o files
%(mmake)_OBJS       := $(%(mmake)_ARCHOBJS) $(addprefix %(objdir)/, $(addsuffix .o,$(notdir $(%(mmake)_C_NARCHFILES))))

# Under Windows con* is a reserved name, it refers to console. Files with such names can't be created.
# This breaks con-handler build. Here we work around this
ifeq (%(modname),con)
    %(mmake)_ERR := $(notdir $(%(mmake)_MODULE)).err
else
    %(mmake)_ERR := %(modname).err
endif

%rule_linkmodule module=$(%(mmake)_MODULE) objs=$(%(mmake)_OBJS) \
		 endobj= err=$(%(mmake)_ERR) objdir="%(objdir)" \
		 ldflags="$(strip $(LDFLAGS) $(%(modname)_LDFLAGS))" \
		 uselibs="%(uselibs) $(%(modname)_LIBS)" usehostlibs="%(usehostlibs)"

# Link kernel object file
%(mmake)_KAUTOLIB := dos intuition layers graphics oop utility expansion keymap

# Make these symbols local
%(mmake)_KBASE := DOSBase IntuitionBase LayersBase GfxBase OOPBase \
	    UtilityBase ExpansionBase KeymapBase KernelBase

%(mmake)_SYMBOLS := $(%(mmake)_KBASE)

%(mmake)_KLIB := hiddstubs amiga arossupport autoinit libinit
%(mmake)_KOBJ_LIBS := $(filter-out $(%(mmake)_KLIB),%(uselibs)) $(%(mmake)_KAUTOLIB)
$(%(mmake)_KOBJ) : LINKLIBS:=$(%(mmake)_KOBJ_LIBS)
$(%(mmake)_KOBJ) : FILTBASES:=$(addprefix -L ,$(%(mmake)_SYMBOLS))
$(%(mmake)_KOBJ) : USER_LDFLAGS := $(USER_LDFLAGS)
$(%(mmake)_KOBJ) : $(%(mmake)_OBJS) $(%(mmake)_ENDOBJS)
	@$(ECHO) "Linking    $(subst $(TARGETDIR)/,,$@)"
	@$(AROS_LD) -Ur -o $@ $^ $(USER_LDFLAGS) -L$(AROS_LIB) $(addprefix -l,$(LINKLIBS))
	@$(OBJCOPY) $@ $(FILTBASES) `$(NM_PLAIN) $@ | $(AWK) '($$3 ~ /^__.*_(LIST|END)__\r?$$/) || ($$3 ~ /^__aros_lib.*\r?$$/) {print "-L " $$3;}'`


## Dependency fine-tuning
##
%(mmake)_DEPS       := $(addprefix %(objdir)/, $(addsuffix .d,%(files)))
%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-kobj" deps=$(%(mmake)_DEPS)

$(%(mmake)_OBJS) $(%(mmake)_DEPS) : | %(objdir)
$(%(mmake)_MODULE) : | $(%(mmake)_MODDIR)
$(%(mmake)_KOBJ) : | $(KOBJSDIR)
GLOB_MKDIRS += %(objdir) $(%(mmake)_MODDIR) $(KOBJSDIR)

%(mmake)-clean : FILES := $(%(mmake)_OBJS) $(%(mmake)_MODULE) $(%(mmake)_KOBJ) $(%(mmake)_DEPS)
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module %(modname)"
	@$(RM) $(FILES)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module - core routine
# Explanation of this macro is done in the developer's manual
%define build_module_core mmake=/A modname=/A modtype=/A modsuffix= version= flavour= conffile= \
    files="$(basename $(call WILDCARD, *.c))" \
    objcfiles= \
    cxxfiles="$(basename $(call WILDCARD $(foreach CXX_EXT, $(AROS_CXXEXTS), *.$(CXX_EXT))))" \
    linklibfiles= linklibobjs= \
    cppflags=$(CPPFLAGS) \
    cflags=$(CFLAGS) dflags= \
    cxxflags=$(CXXFLAGS) dxxflags= \
    objdir= moduledir= prefix=$(AROSDIR) \
    linklibname= uselibs= usehostlibs= \
    compiler=target lto=$(TARGET_LTO) nostartup=yes archspecific=no \
    includedir= libdir= \
    build_abi= build_library=

# We will employ a terrifying, but unavoidable, hack here.
# genmf has no concept of conditionals (ie %ifeq), and MetaMake
# ignores GNU Make ifeq() statements, but will process any #MM
# headed lines in the file.
# 
# So, to make the following #MM lines conditional on whether we want
# to build the ABI, Library, or both, we define build_abi= and 
# build_library as 'M' to enable, or '' to disable, which allows genmf
# to do the following conversions:
# 
#  #%(build_abi)M includes-foo: foo-include
#    becomes, when build_abi=M
#  #MM includes-foo: foo-include   <= Processed by MetaMake
#    but, when build_abi= ...
#  #M includes-foo: foo-includes   <= ignored by MetaMake! Yes!
# 
# Taking full blame for this: Jason S. McMullan <jason.mcmullan@gmail.com>

# Define metamake targets and their dependencies
#MM %(mmake)
#MM %(mmake)-quick
#MM %(mmake)-makefile
#MM %(mmake)-clean

# ABI targets:
#M%(build_abi)- includes-all : %(mmake)-includes
#M%(build_abi)- linklibs-%(modname): %(mmake)-linklib
#M%(build_abi)- linklibs-%(modname)_rel : %(mmake)-linklib
#M%(build_abi)- includes-%(modname): %(mmake)-includes
#M%(build_abi)- includes-%(modname)_rel : %(mmake)-includes
#M%(build_abi)- %(mmake) : %(mmake)-includes core-linklibs linklibs-%(uselibs)
#M%(build_abi) %(mmake)-linklib : %(mmake)-includes includes-%(uselibs)
#M%(build_abi)- %(mmake)-quick : %(mmake)-includes-quick
#M%(build_abi) %(mmake)-includes : %(mmake)-makefile %(mmake)-includes-dirs \
#M%(build_abi)     includes-generate-deps %(mmake)-fd
#M%(build_abi) %(mmake)-includes-quick
#M%(build_abi) %(mmake)-includes-dirs
#M%(build_abi) %(mmake)-fd

# Library targets
#%(build_library)M %(mmake)-kobj : core-linklibs linklibs-%(uselibs)
#%(build_library)M %(mmake)-kobj-quick : 

# Library with ABI targets:
#%(build_library)%(build_abi) %(mmake)-kobj : %(mmake)-includes core-linklibs linklibs-%(uselibs)
#%(build_library)%(build_abi) %(mmake)-kobj-quick : %(mmake)-includes-quick

# All MetaMake targets defined by this macro
%(mmake)%(flavour)_ALLTARGETS := %(mmake) %(mmake)-quick %(mmake)-clean

ifeq (%(build_library),M)
%(mmake)%(flavour)_ALLTARGETS += %(mmake)-kobj %(mmake)-kobj-quick
endif

ifeq (%(build_abi),M)
%(mmake)%(flavour)_ALLTARGETS += %(mmake)-includes \
                 %(mmake)-includes-quick %(mmake)-includes-dirs  \
                 %(mmake)-linklib %(mmake)-fd
endif

.PHONY : $(%(mmake)%(flavour)_ALLTARGETS) %(mmake)-makefile

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# Default values for variables and arguments
ifneq (%(flavour),)
    %(mmake)%(flavour)_DEFNAME := %(modname)_%(flavour)
else
    %(mmake)%(flavour)_DEFNAME := %(modname)
endif
%(mmake)%(flavour)_DEFLINKLIBNAME := $(%(mmake)%(flavour)_DEFNAME)
ifneq (%(linklibname),)
    %(mmake)%(flavour)_LINKLIBNAME := %(linklibname)
else
    %(mmake)%(flavour)_LINKLIBNAME := $(%(mmake)%(flavour)_DEFLINKLIBNAME)
endif
%(mmake)%(flavour)_DEFCPPFLAGS := %(cppflags)
ifneq (%(includedir),)
    %(mmake)%(flavour)_DEFCPPFLAGS += -I%(includedir)
endif
%(mmake)%(flavour)_DEFDFLAGS := %(cflags)
ifneq (%(dflags),)
    %(mmake)%(flavour)_DFLAGS := %(dflags)
else
    %(mmake)%(flavour)_DFLAGS := $(%(mmake)%(flavour)_DEFDFLAGS)
endif
%(mmake)%(flavour)_DEFDXXFLAGS := %(cxxflags)
ifneq (%(dxxflags),)
    %(mmake)%(flavour)_DXXFLAGS := %(dxxflags)
else
    %(mmake)%(flavour)_DXXFLAGS := $(%(mmake)%(flavour)_DEFDXXFLAGS)
endif
ifeq (%(lto),yes)
ifeq (%(compiler),target)
%(mmake)%(flavour)_DEFDFLAGS    := $(strip $(LTO_BINARY_CFLAGS) $(CFLAGS_NO_STRICT_ALIASING) $(NOWARN_LTO_TYPE_MISMATCH) $(%(mmake)%(flavour)_DEFDFLAGS))
%(mmake)%(flavour)_DEFDXXFLAGS := $(strip $(LTO_BINARY_CFLAGS) $(CFLAGS_NO_STRICT_ALIASING) $(NOWARN_LTO_TYPE_MISMATCH) $(%(mmake)%(flavour)_DEFDXXFLAGS))
endif
endif
OBJDIR ?= $(GENDIR)/$(CURDIR)
ifneq (%(objdir),)
%(mmake)_OBJDIR := %(objdir)
ifneq (%(flavour),)
%(mmake)%(flavour)_OBJDIR := %(objdir)
endif
else
%(mmake)_OBJDIR := $(OBJDIR)/%(modname)
ifneq (%(flavour),)
%(mmake)%(flavour)_OBJDIR := $(OBJDIR)/$(%(mmake)%(flavour)_DEFNAME)
endif
endif

## Create genmodule include Makefile for the module
##
%(mmake)-makefile : $(%(mmake)%(flavour)_OBJDIR)/Makefile.$(%(mmake)%(flavour)_DEFNAME)%(modtype)

%rule_genmodule_makefile \
    modname="%(modname)" flavour="%(flavour)" modtype="%(modtype)" \
    modsuffix="%(modsuffix)" targetdir="$(%(mmake)%(flavour)_OBJDIR)" \
    conffile="%(conffile)"

$(%(mmake)%(flavour)_OBJDIR)/Makefile.$(%(mmake)%(flavour)_DEFNAME)%(modtype) : | $(%(mmake)%(flavour)_OBJDIR)

GLOB_MKDIRS += $(%(mmake)%(flavour)_OBJDIR)
ifneq (%(flavour),)
GLOB_MKDIRS += $(%(mmake)%(flavour)_OBJDIR)
endif

# Do not parse these statements if metatarget is not appropriate
ifneq ($(filter $(TARGET),$(%(mmake)%(flavour)_ALLTARGETS)),)

# suppress makes warning that the Makefile doesnt yet exist
# on early passes (it will generate the file as needed though)
# when we include it.
-include $(%(mmake)%(flavour)_OBJDIR)/Makefile.$(%(mmake)%(flavour)_DEFNAME)%(modtype)

%(mmake)%(flavour)_DEFMODDIR := $($(%(mmake)%(flavour)_DEFNAME)_MODDIR)
ifeq (%(archspecific),yes)
%(mmake)%(flavour)_DEFMODDIR := $(AROS_DIR_ARCH)/$(%(mmake)%(flavour)_DEFMODDIR)
endif
ifneq (%(moduledir),)
    %(mmake)%(flavour)_MODDIR := %(moduledir)
else
    %(mmake)%(flavour)_MODDIR := $(%(mmake)%(flavour)_DEFMODDIR)
endif

## include files generation
##
ifneq (%(includedir),)
%(mmake)%(flavour)_INCDIR    := %(includedir)
else
%(mmake)%(flavour)_INCDIR    := %(prefix)/$(AROS_DIR_DEVELOPER)/$(AROS_DIR_INCLUDE)
endif
%(mmake)%(flavour)_LIBDEFSINC := $(%(mmake)%(flavour)_OBJDIR)/include/$(%(mmake)%(flavour)_DEFNAME)_libdefs.h
%(mmake)%(flavour)_DEFLIBDEFSINC := $(%(mmake)%(flavour)_OBJDIR)/include/$(%(mmake)%(flavour)_DEFNAME)_deflibdefs.h

ifeq (%(build_abi),M)
%(mmake)-includes-quick : %(mmake)-includes
%(mmake)-includes : $(addprefix $(GENINCDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES)) \
    $(addprefix $(%(mmake)%(flavour)_INCDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES)) \
    $(%(mmake)%(flavour)_LIBDEFSINC) $(%(mmake)%(flavour)_DEFLIBDEFSINC)

ifneq ($($(%(mmake)%(flavour)_DEFNAME)_INCLUDES),)
%rule_genmodule_includes modname="%(modname)" modtype="%(modtype)" \
		      	 modsuffix="%(modsuffix)" targetdir="$(%(mmake)_OBJDIR)/include" \
		      	 conffile="%(conffile)" flavour="%(flavour)"

%rule_copy_diff_multi \
    files=$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES) srcdir="$(%(mmake)_OBJDIR)/include" targetdir=$(GENINCDIR) \
    stampfile="$(%(mmake)_OBJDIR)/%(modname)_geninc"

%rule_copy_diff_multi \
    files=$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES) srcdir="$(%(mmake)_OBJDIR)/include" targetdir=$(%(mmake)%(flavour)_INCDIR) \
    stampfile="$(%(mmake)_OBJDIR)/%(modname)_incs"

%(mmake)%(flavour)_INCDIRS := $(filter-out ./,$(sort $(dir $($(%(mmake)%(flavour)_DEFNAME)_INCLUDES))))

TMP%(modname)_INCDIRS := \
    $(%(mmake)_OBJDIR)/include $(addprefix $(%(mmake)_OBJDIR)/include/,$(%(mmake)%(flavour)_INCDIRS)) \
    $(GENINCDIR) $(addprefix $(GENINCDIR)/,$(%(mmake)%(flavour)_INCDIRS)) \
    $(%(mmake)%(flavour)_INCDIR) $(addprefix $(%(mmake)%(flavour)_INCDIR)/,$(%(mmake)%(flavour)_INCDIRS))
%rule_makedirs dirs=$(TMP%(modname)_INCDIRS) setuptarget="%(mmake)-includes-dirs"

endif

endif

%rule_genmodule_genlibdefs modname="%(modname)" flavour="%(flavour)" modtype="%(modtype)" \
    modsuffix="%(modsuffix)" targetdir="$(%(mmake)%(flavour)_OBJDIR)/include" \
    conffile="%(conffile)" version="%(version)"

$(%(mmake)%(flavour)_DEFLIBDEFSINC) : FILENAME := $(%(mmake)%(flavour)_LIBDEFSINC)
$(%(mmake)%(flavour)_DEFLIBDEFSINC) :
	@$(ECHO) "Generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(FILENAME)\"" >$@

$(%(mmake)%(flavour)_LIBDEFSINC) $(%(mmake)%(flavour)_DEFLIBDEFSINC) : | $(%(mmake)%(flavour)_OBJDIR)/include
GLOB_MKDIRS += $(%(mmake)%(flavour)_OBJDIR)/include

## Extra genmodule src files generation
## 
%rule_genmodule_files modname="%(modname)" modtype="%(modtype)" \
    modsuffix="%(modsuffix)" targetdir="$(%(mmake)%(flavour)_OBJDIR)" stubdir="$(%(mmake)%(flavour)_OBJDIR)/linklib" \
    conffile="%(conffile)" flavour="%(flavour)"

GLOB_MKDIRS += $(%(mmake)%(flavour)_OBJDIR)/linklib

ifeq (%(build_abi),M)
## Create FD file
ifeq (%(includedir),)
%(mmake)%(flavour)_FDDIR := %(prefix)/$(AROS_DIR_DEVELOPER)/fd
else
%(mmake)%(flavour)_FDDIR := %(includedir)/../fd
endif
%(mmake)-fd : $(%(mmake)%(flavour)_FDDIR)/%(modname)_lib.fd

%rule_genmodule_fd modname="%(modname)" modtype="%(modtype)" \
    modsuffix="%(modsuffix)" targetdir=$(%(mmake)%(flavour)_FDDIR) conffile="%(conffile)"

$(%(mmake)%(flavour)_FDDIR)/%(modname)_lib.fd : | $(%(mmake)%(flavour)_FDDIR)

GLOB_MKDIRS += $(%(mmake)%(flavour)_FDDIR)
endif

## Compilation
##
%(mmake)%(flavour)_FILES            := %(files)
%(mmake)%(flavour)_OBJCFILES        := %(objcfiles)
%(mmake)%(flavour)_CXXFILES         := %(cxxfiles)

%(mmake)%(flavour)_LIBFILES         := %(linklibfiles)

%(mmake)%(flavour)_FDIRS            := $(sort $(dir $(%(mmake)%(flavour)_FILES)))

%(mmake)%(flavour)_FILEMATCH        = $(and $(findstring $(1),$(2)),$(findstring $(2),$(1)))
%(mmake)%(flavour)_MATCHARCH        = $(foreach matchfile,$(2),$(foreach archfile,$(1),$(if $(call %(mmake)%(flavour)_FILEMATCH,$(archfile),$(notdir $(matchfile))),$(matchfile),)))
%(mmake)%(flavour)_FILTERARCH       = $(filter-out $(call %(mmake)%(flavour)_MATCHARCH,$(1),$(2)),$(2))
%(mmake)%(flavour)_STARTFILES       := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_STARTFILES))
%(mmake)%(flavour)_ENDFILES         := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_ENDFILES))

%(mmake)%(flavour)_ARCHOBJS         := $(wildcard $(%(mmake)%(flavour)_OBJDIR)/arch/*.o)
%(mmake)%(flavour)_LIBARCHOBJS      := $(wildcard $(%(mmake)%(flavour)_OBJDIR)/linklib/arch/*.o)
%(mmake)%(flavour)_ARCHFILES        := $(basename $(notdir $(%(mmake)%(flavour)_ARCHOBJS)))
%(mmake)%(flavour)_LIBARCHFILES     := $(basename $(notdir $(%(mmake)%(flavour)_LIBARCHOBJS)))
%(mmake)%(flavour)_C_NARCHFILES     := $(call %(mmake)%(flavour)_FILTERARCH,$(%(mmake)%(flavour)_ARCHFILES),$(%(mmake)%(flavour)_FILES))
%(mmake)%(flavour)_CXX_NARCHFILES   := $(call %(mmake)%(flavour)_FILTERARCH,$(%(mmake)%(flavour)_ARCHFILES),$(%(mmake)%(flavour)_CXXFILES))
%(mmake)%(flavour)_OBJC_NARCHFILES  := $(call %(mmake)%(flavour)_FILTERARCH,$(%(mmake)%(flavour)_ARCHFILES),$(%(mmake)%(flavour)_OBJCFILES))
%(mmake)%(flavour)_NLIBARCHFILES    := $(call %(mmake)%(flavour)_FILTERARCH,$(%(mmake)%(flavour)_LIBARCHFILES),$(%(mmake)%(flavour)_LIBFILES))
%(mmake)%(flavour)_ARCHNLIBFILES    := $(call %(mmake)%(flavour)_FILTERARCH,$(%(mmake)%(flavour)_LIBFILES),$(%(mmake)%(flavour)_LIBARCHFILES))

%(mmake)%(flavour)_CPPFLAGS         := $(strip %(cppflags) -I$(%(mmake)%(flavour)_OBJDIR)/include -include $(%(mmake)%(flavour)_DEFLIBDEFSINC))
ifneq (%(includedir),)
%(mmake)%(flavour)_CPPFLAGS         += -I%(includedir)
endif
%(mmake)%(flavour)_LINKLIBCPPFLAGS  := $(%(mmake)%(flavour)_CPPFLAGS)
%(mmake)%(flavour)_CPPFLAGS         += $(strip $($(%(mmake)%(flavour)_DEFNAME)_CPPFLAGS))
%(mmake)%(flavour)_LINKLIBCPPFLAGS  += $(strip $($(%(mmake)%(flavour)_DEFNAME)_LINKLIBCPPFLAGS))
%(mmake)%(flavour)_CFLAGS           := $(strip %(cflags) $($(%(mmake)%(flavour)_DEFNAME)_CFLAGS))
%(mmake)%(flavour)_LINKLIBCFLAGS    := $(strip %(cflags) $($(%(mmake)%(flavour)_DEFNAME)_LINKLIBCFLAGS))
%(mmake)%(flavour)_CXXFLAGS         := $(strip %(cxxflags) $($(%(mmake)%(flavour)_DEFNAME)_CXXFLAGS))
ifeq (%(lto),yes)
ifeq (%(compiler),target)
%(mmake)%(flavour)_LTOFLAGS=$(strip $(LTO_BINARY_CFLAGS) $(CFLAGS_NO_STRICT_ALIASING) $(NOWARN_LTO_TYPE_MISMATCH))
%(mmake)%(flavour)_CFLAGS           := $(strip $(%(mmake)%(flavour)_LTOFLAGS) $(%(mmake)%(flavour)_CFLAGS))
%(mmake)%(flavour)_LINKLIBCFLAGS    := $(strip $(%(mmake)%(flavour)_LTOFLAGS) $(%(mmake)%(flavour)_LINKLIBCFLAGS))
%(mmake)%(flavour)_CXXFLAGS         := $(strip $(%(mmake)%(flavour)_LTOFLAGS) $(%(mmake)%(flavour)_CXXFLAGS))
endif
endif
%(mmake)%(flavour)_DFLAGS           := $(strip $(%(mmake)%(flavour)_DFLAGS) $($(%(mmake)%(flavour)_DEFNAME)_DFLAGS))
%(mmake)%(flavour)_LINKLIBDFLAGS    := $(strip $(%(mmake)%(flavour)_DFLAGS) $($(%(mmake)%(flavour)_DEFNAME)_LINKLIBDFLAGS))
%(mmake)%(flavour)_DXXFLAGS         := $(strip $(%(mmake)%(flavour)_DXXFLAGS) $($(%(mmake)%(flavour)_DEFNAME)_DXXFLAGS))

ifeq (%(modtype),library)
    %(mmake)%(flavour)_LIBSUFFIX := 
else
    %(mmake)%(flavour)_LIBSUFFIX := .%(modtype)
endif

ifeq (%(libdir),)
%(mmake)%(flavour)_LIBDIR := %(prefix)/$(AROS_DIR_DEVELOPER)/$(AROS_DIR_LIB)
else
%(mmake)%(flavour)_LIBDIR := %(libdir)
endif

ifeq (%(build_abi),M)
%(mmake)%(flavour)_LINKLIBCFILES    := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$($(%(mmake)%(flavour)_DEFNAME)_LINKLIBFILES))
%(mmake)%(flavour)_LINKLIBAFILES    := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$($(%(mmake)%(flavour)_DEFNAME)_LINKLIBAFILES))
ifeq ($(strip $($(%(mmake)%(flavour)_DEFNAME)_LINKLIBFILES) $($(%(mmake)%(flavour)_DEFNAME)_LINKLIBAFILES) %(linklibfiles) $(%(mmake)%(flavour)_ARCHNLIBFILES)),)
    %(mmake)%(flavour)_LINKLIB      :=
else
    %(mmake)%(flavour)_LINKLIB      := $(%(mmake)%(flavour)_LIBDIR)/lib%(modname)$(%(mmake)%(flavour)_LIBSUFFIX).a
    ifneq (%(modname),$(%(mmake)%(flavour)_LINKLIBNAME))
        %(mmake)%(flavour)_LINKLIB  += $(%(mmake)%(flavour)_LIBDIR)/lib$(%(mmake)%(flavour)_LINKLIBNAME)$(%(mmake)%(flavour)_LIBSUFFIX).a
    endif
endif
%(mmake)%(flavour)_LINKLIBFILES := $(%(mmake)%(flavour)_LINKLIBCFILES) $(%(mmake)%(flavour)_LINKLIBAFILES)

%(mmake)%(flavour)_RELLINKLIBCFILES := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$($(%(mmake)%(flavour)_DEFNAME)_RELLINKLIBFILES))
%(mmake)%(flavour)_RELLINKLIBAFILES := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$($(%(mmake)%(flavour)_DEFNAME)_RELLINKLIBAFILES))
ifeq ($(strip $($(%(mmake)%(flavour)_DEFNAME)_RELLINKLIBFILES) $($(%(mmake)%(flavour)_DEFNAME)_RELLINKLIBAFILES) %(linklibfiles) $(%(mmake)%(flavour)_ARCHNLIBFILES)),)
    %(mmake)%(flavour)_RELLINKLIB   :=
else
    %(mmake)%(flavour)_RELLINKLIB   := $(%(mmake)%(flavour)_LIBDIR)/lib$(%(mmake)%(flavour)_DEFNAME)_rel$(%(mmake)%(flavour)_LIBSUFFIX).a
    ifneq (%(modname),$(%(mmake)%(flavour)_LINKLIBNAME))
        %(mmake)%(flavour)_RELLINKLIB += $(%(mmake)%(flavour)_LIBDIR)/lib$(%(mmake)%(flavour)_LINKLIBNAME)_rel$(%(mmake)%(flavour)_LIBSUFFIX).a
    endif
endif
%(mmake)%(flavour)_RELLINKLIBFILES := $(%(mmake)%(flavour)_RELLINKLIBCFILES) $(%(mmake)%(flavour)_RELLINKLIBAFILES)
endif

%(mmake)%(flavour)_ENDOBJS    := $(addsuffix .o,$(%(mmake)%(flavour)_ENDFILES))
%(mmake)%(flavour)_LINKLIBOBJS:= $(addsuffix .o,$(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$(notdir $(%(mmake)%(flavour)_NLIBARCHFILES))) $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/arch/,$(notdir $(%(mmake)%(flavour)_ARCHNLIBFILES))) $(%(mmake)%(flavour)_LINKLIBFILES)) \
                 %(linklibobjs)
%(mmake)%(flavour)_RELLINKLIBOBJS := $(addsuffix .o,$(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$(notdir $(%(mmake)%(flavour)_NLIBARCHFILES))) $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/arch/,$(notdir $(%(mmake)%(flavour)_ARCHNLIBFILES))) $(%(mmake)%(flavour)_RELLINKLIBFILES)) \
                 %(linklibobjs)
$(%(mmake)%(flavour)_LINKLIBFILES) $(%(mmake)%(flavour)_RELLINKLIBFILES) : | $(%(mmake)%(flavour)_OBJDIR)/linklib
$(%(mmake)%(flavour)_LINKLIBOBJS) $(%(mmake)%(flavour)_RELLINKLIBOBJS) : | $(%(mmake)%(flavour)_OBJDIR)/linklib

%(mmake)%(flavour)_CCFILES := $(%(mmake)%(flavour)_C_NARCHFILES)
%(mmake)%(flavour)_TARGETCCFILES := $(strip $(%(mmake)%(flavour)_STARTFILES) $(%(mmake)%(flavour)_ENDFILES))
%(mmake)%(flavour)_LINKLIBCCFILES := $(strip $(%(mmake)%(flavour)_NLIBARCHFILES) $(%(mmake)%(flavour)_LINKLIBCFILES) $(%(mmake)%(flavour)_RELLINKLIBCFILES))
%(mmake)%(flavour)_LINKLIBCCGENFILES := $(strip $(%(mmake)%(flavour)_LINKLIBCFILES) $(%(mmake)%(flavour)_RELLINKLIBCFILES))

%rule_compile_cxx_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_CXX_NARCHFILES) targetdir="$(%(mmake)%(flavour)_OBJDIR)" \
    cppflags=$(%(mmake)%(flavour)_CPPFLAGS) cxxflags=$(%(mmake)%(flavour)_CXXFLAGS) dxxflags=$(%(mmake)%(flavour)_DXXFLAGS) \
    compiler="%(compiler)"
%rule_compile_objc_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_OBJC_NARCHFILES) targetdir=$(%(mmake)%(flavour)_OBJDIR) \
    cppflags=$(%(mmake)%(flavour)_CPPFLAGS) cflags=$(%(mmake)%(flavour)_CFLAGS) dflags=$(%(mmake)%(flavour)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_CCFILES) targetdir="$(%(mmake)%(flavour)_OBJDIR)" \
    cppflags=$(%(mmake)%(flavour)_CPPFLAGS) cflags=$(%(mmake)%(flavour)_CFLAGS) dflags=$(%(mmake)%(flavour)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_TARGETCCFILES) targetdir="$(%(mmake)%(flavour)_OBJDIR)" \
    cppflags="$(%(mmake)%(flavour)_CPPFLAGS) -D__AROS__" cflags=$(%(mmake)%(flavour)_CFLAGS) dflags=$(%(mmake)%(flavour)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_NLIBARCHFILES) targetdir="$(%(mmake)%(flavour)_OBJDIR)/linklib" \
    cppflags="$(%(mmake)%(flavour)_LINKLIBCPPFLAGS) -D__AROS__" cflags=$(%(mmake)%(flavour)_LINKLIBCFLAGS) dflags=$(%(mmake)%(flavour)_LINKLIBDFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake)%(flavour) \
    basenames=$(%(mmake)%(flavour)_LINKLIBCCGENFILES) srcdir="$(%(mmake)%(flavour)_OBJDIR)/linklib" targetdir="$(%(mmake)%(flavour)_OBJDIR)/linklib" \
    cppflags="$(%(mmake)%(flavour)_LINKLIBCPPFLAGS) -D__AROS__" cflags=$(%(mmake)%(flavour)_LINKLIBCFLAGS) dflags=$(%(mmake)%(flavour)_LINKLIBDFLAGS) \
    compiler="%(compiler)"

ifneq ($(%(mmake)%(flavour)_LINKLIBAFILES),)
%rule_assemble_multi  mmake=%(mmake)%(flavour) \
    cmd=$(%(mmake)%(flavour)_ASSEMBLER) basenames="$(%(mmake)%(flavour)_LINKLIBAFILES) $(%(mmake)%(flavour)_RELLINKLIBAFILES)" targetdir="$(%(mmake)%(flavour)_OBJDIR)/linklib" suffix=.S
endif

## Linking
##
ifeq (%(modsuffix),)
%(mmake)%(flavour)_SUFFIX := %(modtype)
else
%(mmake)%(flavour)_SUFFIX := %(modsuffix)
endif

ifeq (%(build_library),M)
# Handlers use dash instead of dot in their names
ifeq ($(%(mmake)%(flavour)_SUFFIX),handler)
%(mmake)%(flavour)_MODULE := %(prefix)/$(%(mmake)%(flavour)_MODDIR)/$(%(mmake)%(flavour)_DEFNAME)-$(%(mmake)%(flavour)_SUFFIX)
else
%(mmake)%(flavour)_MODULE := %(prefix)/$(%(mmake)%(flavour)_MODDIR)/$(%(mmake)%(flavour)_DEFNAME).$(%(mmake)%(flavour)_SUFFIX)
endif
%(mmake)%(flavour)_KOBJ   := $(KOBJSDIR)/$(%(mmake)%(flavour)_DEFNAME)_$(%(mmake)%(flavour)_SUFFIX).o
else
%(mmake)%(flavour)_MODULE :=
%(mmake)%(flavour)_KOBJ   :=
endif

%(mmake)-quick      : %(mmake)
%(mmake)            : $(%(mmake)%(flavour)_MODULE) $(%(mmake)%(flavour)_LINKLIB) $(%(mmake)%(flavour)_RELLINKLIB)
ifeq (%(build_library),M)
%(mmake)-kobj       : $(%(mmake)%(flavour)_KOBJ) $(%(mmake)%(flavour)_LINKLIB) $(%(mmake)%(flavour)_RELLINKLIB)
%(mmake)-kobj-quick : $(%(mmake)%(flavour)_KOBJ) $(%(mmake)%(flavour)_LINKLIB) $(%(mmake)%(flavour)_RELLINKLIB)
endif
ifeq (%(build_abi),M)
%(mmake)-linklib    : $(%(mmake)%(flavour)_LINKLIB) $(%(mmake)%(flavour)_RELLINKLIB)
endif

%(mmake)%(flavour)_OBJS := $(addsuffix .o,$(%(mmake)%(flavour)_STARTFILES)) $(%(mmake)%(flavour)_ARCHOBJS) \
           $(addprefix $(%(mmake)%(flavour)_OBJDIR)/,$(notdir $(%(mmake)%(flavour)_C_NARCHFILES:=.o) $(%(mmake)%(flavour)_CXXFILES:=.o)))

ifeq (%(nostartup),yes)
# Handlers always have entry point
ifneq (%(modtype),handler)
%(mmake)%(flavour)_STARTOBJS  := $(addsuffix .o,$(addprefix $(GENDIR)/,$(RESIDENT_BEGIN)))
endif
endif

# Under Windows con* is a reserved name, it refers to console. Files with such names can't be created.
# This breaks con-handler build. Here we work around this
ifeq (%(modname),con)
    %(mmake)%(flavour)_ERR := $(notdir $(%(mmake)%(flavour)_MODULE)).err
else
    %(mmake)%(flavour)_ERR := %(modname).err
endif

ifeq (%(build_library),M)
# The module is linked from all the compiled .o files
%rule_linkmodule module=$(%(mmake)%(flavour)_MODULE) objs="$(%(mmake)%(flavour)_STARTOBJS) $(%(mmake)%(flavour)_OBJS) $(USER_OBJS)" \
		 endobj=$(%(mmake)%(flavour)_ENDOBJS) err=$(%(mmake)%(flavour)_ERR) objdir="$(%(mmake)%(flavour)_OBJDIR)" \
		 cmd=$(%(mmake)%(flavour)_LINK) ldflags="$(LDFLAGS) $($(%(mmake)%(flavour)_DEFNAME)_LDFLAGS)" \
		 uselibs="%(uselibs) $($(%(mmake)%(flavour)_DEFNAME)_LIBS)" usehostlibs="%(usehostlibs)"
endif

ifeq (%(build_abi),M)
# Link static lib
%(mmake)%(flavour)_LC_LINKLIBNAME := $(shell echo $(%(mmake)%(flavour)_LINKLIBNAME) | tr A-Z a-z)
%(mmake)%(flavour)_LC_MODNAME     := $(shell echo %(modname) | tr A-Z a-z)
ifneq ($(%(mmake)%(flavour)_LINKLIB),)
%rule_link_linklib mmake=%(mmake) libname="$(%(mmake)%(flavour)_LINKLIBNAME)$(%(mmake)%(flavour)_LIBSUFFIX)" objs=$(%(mmake)%(flavour)_LINKLIBOBJS) libdir="$(%(mmake)%(flavour)_LIBDIR)"
ifneq ($(%(mmake)%(flavour)_LC_MODNAME),$(%(mmake)%(flavour)_LC_LINKLIBNAME))
%rule_link_linklib mmake=%(mmake) libname="%(modname)$(%(mmake)%(flavour)_LIBSUFFIX)" objs=$(%(mmake)%(flavour)_LINKLIBOBJS) libdir="$(%(mmake)%(flavour)_LIBDIR)"
endif

$(%(mmake)%(flavour)_LINKLIB) : | $(%(mmake)%(flavour)_LIBDIR)
GLOB_MKDIRS += $(%(mmake)%(flavour)_LIBDIR)
endif

ifneq ($(%(mmake)%(flavour)_RELLINKLIB),)
%rule_link_linklib mmake=%(mmake) libname="$(%(mmake)%(flavour)_LINKLIBNAME)_rel$(%(mmake)%(flavour)_LIBSUFFIX)" objs=$(%(mmake)%(flavour)_RELLINKLIBOBJS) libdir="$(%(mmake)%(flavour)_LIBDIR)"
ifneq ($(%(mmake)%(flavour)_LC_MODNAME),$(%(mmake)%(flavour)_LC_LINKLIBNAME))
%rule_link_linklib mmake=%(mmake) libname="$(%(mmake)%(flavour)_DEFNAME)_rel$(%(mmake)%(flavour)_LIBSUFFIX)" objs=$(%(mmake)%(flavour)_RELLINKLIBOBJS) libdir="$(%(mmake)%(flavour)_LIBDIR)"
endif

$(%(mmake)%(flavour)_RELLINKLIB) : | $(%(mmake)%(flavour)_LIBDIR)
GLOB_MKDIRS += $(%(mmake)%(flavour)_LIBDIR)
endif
endif

ifeq (%(build_library),M)
# Link kernel object file
%(mmake)%(flavour)_KAUTOLIB := dos intuition layers graphics oop utility expansion keymap

# Make these symbols local
%(mmake)%(flavour)_KBASE := DOSBase IntuitionBase LayersBase GfxBase OOPBase \
	    UtilityBase ExpansionBase KeymapBase KernelBase

%(mmake)%(flavour)_SYMBOLS := $(%(mmake)%(flavour)_KBASE)

%(mmake)%(flavour)_KLIB := hiddstubs amiga arossupport autoinit libinit
%(mmake)%(flavour)_KOBJ_LIBS := $(filter-out $(%(mmake)%(flavour)_KLIB),%(uselibs)) $(%(mmake)%(flavour)_KAUTOLIB)
$(%(mmake)%(flavour)_KOBJ) : LINKLIBS:=$(%(mmake)%(flavour)_KOBJ_LIBS) $($(%(mmake)%(flavour)_DEFNAME)_LIBS)
$(%(mmake)%(flavour)_KOBJ) : FILTBASES:=$(addprefix -L ,$(%(mmake)%(flavour)_SYMBOLS))
$(%(mmake)%(flavour)_KOBJ) : USER_LDFLAGS:=$(USER_LDFLAGS)
$(%(mmake)%(flavour)_KOBJ) : $(%(mmake)%(flavour)_OBJS) $(USER_OBJS) $(%(mmake)%(flavour)_ENDOBJS)
	@$(ECHO) "Linking    $(subst $(TARGETDIR)/,,$@)"
	@$(AROS_LD) -Ur -o $@ $^ $(USER_LDFLAGS) -L$(AROS_LIB) $(addprefix -l,$(LINKLIBS))
	@$(OBJCOPY) $@ $(FILTBASES) `$(NM_PLAIN) $@ | $(AWK) '($$3 ~ /^__.*_(LIST|END)__\r?$$/) || ($$3 ~ /^__aros_lib.*\r?$$/) {print "-L " $$3;}'`
endif

## Dependency fine-tuning
##
%(mmake)%(flavour)_DEPS := $(addprefix $(%(mmake)%(flavour)_OBJDIR)/,$(notdir $(%(mmake)%(flavour)_CCFILES:=.d) $(%(mmake)%(flavour)_TARGETCCFILES:=.d) $(%(mmake)%(flavour)_CXXFILES:=.d))) $(addprefix $(%(mmake)%(flavour)_OBJDIR)/linklib/,$(notdir $(%(mmake)%(flavour)_LINKLIBCCFILES:=.d)))

%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-kobj %(mmake)-kobj-quick" deps=$(%(mmake)%(flavour)_DEPS)

$(%(mmake)%(flavour)_OBJS) $(%(mmake)%(flavour)_DEPS) : | $(%(mmake)%(flavour)_OBJDIR) $(%(mmake)%(flavour)_OBJDIR)/linklib
$(%(mmake)%(flavour)_MODULE) : | %(prefix)/$(%(mmake)%(flavour)_MODDIR)
$(%(mmake)%(flavour)_KOBJ)   : | $(KOBJSDIR)
GLOB_MKDIRS += $(%(mmake)%(flavour)_OBJDIR) %(prefix)/$(%(mmake)%(flavour)_MODDIR) $(KOBJSDIR)

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj %(mmake)-kobj-quick),) # Only for this target these deps are wanted

%(mmake)%(flavour)_DFILE_DEPS := $(%(mmake)%(flavour)_LIBDEFSINC) $(%(mmake)%(flavour)_DEFLIBDEFSINC) \
    $(addprefix $(%(mmake)%(flavour)_INCDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES))
$(%(mmake)%(flavour)_DEPS) : $(%(mmake)%(flavour)_DFILE_DEPS)
endif

%(mmake)%(flavour)_TOCLEAN := $(%(mmake)%(flavour)_OBJS) $(%(mmake)%(flavour)_DEPS) \
    $(%(mmake)%(flavour)_MODULE) $(%(mmake)%(flavour)_LINKLIB) $(%(mmake)%(flavour)_KOBJ) \
    $(%(mmake)%(flavour)_OBJDIR)/Makefile.%(modname)%(modtype) \
    $(addprefix $(%(mmake)%(flavour)_OBJDIR)/include/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES)) \
    $(addprefix $(GENINCDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES)) \
    $(addprefix $(%(mmake)%(flavour)_INCDIR)/,$($(%(mmake)%(flavour)_DEFNAME)_INCLUDES)) \
    $(%(mmake)%(flavour)_OBJDIR)/%(modname)_geninc $(%(mmake)%(flavour)_OBJDIR)/%(modname)_incs \
    $(addsuffix .c,$(%(mmake)%(flavour)_LINKLIBFILES)) $(%(mmake)%(flavour)_LINKLIBOBJS) $(%(mmake)%(flavour)_LIBDEFSINC) \
    $(%(mmake)%(flavour)_DEFLIBDEFSINC) $(addsuffix .c,$(%(mmake)%(flavour)_STARTFILES) $(%(mmake)%(flavour)_ENDFILES)) \
    $(%(mmake)%(flavour)_ENDOBJS)
%(mmake)-clean : FILES := $(%(mmake)%(flavour)_TOCLEAN)
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module %(modname)"
	@$(RM) $(FILES)

endif # $(TARGET) in $(%(mmake)%(flavour)_ALLTARGETS)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Build a module - ABI and library
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A modsuffix= version= flavour= conffile= \
  files="$(basename $(call WILDCARD, *.c))" \
  objcfiles= \
  cxxfiles="$(basename $(call WILDCARD $(foreach CXX_EXT, $(AROS_CXXEXTS), *.$(CXX_EXT))))" \
  linklibfiles= linklibobjs= cflags=$(CFLAGS) cppflags=$(CPPFLAGS) dflags= cxxflags=$(CXXFLAGS) dxxflags= \
  objdir= moduledir= prefix=$(AROSDIR) \
  linklibname= uselibs= usehostlibs= \
  compiler=target lto=$(TARGET_LTO) nostartup=yes archspecific=no \
  includedir= libdir=

%build_module_core mmake="%(mmake)" modname="%(modname)" modtype="%(modtype)" \
   modsuffix="%(modsuffix)" version="%(version)" flavour="%(flavour)" conffile="%(conffile)" \
   files="%(files)" objcfiles="%(objcfiles)" cxxfiles="%(cxxfiles)" \
   linklibname="%(linklibname)" \
   linklibfiles="%(linklibfiles)" linklibobjs="%(linklibobjs)" \
   cflags="%(cflags)" cppflags="%(cppflags)" dflags="%(dflags)" cxxflags="%(cxxflags)" dxxflags="%(dxxflags)" \
   objdir="%(objdir)" moduledir="%(moduledir)" prefix="%(prefix)" \
   uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" compiler="%(compiler)" lto=%(lto) \
   nostartup="%(nostartup)" archspecific="%(archspecific)" \
   includedir="%(includedir)" libdir="%(libdir)" \
   build_abi=M build_library=M

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module skeleton ABI
# This is a stripped-down version of build_module, it only creates include
# files and the linklibs.
# This is used when for plugins or classes with the same API, but no actual
# implementation here.
%define build_module_abi mmake=/A modname=/A modtype=/A modsuffix= version= flavour= conffile= \
  linklibfiles= linklibobjs= cflags=$(CFLAGS) cppflags=$(CPPFLAGS) dflags= cxxflags=$(CXXFLAGS) dxxflags= \
  objdir= moduledir= prefix=$(AROSDIR) \
  linklibname= uselibs= usehostlibs= \
  compiler=target nostartup=yes archspecific=no \
  includedir= libdir=

%build_module_core mmake="%(mmake)" modname="%(modname)" modtype="%(modtype)" \
  modsuffix="%(modsuffix)" version="%(version)" flavour="%(flavour)" conffile="%(conffile)" \
  linklibname="%(linklibname)" \
  linklibfiles="%(linklibfiles)" linklibobjs="%(linklibobjs)" \
  cflags="%(cflags)" cppflags="%(cppflags)" dflags="%(dflags)" cxxflags="%(cxxflags)" dxxflags="%(dxxflags)" \
  objdir="%(objdir)" moduledir="%(moduledir)" prefix="%(prefix)" \
  uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" compiler="%(compiler)" lto=%(lto) \
  nostartup="%(nostartup)" archspecific="%(archspecific)" \
  includedir="%(includedir)" libdir="%(libdir)" \
  build_abi=M build_library=

%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Build a module library - no includes nor linklibs
# Explanation of this macro is done in the developer's manual
%define build_module_library mmake=/A modname=/A modtype=/A modsuffix= version= flavour= conffile= \
  files="$(basename $(call WILDCARD, *.c))" \
  objcfiles= \
  cxxfiles="$(basename $(call WILDCARD $(foreach CXX_EXT, $(AROS_CXXEXTS), *.$(CXX_EXT))))" \
  cflags=$(CFLAGS) cppflags=$(CPPFLAGS) dflags= cxxflags="$(CXXFLAGS)" dxxflags= \
  objdir= moduledir= prefix=$(AROSDIR) \
  uselibs= usehostlibs= \
  compiler=target lto=$(TARGET_LTO) nostartup=yes archspecific=no \
  includedir= libdir=

%build_module_core mmake="%(mmake)" modname="%(modname)" modtype="%(modtype)" \
   modsuffix="%(modsuffix)" version="%(version)" flavour="%(flavour)" conffile="%(conffile)" \
   files="%(files)" objcfiles="%(objcfiles)" cxxfiles="%(cxxfiles)" \
   cflags="%(cflags)" cppflags="%(cppflags)" dflags="%(dflags)" cxxflags="%(cxxflags)" dxxflags="%(dxxflags)" \
   objdir="%(objdir)" moduledir="%(moduledir)" prefix="%(prefix)" \
   uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" compiler="%(compiler)" lto=%(lto) \
   nostartup="%(nostartup)" archspecific="%(archspecific)" \
  includedir="%(includedir)" libdir="%(libdir)" \
   build_abi= build_library=M

%end
#------------------------------------------------------------------------------



#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - cxxfiles are C++ source files without suffix.
#   NB: files will be matched in the order .cpp > .cxx > .cc
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given without the .s suffix
# - objs additional object to link into the linklib. The objects have to be
#   given with full absolute path and the .o suffix.
# - objdir is where the .o are generated. Defaults to $(GENDIR)/$(CURDIR)
# - libdir is the directory where the linklib will be placed (default $(AROS_LIB))
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags used during makedepend (default equal to cflags)
# - aflags are the flags used during assembling (default $(AFLAGS))
%define build_linklib mmake=/A libname=/A files= objcfiles= cxxfiles= \
  asmfiles= objs= objdir=$(GENDIR)/$(CURDIR) libdir=$(AROS_LIB) \
  includedir= \
  cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= cxxflags=$(CXXFLAGS) dxxflags= \
  aflags=$(AFLAGS) compiler=target lto=$(TARGET_LTO)

# assign and generate the local variables used in this macro
%(mmake)_LIBNAME      := %(libname)
%(mmake)_LINKLIB      := %(libdir)/lib%(libname).a

%(mmake)_FILES        := %(files)
%(mmake)_ASMFILES     := %(asmfiles)
%(mmake)_OBJCFILES    := %(objcfiles)
%(mmake)_CXXFILES     := %(cxxfiles)

%(mmake)_ARCHOBJS     := $(wildcard %(objdir)/arch/*.o)
%(mmake)_ARCHFILES    := $(basename $(notdir $(%(mmake)_ARCHOBJS)))
%(mmake)_C_NARCHFILES   := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_FILES))
%(mmake)_CXX_NARCHFILES   := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_CXXFILES))
%(mmake)_OBJC_NARCHFILES   := $(filter-out $(%(mmake)_ARCHFILES),$(%(mmake)_OBJCFILES))

%(mmake)_OBJS         := $(%(mmake)_ARCHOBJS) \
                 $(addprefix %(objdir)/,$(notdir $(%(mmake)_C_NARCHFILES:=.o) $(%(mmake)_CXX_NARCHFILES:=.o) $(%(mmake)_ASMFILES:=.o) $(%(mmake)_OBJC_NARCHFILES:=.o))) \
                 %(objs)
%(mmake)_DEPS         := $(patsubst %.o,%.d,$(%(mmake)_OBJS))

%(mmake)_CPPFLAGS     := %(cppflags)
ifneq (%(includedir),)
%(mmake)_CPPFLAGS     += -I%(includedir)
endif
%(mmake)_CFLAGS       := %(cflags)
%(mmake)_CXXFLAGS     := %(cxxflags)
ifeq (%(lto),yes)
ifeq (%(compiler),target)
%(mmake)_CFLAGS       := $(strip $(LTO_CFLAGS) $(%(mmake)_CFLAGS))
%(mmake)_CXXFLAGS     := $(strip $(LTO_CFLAGS) $(%(mmake)_CXXFLAGS))
endif
endif
%(mmake)_AFLAGS       := %(aflags)
%(mmake)_DFLAGS       := %(dflags)
ifneq (%(dflags),)
    %(mmake)_DFLAGS   := %(dflags)
else
    %(mmake)_DFLAGS   := $(%(mmake)_CFLAGS)
endif
%(mmake)_DXXFLAGS     := %(dxxflags)
ifneq (%(dxxflags),)
    %(mmake)_DXXFLAGS := %(dxxflags)
else
    %(mmake)_DXXFLAGS := $(%(mmake)_CXXFLAGS)
endif

.PHONY : %(mmake) %(mmake)-clean %(mmake)-quick

#MM
%(mmake)-quick : %(mmake)

#MM %(mmake) : includes-generate-deps
%(mmake) : $(%(mmake)_LINKLIB)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)

%rule_compile_cxx_multi mmake=%(mmake) \
    basenames=$(%(mmake)_CXX_NARCHFILES) targetdir="%(objdir)" \
    cppflags=$(%(mmake)_CPPFLAGS) cxxflags=$(%(mmake)_CXXFLAGS) dxxflags=$(%(mmake)_DXXFLAGS) \
    compiler="%(compiler)"
%rule_compile_objc_multi mmake=%(mmake) \
    basenames=$(%(mmake)_OBJC_NARCHFILES) targetdir=$(%(mmake)_OBJDIR) \
    cppflags=$(%(mmake)_CPPFLAGS) cflags=$(%(mmake)_CFLAGS) dflags=$(%(mmake)_DFLAGS) \
    compiler="%(compiler)"
%rule_compile_multi mmake=%(mmake) \
    basenames=$(%(mmake)_C_NARCHFILES) targetdir="%(objdir)" \
    cppflags=$(%(mmake)_CPPFLAGS) cflags=$(%(mmake)_CFLAGS) dflags=$(%(mmake)_DFLAGS) \
    compiler="%(compiler)"
%rule_assemble basename=% targetdir="%(objdir)" \
    aflags=$(%(mmake)_AFLAGS)

%rule_link_linklib mmake=%(mmake) libname="%(libname)" objs=$(%(mmake)_OBJS) libdir="%(libdir)" linker="%(compiler)"
endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(%(mmake)_DEPS)

$(%(mmake)_OBJS) $(%(mmake)_DEPS) : | %(objdir)
$(%(mmake)_LINKLIB) : | %(libdir)
GLOB_MKDIRS += %(objdir) %(libdir)

%(mmake)-clean : FILES := $(%(mmake)_OBJS) $(%(mmake)_LINKLIB) $(%(mmake)_DEPS)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd), without the .cd suffix (default *.cd)
# - subdir is the destination subdirectory of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - source is the path to the generated source code file
# - dir is the base destination directory (default $(AROS_CATALOGS))
# - sourcedescription is the path to the FlexCat's source description file, without the .sd suffix
# - srcdir is the directory in which the *.cd and *.ct files are searched

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs= source="../strings.h" description= dir=$(AROS_CATALOGS) \
 sourcedescription=$(TOOLDIR)/C_h_aros srcdir=$(SRCDIR)/$(CURDIR)

ifeq (%(description),)
%(mmake)_DESC := $(basename $(wildcard %(srcdir)/*.cd))
else
%(mmake)_DESC := %(description)
endif

%(mmake)_SRC := $(shell echo %(sourcedescription) | sed 's/^\(.\):\//\/\1\//')

ifeq (%(catalogs),)
%(mmake)_LNGS := $(basename $(notdir $(call WILDCARD, %(srcdir)/*.ct)))
else
%(mmake)_LNGS := %(catalogs)
endif

%(mmake)_OBJS := $(addsuffix /%(subdir)/%(name).catalog, $(addprefix %(dir)/, $(%(mmake)_LNGS)))
%(mmake)_DIRS := $(addsuffix /%(subdir), $(addprefix %(dir)/, $(%(mmake)_LNGS))) $(dir %(source))

#MM
%(mmake) : $(%(mmake)_OBJS) %(source)

$(%(mmake)_OBJS) : | $(%(mmake)_DIRS)
GLOB_MKDIRS += $(%(mmake)_DIRS)

%(dir)/%/%(subdir)/%(name).catalog : %(srcdir)/%.ct $(%(mmake)_DESC).cd
	@$(ECHO) "Creating   %(name) catalog for language $*."
	@$(FLEXCAT) $(%(mmake)_DESC).cd $< CATALOG="%(dir)/$*/%(subdir)/%(name).catalog" || [ $$? -lt 10 ]

ifneq (%(source),)
%(source) : %(mmake)_DESC := $(%(mmake)_DESC)
%(source) : %(mmake)_SRC := $(%(mmake)_SRC)
%(source) : $(%(mmake)_DESC).cd $(%(mmake)_SRC).sd | $(dir %(source))
	@$(ECHO) "Creating   %(name) catalog source file $@"
	@$(FLEXCAT) $(%(mmake)_DESC).cd $@=$(%(mmake)_SRC).sd
endif

%(mmake)-clean : FILES := $(%(mmake)_OBJS) %(source)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

.PHONY: %(mmake) %(mmake)-clean

%end
#-----------------------------------------------------------------------------


#-----------------------------------------------------------------------------
# Build icons.
# - mmake is the mmaketarget
# - icons is a list of icon base names (i.e. without the .info suffix)
# - dir is the destination directory
# - srcdir is where *.png and *.info.src are sought
#-----------------------------------------------------------------------------

%define build_icons mmake=/A icons=/A dir=/A srcdir=$(SRCDIR)/$(CURDIR) image=

BD_OBJS := $(addprefix  %(dir)/, $(addsuffix .info,%(icons)))

#MM
%(mmake) : $(BD_OBJS)

ifeq (%(image),)

%(dir)/%.info : %(srcdir)/%.info.src %(srcdir)/%.png
	@$(ECHO) "Creating   $(subst $(TARGETDIR)/,,$@)..."
	@$(ILBMTOICON) $+ $@

else

%(dir)/%.info : %(srcdir)/%.info.src %(srcdir)/%(image)
	@$(ECHO) "Creating   $(subst $(TARGETDIR)/,,$@)..."
	@$(ILBMTOICON) $+ $@

endif

$(BD_OBJS) : | %(dir)
GLOB_MKDIRS += %(dir)

%(mmake)-clean : FILES := $(BD_OBJS)
#MM
%(mmake)-clean ::
	@$(RM) $(FILES)

.PHONY: %(mmake) %(mmake)-clean

%end
#-----------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Compile files for an arch-specific replacement of code for a module
# - files: the basenames of the C files to compile.
# - asmfiles: the basenames of the asm files to assemble.
# - mainmmake: the mmake of the module in the main directory to compile these
#   arch specific files for.
# - maindir: the object directory for the main module
# - arch: the arch for which to compile these files. It can have the form
#   of ARCH, CPU or ARCH-CPU, e.g. linux, i386 or linux-i386
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - aflags: the flags used during assembling
# - compiler: (host, kernel or target) specifies which compiler to use. By default
#   the target compiler is used
# - modname: arch_specific builds of modules (built using build_module) MUST
#   specify the name here matching the original module. this insures multiple modules
#   built from the same makefile will not pollute each other.
%define build_archspecific files= cxxfiles= asmfiles= linklibfiles= linklibobjs= mainmmake=/A maindir=/A arch=/A \
 cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) compiler=target objdir= modname=

ifeq (%(files) %(linklibfiles) %(linklibobjs) %(asmfiles),)
    $(error no files or asmfiles given)
endif

ifneq (%(cxxfiles),)
    $(error cxx support is TODO)
endif

%buildid targets="%(mainmmake)-%(arch)"

#MM- %(mainmmake) : 	    %(mainmmake)-$(ARCH)-$(CPU)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH)-$(CPU) \
#MM			    %(mainmmake)-$(ARCH)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH) \
#MM			    %(mainmmake)-$(FAMILY) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-linklib : %(mainmmake)-$(ARCH)-$(CPU)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH)-$(CPU) \
#MM			    %(mainmmake)-$(ARCH)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH) \
#MM			    %(mainmmake)-$(FAMILY) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj :    %(mainmmake)-$(ARCH)-$(CPU)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH)-$(CPU) \
#MM			    %(mainmmake)-$(ARCH)-$(AROS_TARGET_VARIANT) %(mainmmake)-$(ARCH) \
#MM			    %(mainmmake)-$(FAMILY) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj-quick : %(mainmmake)-$(ARCH)-$(CPU)-$(AROS_TARGET_VARIANT)-quick %(mainmmake)-$(ARCH)-$(CPU)-quick \
#MM			    %(mainmmake)-$(ARCH)-$(AROS_TARGET_VARIANT)-quick %(mainmmake)-$(ARCH)-quick \
#MM			    %(mainmmake)-$(FAMILY)-quick %(mainmmake)-$(CPU)-quick
#MM- %(mainmmake)-quick :   %(mainmmake)-$(ARCH)-$(CPU)-$(AROS_TARGET_VARIANT)-quick %(mainmmake)-$(ARCH)-$(CPU)-quick \
#MM			    %(mainmmake)-$(ARCH)-$(AROS_TARGET_VARIANT)-quick %(mainmmake)-$(ARCH)-quick \
#MM			    %(mainmmake)-$(FAMILY)-quick %(mainmmake)-$(CPU)-quick

#MM %(mainmmake)-%(arch) : %(mainmmake)-includes

ifneq (%(objdir),)
    BD_OBJROOT$(BDID)  := %(objdir)
else
ifneq (%(modname),)
    BD_OBJROOT$(BDID)  := $(GENDIR)/%(maindir)/%(modname)
else
    BD_OBJROOT$(BDID)  := $(GENDIR)/%(maindir)
endif
endif
BD_OBJDIR$(BDID)  := $(BD_OBJROOT$(BDID))/arch
BD_LIBOBJDIR$(BDID)  := $(BD_OBJROOT$(BDID))/linklib/arch
BD_FILEOBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files)))) $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(cxxfiles))))
BD_LINKLIBOBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_LIBOBJDIR$(BDID))/,$(notdir %(linklibfiles))))
BD_LINKLIBARCHOBJS$(BDID)   := $(addprefix $(BD_LIBOBJDIR$(BDID))/,$(notdir %(linklibobjs)))
BD_ASMOBJS$(BDID) := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(asmfiles))))
BD_OBJS$(BDID)    := $(BD_FILEOBJS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_ASMOBJS$(BDID))
BD_DEPS$(BDID)    := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files)))) $(addsuffix .d,$(addprefix $(BD_LIBOBJDIR$(BDID))/,$(notdir %(linklibfiles))))

ifneq (%(modname),)
BD_DEFLIBDEFSINC$(BDID) := -include $(BD_OBJROOT$(BDID))/include/%(modname)_deflibdefs.h
endif

ifeq ($(TARGET),%(mainmmake)-%(arch)-quick)
    BD_TARGET := %(mainmmake)-%(arch)-quick
else
    BD_TARGET := %(mainmmake)-%(arch)
endif


ifeq ($(TARGET),$(BD_TARGET))
TMP_SRCDIR := $(shell echo $(SRCDIR) | sed 's/^\(.\):\//\/\1\//')
vpath %.c $(addprefix $(TMP_SRCDIR)/$(CURDIR)/,$(dir %(files)))
vpath %.c $(addprefix $(TMP_SRCDIR)/$(CURDIR)/,$(dir %(linklibfiles)))
vpath %.s $(addprefix $(TMP_SRCDIR)/$(CURDIR)/,$(dir %(asmfiles)))
vpath %.S $(addprefix $(TMP_SRCDIR)/$(CURDIR)/,$(dir %(asmfiles)))
endif

$(BD_OBJS$(BDID)) : | $(BD_OBJDIR$(BDID)) $(BD_LIBOBJDIR$(BDID))
GLOB_MKDIRS += $(BD_OBJDIR$(BDID)) $(BD_LIBOBJDIR$(BDID))

#MM
%(mainmmake)-%(arch) :: $(BD_OBJS$(BDID))

#MM
%(mainmmake)-%(arch)-quick :: $(BD_OBJS$(BDID))

ifeq ($(findstring %(compiler),host kernel target),)
    $(error unknown compiler %(compiler))
endif
ifneq (%(modname),)
$(BD_FILEOBJS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CPPFLAGS:=$(strip %(cppflags) -I$(BD_OBJROOT$(BDID)) $(BD_DEFLIBDEFSINC$(BDID)))
else
$(BD_FILEOBJS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CPPFLAGS:=%(cppflags)
endif
$(BD_FILEOBJS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CFLAGS:=%(cflags)
ifeq (%(compiler),target)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CMD:=$(strip $(TARGET_CC) $(TARGET_SYSROOT))
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CPPFLAGS:=$(TMP_CPPFLAGS)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CFLAGS:=$(strip $(TMP_CFLAGS) $(SAFETY_CFLAGS))
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE:=$(CFLAGS_IQUOTE)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE_END:=$(CFLAGS_IQUOTE_END)
endif
ifeq (%(compiler),host)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CMD:=$(HOST_CC)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE:=$(HOST_IQUOTE)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE_END:=$(HOST_IQUOTE_END)
endif
ifeq (%(compiler),kernel)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CMD:=$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CPPFLAGS:=$(strip $(KERNEL_CPPFLAGS) $(TMP_CPPFLAGS))
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_CFLAGS:=$(strip $(TARGET_ISA_CFLAGS) $(KERNEL_CFLAGS) $(TMP_CFLAGS))
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE:=$(KERNEL_IQUOTE)
$(BD_FILEOBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_LINKLIBOBJS$(BDID)) : TMP_IQUOTE_END:=$(KERNEL_IQUOTE_END)
endif

ifeq ($(TARGET),$(BD_TARGET))
$(BD_LIBOBJDIR$(BDID))/%.o : $(SRCDIR)/$(CURDIR)/%.c
	%compile_q cmd=$(TMP_CMD) opt="$(strip $(TMP_CFLAGS) $(TMP_CPPFLAGS))" iquote=$(TMP_IQUOTE) iquote_end=$(TMP_IQUOTE_END)
$(BD_OBJDIR$(BDID))/%.o : $(SRCDIR)/$(CURDIR)/%.c
	%compile_q cmd=$(TMP_CMD) opt="$(strip $(TMP_CFLAGS) $(TMP_CPPFLAGS))" iquote=$(TMP_IQUOTE) iquote_end=$(TMP_IQUOTE_END)
endif

ifeq (%(dflags),)
$(BD_DEPS$(BDID)) : TMP_CPPFLAGS:=$(strip %(cppflags) $(BD_DEFLIBDEFSINC$(BDID)))
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(cflags)
else
$(BD_DEPS$(BDID)) : TMP_CPPFLAGS:=%(cppflags)
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(dflags)
endif
ifeq ($(TARGET),$(BD_TARGET))
$(BD_LIBOBJDIR$(BDID))/%.d : $(SRCDIR)/$(CURDIR)/%.c
	%mkdepend_q cc=$(TMP_CMD) flags="$(strip $(TMP_DFLAGS) $(TMP_CPPFLAGS))"

$(BD_OBJDIR$(BDID))/%.d : $(SRCDIR)/$(CURDIR)/%.c
	%mkdepend_q cc=$(TMP_CMD) flags="$(strip $(TMP_DFLAGS) $(TMP_CPPFLAGS))"
endif

$(BD_ASMOBJS$(BDID)) : CPPFLAGS:=%(cppflags)
$(BD_ASMOBJS$(BDID)) : AFLAGS:=%(aflags)

ifeq ($(TARGET),$(BD_TARGET))
$(BD_OBJDIR$(BDID))/%.o : %.s
	%assemble_q
$(BD_OBJDIR$(BDID))/%.o : %.S
	%assemble_q
endif

%include_deps depstargets=$(BD_TARGET) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) $(TARGET_SYSROOT) -S $(CFLAGS) $(CPPFLAGS) $< -c -o $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q mmake=/A files=$(FILES) src=. dst=/A

%(mmake)_SRC := $(shell echo %(src) | sed 's/^\(.\):\//\/\1\//')

GLOB_MKDIRS += %(dst)

.PHONY : %(mmake)

#MM
%(mmake) : | %(dst) 
	$(foreach file, %(files), $(shell $(CP) $(addprefix $(if $(filter /%,$(%(mmake)_SRC)),$(%(mmake)_SRC),$(SRCDIR)/$(CURDIR)/$(%(mmake)_SRC))/, $(file)) $(addprefix %(dst)/, $(file))))

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy a directory recursively to another place, preserving the original 
# hierarchical structure
#
# src: the source directory whose content will be copied.
# dst: the directories where to copy src's content. If not existing, they will be made.
# excludefiles: files which must not be copied. Path must be relative to src.

%define copy_dir_recursive mmake=/A src=. dst=/A excludefiles=

.PHONY : %(mmake)

#MM
%(mmake) :
	@cd $(SRCDIR)/$(CURDIR) && $(CPYDIRREC) -s %(src) -d %(dst) -e %(excludefiles)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake=includes-copy includes=$(INCLUDE_FILES) path=. \
    dir= compiler=target includedir=$(AROS_INCLUDES)

ifeq ($(findstring %(compiler),host kernel target),)
$(error %copy_includes: compiler argument (%(compiler)) has to be host, kernel or target)
endif

ifneq (%(dir),)
TMP_DIR := %(dir)
$(eval TMP_DIRREMAIN := $$$(TMP_DIR))
TMP_DIRFIRST := $(subst $(TMP_DIRREMAIN),,$(TMP_DIR))
BD_INCL_FILES := $(subst %(dir),$(GENINCDIR)/%(path),$(dir %(includes)))
BD_INCL_FILES := $(addprefix $(GENINCDIR)/%(path)/,$(notdir %(includes)))
ifeq ($(TMP_DIRFIRST),/)
BD_INC_PATH := %(dir)/
else
BD_INC_PATH := $(SRCDIR)/$(CURDIR)/%(dir)/
endif
else
BD_INCL_FILES := $(addprefix $(GENINCDIR)/%(path)/,%(includes))
BD_INC_PATH := $(SRCDIR)/$(CURDIR)/
endif

$(BD_INCL_FILES) : $(GENINCDIR)/%(path)/% : $(BD_INC_PATH)%
	@$(CP) $< $@

ifeq (%(compiler),target)

ifneq (%(dir),)
BD_INCL_FILES2 := $(subst %(dir),%(includedir)/%(path),$(dir %(includes)))
BD_INCL_FILES2 := $(addprefix %(includedir)/%(path)/,$(notdir %(includes)))
else
BD_INCL_FILES2 := $(addprefix %(includedir)/%(path)/,%(includes))
endif

BD_INCL_FILES += $(BD_INCL_FILES2)

$(BD_INCL_FILES2) : %(includedir)/%(path)/% : $(BD_INC_PATH)%
	@$(CP) $< $@
endif

#MM
%(mmake) : $(BD_INCL_FILES)

.PHONY: %(mmake)

$(BD_INCL_FILES) : | $(dir $(BD_INCL_FILES))
GLOB_MKDIRS += $(dir $(BD_INCL_FILES))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
%define make_hidd_stubs hidd=/A cppflags=$(CPPFLAGS) cflags=$(CFLAGS) dflags=$(CFLAGS) parenttarget=linklibs
STUBS_SRC := $(addprefix $(SRCDIR)/$(CURDIR)/,$(addsuffix .c,$(STUBS)))
STUBS_MEM := $(addsuffix .o,$(STUBS))
STUBS_OBJ := $(addprefix $(OBJDIR)/,$(STUBS_MEM))
STUBS_DEP := $(addprefix $(OBJDIR)/,$(addsuffix .d,$(STUBS)))
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs : hidd-%(hidd)-stubs
#MM- %(parenttarget): hidd-%(hidd)-stubs
#MM hidd-%(hidd)-stubs : includes includes-copy
hidd-%(hidd)-stubs : setup $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC) 
	%compile_q cmd="$(strip $(TARGET_CC) $(TARGET_SYSROOT))" opt="$(strip %(cflags) %(cppflags))" iquote=$(CFLAGS_IQUOTE) iquote_end=$(CFLAGS_IQUOTE_END)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags="$(strip %(dflags) %(cppflags))"

setup ::
	%mkdirs_q $(OBJDIR) $(AROS_LIB)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build an imported source tree which uses the configure script from the
# autoconf package.  This rule will try to "integrate" the produced files as
# much as possible in the AROS build, for example by putting libraries in the
# standard library directory, includes in the standard include directory, and
# so on. You can however override this behaviour.
#
# As a special "bonus" for you, the PROGDIR environment variable is defined to
# be %(bindir) (or its deduced value) when running "make install", and
# "PROGDIR:" when running "make" alone; you can use this feature to pass the
# configure script some more parameters whose value depends upon the PROGDIR
# env var, so that the program gets all its stuff installed in the proper place
# when building it, but when running it from inside AROS it can also find that
# stuff by simply opening PROGDIR:, which it will do automatically if it uses
# the configuration parameters set when running ./configure
#
# *NOTICE*: DO NOT put a trailing '/' (slash) after $PROGDIR, as the variable
# already contains either a '/' (slash) or a ':' (colon), thus simply attach it
# to the name which has to follow it.
#
# Arguments:
#
#     - mmake           = the meta make target.
#     - package         = name of the package to be built.
#     - srcdir          = the location of the unpacked source code. Defaults
#                         to $(SRCDIR)/$(CURDIR).
#     - prefix          = the target directory. Must be an absolute path of the
#                         host system. Defaults to $(AROS_CONTRIB).
#     - aros_prefix     = set a path which is valid within the AROS filesystem.
#                         Defaults to the value of the prefix option.
#     - extraoptions    = additional options for the configure script.
#     - usecppflags      = enable the use of cpp flags. some external configure
#                         scripts will not set their own cppflags if it is already
#                         set, so this allows them to be disabled (unless you can provide
#                         all the options they would need)
#     - extracppflags      = additional preprocessor flags.
#     - extracflags     = additional flags to use with the C compiler.
#     - extracxxflags   = additional flags to use with the C++ compiler.
#     - nix_dir_layout  = if yes the binary will be stored in a bin subdirectory.
#                         Defaults to the value of the nix argument.
#     - nix             = enable u*nix path handling, i.e. a path like
#                         /progdir//./file will be translated to
#                         progdir:file during run-time. Defaults to no.
#     - compiler        = target, host or kernel. Defaults to target.
#     - install_target  = the command used for installing. Defaults to install. Leave
#                         it empty if you want to suppress installing.
#     - preconfigure    = a metatarget which is executed before configure is called.
#     - postconfigure   = a metatarget which is executed after configure is called.
#     - postinstall     = a metatarget which is executed after installing.
#     - install_env     = set additional options for installing.
#     - use_build_env   = if yes the configuration environment is used for
#                         installing, too. Defaults to no.
#
# The arguments aros_prefix, nix and nix_dir_layout are related. The logic is
# like this:
#
# if nix_dir_layout
#    --prefix = $(aros_prefix)
#    progdir = $(aros_prefix)/bin
# else
#    if nix
#        --prefix = /PROGDIR
#        --bindir = /PROGDIR
#        --sbindir = /PROGDIR
#        --libdir = /LIB
#        --includedir = /INCLUDE
#        --oldincludedir = /INCLUDE   
#    else
#        --prefix = $(aros_prefix)
#    endif
#
#    progdir = $(aros_prefix)
#
#    # Install options
#    bindir = $(prefix)
#    sbindir = $(prefix)
#    libdir = $(AROS_LIB)
#    includedir = $(AROS_INCLUDES)
#    oldincludedir = $(AROS_INCLUDES)
# endif
#

%define build_with_configure mmake=/A package= srcdir=$(SRCDIR)/$(CURDIR) \
    prefix= gendir= basedir=$(CURDIR) extraoptions= \
    usecppflags=yes extracppflags= extracflags="$(OPTIMIZATION_CFLAGS)" extracxxflags="$(OPTIMIZATION_CFLAGS)" \
    hostisaflags="$(TARGET_ISA_CFLAGS)" targetisaflags="$(TARGET_ISA_CFLAGS)" \
    aros_prefix= nix_dir_layout= nix=no compiler=target crossbuild=no \
    install_target=install preconfigure= postconfigure= postinstall= \
    config_env_extra= install_env= use_build_env=no buildflags=yes gnuflags=yes nlsflag=yes xflag=yes

ifneq (%(prefix),)
    %(mmake)-prefix := %(prefix)
else
    %(mmake)-prefix := $(AROS_CONTRIB)
endif

ifneq (%(aros_prefix),)
    %(mmake)-aros_prefix := %(aros_prefix)
else
    %(mmake)-aros_prefix := $(%(mmake)-prefix)
endif

BD_NIXFLAG ?= -nix

ifeq (%(nix),yes)
    %(mmake)-nix    := $(BD_NIXFLAG)
    %(mmake)-volpfx := /
    %(mmake)-volsfx := /
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := yes
    endif
else
    %(mmake)-volsfx := :
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := no
    endif
endif

%(mmake)-volfunc = $(%(mmake)-volpfx)$(notdir $1)$(%(mmake)-volsfx)

%(mmake)-install_opts := prefix=$(%(mmake)-prefix) \
        exec_prefix=$(%(mmake)-prefix) %(install_env)

# Check if chosen compiler is valid
ifeq ($(findstring %(compiler),host target kernel),)
  $(error unknown compiler %(compiler))
endif

# Set legacy 'host' variable based on chosen compiler
ifeq (%(compiler),host)
    host := yes
    ifeq (%(basedir),)
        %(mmake)-pkgbasedir := $(HOSTGENDIR)
    else
        %(mmake)-pkgbasedir := $(HOSTGENDIR)/%(basedir)
    endif
else
    host := no
    ifeq (%(basedir),)
        %(mmake)-pkgbasedir := $(GENDIR)
    else
        %(mmake)-pkgbasedir := $(GENDIR)/%(basedir)
    endif
endif
ifneq (%(gendir),)
    ifeq (%(basedir),)
        %(mmake)-pkgbasedir := %(gendir)
    else
        %(mmake)-pkgbasedir := %(gendir)/%(basedir)
    endif
endif

ifeq (%(package),)
    %(mmake)-pkgdir := $(%(mmake)-pkgbasedir)
else
    %(mmake)-pkgdir := $(%(mmake)-pkgbasedir)/%(package)
endif

%(mmake)-configflag := $(%(mmake)-pkgdir)/.configured
%(mmake)-installflag := $(%(mmake)-pkgdir)/.installed

ifeq ($(filter yes, $(%(mmake)-nix_dir_layout) $(host)),yes)
    %(mmake)-PROGDIR      := $(%(mmake)-aros_prefix)/bin
    %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
else
    ifeq (%(nix),yes)
        %(mmake)-config_opts := --prefix=/PROGDIR  --bindir=/PROGDIR --sbindir=/PROGDIR \
        --libdir=/LIB --includedir=/INCLUDE --oldincludedir=/INCLUDE   
    else
        %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
    endif

    %(mmake)-PROGDIR := $(%(mmake)-aros_prefix)
    
    %(mmake)-install_opts := bindir=$(%(mmake)-prefix) \
        sbindir=$(%(mmake)-prefix) \
        libdir=$(AROS_LIB) includedir=$(AROS_INCLUDES) \
        oldincludedir=$(AROS_INCLUDES) %(install_env)
endif

ifneq ($(DEBUG),yes)
    %(mmake)-s_flag = -s
endif

# Set up build environment, and options for configure script
ifeq (%(compiler),host)
    # NB: We need to pass in our crosstoolsdir, but cannot set CFLAGS since it
    # confused configure scripts. We also cannot pass it via _FOR_BUILD
    # since that won't get picked up during configure.
    # We also cannot pass in the compiler including std flags so we need to use
    # the "plain" host compiler.
    %(mmake)-cfg-env := %(config_env_extra) \
        CPP="$(HOST_CPP)" \
        CXXCPP="$(HOST_CPP)" \
        CC="$(strip $(HOST_DEF_CC) $(HOST_CFLAGS) -I$(CROSSTOOLSDIR)/include)" \
        CXX="$(strip $(HOST_CXX) $(HOST_CXXFLAGS) -I$(CROSSTOOLSDIR)/include)" \
        LDFLAGS="-L$(CROSSTOOLSDIR)/lib $(USER_LDFLAGS)"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += TARGET_CPPFLAGS="$(KERNEL_CPPFLAGS)"
endif
    %(mmake)-cfg-env += TARGET_CC="$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))" \
        TARGET_CFLAGS="$(strip %(targetisaflags) $(KERNEL_CFLAGS) $(%(mmake)-s_flag))" \
        TARGET_CXX="$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))" \
        TARGET_CXXFLAGS="$(strip $(KERNEL_CXXFLAGS) $(%(mmake)-s_flag))" \
        TARGET_AS="$(TARGET_AS)" \
        OBJCOPY="$(OBJCOPY)" \
        TARGET_RANLIB="$(RANLIB)" \
        TARGET_STRIP="$(STRIP_PLAIN)" \
        TARGET_NM="$(NM_PLAIN)" \
        TARGET_OBJCOPY="$(TARGET_OBJCOPY)"
endif
ifeq (%(compiler),target)
    %(mmake)-cfg-env := %(config_env_extra) \
        PKG_CONFIG_LIBDIR="$(AROS_DEVELOPER)/lib/pkgconfig" \
        PKG_CONFIG_SYSROOT_DIR="$(AROSDIR)"
    %(mmake)-cfg-env += CPP="$(strip $(TARGET_CPP) $(TARGET_SYSROOT))" \
        CXXCPP="$(strip $(TARGET_CPP) $(TARGET_SYSROOT))" \
        CC="$(strip $(TARGET_CC) $(TARGET_SYSROOT))" \
        CXX="$(strip $(TARGET_CXX) $(TARGET_SYSROOT))" \
        LD="$(strip $(TARGET_LD))"
ifeq (%(crossbuild),yes)
    %(mmake)-cfg-env += CFLAGS="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CFLAGS) $(USER_CFLAGS) %(extracflags) $(%(mmake)-s_flag))" \
        CXXFLAGS="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CXXFLAGS) $(USER_CXXFLAGS) %(extracxxflags) $(%(mmake)-s_flag))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS="$(strip $(BASE_CPPFLAGS) $(USER_CPPFLAGS) %(extracppflags))"
endif
else
    %(mmake)-cfg-env += CFLAGS="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CFLAGS) $(USER_CFLAGS) %(extracflags) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        CXXFLAGS="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CXXFLAGS) $(USER_CXXFLAGS) %(extracxxflags) $(%(mmake)-nix) $(%(mmake)-s_flag))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS="$(strip $(BASE_CPPFLAGS) $(USER_CPPFLAGS) %(extracppflags))"
endif
endif
    %(mmake)-cfg-env += LDFLAGS="$(strip -L$(AROS_DEVELOPER)/lib $(USER_LDFLAGS) $(%(mmake)-nix) $(%(mmake)-s_flag))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS_FOR_BUILD="$(HOST_CPPFLAGS)"
endif
    %(mmake)-cfg-env += CC_FOR_BUILD="$(strip $(HOST_DEF_CC))" \
        CFLAGS_FOR_BUILD="$(strip $(HOST_CFLAGS) $(%(mmake)-s_flag))" \
        CXX_FOR_BUILD="$(strip $(HOST_CXX))" \
        CXXFLAGS_FOR_BUILD="$(strip $(HOST_CXXFLAGS) $(%(mmake)-s_flag))" \
        LD_FOR_BUILD="$(strip $(HOST_LD))" \
        LDFLAGS_FOR_BUILD="$(strip $(HOST_LDFLAGS) $(%(mmake)-s_flag))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS_FOR_HOST="$(strip $(BASE_CPPFLAGS) $(USER_CPPFLAGS) %(extracppflags))"
endif
    %(mmake)-cfg-env += CC_FOR_HOST="$(strip $(TARGET_CC) $(TARGET_SYSROOT))" \
        CFLAGS_FOR_HOST="$(strip %(hostisaflags) $(USER_INCLUDES) $(BASE_CFLAGS) $(USER_CFLAGS) -L$(AROS_DEVELOPER)/lib %(extracflags) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        CXX_FOR_HOST="$(strip $(TARGET_CXX) $(TARGET_SYSROOT))" \
        CXXFLAGS_FOR_HOST="$(strip %(hostisaflags) $(USER_INCLUDES) $(BASE_CXXFLAGS) $(USER_CXXFLAGS) -L$(AROS_DEVELOPER)/lib %(extracxxflags) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        LD_FOR_HOST="$(strip $(TARGET_LD))" \
        LDFLAGS_FOR_HOST="$(strip -L$(AROS_DEVELOPER)/lib $(USER_LDFLAGS) $(%(mmake)-nix) $(%(mmake)-s_flag))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS_FOR_TARGET="$(strip $(BASE_CPPFLAGS) $(USER_CPPFLAGS) %(extracppflags))"
endif
    %(mmake)-cfg-env += CC_FOR_TARGET="$(strip $(TARGET_CC) $(TARGET_SYSROOT))" \
        CFLAGS_FOR_TARGET="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CFLAGS) $(USER_CFLAGS) -L$(AROS_DEVELOPER)/lib %(extracflags) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        CXX_FOR_TARGET="$(strip $(TARGET_CXX) $(TARGET_SYSROOT))" \
        CXXFLAGS_FOR_TARGET="$(strip %(targetisaflags) $(USER_INCLUDES) $(BASE_CXXFLAGS) $(USER_CXXFLAGS) -L$(AROS_DEVELOPER)/lib %(extracxxflags) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        LD_FOR_TARGET="$(strip $(TARGET_LD))" \
        LDFLAGS_FOR_TARGET="$(strip -L$(AROS_DEVELOPER)/lib $(USER_LDFLAGS) $(%(mmake)-nix) $(%(mmake)-s_flag))" \
        AR="$(strip $(AR_PLAIN))" \
        AS="$(strip $(TARGET_AS))" \
        OBJCOPY="$(strip $(OBJCOPY))" \
        RANLIB="$(strip $(RANLIB))" \
        STRIP="$(strip $(STRIP_PLAIN))"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += TARGET_CPPFLAGS="$(KERNEL_CPPFLAGS)"
endif
    %(mmake)-cfg-env += TARGET_CC="$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))" \
        TARGET_CFLAGS="$(strip %(targetisaflags) $(KERNEL_CFLAGS) $(%(mmake)-s_flag))" \
        TARGET_CXX="$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))" \
        TARGET_CXXFLAGS="$(strip $(KERNEL_CXXFLAGS) $(%(mmake)-s_flag))" \
        TARGET_AS="$(strip $(TARGET_AS))" \
        TARGET_RANLIB="$(strip $(RANLIB))" \
        TARGET_STRIP="$(strip $(STRIP_PLAIN))" \
        TARGET_NM="$(strip $(NM_PLAIN))"
ifeq (%(buildflags),yes)
    %(mmake)-config_opts += --target=$(AROS_TARGET_CPU)-aros
    %(mmake)-config_opts += --build=$(AROS_HOST_CPU)-$(AROS_HOST_ARCH)
    %(mmake)-config_opts += --host=$(AROS_TARGET_CPU)-aros
endif
ifeq (%(gnuflags),yes)
    %(mmake)-config_opts += --without-pic --disable-shared
ifeq (%(nlsflag),yes)
# disable native language support
    %(mmake)-config_opts += --disable-nls
endif
ifeq (%(xflag),yes)
# disable X window system
    %(mmake)-config_opts += --without-x
endif
endif
endif
ifeq (%(compiler),kernel)
    %(mmake)-cfg-env := %(config_env_extra) \
        CPP="$(KERNEL_CPP)" \
        CXXCPP="$(KERNEL_CPP)"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS="$(strip $(KERNEL_CPPFLAGS) %(extracppflags))"
endif
    %(mmake)-cfg-env += CC="$(strip $(KERNEL_CC) $(KERNEL_SYSROOT))" \
        CFLAGS="$(strip %(targetisaflags) $(KERNEL_CFLAGS) %(extracflags) $(%(mmake)-s_flag))" \
        CXX="$(strip $(KERNEL_CXX) $(KERNEL_SYSROOT))" \
        CXXFLAGS="$(strip $(KERNEL_CXXFLAGS) %(extracxxflags) $(%(mmake)-s_flag))" \
        AS="$(KERNEL_AS)"
ifeq (%(usecppflags),yes)
    %(mmake)-cfg-env += CPPFLAGS_FOR_BUILD="$(HOST_CPPFLAGS)"
endif
    %(mmake)-cfg-env += CC_FOR_BUILD="$(HOST_DEF_CC)" \
        CFLAGS_FOR_BUILD="$(HOST_CFLAGS)" \
        CXX_FOR_BUILD="$(HOST_CXX)" \
        CXXFLAGS_FOR_BUILD="$(HOST_CXXFLAGS)" \
        RANLIB="$(RANLIB)" \
        TARGET_RANLIB="$(RANLIB)" \
        TARGET_STRIP="$(STRIP_PLAIN)" \
        TARGET_NM="$(NM_PLAIN)"
ifeq (%(buildflags),yes)
    %(mmake)-config_opts += --target=$(AROS_TARGET_CPU)-aros
    %(mmake)-config_opts += --build=$(AROS_HOST_CPU)-$(AROS_HOST_ARCH)
    %(mmake)-config_opts += --host=$(AROS_TARGET_CPU)-aros
endif
ifeq (%(gnuflags),yes)
    %(mmake)-config_opts += --without-pic --disable-shared
ifeq (%(nlsflag),yes)
# disable native language support
    %(mmake)-config_opts += --disable-nls
endif
ifeq (%(xflag),yes)
# disable X window system
    %(mmake)-config_opts += --without-x
endif

endif
endif

ifeq (%(use_build_env),yes)
    BUILD_ENV := $(%(mmake)-cfg-env)
endif

ifneq ("$(wildcard %(srcdir)/Makefile)","")
# in an ideal world, we would depend on the files in the source directory,
# so we could copy them when they change. unfortunately filenames with
# spaces causes problems with this
$(%(mmake)-pkgdir)/.local-copy:
	%mkdirs_q $(%(mmake)-pkgdir)
	@$(ECHO) "Copying Local-Build Sources to  \`$(patsubst $(TOP)/%,%,$(abspath $(%(mmake)-pkgdir)))'"
	@$(CP) -Rf "%(srcdir)/." $(%(mmake)-pkgdir)/ && $(TOUCH) $@

$(%(mmake)-pkgdir)/.files-touched : $(%(mmake)-pkgdir)/.local-copy

    %(mmake)-cfg-srcdir=$(%(mmake)-pkgdir)
else
    %(mmake)-cfg-srcdir=%(srcdir)
endif
%(mmake)-make-env := -C $(%(mmake)-pkgdir)

.PHONY : %(mmake) %(mmake)-clean %(mmake)-build_and_install-quick

# When building for the host, we don't need to build the
# linklibs - this is especially true when building the
# crosstool toolchain on 'foreign' architectures (such as
# building PPC on x86)

#MM- %(mmake)-host : setup includes %(mmake)-quick
#MM- %(mmake)-target : setup includes core-linklibs %(mmake)-quick
#MM- %(mmake): %(mmake)-%(compiler)

# Using -j1 in install_command may result in a warning but finally
# it does its job. make install for gcc does not work reliably for -jN
# where N > 1.
ifneq (%(install_target),)
    %(mmake)-install_command = \
        $(ECHO) "Installing from build in         $(subst $(TOP)/,,$(%(mmake)-pkgdir))" && \
        $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_opts) \
        $(%(mmake)-make-env) %(install_target) -j1

    %(mmake)-uninstall_command = \
    $(RM) $(%(mmake)-installflag) && \
    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" \
    $(%(mmake)-install_opts) $(%(mmake)-make-env) uninstall
else
    %(mmake)-install_command   := true
    %(mmake)-uninstall_command := true
endif

#MM- %(mmake)-quick : %(preconfigure) %(mmake)-configure %(postconfigure) %(mmake)-build_and_install-quick %(postinstall)

#MM
%(mmake)-build_and_install-quick :  $(%(mmake)-installflag)

#
# N.B.: the make test for the targets being up to date generates a benign Error 1.
#
$(%(mmake)-installflag) : $(%(mmake)-configflag)
	@$(IF) ! $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" -q $(%(mmake)-make-env); then \
	    $(RM) $(%(mmake)-installflag) && \
	    $(ECHO) "Performing build in         $(subst $(TOP)/,,$(%(mmake)-pkgdir))" && \
	    $(BUILD_ENV) $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" $(%(mmake)-make-env) && \
	    $(%(mmake)-install_command) && \
	    $(TOUCH) $@ -r $^; \
	fi

$(%(mmake)-pkgdir)/.files-touched:
	%mkdirs_q $(%(mmake)-pkgdir)
	@find %(srcdir) -exec $(TOUCH) -c -r $(%(mmake)-cfg-srcdir)/configure '{}' \; && \
	$(TOUCH) $@

#MM
%(mmake)-uninstall :
	$(%(mmake)-uninstall_command)

#MM
%(mmake)-configure : $(%(mmake)-configflag)

$(%(mmake)-configflag) : TMP_SRCDIR := $(shell echo $(%(mmake)-cfg-srcdir) | sed 's/^\(.\):\//\/\1\//')
$(%(mmake)-configflag) : $(%(mmake)-pkgdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	@$(RM) $@
	%mkdirs_q $(%(mmake)-pkgdir)
	@$(ECHO) "Configuring build in         $(subst $(TOP)/,,$(%(mmake)-pkgdir))"
	@cd $(%(mmake)-pkgdir) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	$(%(mmake)-cfg-env) $(TMP_SRCDIR)/configure $(%(mmake)-config_opts) %(extraoptions) && \
	$(TOUCH) $@

#MM
%(mmake)-clean : %(mmake)-uninstall
	@$(RM) $(%(mmake)-pkgdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build an imported source tree which uses cmake 
#
# Arguments:
#
#     - mmake           = the meta make target.
#     - package         = name of the package to be built.
#     - srcdir          = the location of the unpacked source code. Defaults
#                         to $(SRCDIR)/$(CURDIR).
#     - prefix          = the target directory. Must be an absolute path of the
#                         host system. Defaults to $(AROS_CONTRIB).
#     - aros_prefix     = set a path which is valid within the AROS filesystem.
#                         Defaults to the value of the prefix option.
#     - extraoptions    = additional options for the cmake script.
#     - usecppflags     = enable the use of cpp flags. some external cmake
#                         scripts will not set their own cppflags if it is already
#                         set, so this allows them to be disabled (unless you can provide
#                         all the options they would need)
#     - cppflags        = preprocessor flags.
#     - cflags          = flags to use with the C compiler.
#     - cxxflags        = flags to use with the C++ compiler.
#     - installoptions    = additional options for the install step.
#

%define build_with_cmake mmake=/A package= srcdir=$(SRCDIR)/$(CURDIR) gendir= prefix= \
    aros_prefix= extraoptions= installoptions= maketarget= compiler=target \
    usecppflags=yes cppflags=$(CPPFLAGS) cflags=$(CFLAGS) cxxflags=$(CXXFLAGS) ldflags=$(LDFLAGS)

ifneq (%(prefix),)
    %(mmake)-prefix := %(prefix)
else
    %(mmake)-prefix := $(AROS_CONTRIB)
endif

ifneq (%(aros_prefix),)
    %(mmake)-aros_prefix := %(aros_prefix)
else
    %(mmake)-aros_prefix := $(%(mmake)-prefix)
endif

ifeq (%(compiler),host)
    BD_LDFLAGS   := $(strip -L$(CROSSTOOLSDIR)/lib $(USER_LDFLAGS))
    BD_CFLAGS := $(strip $(HOST_CFLAGS) -I$(CROSSTOOLSDIR)/include)
    BD_CXXFLAGS := $(strip $(HOST_CXXFLAGS) -I$(CROSSTOOLSDIR)/include)
    BD_CPPFLAGS := $(HOST_CPPFLAGS)
    %(mmake)-cmake_opts  := -DCMAKE_INSTALL_PREFIX=$(%(mmake)-prefix) -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER="$(HOST_DEF_CC)" -DCMAKE_C_FLAGS="$(BD_CFLAGS)"
    ifeq (%(usecppflags),yes)
        %(mmake)-cmake_opts += -DCMAKE_CPP_FLAGS="$(BD_CPPFLAGS)"
    endif
    %(mmake)-cmake_opts += -DCMAKE_CXX_COMPILER="$(HOST_CXX)" -DCMAKE_CXX_FLAGS="$(BD_CXXFLAGS)"
    ifeq (%(package),)
        %(mmake)-pkgdir := $(HOSTGENDIR)/$(CURDIR)
    else
        %(mmake)-pkgdir := $(HOSTGENDIR)/$(CURDIR)/%(package)
    endif
else
    BD_LDFLAGS   := %(ldflags)
    BD_CFLAGS := %(cflags) 
    BD_CXXFLAGS := %(cxxflags)
    BD_CPPFLAGS := %(cppflags)
    %(mmake)-cmake_opts  := -DCMAKE_TOOLCHAIN_FILE=$(GENDIR)/config/conf.cmake -DCMAKE_INSTALL_PREFIX=$(%(mmake)-prefix) -DCMAKE_C_FLAGS="$(strip $(BD_CFLAGS))"
    ifeq (%(usecppflags),yes)
        %(mmake)-cmake_opts += -DCMAKE_CPP_FLAGS="$(BD_CPPFLAGS)"
    endif
    %(mmake)-cmake_opts  += -DCMAKE_CXX_FLAGS="$(strip $(BD_CXXFLAGS))" -DCMAKE_EXE_LINKER_FLAGS="$(strip $(BD_LDFLAGS))"
    ifeq (%(package),)
        %(mmake)-pkgdir := $(GENDIR)/$(CURDIR)
    else
        %(mmake)-pkgdir := $(GENDIR)/$(CURDIR)/%(package)
    endif
endif
ifneq (%(gendir),)
    ifeq (%(package),)
        %(mmake)-pkgdir := %(gendir)/$(CURDIR)
    else
        %(mmake)-pkgdir := %(gendir)/$(CURDIR)/%(package)
    endif
endif

%(mmake)-cmakeflag := $(%(mmake)-pkgdir)/.cmake
%(mmake)-installflag := $(%(mmake)-pkgdir)/.installed

.PHONY : %(mmake) %(mmake)-clean %(mmake)-build_and_install-quick

#MM- %(mmake): setup includes core-linklibs %(mmake)-quick

#MM- %(mmake)-quick : %(mmake)-cmake %(mmake)-build_and_install-quick

#MM
%(mmake)-build_and_install-quick :  $(%(mmake)-installflag)

$(%(mmake)-installflag) : $(%(mmake)-cmakeflag)
	$(IF) ! $(MAKE) -q -C $(%(mmake)-pkgdir); then \
	    $(RM)  $(%(mmake)-installflag) && \
	    $(MAKE) -C $(%(mmake)-pkgdir) %(maketarget) && \
	    cd $(%(mmake)-pkgdir) && \
	    cmake %(installoptions) -P cmake_install.cmake && \
	    $(TOUCH) $@ -r $^; \
	fi

$(%(mmake)-pkgdir)/.files-touched:
	%mkdirs_q $(%(mmake)-pkgdir)
	find %(srcdir) -exec $(TOUCH) -c -r %(srcdir)/CMakeLists.txt '{}' \; && \
	$(TOUCH) $@

#MM
%(mmake)-cmake : $(%(mmake)-cmakeflag)

$(%(mmake)-cmakeflag) : TMP_SRCDIR := $(shell echo %(srcdir) | sed 's/^\(.\):\//\/\1\//')
$(%(mmake)-cmakeflag) : $(%(mmake)-pkgdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(%(mmake)-pkgdir)
	cd $(%(mmake)-pkgdir) && \
	$(RM) -Rf CMakeCache.txt CMakeFiles \; && \
	cmake $(%(mmake)-cmake_opts) %(extraoptions) $(TMP_SRCDIR) && \
	$(TOUCH) $@

#MM
%(mmake)-clean : %(mmake)-uninstall
	@$(RM) $(%(mmake)-pkgdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Given an archive name, patches names and locations where to find them, fetch
# the archive and the patches from any of those locations, unpack the archive
# and then apply the patches.
#
# Locations currently supported are http and ftp sites, plus local filesystem
# directories. Supported archives are .tar.bz2 and .tar.gz. To modify this,
# the fetch.sh script needs to be modified, since this macro relies on that script.
#
# Arguments:
#
#     - mmake           = mmaketarget
#     - archive_origins = list of locations where to find the archive. They are tried
#                         in sequence, until the archive is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - archive         = the archive name. Mandatory.
#     - suffixes        = a list of suffixes to append to the package name plus the
#                         version. Each one of them is tried until a matching archive is
#                         found. They are appended to patches and these are tried the
#                         same way as packages are.
#     - location        = the local directory where to put the fetched archive and patches.
#                         If not specified, the directory specified by destination is used.
#     - destination     = the directory to unpack the archive to.
#                         If not specified, the current directory is assumed.
#     - patches_origins = list of locations where to find the patches. They are tried
#                         in sequence, until a patch is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - patches_specs   = list of "patch specs". A patch spec is of the form
#                         patch_name[:[patch_subdir][:patch_opt]].
#
#			      - patch_name   = the name of the patch file
#			      - patch_subdir = the directory within \destination\ where to
#			                       apply the patch.
#			      - patch_opt    = any options to pass to the `patch' command
#			                       when applying the patch.
#                         
#                         The patch_subdir and patch_opt fields are optional.

%define fetch mmake=/A archive_origins=. archive=/A suffixes= location= destination=. \
    patches_origins=$(SRCDIR)/$(CURDIR) patches_specs=::

.PHONY: %(mmake)

ifneq (%(location),)
    %(mmake)-location := %(location)
else
    %(mmake)-location := %(destination)
endif

#MM
%(mmake) :
	$(FETCH) -ao "%(archive_origins)" -a %(archive) -s "%(suffixes)" -l $(%(mmake)-location) \
	-d %(destination) -po "%(patches_origins)" -p "%(patches_specs)"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# This macro can aid in patch creation for fetched ports. It temporarily creates another
# unpatched source tree and runs diff against this and a previously fetched and possibly
# patched tree. Depending on what happens after patching during a normal build it might
# give best results if the new patch is created directly after fetch.
#
# Arguments:
#
#     - mmake       = mmaketarget
#     - archive     = archive base name
#     - srcdir      = the top level directory the package is unpacked to, useful if
#                     an archive unpacks to a directory other than its name suggests.
#                     this should not be deeper than a single path element.
#     - suffixes    = a list of suffixes to append to the the package name plus the
#                     version. Each one of them is tried until a matching archive is
#                     found.
#     - destination = the directory to unpack the archive to.
#     - excludes    = diff patterns to exclude files or directories from the patch

%define create_patch mmake=/A archive=/A srcdir= suffixes="tar.bz2 tar.gz" destination=/A excludes=

.PHONY: %(mmake)

ifneq (%(excludes),)
    %(mmake)-exclude := -X ./exclude.patterns
endif

ifneq (%(srcdir),)
    %(mmake)-srcdir := %(srcdir)
else
    %(mmake)-srcdir := %(archive)
endif

#MM- %(mmake) : %(mmake)-diff
#MM- %(mmake)-quick : %(mmake)-diff

#MM
%(mmake)-diff:
	@$(FETCH) -a %(archive) -s "%(suffixes)" -l $(PORTSSOURCEDIR) -d %(destination)/tmp ; \
	$(MV) %(destination)/$(%(mmake)-srcdir) %(destination)/tmp/$(%(mmake)-srcdir).aros ; \
	cd %(destination)/tmp ; \
	$(FOR) f in %(excludes) ; do \
	    $(ECHO) $$f >> ./exclude.patterns ; \
	done ; \
	diff -ruN $(%(mmake)-exclude) \
	    $(%(mmake)-srcdir) \
	    $(%(mmake)-srcdir).aros \
	    >$(SRCDIR)/$(CURDIR)/%(archive)-aros-new.diff ; \
	$(MV) %(destination)/tmp/$(%(mmake)-srcdir).aros %(destination)/$(%(mmake)-srcdir) ; \
	$(RM) %(destination)/tmp
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Joins the features of %fetch and %build_with_configure.
#
# If a patch is provided, it *must* be named the following way:
#
#    <package name>-<version number>-aros.diff
#
# Moreover, it *must* be appliable with the -p1 option of the `patch' command after
# CD'ing into the archive's extracted directory.
#
# Note that whilst the %fetch macro accepts a list of patches for any given archive,
# the %fetch_and_build macro only accepts *one* patch for each package. It's up to you
# to make that patch fully comprehensive.
#
# Arguments:
#
#    - mmake            = the meta make target.
#    - package          = the GNU package name, sans version and archive format suffixes.
#    - subpackage       = ???
#    - compiler         = same meaning as the one for the %build_with_configure macro.
#    - install_target   = same meaning as the one for the %build_with_configure macro.
#    - version          = the package's version number, or otherwise any other version string.
#                         It gets appended to the package name to form the basename of the archive.
#    - suffixes         = a list of suffixes to apped to the the package name plus the
#                         version. Each one of them is tried until a matching archive is found.
#                         Defaults to "tar.bz2 tar.gz".
#    - srcdir           = the top level directory the package is unpacked to (see create_patch).
#    - builddir         = override the location we expect to run configure/make in.
#    - package_repo     = same meaning as the one of the %fetch macro's %(archive_origins) argument
#    - patch            = "yes" or "no", depending on whether a patch for this package needs to be
#                         fetched or not. Default to no.
#    - patch_repo       = same meaning as the one of the %fetch macro's %(patches_origins) argument
#    - prefix           = same meaning as the one for the %build_with_configure macro.
#    - aros_prefix      = same meaning as the one for the %build_with_configure macro.
#    - extraoptions     = same meaning as the one for the %build_with_configure macro.
#    - usecppflags      = same meaning as the one for the %build_with_configure macro.
#    - extracppflags    = same meaning as the one for the %build_with_configure macro.
#    - extracflags      = same meaning as the one for the %build_with_configure macro.
#    - extracxxflags    = same meaning as the one for the %build_with_configure macro.
#    - preconfigure     = same meaning as the one for the %build_with_configure macro.
#    - postconfigure    = same meaning as the one for the %build_with_configure macro.
#    - postinstall      = same meaning as the one for the %build_with_configure macro.
#    - install_env      = same meaning as the one for the %build_with_configure macro.
#    - use_build_env    = same meaning as the one for the %build_with_configure macro.
#    - nix              = same meaning as the one for the %build_with_configure macro.
#    - nix_dir_layout   = same meaning as the one for the %build_with_configure macro.
#    - create_pkg       = create a distributable package of the compiled sources, defaults to no

%define fetch_and_build mmake=/A package=/A subpackage= compiler=target crossbuild=no install_target=install \
    version=/A suffixes="tar.bz2 tar.gz" srcdir= builddir= gendir= basedir=$(CURDIR) package_repo= patch=no patch_repo= \
    prefix= aros_prefix= preconfigure= postconfigure= postinstall= \
    extraoptions= usecppflags=yes extracppflags= extracflags="$(OPTIMIZATION_CFLAGS)" extracxxflags="$(OPTIMIZATION_CFLAGS)" \
    config_env_extra= install_env= use_build_env=no nix=no nix_dir_layout= create_pkg=no buildflags=yes gnuflags=yes nlsflag=yes xflag=yes hostisaflags="$(TARGET_ISA_CFLAGS)" targetisaflags="$(TARGET_ISA_CFLAGS)"

#MM- %(mmake)-quick : %(mmake)-%(subpackage)-quick
#MM- %(mmake)-%(subpackage)-quick : %(mmake)-%(subpackage)-fetch
#MM- %(mmake)-fetch : %(mmake)-%(subpackage)-fetch
#MM- %(mmake)-create-patch : %(mmake)-%(subpackage)-create-patch
 
%(mmake)-archbase  := %(package)-%(version)

ifeq (%(compiler),host)
    %(mmake)-portdir  := $(HOSTDIR)/Ports/host/%(package)
else
    %(mmake)-portdir  := $(PORTSDIR)/%(package)
endif

ifeq (%(prefix),)
    %(mmake)-prefix := $(CONTRIB_DIR)/%(package)
else
    %(mmake)-prefix := %(prefix)
endif

ifneq (%(subpackage),)
    %(mmake)-%(subpackage)-archbase  := %(package)-%(subpackage)-%(version)
else
    %(mmake)-%(subpackage)-archbase  := %(package)-%(version)
endif

ifneq (%(srcdir),)
    %(mmake)-%(subpackage)-srcdir  := %(srcdir)
else
    %(mmake)-%(subpackage)-srcdir  := $(%(mmake)-archbase)
endif

ifneq (%(builddir),)
    %(mmake)-%(subpackage)-builddir  := $(%(mmake)-%(subpackage)-srcdir)/%(builddir)
else
    %(mmake)-%(subpackage)-builddir  := $(%(mmake)-%(subpackage)-srcdir)
endif

ifeq (%(patch),yes)
    %(mmake)-%(subpackage)-patches_specs := $(%(mmake)-%(subpackage)-archbase)-aros.diff:$(%(mmake)-%(subpackage)-srcdir):-f,-p1
else
    %(mmake)-%(subpackage)-patches_specs := ::
endif

%fetch mmake="%(mmake)-%(subpackage)-fetch" archive=$(%(mmake)-%(subpackage)-archbase) suffixes="%(suffixes)" \
    location=$(PORTSSOURCEDIR) destination=$(%(mmake)-portdir) \
    archive_origins=". %(package_repo)" \
    patches_specs=$(%(mmake)-%(subpackage)-patches_specs) patches_origins="$(SRCDIR)/$(CURDIR) %(patch_repo)"

%create_patch mmake="%(mmake)-%(subpackage)-create-patch" \
    archive=$(%(mmake)-%(subpackage)-archbase) \
    srcdir=$(%(mmake)-%(subpackage)-srcdir) \
    suffixes="%(suffixes)" \
    destination=$(%(mmake)-portdir)

#MM- %(mmake) : %(mmake)-%(subpackage)

%(mmake)-%(subpackage)-package-dir := $(%(mmake)-portdir)/$(%(mmake)-%(subpackage)-archbase)

%(mmake)-%(subpackage)-package-basename := \
    $(DISTDIR)/Packages/$(%(mmake)-%(subpackage)-archbase)-aros.$(AROS_TARGET_CPU)

ifneq (%(create_pkg),no)
    %(mmake)-%(subpackage)-package := $(%(mmake)-%(subpackage)-package-basename).tar.bz2
endif

%build_with_configure mmake="%(mmake)-%(subpackage)" package="%(package)" compiler="%(compiler)"  crossbuild="%(crossbuild)" install_target="%(install_target)" \
     srcdir=$(%(mmake)-portdir)/$(%(mmake)-%(subpackage)-builddir) gendir="%(gendir)" basedir="%(basedir)" \
     config_env_extra="%(config_env_extra)" install_env="%(install_env)" use_build_env="%(use_build_env)" \
     nix="%(nix)" nix_dir_layout="%(nix_dir_layout)" prefix=$(%(mmake)-prefix)  aros_prefix="%(aros_prefix)" \
     preconfigure="%(preconfigure)" postconfigure="%(postconfigure)" postinstall="%(postinstall) %(mmake)-%(subpackage)-make-package" \
     extraoptions="%(extraoptions)" usecppflags="%(usecppflags)" extracppflags="%(extracppflags)" extracflags="%(extracflags)" extracxxflags="%(extracxxflags)" \
     buildflags=%(buildflags) gnuflags=%(gnuflags) nlsflag=%(nlsflag) xflag=%(xflag) hostisaflags=%(hostisaflags) targetisaflags=%(targetisaflags)

.PHONY : %(mmake)-%(subpackage)-make-package %(mmake)-%(subpackage)-create-patch
#MM %(mmake)-%(subpackage)-make-package : %(mmake)-%(subpackage)-quick

#MM
%(mmake)-%(subpackage)-make-package : $(%(mmake)-%(subpackage)-package)
 
#There seems to be a bug, either with my clock or with make, 'cause it may happen
#that $^ and $@ have exactly the same mtime, and in that case make tries
#to rebuild $@ again, which would fail because the directory where
#the package got installed would not exist anymore. 
#We work this around by using an if statement to manually check the mtimes.
$(%(mmake)-%(subpackage)-package-basename).tar.bz2 :
	@$(IF) $(TEST) $(%(mmake)-installflag) -nt $@ || ! $(TEST) -s $@; then \
	    $(RM) $@ ; \
	    $(ECHO) "Building   \`$(%(mmake)-%(subpackage)-package-basename).tar.bz2'" ; \
	    $(MKDIR) -p "$(DISTDIR)/Packages" ; \
	    $(MKDIR) -p "$(%(mmake)-prefix)" ; \
	    cd $(%(mmake)-%(subpackage)-package-dir) ; \
	    tar -cvf $(%(mmake)-%(subpackage)-package-basename).tar * ; \
	    bzip2 -9 -f $(%(mmake)-%(subpackage)-package-basename).tar ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Joins the features of %fetch and %build_with_configure, taking advantage of
# the naming scheme of GNU packages. GNU packages names are in the form
#
#     <package name>-<version number>.<archive format suffix>
#
# If a patch is provided, it *must* be named the following way:
#
#    <package name>-<version number>-aros.diff
#
# Moreover, it *must* be appliable with the -p1 option of the `patch' command after
# CD'ing into the archive's extracted directory.
#
# Note that whilst the %fetch macro accepts a list of patches for any given archive,
# the %fetch_and_build macro only accepts *one* patch for each package. It's up to you
# to make that patch fully comprehensive.
#
# NOTE: GNU packages are always compiled with *nix semantics turned on.
#
# Arguments:
#
#    Arguments have the same meaning as the one for the %fetch_and_build macro, except:
#
#    - prefix           = defaults to $(GNUDIR).
#    - aros_prefix      = defaults to /GNU.

%define fetch_and_build_gnu mmake=/A package=/A subpackage= version=/A crossbuild=no suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(GNUDIR) \
    aros_prefix=/GNU config_env_extra= preconfigure= postconfigure= postinstall= \
    extraoptions= usecppflags=yes extracppflags= extracflags="$(OPTIMIZATION_CFLAGS)" extracxxflags="$(OPTIMIZATION_CFLAGS)" \
    nix=yes gnuflags=yes nlsflag=yes xflag=yes

GNU_REPOSITORY := gnu://

%fetch_and_build mmake="%(mmake)" package="%(package)" subpackage="%(subpackage)" version="%(version)" \
    crossbuild="%(crossbuild)" suffixes="%(suffixes)" srcdir="%(srcdir)" \
    package_repo="%(package_repo) $(GNU_REPOSITORY)%(package)" \
    patch="%(patch)" patch_repo="%(patch_repo)" \
    prefix="%(prefix)" aros_prefix="%(aros_prefix)" \
    extraoptions="%(extraoptions)" usecppflags="%(usecppflags)" extracppflags="%(extracppflags)" extracflags="%(extracflags)" extracxxflags="%(extracxxflags)" \
    config_env_extra="%(config_env_extra)" preconfigure="%(preconfigure)" postconfigure="%(postconfigure)" postinstall="%(postinstall)" \
    nix=%(nix) gnuflags=%(gnuflags) nlsflag=%(nlsflag) xflag=%(xflag)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Same job as the one of %fetch_and_build_gnu, except that this one assumes
# that the package is a "Developer" package, and as such it needs to be placed
# under the $(AROS_DEVELOPER) directory, as a default. 
#
# All the arguments have the same meaning as the ones of the %fetch_and_build_gnu 
# macro, but notice that %fetch_and_build_gnu_development *doesn't* have a
# "mmake" argument, because the metatarget is implicitely defined as
#
#     #MM- development-%(package)

%define fetch_and_build_gnu_development package=/A subpackage= version=/A  crossbuild=no suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(AROS_DEVELOPER) \
    aros_prefix=/Developer config_env_extra= preconfigure= postconfigure= postinstall= \
    extraoptions= usecppflags=yes extracppflags= extracflags="$(OPTIMIZATION_CFLAGS)" extracxxflags="$(OPTIMIZATION_CFLAGS)" \
    nix=yes gnuflags=yes nlsflag=yes xflag=yes

#MM- development : development-%(package)


%fetch_and_build_gnu mmake="development-%(package)" package="%(package)" subpackage="%(subpackage)" \
   version="%(version)" crossbuild="%(crossbuild)" suffixes="%(suffixes)" srcdir="%(srcdir)" \
   package_repo="%(package_repo)" \
   patch="%(patch)" patch_repo="%(patch_repo)" \
   prefix="%(prefix)"  aros_prefix="%(aros_prefix)" \
   extraoptions="%(extraoptions)" usecppflags="%(usecppflags)" extracflags="%(extracflags)" extracppflags="%(extracppflags)" extracxxflags="%(extracxxflags)" \
   config_env_extra="%(config_env_extra)" preconfigure="%(preconfigure)" postconfigure="%(postconfigure)" postinstall="postinstall-%(package)-delete-la-files %(postinstall)" \
   nix=%(nix) gnuflags=%(gnuflags) nlsflag=%(nlsflag) xflag=%(xflag)

#MM
postinstall-%(package)-delete-la-files:
	$(RM) %(prefix)/lib/*.la

%end
#------------------------------------------------------------------------------

# Builds a kickstart package in PKG format
#
# Arguments:
#
#    - mmake   = target name
#    - file    = destination file name with path
#
# Other arguments are self-explanatory

%define make_package mmake=/A file=/A classes= devs= handlers= hidds= libs= res= \
    arch_classes= arch_devs= arch_handlers= arch_hidds= arch_libs= arch_res=

PKG_CLASSES   := $(addprefix $(AROS_CLASSES)/,$(addsuffix .class, %(classes)))
PKG_DEVICES   := $(addprefix $(AROS_DEVS)/,$(addsuffix .device, %(devs)))
PKG_HANDLERS  := $(addprefix $(AROS_FS)/,$(addsuffix -handler, %(handlers)))
PKG_HIDD      := $(addprefix $(AROS_DEVS)/Drivers/,$(addsuffix .hidd, %(hidds)))
PKG_LIBS      := $(addprefix $(AROS_LIBRARIES)/,$(addsuffix .library, %(libs)))
PKG_RESOURCES := $(addprefix $(AROS_DEVS)/,$(addsuffix .resource, %(res)))

PKG_CLASSES_ARCH   := $(addprefix $(AROS_CLASSES_ARCH)/,$(addsuffix .class, %(arch_classes)))
PKG_DEVICES_ARCH   := $(addprefix $(AROS_DEVS_ARCH)/,$(addsuffix .device, %(arch_devs)))
PKG_HANDLERS_ARCH  := $(addprefix $(AROS_FS_ARCH)/,$(addsuffix -handler, %(arch_handlers)))
PKG_HIDD_ARCH      := $(addprefix $(AROS_DEVS_ARCH)/Drivers/,$(addsuffix .hidd, %(arch_hidds)))
PKG_LIBRARIES_ARCH := $(addprefix $(AROS_LIBRARIES_ARCH)/,$(addsuffix .library, %(arch_libs)))
PKG_RESOURCES_ARCH := $(addprefix $(AROS_DEVS_ARCH)/,$(addsuffix .resource, %(arch_res)))

PKG_FILES := $(PKG_CLASSES) $(PKG_DEVICES) $(PKG_HANDLERS) $(PKG_HIDD) $(PKG_LIBS) $(PKG_RESOURCES) \
    $(PKG_CLASSES_ARCH) $(PKG_DEVICES_ARCH) $(PKG_HANDLERS_ARCH) $(PKG_HIDD_ARCH) $(PKG_LIBRARIES_ARCH) $(PKG_RESOURCES_ARCH)
PKG_DIR   := $(dir %(file))

#MM
%(mmake) : %(file)

#MM
%(mmake)-quick : %(file)

%(file): $(PKG_FILES) | $(PKG_DIR)
	@$(ECHO) Packaging $@...
	@$(SRCDIR)/tools/package/pkg c $@ $^

%compress_file mmake="%(mmake)" file="%(file)"

GLOB_MKDIRS += $(PKG_DIR)

%end

#------------------------------------------------------------------------------
# Compresses %(file) with a gzip.
# Good in conjunction with for example %build_prog

%define compress_file mmake=/A file=/A

#MM- %(mmake)-gz : %(mmake) %(mmake)-gz-quick

#MM
%(mmake)-gz-quick : %(file).gz

%(file).gz: %(file)
	@$(ECHO) Compressing $(subst $(TARGETDIR)/,,$^)...
	@gzip -9 -f $^

%end

#------------------------------------------------------------------------------
# Links a kickstart module in ELF format
# Arguments are similar to make_package

%define link_kickstart mmake=/A file=/A classes= devs= handlers= hidds= libs= res= \
    startup= uselibs= ldflags=$(LDFLAGS) map= deps=

KOBJ_CLASSES  := $(addprefix $(KOBJSDIR)/, $(addsuffix _class.o, %(classes)))
KOBJ_DEVICES  := $(addprefix $(KOBJSDIR)/, $(addsuffix _device.o, %(devs)))
KOBJ_HANDLERS := $(addprefix $(KOBJSDIR)/, $(addsuffix _handler.o, %(handlers)))
KOBJ_HIDD     := $(addprefix $(KOBJSDIR)/, $(addsuffix _hidd.o, %(hidds)))
KOBJ_LIBS     := $(addprefix $(KOBJSDIR)/, $(addsuffix _library.o, %(libs)))
KOBJ_RES      := $(addprefix $(KOBJSDIR)/, $(addsuffix _resource.o, %(res)))

ifeq (%(startup),)
    KOBJ_STARTUP := $(GENDIR)/$(RESIDENT_BEGIN).o
else
    KOBJ_STARTUP := %(startup)
endif

KOBJS        := $(KOBJ_STARTUP) $(KOBJ_CLASSES) $(KOBJ_HANDLERS) $(KOBJ_LIBS) $(KOBJ_DEVICES) $(KOBJ_HIDD) $(KOBJ_RES)

TMP_LDFLAGS := %(ldflags)

# Make a list of the lib files this program depends on.
# In LDFLAGS remove white space between -L and directory
TMP_DIRS := $(subst -L ,-L,$(strip $(TMP_LDFLAGS)))
# Filter out only the libdirs and remove -L
TMP_DIRS := $(patsubst -L%,%,$(filter -L%,$(TMP_DIRS)))
# Add trailing /
TMP_DIRS := $(subst //,/,$(addsuffix /,$(TMP_DIRS)))
# Add normal linklib path
TMP_DIRS += $(AROS_LIB)/
# add lib and .a to static linklib names
TMP_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs)))
# search for the linklibs in the given path, ignore ones not found
TMP_DEPLIBS := $(foreach lib,$(TMP_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(TMP_DIRS)))) \
)

TMP_DIRS += $(dir %(file))
ifneq (%(map),)
    TMP_LDFLAGS += $(GENMAP) %(map)
    TMP_DIRS    += $(dir %(map))
endif

#MM %(mmake) : %(deps)

#MM
%(mmake) : %(file)

#MM
%(mmake)-quick : %(file)

%(file): KOBJS := $(KOBJS)
%(file): LDFLAGS := $(TMP_LDFLAGS) $(NOSTARTUP_LDFLAGS) \
                    -static -nosysbase -Wl,-Ur
%(file): LDLIBS := $(addprefix -l, %(uselibs))
%(file): $(KOBJS) $(DEPLIBS) | $(TMP_DIRS)
	@$(ECHO) "Kickstart  $(subst $(TARGETDIR)/,,$@)..."
	@$(TARGET_CC) $(TARGET_SYSROOT) -o $@ $(KOBJS) $(LDFLAGS) $(LDLIBS)
ifeq ($(DEBUG),yes)
	@$(STRIP) $@ --only-keep-debug -o $@.dbg
endif
	@$(STRIP) $@
ifeq ($(DEBUG),yes)
	@$(OBJCOPY) --add-gnu-debuglink=$@.dbg $@
endif

%compress_file mmake="%(mmake)" file="%(file)"

GLOB_MKDIRS += $(TMP_DIRS)

%end

#------------------------------------------------------------------------------
# Generate generic rules for a subtarget

%define subtarget parentmmake= mmake=/A mmbase=MM-
#%(mmbase) %(parentmmake) : %(mmake)
#%(mmbase) %(parentmmake)-includes : %(mmake)-includes
#%(mmbase) %(parentmmake)-quick : %(mmake)-quick
%end

#------------------------------------------------------------------------------
# Create a target directory

%define directorytarget mmake=/A directory=  icontarget= mmbase=MM-
#MM
%(mmake)-makedir ::
    %mkdirs_q %(directory)

#%(mmbase) %(mmake) : %(mmake)-makedir
%end
