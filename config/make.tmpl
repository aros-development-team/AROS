############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macros that are used as commands in the body     ##
## of a make rule.                                                         ##
## They are used to help the portability of mmakefiles to different        ##
## platforms and also will handle the error handling in a standard way.    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt).
%define compile_q cmd=$(TARGET_CC) opt=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Compiling %(from)"
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "%(from): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Compile failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd=$(CC) opt=$(AFLAGS) from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "$(notdir %(from)): %(cmd) %(opt) %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Assemble failed: %(cmd) %(opt) %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link a specified number of objects to an executable
%define link_q cmd=$(AROS_CC) opt=$(LDFLAGS) from=$< to=$@ libs=$(LIBS)
	@$(ECHO) "Linking %(to)..."
	@$(IF) %(cmd) %(opt) %(from) -o %(to) %(libs) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "%(to): %(cmd) %(opt) %(from) -o %(to) %(libs)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	   	else \
			$(NOP) ; \
    		fi ; \
	else \
	    $(ECHO) "Link failed: %(cmd) %(opt) %(from) -o %(to) %(libs)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi; \
	$(STRIP) %(to)
%end

#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building $(notdir $@) ..."
	@if $(AROS_CC) $(NOSTARTUP_LDFLAGS) %(ldflags) \
	    $(GENMAP) %(objdir)/%(module).map \
	    %(objs) %(libs) %(endtag) \
	    -o $@ 2>&1 > %(objdir)/%(err); \
	then \
	    cat %(objdir)/%(err); \
	else \
	    cat %(objdir)/%(err); \
	    exit 1; \
	fi

	@if $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(STRIP) $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags=$(CFLAGS) from=$< to=$@ cc=$(AROS_CC)
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	@AROS_CC="%(cc)" $(MKDEPEND) %(flags) %(from) -o %(to)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the function reference file %(to) to %(from)
%define mkref_q cc=$(AROS_CC) cppflags="-E -C -dD -D__CXREF__" cflags=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Generating ref for $(notdir %(from))..."
	@$(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to) 2>$(GENDIR)/cerrors
	@$(IF) $(TEST) -s %(to) ; \
	then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
	        $(ECHO) "%(from): $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" >> $(GENDIR)/errors ; \
	        tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    fi ; \
	else \
	    $(ECHO) "Reference generation failed: $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    $(RM) %(to) ; \
	    exit 1 ; \
	fi
%end

#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used to do certain tasks in a   ##
## mmakefile. They consist of one or more full makefile rules.             ##
## In general the files generated in these macro's are also defined as     ##
## make targets so that they can be used as a dependency in other rules    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy the files %(files) to %(targetdir). For each file in %(files),
# %(srcdir)/file is copied to %(targetdir)/file. The targetdir and the
# appropriate subdirs are not generated by this rule so they have to be
# present.
%define rule_copy_multi files=/A targetdir=/A srcdir=.

$(addprefix %(targetdir)/,%(files)) : %(targetdir)/% : %(srcdir)/%
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Copy the files %(files) to %(targetdir). For each file in %(files),
# %(srcdir)/file is copied to %(targetdir)/file if these files are different.
# %(stampfile) is used to keep track of when the last time the comparison has
# been done. The targetdir and the appropriate subdirs are not generated by 
# this rule so they have to be present.
%define rule_copy_diff_multi files=/A targetdir=/A srcdir=. \
    stampfile=$(TMP_SRCDIR)/.copy_stamp

TMP_SRCDIR := %(srcdir)

$(addprefix %(targetdir)/,%(files)) : | %(stampfile)

%(stampfile) : COPYSRCDIR := %(srcdir)
%(stampfile) : TGTDIR := %(targetdir)
%(stampfile) : FILES := %(files)
%(stampfile) : $(addprefix %(srcdir)/,%(files))
	@for f in $(FILES); do \
	     $(IF) ! $(CMP) -s $(COPYSRCDIR)/$$f $(TGTDIR)/$$f ; then \
	         $(CP) $(COPYSRCDIR)/$$f $(TGTDIR)/$$f ; \
	     fi ; \
	done
	@$(TOUCH) $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $^ >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# include when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

GLOB_MKDIRS += %(dirs)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile basename=/A cflags=$(CFLAGS) dflags= targetdir= compiler=target nix=no

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).o : TMP_CMD:=$(TARGET_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).o : TMP_CMD:=$(HOST_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(HOST_CC)
endif
ifeq (%(compiler),kernel)
$(TMP_TARGETBASE).o : TMP_CMD:=$(KERNEL_CC) $(KERNEL_CFLAGS)
$(TMP_TARGETBASE).d : TMP_CMD:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif

ifeq (%(nix),yes)
  $(TMP_TARGETBASE).o : CFLAGS := -nix %(cflags)
else
  $(TMP_TARGETBASE).o : CFLAGS := %(cflags)
endif
$(TMP_TARGETBASE).o : %(basename).c
	%compile_q cmd=$(TMP_CMD)

ifeq (%(dflags),)
  ifeq (%(nix),yes)
    $(TMP_TARGETBASE).d : TMP_DFLAGS:=-nix %(cflags)
  else
    $(TMP_TARGETBASE).d : TMP_DFLAGS:=%(cflags)
  endif
else
  ifeq (%(nix),yes)
    $(TMP_TARGETBASE).d : TMP_DFLAGS:=-nix %(dflags)
  else
    $(TMP_TARGETBASE).d : TMP_DFLAGS:=%(dflags)
  endif
endif
$(TMP_TARGETBASE).d : %(basename).c
	%mkdepend_q cc=$(TMP_CMD) flags=$(TMP_DFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile multiple C source files to an object file and
# generate the corresponding dependency files. The generated file will be put
# in the object directory without the directory part of the source file.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
# - compiler (default target): compiler to use, target, kernel or host
%define rule_compile_multi basenames=/A cflags=$(CFLAGS) dflags= targetdir= \
    compiler=target

ifeq (%(targetdir),)
TMP_TARGETS := $(addsuffix .o,%(basenames))
TMP_DTARGETS := $(addsuffix .d,%(basenames))
TMP_WILDCARD := %
else
TMP_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,$(notdir %(basenames))))
TMP_DTARGETS := $(addsuffix .d,$(addprefix %(targetdir)/,$(notdir %(basenames))))
TMP_WILDCARD := %(targetdir)/%

# Be sure that all .c files are generated
$(TMP_TARGETS) $(TMP_DTARGETS) : | $(addsuffix .c,%(basenames))

# Be sure that all .c files are found
TMP_DIRS := $(filter-out ./,$(sort $(dir %(basenames))))
ifneq ($(TMP_DIRS),)
    vpath %.c $(TMP_DIRS)
endif

endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETS) $(TMP_DTARGETS) : CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETS) $(TMP_DTARGETS) : CMD:=$(HOST_CC)
endif
ifeq (%(compiler),kernel)
$(TMP_TARGETS) $(TMP_DTARGETS) : CMD:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif

$(TMP_TARGETS) : CFLAGS := %(cflags)
$(TMP_TARGETS) : $(TMP_WILDCARD).o : %.c
	%compile_q cmd=$(CMD)

ifeq (%(dflags),)
$(TMP_DTARGETS) : DFLAGS:=%(cflags)
else
$(TMP_DTARGETS) : DFLAGS:=%(dflags)
endif
$(TMP_DTARGETS) : $(TMP_WILDCARD).d : %.c
	%mkdepend_q cc=$(CMD) flags=$(DFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Make an alias from one arch specific build to another arch.
# arguments:
# - mainmmake: the mmake of the module in the main tree
# - arch: the current arch
# - alias: the alias to which this should point
%define rule_archalias mainmmake=\A arch=\A alias=\A

#MM- %(mainmmake)-%(arch) : %(mainmmake)-%(alias)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to a shared object file with a
# .so suffix. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_shared basename=/A cflags=$(CFLAGS) targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).so : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).so : TMP_CMD:=$(HOST_CC)
endif
ifeq (%(compiler),kernel)
$(TMP_TARGETBASE).so : TMP_CMD:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif

$(TMP_TARGETBASE).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)" cmd=$(TMP_CMD)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file in. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A aflags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : AFLAGS := %(aflags)
%(basename).o : %(basename).s
	%assemble_q

else
%(targetdir)/$(notdir %(basename)).o : AFLAGS := %(aflags)
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble multiple source files to an object file. The
# generated file will be put in the object directory with the directory part
# of the source file stripped off.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - aflags (default $(AFLAGS)): the flags to use for assembly
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will be stripped from the file names so that all files
#   are in that dir and not in subdirectories.
%define rule_assemble_multi basenames=/A aflags=$(AFLAGS) targetdir= suffix=.s

ifeq (%(targetdir),)
TMP_TARGETS := $(addsuffix .o,%(basenames))
TMP_WILDCARD := %
else
TMP_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,$(notdir %(basenames))))
TMP_WILDCARD := %(targetdir)/%

# Be sure that all .s files are generated
$(TMP_TARGETS) : | $(addsuffix %(suffix),%(basenames))

# Be sure that all .c files are found
TMP_DIRS := $(filter-out ./,$(sort $(dir %(basenames))))
ifneq ($(TMP_DIRS),)
    vpath %%(suffix) $(TMP_DIRS)
endif

endif

$(TMP_TARGETS) : AFLAGS := %(aflags)
$(TMP_TARGETS) : $(TMP_WILDCARD).o : %%(suffix)
	%assemble_q opt=$(AFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(objs) to %(prog) using the libraries in %(uselibs)
%define rule_link_prog prog=/A objs=/A ldflags=$(LDFLAGS) uselibs= \
    usehostlibs= usestartup=yes detach=no nix=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif

# Make a list of the lib files this program depends on.
ifneq (%(uselibs),)
# In LDFLAGS remove white space between -L and directory
TMP_DIRS := $(subst -L ,-L,$(strip %(ldflags)))
# Filter out only the libdirs and remove -L
TMP_DIRS := $(patsubst -L%,%,$(filter -L%,$(TMP_DIRS)))
# Add trailing /
TMP_DIRS := $(subst //,/,$(addsuffix /,$(TMP_DIRS)))
# Add normal linklib path
TMP_DIRS += $(LIBDIR)/
# add lib and .a to static linklib names
TMP_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs) libinit autoinit))
# search for the linklibs in the given path, ignore ones not found
TMP_DEPLIBS := $(foreach lib,$(TMP_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(TMP_DIRS)))) \
)
else
TMP_DEPLIBS :=
endif

%(prog) : OBJS := %(objs)
%(prog) : LDFLAGS := %(ldflags) $(TMP_EXTRA_LDFLAGS)
%(prog) : LIBS := $(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))
%(prog) : %(objs) $(TMP_DEPLIBS)
	%link_q from=$(OBJS) opt=$(LDFLAGS) libs=$(LIBS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(progs) from object in %(objdir) to executables in %(targetdir) using
# the AROS libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_link_progs progs=/A targetdir=$(AROSDIR)/$(CURDIR) nix=%(nix) \
    objdir=$(GENDIR)/$(CURDIR) ldflags=$(LDFLAGS) uselibs= usehostlibs= \
    usestartup=yes detach=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif

# Make a list of the lib files the programs depend on.
ifneq (%(uselibs),)
# In LDFLAGS remove white space between -L and directory
TMP_DIRS := $(subst -L ,-L,$(strip %(ldflags)))
# Filter out only the libdirs and remove -L
TMP_DIRS := $(patsubst -L%,%,$(filter -L%,$(TMP_DIRS)))
# Add trailing /
TMP_DIRS := $(subst //,/,$(addsuffix /,$(TMP_DIRS)))
# Add normal linklib path
TMP_DIRS += $(LIBDIR)/lib/
# add lib and .a to static linklib names
TMP_LIBS := $(addprefix lib,$(addsuffix .a,%(uselibs) libinit autoinit))
# search for the linklibs in the given path, ignore ones not found
TMP_DEPLIBS := $(foreach lib,$(TMP_LIBS), \
    $(firstword $(wildcard $(addsuffix $(lib),$(TMP_DIRS)))) \
)
else
TMP_DEPLIBS :=
endif

$(addprefix %(targetdir)/,%(progs)) : LDFLAGS:= %(ldflags) $(TMP_EXTRA_LDFLAGS)
$(addprefix %(targetdir)/,%(progs)) : LIBS:= $(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))
$(addprefix %(targetdir)/,%(progs)) : %(targetdir)/% : %(objdir)/%.o $(TMP_DEPLIBS)
	%link_q from=$< opt=$(LDFLAGS) libs=$(LIBS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a in
%define rule_link_linklib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).so in
%define rule_link_shlib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).so : %(objs)
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A objdir=$(OBJDIR) \
    uselibs= usehostlibs=

%(module) : OBJS := %(objs)
%(module) : ENDTAG := %(endobj)
%(module) : ERR := %(err)
%(module) : OBJDIR := %(objdir)
%(module) : LIBS := $(addprefix -l,%(uselibs)) -lautoinit -llibinit -L/usr/lib $(addprefix -l,%(usehostlibs))
%(module) : %(objs) %(endobj) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_module_q err=$(ERR) endtag=$(ENDTAG) objs=$(OBJS) libs=$(LIBS) objdir=$(OBJDIR)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file.
# - includefile: This file will be included at the head of the source file
%define rule_ref basename=/A cflags=$(CFLAGS) targetdir= includefile= compiler=target

ifeq (%(targetdir),)
GENFILE_TMP := %(basename).ref
else
GENFILE_TMP := %(targetdir)/$(notdir %(basename)).ref
endif

ifeq ($(filter %(compiler),target kernel host),)
$(error use of %rule_ref: compiler has to be 'host', 'kernel' or 'target')
endif

ifeq (%(compiler),target)
$(GENFILE_TMP) : CC:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(GENFILE_TMP) : CC:=$(HOST_CC)
endif
ifeq(%(compiler),kernel)
$(GENFILE_TMP) : CC:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif

$(GENFILE_TMP) : %(basename).c $(CXREF) %(includefile)
ifeq (%(includefile),)
	%mkref_q cc=$(CC) cflags="%(cflags)"
else
	%mkref_q cc=$(CC) cflags="%(cflags) -include %(includefile)"
endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basenames: the basenames of the files to compile. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file. When targetdir
#   is not empty all files will be put there and path parts in the basenames
#   will be stripped off.
# - includefile: This file will be included at the head of the source file
%define rule_ref_multi basenames=/A cflags=$(CFLAGS) targetdir= includefile= \
    compiler=target

ifeq (%(targetdir),)
TMP_TARGETS := $(addsuffix .ref,%(basenames))
TMP_WILDCARD := %.ref
else
TMP_TARGETS := $(addprefix %(targetdir)/,$(addsuffix .ref,$(notdir %(basenames))))
TMP_WILDCARD := %(targetdir)/%.ref

# Be sure that all .c files are generated
$(TMP_TARGETS) : | $(addsuffix .c,%(basenames))

# Be sure that all .c files are found
TMP_DIRS := $(filter-out ./,$(sort $(dir %(basenames))))
ifneq ($(TMP_DIRS),)
    vpath %.c $(TMP_DIRS)
endif

endif

ifeq ($(filter %(compiler),target kernel host),)
$(error use of %rule_ref: compiler has to be 'host', 'kernel' or 'target')
endif

ifeq (%(compiler),target)
$(TMP_TARGETS) : CC:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETS) : CC:=$(HOST_CC)
endif
ifeq (%(compiler),kernel)
$(TMP_TARGETS) : CC:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif
ifeq (%(includefile),)
$(TMP_TARGETS) : CFLAGS:=%(cflags)
else
$(TMP_TARGETS) : CFLAGS:="%(cflags) -include %(includefile)"
$(TMP_TARGETS) : %(includefile)
endif
$(TMP_TARGETS) : $(CXREF)
$(TMP_TARGETS) : $(TMP_WILDCARD) : %.c
	%mkref_q cc=$(CC)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genmodule_genlibdefs modname=/A modtype=/A modsuffix= conffile= targetdir=

TMP_TARGET := %(modname)_libdefs.h
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENMODULE) $(OPTS) writelibdefs $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genmodule_funclist \
    modname=/A modtype=/A modsuffix= conffile= targetdir= reffile=

TMP_TARGET := %(modname).funclist
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifeq (%(reffile),)
    $(error reffile needed in rule_genmodule_funclist but none specified)
endif
TMP_OPTS := -r %(reffile)
TMP_DEPS += %(reffile)
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENMODULE) $(OPTS) writefunclist $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a Makefile.%(modname) with the genmodule program and include this
# generated file in this Makefile
%define rule_genmodule_makefile modname=/A modtype=/A modsuffix= conffile= \
    targetdir= genlinklib=yes

TMP_TARGET := Makefile.%(modname)
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif
ifeq (%(genlinklib),no)
    TMP_OPTS += -n
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(GENMODULE) $(OPTS) writemakefile $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate dummy support files so cxref when used on the a module source file
# will find something to include. This rule has to be preceeded by
# %rule_genmodule_makefile
%define rule_genmodule_dummy modname=/A modtype=/A modsuffix= conffile= targetdir=

ifneq ($(%(modname)_INCLUDES),)
TMP_TARGETS := $(%(modname)_INCLUDES)

TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating dummy include files"
	@$(GENMODULE) $(OPTS) writedummy $(MODNAME) $(MODTYPE)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files. This rule has to be preceeded by
# %rule_genmodule_makefile
%define rule_genmodule_files modname=/A modtype=/A modsuffix= targetdir= \
    conffile= reffile=

TMP_TARGETS := $(%(modname)_STARTFILES) $(%(modname)_ENDFILES) \
	       $(%(modname)_LINKLIBFILES)
TMP_TARGETS := $(addsuffix .c,$(TMP_TARGETS)) $(addsuffix .S, $(%(modname)_LINKLIBAFILES))

TMP_DEPS := $(GENMODULE)
ifeq ($(%(modname)_NEEDREF), yes)
    ifeq (%(reffile),)
        $(error reffile needed in rule_genmodule_files but none specified)
    endif
    TMP_OPTS := -r %(reffile)
    TMP_DEPS += %(reffile)
else
    TMP_OPTS :=
endif
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating functable and support files for module $(MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) $(OPTS) writefiles $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule_includes modname=/A modtype=/A modsuffix= \
    targetdir= conffile= reffile=


ifneq ($(%(modname)_INCLUDES),)
TMP_TARGETS := $(%(modname)_INCLUDES)

TMP_DEPS := $(GENMODULE)
ifeq ($(%(modname)_NEEDREF), yes)
    ifeq (%(reffile),)
        $(error reffile needed in rule_genmodule_files but none specified)
    endif
    TMP_OPTS := -r %(reffile)
    TMP_DEPS += %(reffile)
else
    TMP_OPTS :=
endif
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating include files"
	@$(GENMODULE) $(OPTS) writeincludes $(MODNAME) $(MODTYPE)
endif
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(SRCDIR)/config/make.tail

BDID := $(BDTARGETID)
%end
#------------------------------------------------------------------------------
      

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile build macro's. These are macro's that takes care ##
## of everything to go from the sources to the generated target. Also all  ##
## intermediate files and directories that are needed are created by these ##
## rules.                                                                  ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Build a program
%define build_prog mmake=/A progname=/A files=$(BD_PROGNAME) asmfiles= \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS) ldflags=$(LDFLAGS) \
    aflags=$(AFLAGS) uselibs= usehostlibs= usestartup=yes detach=no nix=no \
    srcdir=

.PHONY : %(mmake)

BD_PROGNAME  := %(progname)
BD_OBJDIR    := %(objdir)
BD_TARGETDIR := %(targetdir)

BD_FILES     := %(files)
BD_ASMFILES  := %(asmfiles)
BD_OBJS      := $(addsuffix .o,$(addprefix $(BD_OBJDIR)/,$(BD_FILES) $(BD_ASMFILES)))
BD_DEPS      := $(addsuffix .d,$(addprefix $(BD_OBJDIR)/,$(BD_FILES)))

BD_CFLAGS    := %(cflags)
BD_AFLAGS    := %(aflags)
BD_DFLAGS    := %(dflags)
BD_LDFLAGS   := %(ldflags)

#MM
%(mmake)-quick : %(mmake)

#MM %(mmake) : includes-generate-deps
%(mmake) : $(BD_TARGETDIR)/$(BD_PROGNAME)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=%(srcdir)% targetdir=$(BD_OBJDIR) \
    cflags=$(BD_CFLAGS) dflags=$(BD_DFLAGS)
%rule_assemble_multi basenames=$(BD_ASMFILES) targetdir=$(BD_OBJDIR) \
    aflags=$(BD_AFLAGS)

%rule_link_prog prog=$(BD_TARGETDIR)/$(BD_PROGNAME) \
    objs=$(BD_OBJS) ldflags=$(BD_LDFLAGS) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" nix="%(nix)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS)

$(BD_OBJS) $(BD_DEPS) : | $(BD_OBJDIR)
$(BD_TARGETDIR)/$(BD_PROGNAME) : | $(BD_TARGETDIR)
GLOB_MKDIRS += $(BD_OBJDIR) $(BD_TARGETDIR)

%(mmake)-clean : FILES := $(BD_OBJS) $(BD_TARGETDIR)/$(BD_PROGNAME) $(BD_DEPS)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build programs, for every C file an executable will be built with the same
# 
%define build_progs mmake=/A files=/A nix=no \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS) ldflags=$(LDFLAGS) \
    uselibs= usehostlibs= usestartup=yes detach=no

.PHONY : %(mmake)

BD_OBJDIR    := %(objdir)
BD_TARGETDIR := %(targetdir)

BD_FILES     := %(files)
BD_OBJS      := $(addsuffix .o,$(addprefix $(BD_OBJDIR)/,$(BD_FILES)))
BD_DEPS      := $(addsuffix .d,$(addprefix $(BD_OBJDIR)/,$(BD_FILES)))
BD_EXES      := $(addprefix $(BD_TARGETDIR)/,$(BD_FILES))

BD_CFLAGS    := %(cflags)
BD_DFLAGS    := %(dflags)
BD_LDFLAGS   := %(ldflags)

#MM
%(mmake)-quick : %(mmake)

#MM %(mmake) : includes-generate-deps
%(mmake) : $(BD_EXES)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR) nix=%(nix) \
    cflags=$(BD_CFLAGS) dflags=$(BD_DFLAGS)

%rule_link_progs progs=$(BD_FILES) nix=%(nix) \
    targetdir=$(BD_TARGETDIR) objdir=$(BD_OBJDIR) \
    ldflags=$(BD_LDFLAGS) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS)

$(addprefix $(BD_TARGETDIR)/,$(BD_FILES)) : | $(BD_TARGETDIR)
$(BD_DEPS) $(BD_OBJS) : | $(BD_OBJDIR)
GLOB_MKDIRS += $(BD_TARGETDIR) $(BD_OBJDIR)

%(mmake)-clean : FILES := $(BD_OBJS) $(BD_EXES) $(BD_DEPS)
#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for metatarget %(mmake)"
	@$(RM) $(FILES)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module.
# This is a bare version: It just compiles and links the given files. It is
# assumed that all needed boiler plate code is in the files. This should only
# be used for compiling external code. For AROS code use %build_module
%define build_module_simple mmake=/A modname=/A modtype=/A \
    files="$(basename $(wildcard *.c))" \
    cflags=$(CFLAGS) dflags=$(BD_DEFDFLAGS) \
    objdir=$(OBJDIR) moduledir= \
    uselibs= usehostlibs= compiler=target

# Define metamake targets and their dependencies
#MM %(mmake) : core-linklibs includes-generate-deps
#MM %(mmake)-kobj : core-linklibs includes-generate-deps
#MM %(mmake)-quick
#MM %(mmake)-clean

BD_ALLTARGETS := %(mmake) %(mmake)-clean %(mmake)-quick %(mmake)-kobj

.PHONY : $(BD_ALLTARGETS)

ifeq (%(modname),)
$(error using %build_module_simple: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module_simple: $(MODTYPE) has to be defined with the type of the module)
endif

# Default values for variables and arguments
BD_DEFLINKLIBNAME := %(modname)
BD_DEFREFFILE := %(objdir)/%(modname)_ALL.ref
BD_DEFDFLAGS := %(cflags)
OBJDIR ?= $(GENDIR)/$(CURDIR)
BD_MODDIR := %(moduledir)
ifeq ($(BD_MODDIR),)
  ifeq (%(modtype),library)
    BD_MODDIR  := $(AROS_LIBS)
  endif
  ifeq (%(modtype),gadget)
    BD_MODDIR  := $(AROS_GADGETS)
  endif
  ifeq (%(modtype),datatype)
    BD_MODDIR  := $(AROS_DATATYPES)
  endif
  ifeq (%(modtype),handler)
    BD_MODDIR  := $(AROS_FS)
  endif
  ifeq (%(modtype),device)
    BD_MODDIR  := $(AROS_DEVS)
  endif
  ifeq (%(modtype),resource)
    BD_MODDIR  := $(AROS_RESOURCES)
  endif
  ifeq (%(modtype),mui)
    BD_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),mcc)
    BD_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),mcp)
    BD_MODDIR  := $(AROS_CLASSES)/Zune
  endif
  ifeq (%(modtype),hidd)
    BD_MODDIR  := $(AROS_DRIVERS)
  endif
endif
ifeq ($(BD_MODDIR),)
  $(error Don't know where to put the file for modtype %(modtype). Specify moduledir=)
endif

%rule_compile_multi \
    basenames="%(files)" targetdir="%(objdir)" \
    cflags="%(cflags)" dflags="%(dflags)" \
    compiler=%(compiler)

BD_MODULE := $(BD_MODDIR)/%(modname).%(modtype)
BD_KOBJ := $(KOBJSDIR)/%(modname)_%(modtype).o

%(mmake)-quick : %(mmake)
%(mmake) : $(BD_MODULE)
%(mmake)-kobj : $(BD_KOBJ)

# The module is linked from all the compiled .o files
BD_OBJS       := $(addprefix %(objdir)/, $(addsuffix .o,%(files)))
%rule_linkmodule module=$(BD_MODULE) objs=$(BD_OBJS) \
		 endobj= err=%(modname).err objdir=%(objdir) \
		 uselibs="%(uselibs)" usehostlibs="%(usehostlibs)"

# Link kernel object file
BD_KAUTOLIB := workbench dos cybergraphics intuition layers graphics oop utility \
    expansion keymap
BD_KBASE := WorkbenchBase DOSBase CyberGfxBase IntuitionBase LayersBase \
    GfxBase OOPBase UtilityBase ExpansionBase KeymapBase
BD_KLIB := hiddgraphicsstubs hiddstubs amiga arossupport rom arosm autoinit libinit
BD_KOBJ_LIBS := $(filter-out $(BD_KLIB),%(uselibs)) $(BD_KAUTOLIB)
$(BD_KOBJ) : LINKLIBS:=$(BD_KOBJ_LIBS)
$(BD_KOBJ) : FILTBASES:=$(addprefix -L ,$(BD_KBASE))
$(BD_KOBJ) : $(BD_OBJS) $(BD_ENDOBJS)
	@$(ECHO) "Linking $@"
	@$(AROS_LD) -Ur -o $@ $^ -L$(AROS_LIB) $(addprefix -l,$(LINKLIBS))
	@$(OBJCOPY) $@ $(FILTBASES) `$(NM_PLAIN) $@ | $(AWK) '($$3 ~ /^__.*_(LIST|END)__$$/) || ($$3 ~ /^libraryset_.*$$/) {print "-L " $$3;}'`


## Dependency fine-tuning
##
BD_DEPS       := $(addprefix %(objdir), $(addsuffix .o,%(files)))
%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-kobj" deps=$(BD_DEPS)

$(BD_OBJS) $(BD_DEPS) $(BD_REFS) : | %(objdir)
$(BD_MODULE) : | $(BD_MODDIR)
$(BD_KOBJ) : | $(KOBJSDIR)
GLOB_MKDIRS += %(objdir) $(BD_MODDIR) $(KOBJSDIR)

%(mmake)-clean : FILES := $(BD_OBJS) $(BD_MODULE) $(BD_KOBJ) $(BD_DEPS)
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module %(modname)"
	@$(RM) $(FILES)
%end


#------------------------------------------------------------------------------
# Build a module
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A modsuffix= \
  conffile= files="$(basename $(wildcard *.c))" \
  linklibfiles= cflags=$(CFLAGS) dflags=$(BD_DEFDFLAGS) \
  objdir=$(OBJDIR) moduledir=$(BD_DEFMODDIR) prefix=$(AROSDIR) \
  reffile=$(BD_DEFREFFILE) noref= \
  linklibname=$(BD_DEFLINKLIBNAME) uselibs= usehostlibs= \
  compiler=target genincludes=

# Define metamake targets and their dependencies
#MM- includes-all : %(mmake)-includes
#MM %(mmake) : %(mmake)-includes core-linklibs
#MM %(mmake)-kobj : %(mmake)-includes core-linklibs
#MM %(mmake)-linklib : %(mmake)-includes
#MM %(mmake)-quick : %(mmake)-includes-quick
#MM %(mmake)-includes : %(mmake)-makefile %(mmake)-includes-dirs \
#MM     includes-generate-deps
#MM %(mmake)-includes-quick
#MM %(mmake)-includes-dirs
#MM %(mmake)-makefile
#MM %(mmake)-funclist
#MM %(mmake)-clean

# All MetaMake targets defined by this macro
BD_ALLTARGETS := %(mmake) %(mmake)-quick %(mmake)-includes \
    %(mmake)-includes-quick %(mmake)-includes-dirs %(mmake)-clean \
    %(mmake)-kobj %(mmake)-funclist %(mmake)-linklib

.PHONY : $(BD_ALLTARGETS) %(mmake)-makefile

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# Default values for variables and arguments
BD_DEFLINKLIBNAME := %(modname)
BD_DEFREFFILE := %(objdir)/%(modname)_ALL.ref
BD_DEFDFLAGS := %(cflags)
OBJDIR ?= $(GENDIR)/$(CURDIR)

## Create genmodule include Makefile for the module
##
%(mmake)-makefile : %(objdir)/Makefile.%(modname)

%rule_genmodule_makefile \
    modname=%(modname) modtype=%(modtype) \
    modsuffix=%(modsuffix) targetdir=%(objdir) \
    conffile=%(conffile) genlinklib=%(genincludes)

%(objdir)/Makefile.%(modname) : | %(objdir)

GLOB_MKDIRS += %(objdir)

# Do not parse these statements if metatarget is not appropriate
ifneq ($(filter $(TARGET),$(BD_ALLTARGETS)),)

include %(objdir)/Makefile.%(modname)

BD_DEFMODDIR := $(%(modname)_MODDIR)


## include files generation
##
BD_INCDIR    := %(prefix)/$(AROS_DIR_INCLUDE)
ifeq (%(genincludes),yes)
    %(modname)_INCLUDES := proto/%(modname).h clib/%(modname)_protos.h defines/%(modname).h 
endif
ifeq (%(genincludes),no)
    %(modname)_INCLUDES :=
endif
BD_LIBDEFSINC := %(objdir)/include/%(modname)_libdefs.h
BD_DEFLIBDEFSINC := %(objdir)/include/%(modname)_deflibdefs.h

%(mmake)-includes-quick : %(mmake)-includes
%(mmake)-includes : $(addprefix $(GENINCDIR)/,$(%(modname)_INCLUDES)) \
    $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES)) \
    $(BD_LIBDEFSINC) $(BD_DEFLIBDEFSINC)

ifneq ($(%(modname)_INCLUDES),)
%rule_genmodule_includes modname=%(modname) modtype=%(modtype) \
		      	 modsuffix=%(modsuffix) targetdir=%(objdir)/include \
		      	 conffile=%(conffile) reffile=%(reffile)

%rule_copy_diff_multi \
    files=$(%(modname)_INCLUDES) srcdir=%(objdir)/include targetdir=$(GENINCDIR) \
    stampfile=%(objdir)/%(modname)_geninc

%rule_copy_diff_multi \
    files=$(%(modname)_INCLUDES) srcdir=%(objdir)/include targetdir=$(BD_INCDIR) \
    stampfile=%(objdir)/%(modname)_incs

%rule_genmodule_dummy modname=%(modname) modtype=%(modtype) \
		      modsuffix=%(modsuffix) \
		      targetdir=%(objdir)/dummyinc conffile=%(conffile)

BD_INCDIRS := $(filter-out ./,$(sort $(dir $(%(modname)_INCLUDES))))

TMP%(modname)_INCDIRS := \
    %(objdir)/include $(addprefix %(objdir)/include/,$(BD_INCDIRS)) \
    $(GENINCDIR) $(addprefix $(GENINCDIR)/,$(BD_INCDIRS)) \
    $(BD_INCDIR) $(addprefix $(BD_INCDIR)/,$(BD_INCDIRS))
%rule_makedirs dirs=$(TMP%(modname)_INCDIRS) setuptarget=%(mmake)-includes-dirs

$(addprefix %(objdir)/dummyinc/,$(%(modname)_INCLUDES)) : | %(objdir)/dummyinc $(addprefix %(objdir)/dummyinc/,$(BD_INCDIRS))
GLOB_MKDIRS += %(objdir)/dummyinc $(addprefix %(objdir)/dummyinc/,$(BD_INCDIRS))

endif

%rule_genmodule_genlibdefs modname=%(modname) modtype=%(modtype) \
		 	   modsuffix=%(modsuffix) targetdir=%(objdir)/include \
		 	   conffile=%(conffile)

$(BD_DEFLIBDEFSINC) : FILENAME := $(BD_LIBDEFSINC)
$(BD_DEFLIBDEFSINC) :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(FILENAME)\"" >$@

$(BD_LIBDEFSINC) $(BD_DEFLIBDEFSINC) : | %(objdir)/include
GLOB_MKDIRS += %(objdir)/include

## Generation of the funclist file
##
%(mmake)-funclist : %(modname).funclist

%rule_genmodule_funclist \
    modname=%(modname) modtype=%(modtype) modsuffix=%(modsuffix) \
    conffile=%(conffile) reffile=%(reffile)


## Extra genmodule src files generation
## 
%rule_genmodule_files modname=%(modname) modtype=%(modtype) \
		      modsuffix=%(modsuffix) targetdir=%(objdir) \
		      conffile=%(conffile) reffile=%(reffile)

## Compilation
##
BD_FILES      := %(files)
BD_FDIRS      := $(sort $(dir $(BD_FILES)))
BD_STARTFILES := $(addprefix %(objdir)/,$(%(modname)_STARTFILES))
BD_ENDFILES   := $(addprefix %(objdir)/,$(%(modname)_ENDFILES))

BD_ARCHOBJS   := $(wildcard %(objdir)/arch/*.o)
BD_ARCHFILES  := $(basename $(notdir $(BD_ARCHOBJS)))
BD_NARCHFILES := $(filter-out $(BD_ARCHFILES),$(BD_FILES))

TMP_QUOTE     := $(CFLAGS_IQUOTE) $(TOP)/$(CURDIR) \
    $(addprefix $(CFLAGS_IQUOTE),$(BD_FDIRS)) \
    $(CFLAGS_IQUOTE_END)
BD_CFLAGS     := $(TMP_QUOTE) %(cflags) -I%(objdir)/include -include $(BD_DEFLIBDEFSINC)
BD_DFLAGS     := $(TMP_QUOTE) %(dflags) -I%(objdir)/include -include $(BD_DEFLIBDEFSINC)

BD_LINKLIBCFILES := $(addprefix %(objdir)/,$(%(modname)_LINKLIBFILES))
BD_LINKLIBAFILES := $(addprefix %(objdir)/,$(%(modname)_LINKLIBAFILES))
ifeq ($(strip $(%(modname)_LINKLIBFILES) %(linklibfiles)),)
    BD_LINKLIB :=
else
    BD_LINKLIB := %(prefix)/$(AROS_DIR_LIB)/lib%(linklibname).a
endif
BD_LINKLIBFILES := $(BD_LINKLIBCFILES) $(BD_LINKLIBAFILES)

BD_CCFILES := $(BD_NARCHFILES) %(linklibfiles)
BD_TARGETCCFILES := $(BD_STARTFILES) $(BD_ENDFILES) $(BD_LINKLIBCFILES) 

%rule_compile_multi \
    basenames=$(BD_CCFILES) targetdir=%(objdir) \
    cflags=$(BD_CFLAGS) dflags=$(BD_DFLAGS) \
    compiler=%(compiler)
%rule_compile_multi \
    basenames=$(BD_TARGETCCFILES) targetdir=%(objdir) \
    cflags="$(BD_CFLAGS) -D__AROS__" dflags=$(BD_DFLAGS) \
    compiler=%(compiler)

ifneq ($(BD_LINKLIBAFILES),)
%rule_assemble_multi \
    basenames=$(BD_LINKLIBAFILES) targetdir=%(objdir) suffix=.S
endif

## function reference files generation
##
BD_CFLAGS_REF := -I$(dir $(GENMODULE))/genmod_inc -I%(objdir)/dummyinc $(strip %(cflags)) -I$(TOP)/$(CURDIR) -I%(objdir)/include -include $(BD_DEFLIBDEFSINC)
%rule_ref_multi \
    basenames=$(BD_FILES) targetdir=%(objdir) \
    cflags=$(BD_CFLAGS_REF) \
    compiler=%(compiler)

ifeq (%(noref),)
BD_REFS   := $(addprefix %(objdir)/,$(addsuffix .ref, $(notdir $(BD_FILES))))
else
BD_REFS   := $(addprefix %(objdir)/,$(addsuffix .ref, $(notdir $(filter-out %(noref),$(BD_FILES)))))
endif

%rule_join from=$(BD_REFS) to=%(reffile) \
	   text="Collecting function references for module %(modname)"


## Linking
##
ifeq (%(modsuffix),)
BD_MODULE    := %(prefix)/%(moduledir)/%(modname).%(modtype)
BD_KOBJ      := $(KOBJSDIR)/%(modname)_%(modtype).o
else
BD_MODULE    := %(prefix)/%(moduledir)/%(modname).%(modsuffix)
BD_KOBJ      := $(KOBJSDIR)/%(modname)_%(modsuffix).o
endif

%(mmake)-quick : %(mmake)
%(mmake) : $(BD_MODULE) $(BD_LINKLIB)
%(mmake)-kobj : $(BD_KOBJ) $(BD_LINKLIB)
%(mmake)-linklib : $(BD_LINKLIB)

BD_OBJS       := $(addsuffix .o,$(BD_STARTFILES)) $(BD_ARCHOBJS) \
	     	 $(addsuffix .o, $(addprefix %(objdir)/,$(notdir $(BD_NARCHFILES))))
BD_ENDOBJS    := $(addsuffix .o,$(BD_ENDFILES))
BD_LINKLIBOBJS:= $(addsuffix .o,$(addprefix %(objdir)/,$(notdir %(linklibfiles))) $(BD_LINKLIBFILES))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE) objs=$(BD_OBJS) \
		 endobj=$(BD_ENDOBJS) err=%(modname).err objdir=%(objdir) \
		 uselibs="%(uselibs)" usehostlibs="%(usehostlibs)"

# Link static lib
ifneq ($(BD_LINKLIB),)
%rule_link_linklib libname=%(linklibname) objs=$(BD_LINKLIBOBJS) libdir=%(prefix)/$(AROS_DIR_LIB)

$(BD_LINKLIB) : | %(prefix)/$(AROS_DIR_LIB)
GLOB_MKDIRS += %(prefix)/$(AROS_DIR_LIB)
endif

# Link kernel object file
BD_KAUTOLIB := workbench dos cybergraphics intuition layers graphics oop utility \
    expansion keymap
BD_KBASE := WorkbenchBase DOSBase CyberGfxBase IntuitionBase LayersBase \
    GfxBase OOPBase UtilityBase ExpansionBase KeymapBase
BD_KLIB := hiddgraphicsstubs hiddstubs amiga arossupport rom arosm autoinit libinit
BD_KOBJ_LIBS := $(filter-out $(BD_KLIB),%(uselibs)) $(BD_KAUTOLIB)
$(BD_KOBJ) : LINKLIBS:=$(BD_KOBJ_LIBS)
$(BD_KOBJ) : FILTBASES:=$(addprefix -L ,$(BD_KBASE))
$(BD_KOBJ) : $(BD_OBJS) $(BD_ENDOBJS)
	@$(ECHO) "Linking $@"
	@$(AROS_LD) -Ur -o $@ $^ -L$(AROS_LIB) $(addprefix -l,$(LINKLIBS))
	@$(OBJCOPY) $@ $(FILTBASES) `$(NM_PLAIN) $@ | $(AWK) '($$3 ~ /^__.*_(LIST|END)__$$/) || ($$3 ~ /^libraryset_.*$$/) {print "-L " $$3;}'`

## Dependency fine-tuning
##
BD_DEPS := $(addsuffix .d,$(addprefix %(objdir)/,$(notdir $(BD_CCFILES) $(BD_TARGETCCFILES))))
%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-kobj" deps=$(BD_DEPS)

$(BD_OBJS) $(BD_DEPS) $(BD_REFS) : | %(objdir)
$(BD_MODULE) : | %(prefix)/%(moduledir)
$(BD_KOBJ) : | $(KOBJSDIR)
GLOB_MKDIRS += %(objdir) %(prefix)/%(moduledir) $(KOBJSDIR)

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Only for this target these deps are wanted
BD_REFFILE_DEPS := $(BD_LIBDEFSINC) $(BD_DEFLIBDEFSINC) \
    $(addprefix %(objdir)/dummyinc/,$(%(modname)_INCLUDES))
$(BD_REFS) : $(BD_REFFILE_DEPS) $(dir $(GENMODULE))/genmod_inc/aros/libcall.h

BD_DFILE_DEPS := $(BD_LIBDEFSINC) $(BD_DEFLIBDEFSINC) \
    $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES))
$(BD_DEPS) : $(BD_DFILE_DEPS)
endif

BD_TOCLEAN := $(BD_OBJS) $(BD_DEPS) %(reffile) \
    $(BD_REFS) $(BD_MODULE) $(BD_LINKLIB) $(BD_KOBJ) \
    %(objdir)/Makefile.%(modname) \
    $(addprefix %(objdir)/include/,$(%(modname)_INCLUDES)) \
    $(addprefix $(GENINCDIR)/,$(%(modname)_INCLUDES)) \
    $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES)) \
    %(objdir)/%(modname)_geninc %(objdir)/%(modname)_incs \
    $(addsuffix .c,$(BD_LINKLIBFILES)) $(BD_LINKLIBOBJS) $(BD_LIBDEFSINC) \
    $(BD_DEFLIBDEFSINC) $(addsuffix .c,$(BD_STARTFILES) $(BD_ENDFILES)) \
    $(BD_ENDOBJS)
%(mmake)-clean : FILES := $(BD_TOCLEAN)
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module %(modname)"
	@$(RM) $(FILES)

endif # $(TARGET) in $(BD_ALLTARGETS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given with the .s suffix
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags use during makedepend (default equal to cflags)
# - aflags are the flags use during assembling (default $(AFLAGS))
# - objdir is where the .o are generated
# - libdir is the directory where the linklib will be placed (default $(LIBDIR))
%define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c))" \
  asmfiles= cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) objdir=$(OBJDIR) libdir=$(LIBDIR)

# assign and generate the local variables used in this macro
OBJDIR        ?= $(GENDIR)/$(CURDIR)

BD_FILES      := %(files)
BD_ASMFILES   := %(asmfiles)

BD_ARCHOBJS   := $(wildcard %(objdir)/arch/*.o)
BD_ARCHFILES  := $(basename $(notdir $(BD_ARCHOBJS)))
BD_NARCHFILES := $(filter-out $(BD_ARCHFILES),$(BD_FILES))

BD_OBJS       := $(BD_ARCHOBJS) $(addsuffix .o,$(addprefix %(objdir)/,$(notdir $(BD_NARCHFILES) $(BD_ASMFILES))))
BD_DEPS       := $(patsubst %.o,%.d,$(BD_OBJS))

BD_CFLAGS     := %(cflags)
ifeq (%(dflags),)
BD_DFLAGS     := $(BD_CFLAGS)
else
BD_DFLAGS     := %(dflags)
endif
BD_AFLAGS     := %(aflags)

BD_LINKLIB    := %(libdir)/lib%(libname).a

.PHONY : %(mmake) %(mmake)-clean

#MM %(mmake) : includes-generate-deps
%(mmake) : $(BD_LINKLIB)

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS) $(BD_DEPS)

ifeq ($(TARGET),%(mmake))
ifneq ($(dir $(BD_FILES)),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES)))
endif

%rule_compile basename=% targetdir=%(objdir) \
	      cflags=$(BD_CFLAGS) dflags=$(BD_DFLAGS)
%rule_assemble basename=% targetdir=%(objdir) \
	      aflags=$(BD_AFLAGS)
endif

%rule_link_linklib libname=%(libname) objs=$(BD_OBJS) libdir=%(libdir)

%include_deps depstargets=%(mmake) deps=$(BD_DEPS)

$(BD_OBJS) $(BD_DEPS) : | %(objdir)
$(BD_LINKLIB) : | %(libdir)
GLOB_MKDIRS += %(objdir) %(libdir)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd) (default *.cd)
# - subdir is the destination subdir of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - source is the path to the generated source code file
# - dir is the base destination directory (default $(AROS_CATALOGS))
# - sourcedescription is the path to the FlexCat's source description file, without the .sd suffix

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs="$(basename $(wildcard *.ct))" source="../strings.h" \
 description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS) \
 sourcedescription="$(TOOLDIR)/C_h_orig"

BD_SRCS := $(addsuffix .ct, %(catalogs))
BD_OBJS := $(addsuffix /%(subdir)/%(name).catalog, $(addprefix %(dir)/, %(catalogs)))
BD_DIRS := $(addsuffix /%(subdir), $(addprefix %(dir)/, %(catalogs)))

#MM
%(mmake) : $(BD_OBJS) %(source)

$(BD_OBJS) : | $(BD_DIRS)
GLOB_MKDIRS += $(BD_DIRS)

%(dir)/%/%(subdir)/%(name).catalog : %.ct %(description).cd
	@$(ECHO) "Creating %(name) catalog for language $*."
	@$(FLEXCAT) %(description).cd $*.ct CATALOG=%(dir)/$*/%(subdir)/%(name).catalog || [ $$? -lt 10 ]

ifneq (%(source),)
%(source) : %(description).cd
	@$(ECHO) "Creating %(name) catalog source file %(source)"
	@$(FLEXCAT) %(description).cd %(source)=%(sourcedescription).sd
endif

%(mmake)-clean : FILES := $(BD_OJS) %(source)
#MM
%(mmake)-clean ::
	$(RM) $(FILES)

.PHONY: %(mmake) %(mmake)-clean

%end

#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Build icons.
# - mmake is the mmaketarget
# - icons is a list of icon base names (ie. without the .info suffix)
# - dir is the destination directory
#-----------------------------------------------------------------------------

%define build_icons mmake=/A icons=/A dir=/A

BD_OBJS := $(addprefix  %(dir)/, $(addsuffix .info,%(icons)))

#MM
%(mmake) : $(BD_OBJS)

%(dir)/%.info : %.info.src %.png
	@$(ECHO) Creating $(notdir $@)...
	@$(ILBMTOICON) $+ $@

$(BD_OBJS) : | %(dir)
GLOB_MKDIRS += %(dir)

%(mmake)-clean : FILES := $(BD_OBJS)
#MM
%(mmake)-clean ::
	@$(RM) $(FILES)

.PHONY: %(mmake) %(mmake)-clean

%end

#-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Compile files for an arch-specific replacement of code for a module
# - files: the basenames of the C files to compile.
# - asmfiles: the basenames of the asm files to assemble.
# - mainmmake: the mmake of the module in the main directory to compile these
#   arch specific files for.
# - maindir: the object directory for the main module
# - arch: the arch for which to compile these files. It can have the form
#   of ARCH, CPU or ARCH-CPU, e.g. linux, i386 or linux-i386
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - aflags: the flags used during assembling
# - compiler: (host, kernel or target) specifies which compiler to use. By default
#   the target compiler is used
%define build_archspecific files= asmfiles= mainmmake=/A maindir=/A arch=/A \
cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) compiler=target modulename=

ifeq (%(files) %(asmfiles),)
  $(error no files or asmfiles given)
endif

%buildid targets="%(mainmmake)-%(arch)"

#MM- %(mainmmake) : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-linklib : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)

#MM %(mainmmake)-%(arch) : %(mainmmake)-includes

ifeq (%(arch),)
  $(error argument arch has to be non empty for the rule_compile_archspecific macro)
endif

BD_OBJDIR$(BDID)  := $(GENDIR)/%(maindir)/arch
BD_COBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))
BD_ASMOBJS$(BDID) := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(asmfiles))))
BD_OBJS$(BDID)    := $(BD_COBJS$(BDID)) $(BD_ASMOBJS$(BDID))
BD_DEPS$(BDID)    := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))

ifeq ($(TARGET),%(mainmmake)-%(arch))
vpath %.c $(filter-out ./,$(dir %(files)))
vpath %.s $(filter-out ./,$(dir %(asmfiles)))
vpath %.S $(filter-out ./,$(dir %(asmfiles)))
endif

$(BD_OBJS$(BDID)) : | $(BD_OBJDIR$(BDID))
GLOB_MKDIRS += $(BD_OBJDIR$(BDID))

#MM
%(mainmmake)-%(arch) :: $(BD_OBJS$(BDID))

ifeq ($(findstring %(compiler),host kernel target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(HOST_CC)
endif
ifeq (%(compiler),kernel)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(KERNEL_CC) $(KERNEL_CFLAGS)
endif
ifneq (%(modulename),)
$(BD_COBJS$(BDID)) : TMP_CFLAGS:=%(cflags) -I$(GENDIR)/%(maindir) \
                     -include $(GENDIR)/%(maindir)/include/%(modulename)_deflibdefs.h
else
$(BD_COBJS$(BDID)) : TMP_CFLAGS:=%(cflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.c
	%compile_q opt=$(TMP_CFLAGS) cmd=$(TMP_CMD)
endif

ifeq (%(dflags),)
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(cflags)
else
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(dflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.d : %.c
	%mkdepend_q flags=$(TMP_DFLAGS)
endif

$(BD_ASMOBJS$(BDID)) : AFLAGS:=%(aflags)

ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.s
	%assemble_q opt=$(AFLAGS)
$(BD_OBJDIR$(BDID))/%.o : %.S
	%assemble_q opt=$(AFLAGS)
endif

%include_deps depstargets=%(mainmmake)-%(arch) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------







# ======================
# Old stuff, will probably be removed in the future




# GNU Make automatic variables
# $@ current target
# $< First dependency
# $? All newer dependencies
# $^ All dependencies
# $* The stem (ie. target is dir/a.foo.b and the pattern is
#    a.%.b, then the stem is dir/foo)

#------------------------------------------------------------------------------
# rule to generate libdefs.h with archtool (options may go away!)
%define libdefs_rule conffile=lib.conf genlibdefstool=$(ARCHTOOL) dest=libdefs.h
%(dest) : %(conffile) %(genlibdefstool)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@%(genlibdefstool) -c -o $@ %(conffile)
%end


#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) -S $(CFLAGS) $< -c -o $@
%end

#------------------------------------------------------------------------------
# Convert two png images to an Amiga icon file based on the description
# file %(from), with outputfile going to %(to).
%define makeicon2 from=$< to=$@ img1="$(basename $(basename $<))_N.png" img2="$(basename $(basename $<))_S.png"
	@$(ECHO) "Creating icon %(to)..."
	@$(PNGTOPNM) %(img1) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon1.iff
	@$(PNGTOPNM) %(img2) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon2.iff
	@$(ILBMTOICON) %(from) $(GENDIR)/genicon1.iff $(GENDIR)/genicon2.iff %(to)
%end

#------------------------------------------------------------------------------
# NOTE: The following are all part of Iain's build changes, please don't use
# or change anything below this line until you know what you are doing. This
# is so that I don't conflict with the semantics of any of the above macros.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q files=$(FILES) src=. dst=/A maketarget=files-copy

%(maketarget) : setup 
	$(foreach file, %(files), $(shell $(CP) $(addprefix %(src)/, $(file)) $(addprefix %(dst)/, $(file))))

setup ::
	%mkdirs_q %(dst)

%end

#----------------------------------------------------------------------------------
# Copy a diretory recursively to another place, preserving the original 
# hierarchical structure
#
# src: the source directory whose content will be copied
# dst: the directory where to copy src's content. If not existing, it will be made.

%define copy_dir_recursive mmake=/A src=$(TOP)/$(CURDIR) dst=/A

%(mmake)_FILES := $(shell cd %(src); find . -path '*/CVS' -prune -o -path '*/.svn' -prune -o -name .cvsignore -prune -o -name mmakefile -prune -o -name mmakefile.src -prune -o -type f -print)
%(mmake)_DIRS  := $(sort $(dir $(%(mmake)_FILES)))

define %(mmake)_mkdir
$(1):
	$(MKDIR) $$@
endef

define %(mmake)_copy
$(3)/$(1): $(2)/$(1) | $(dir $(3)/$(1))
	$(CP) $$< $$@
endef

.PHONY : %(mmake)

#MM
%(mmake): | $(GENDIR)/$(CURDIR)
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";        \
	$(ECHO) "all: $(addprefix \$$(DST)/,$(%(mmake)_FILES))" > $$m 
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";    \
	for d in $(%(mmake)_DIRS); do                      \
	    $(ECHO) "\$$(DST)/$$d: ; $(MKDIR) \$$@" >> $$m;  \
	done
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";                           \
	for f in $(%(mmake)_FILES); do                                            \
	    $(ECHO) "\$$(DST)/$$f: \$$(SRC)/$$f | \$$(dir \$$(DST)/$$f); $(CP) \$$< \$$@" >> $$m; \
	done;  \
	for dst in %(dst); do \
	    $(MAKE) -f $$m DST=$$dst SRC=%(src) all; \
	done

$(GENDIR)/$(CURDIR):
	$(MKDIR) $@

%end

#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake=includes-copy includes=$(INCLUDE_FILES) path=. \
    dir= compiler=target

ifeq ($(findstring %(compiler),host kernel target),)
$(error %copy_includes: compiler argument (%(compiler)) has to be host, kernel or target)
endif

ifneq (%(dir),)
BD_INCL_FILES := $(subst %(dir),$(GENINCDIR)/%(path),%(includes))
BD_INC_PATH := %(dir)/
else
BD_INCL_FILES := $(addprefix $(GENINCDIR)/%(path)/,%(includes))
BD_INC_PATH :=
endif

$(BD_INCL_FILES) : $(GENINCDIR)/%(path)/% : $(BD_INC_PATH)%
	@$(CP) $< $@


ifeq (%(compiler),target)

ifneq (%(dir),)
BD_INCL_FILES2 := $(subst %(dir),$(AROS_INCLUDES)/%(path),%(includes))
else
BD_INCL_FILES2 := $(addprefix $(AROS_INCLUDES)/%(path)/,%(includes))
endif

BD_INCL_FILES += $(BD_INCL_FILES2)

$(BD_INCL_FILES2) : $(AROS_INCLUDES)/%(path)/% : $(BD_INC_PATH)%
	@$(CP) $< $@
endif

#MM
%(mmake) : $(BD_INCL_FILES)

.PHONY: %(mmake)

$(BD_INCL_FILES) : | $(dir $(BD_INCL_FILES))
GLOB_MKDIRS += $(dir $(BD_INCL_FILES))
%end


%define make_hidd_stubs hidd=/A cflags=$(CFLAGS) dflags=$(CFLAGS) parenttarget=linklibs
STUBS_SRC := $(addsuffix .c,$(STUBS))
STUBS_MEM := $(addsuffix .o,$(STUBS))
STUBS_OBJ := $(addprefix $(OBJDIR)/,$(STUBS_MEM))
STUBS_DEP := $(addprefix $(OBJDIR)/,$(addsuffix .d,$(STUBS)))
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs : hidd-%(hidd)-stubs
#MM- %(parenttarget): hidd-%(hidd)-stubs
#MM hidd-%(hidd)-stubs : includes includes-copy
hidd-%(hidd)-stubs : setup $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC) 
	%compile_q cmd=$(TARGET_CC) opt=%(cflags)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags=%(dflags)

setup ::
	%mkdirs_q $(OBJDIR) $(LIBDIR)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end
      
#------------------------------------------------------------------------------
# Build an imported source tree which uses the configure script from the
# autoconf package.  This rule will try to "integrate" the produced files as
# much as possible in the AROS build, for example by putting libraries in the
# standard library directory, includes in the standard include directory, and
# so on. You can however override this behaviour.
#
# As a special "bonus" for you, the PROGDIR environment variable is defined to
# be %(bindir) (or its deduced value) when running "make install", and
# "PROGDIR:" when running "make" alone; you can use this feature to pass the
# configure script some more parameters whose value depends upon the PROGDIR
# env var, so that the program gets all its stuff installed in the proper place
# when building it, but when running it from inside AROS it can also find that
# stuff by simply opening PROGDIR:, which it will do automatically if it uses
# the configuration parameters set when running ./configure
#
# *NOTICE*: DO NOT put a trailing '/' (slash) after $PROGDIR, as the variable
# already contains either a '/' (slash) or a ':' (colon), thus simply attach it
# to the name which has to follow it.


%define build_with_configure mmake=/A srcdir=$(TOP)/$(CURDIR) prefix= \
    aros_prefix= extraoptions= nix_dir_layout= nix=no compiler=target \
    install_target=install postconfigure= postinstall= \
    install_env=

ifneq (%(prefix),)
    %(mmake)-prefix := %(prefix)
else
    %(mmake)-prefix := $(AROS_CONTRIB)
endif

ifneq (%(aros_prefix),)
    %(mmake)-aros_prefix := %(aros_prefix)
else
    %(mmake)-aros_prefix := $(%(mmake)-prefix)
endif

ifeq (%(nix),yes)
    %(mmake)-nix    := -nix
    %(mmake)-volpfx := /
    %(mmake)-volsfx := /
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := yes
    endif
else
    %(mmake)-volsfx := :
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := no
    endif
endif

%(mmake)-volfunc = $(%(mmake)-volpfx)$(notdir $1)$(%(mmake)-volsfx)

%(mmake)-install_opts := prefix=$(%(mmake)-prefix) \
	exec_prefix=$(%(mmake)-prefix) %(install_env)

# Check if chosen compiler is valid
ifeq ($(findstring %(compiler),host target kernel),)
  $(error unknown compiler %(compiler))
endif

# Set legacy 'host' variable based on chosen compiler
ifeq (%(compiler),host)
    host := yes
else
    host := no
endif

ifeq ($(filter yes, $(%(mmake)-nix_dir_layout) $(host)),yes)
    %(mmake)-PROGDIR      := $(%(mmake)-aros_prefix)/bin
    %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
else
    ifeq (%(nix),yes)
        %(mmake)-config_opts := --prefix=/PROGDIR  --bindir=/PROGDIR --sbindir=/PROGDIR \
        --libdir=/LIB --includedir=/INCLUDE --oldincludedir=/INCLUDE   
    else
        %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
    endif

    %(mmake)-PROGDIR := $(%(mmake)-aros_prefix)
    
    %(mmake)-install_opts := bindir=$(%(mmake)-prefix) \
	sbindir=$(%(mmake)-prefix) \
	libdir=$(AROS_LIB) includedir=$(AROS_INCLUDES) \
	oldincludedir=$(AROS_INCLUDES) %(install_env)
endif


.PHONY : %(mmake) %(mmake)-clean %(mmake)-build_and_install-quick

#MM- %(mmake) : setup includes linklibs-core %(mmake)-quick

ifneq (%(install_target),)
    %(mmake)-install_command = \
        $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_opts) \
        -C $(GENDIR)/$(CURDIR) %(install_target) && \
        $(TOUCH) $(GENDIR)/$(CURDIR)/.installed

    %(mmake)-uninstall_command = \
    $(RM) $(GENDIR)/$(CURDIR)/.installed && \
    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_opts) \
    -C $(GENDIR)/$(CURDIR) uninstall
else
    %(mmake)-install_command   := true
    %(mmake)-uninstall_command := true
endif

#MM- %(mmake)-quick : %(mmake)-configure %(postconfigure) %(mmake)-build_and_install-quick %(postinstall)

#MM
%(mmake)-build_and_install-quick :  $(GENDIR)/$(CURDIR)/.configured
	if ! $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" -q -C $(GENDIR)/$(CURDIR); then \
            $(RM)  $(GENDIR)/$(CURDIR)/.installed && \
	    $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" -C $(GENDIR)/$(CURDIR) && \
	    $(%(mmake)-install_command); \
        fi

%(srcdir)/.files-touched:
	find %(srcdir) -exec $(TOUCH) -r %(srcdir)/configure '{}' \; && \
	$(TOUCH) $@

#MM
%(mmake)-uninstall :
	$(%(mmake)-uninstall_command)

ifneq ($(DEBUG),yes)
    %(mmake)-s_flag = -s
endif

#MM
%(mmake)-configure : $(GENDIR)/$(CURDIR)/.configured

ifeq (%(compiler),host)
$(GENDIR)/$(CURDIR)/.configured : %(srcdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@ 
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(HOST_CC)" \
	    %(srcdir)/configure $(%(mmake)-config_opts) %(extraoptions) && \
	    $(TOUCH) $@
endif
ifeq (%(compiler),target)
$(GENDIR)/$(CURDIR)/.configured : %(srcdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(TARGET_CC) $(%(mmake)-nix) $(%(mmake)-s_flag)" \
	    AS="$(TARGET_AS)" CC_FOR_BUILD="$(HOST_CC)" RANLIB="$(RANLIB)" \
	    %(srcdir)/configure $(%(mmake)-config_opts) %(extraoptions) \
	    --build=$(AROS_HOST_CPU)-$(AROS_HOST_ARCH) \
	    --host=$(AROS_TARGET_CPU)-aros \
	    --target=$(AROS_TARGET_CPU)-aros \
	    --disable-nls \
	    --without-x --without-pic --disable-shared && \
	    $(TOUCH) $@
endif
ifeq (%(compiler),kernel)
$(GENDIR)/$(CURDIR)/.configured : %(srcdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(KERNEL_CC) $(KERNEL_CFLAGS) $(%(mmake)-nix) $(%(mmake)-s_flag)" \
	    AS="$(TARGET_AS)" CC_FOR_BUILD="$(HOST_CC)" RANLIB="$(RANLIB)" \
	    %(srcdir)/configure $(%(mmake)-config_opts) %(extraoptions) \
	    --build=$(AROS_HOST_CPU)-$(AROS_HOST_ARCH) \
	    --host=$(AROS_TARGET_CPU)-aros \
	    --target=$(AROS_TARGET_CPU)-aros --disable-nls \
	    --without-x --without-pic --disable-shared && \
	    $(TOUCH) $@
endif
	
#MM
%(mmake)-clean : %(mmake)-uninstall
	@$(RM) $(GENDIR)/$(CURDIR)
%end

#############################################################################
#############################################################################
##                                                                         ##
## Miscellaneous macros. Everything that doesn't fit above should be put   ##
## here.                                                                   ##
##                                                                         ##
#############################################################################
#############################################################################

#----------------------------------------------------------------------------------
# Given an archive name, patches names and locations where to find them, fetch
# the archive and the patches from any of those locations, unpack the archive
# and then apply the patches.
#
# Locations currently supported are http and ftp sites, plus local filesystem
# directories. Supported archives are .tar.bz2 and .tar.gz. To modify this,
# the fetch.sh script needs to be modified, since this macro relies on that script.
#
# Arguments:
#
#     - archive_origins = list of locations where to find the archive. They are tried
#                         in sequence, until the archive is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - archive         = the archive name. Mandatory.
#     - suffixes        = a list of suffixes to append to the the package name plus the
#                         version. Each one of them is tried until a matching archive is
#                         found. They are appended to patches and these are tried the
#                         same way as packages are.
#     - destination     = the local directory where to put the archive and patches.
#                         If not specified, the current directory is assumed.
#     - patches_origins = list of locations where to find the patches. They are tried
#                         in sequence, until a patch is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - patches_specs   = list of "patch specs". A patch spec is of the form
#                         patch_name[:[patch_subdir][:patch_opt]].
#			  
#			      - patch_name   = the name of the patch file
#			      - patch_subdir = the directory within \destination\ where to
#			                       apply the patch.
#			      - patch_opt    = any options to pass to the `patch' command
#			                       when applying the patch.
#                         
#                         The patch_subdir and patch_opt fields are optional.

%define fetch archive_origins=. archive=/A suffixes= location=%destination destination=. patches_origins=. patches_specs=::
	$(FETCH) -ao "%(archive_origins)" -a %(archive) -s "%(suffixes)" -l %(location) -d %(destination) \
        -po "%(patches_origins)" -p %(patches_specs)
%end

#-----------------------------------------------------------------------------------------
# Joins the features of %fetch and %build_with_configure, taking advantage of
# the naming scheme of GNU packages. GNU packages names are in the form
#
#     <package name>-<version number>.<archive format suffix>
#
# If a patch is provided, it *must* be named the following way:
#
#    <package name>-<version number>-aros.diff
#
# Moreover, it *must* be appliable with the -p1 option of the `patch' command after
# CD'ing into the archive's extracted directory.
#
# Note that whilst the %fetch macro accepts a list of patches for any given archive,
# the %fetch_and_build macro only accept *one* patch for each package. It's up to you
# to make that patch fully comprehensive.
#
# NOTE: GNU packages are always compiled with *nix semantics turned on.
#
# Arguments:
#
#    - mmake        = the meta make target, as would be supplied to the %build_with_configure
#                     macro.
#    - package      = the GNU package name, sans version and archive format suffixes.
#    - version      = the package's version number, or otherwise any other version string.
#                     It gets appended to the package name to form the basename of the archive.
#    - suffixes     = a list of suffixes to apped to the the package name plus the
#                     version. Each one of them is tried until a matching archive is found.
#                     Defaults to "tar.bz2 tar.gz".
#    - destination  = same meaning as the one for the %fetch macro
#    - package_repo = same meaning as the one of the %fetch macro's %(archive_origins) argument
#    - patch        = "yes" or "no", depending on whether a patch for this package needs to be
#                     fetched or not
#    - patch_repo   = same meaning as the one of the %fetch macro's %(patches_origins) argument
#    - prefix       = same meaning as the one for the %build_with_configure macro. Defaults to
#                     $(GNUDIR).
#    - aros_prefix  = same meaning as the one for the %build_with_configure macro. Defaults to
#                     /GNU.
#    - extraoptions = same meaning as the one for the %build_with_configure macro.
#    - postinstall  = same meaning as the one for the %build_with_configure macro.

%define fetch_and_build mmake=/A package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix= \
    aros_prefix= extraoptions= postconfigure= postinstall= nix=no nix_dir_layout=

#MM- %(mmake)-quick : %(mmake)-%(subpackage)-quick
#MM- %(mmake)-%(subpackage)-quick : %(mmake)-%(subpackage)-fetch
#MM- %(mmake)-fetch : %(mmake)-%(subpackage)-fetch
 
%(mmake)-archbase  := %(package)-%(version)

ifeq (%(prefix),)
    %(mmake)-prefix := $(CONTRIB_DIR)/%(package)
else
    %(mmake)-prefix := %(prefix)
endif

ifneq (%(subpackage),)
    %(mmake)-%(subpackage)-archbase  := %(package)-%(subpackage)-%(version)
else
    %(mmake)-%(subpackage)-archbase  := %(package)-%(version)
endif

ifneq (%(srcdir),)
    %(mmake)-%(subpackage)-srcdir  := %(srcdir)
else
    %(mmake)-%(subpackage)-srcdir  := $(%(mmake)-archbase)
endif

ifeq (%(patch),yes)
    %(mmake)-%(subpackage)-patches_specs := $(%(mmake)-%(subpackage)-archbase)-aros.diff:$(%(mmake)-%(subpackage)-srcdir):-p1    
else
    %(mmake)-%(subpackage)-patches_specs := ::
endif

.PHONY : %(mmake)-%(subpackage)-fetch
#MM
%(mmake)-%(subpackage)-fetch :
	%fetch archive=$(%(mmake)-%(subpackage)-archbase) suffixes="%(suffixes)" \
	    location=$(PORTSSOURCEDIR) destination=$(PORTSDIR)/%(package) \
	    archive_origins=". %(package_repo)" \
	    patches_specs="$(%(mmake)-%(subpackage)-patches_specs)" patches_origins=". %(patch_repo)"

#MM- %(mmake) : %(mmake)-%(subpackage)

%(mmake)-%(subpackage)-package-dir := $(PORTSDIR)/%(package)/$(%(mmake)-%(subpackage)-archbase)

%(mmake)-%(subpackage)-package-basename := \
    $(DISTDIR)/Packages/$(%(mmake)-%(subpackage)-archbase)-aros.$(AROS_TARGET_CPU)

%build_with_configure mmake=%(mmake)-%(subpackage) \
     srcdir=$(PORTSDIR)/%(package)/$(%(mmake)-%(subpackage)-srcdir) \
     nix=%(nix) nix_dir_layout=%(nix_dir_layout) prefix="$(%(mmake)-prefix)" \
     aros_prefix="%(aros_prefix)" postconfigure="%(postconfigure)" postinstall="%(postinstall) \
     %(mmake)-%(subpackage)-make-package"  extraoptions="%(extraoptions)"

.PHONY : %(mmake)-%(subpackage)-make-package
#MM %(mmake)-%(subpackage)-make-package : %(mmake)-%(subpackage)-quick

#MM
%(mmake)-%(subpackage)-make-package : $(%(mmake)-%(subpackage)-package-basename).tar.bz2
 
#There seems to be a bug, either with my clock or with make, 'cause it may happen
#that $^ and $@ have exactly the same mtime, and in that case make tries
#to rebuild $@ again, which would fail because the directory where
#the package got installed would not exist anymore. 
#We work this around by using an if statement to manually check the mtimes.
$(%(mmake)-%(subpackage)-package-basename).tar.bz2 :
	@$(IF) test $(GENDIR)/$(CURDIR)/.installed -nt $@ || ! test -f $@; then \
        $(RM) $@ ; \
        $(ECHO) "Building \`$(%(mmake)-%(subpackage)-package-basename).tar.bz2'" ; \
        mkdir -p "$(DISTDIR)/Packages" ; \
        mkdir -p "$(%(mmake)-prefix)" ; \
        cd $(%(mmake)-%(subpackage)-package-dir) ; \
        tar -cvf $(%(mmake)-%(subpackage)-package-basename).tar * ; \
        bzip2 -9 -f $(%(mmake)-%(subpackage)-package-basename).tar ; \
    fi
%end

%define fetch_and_build_gnu mmake=/A package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(GNUDIR) \
    aros_prefix=/GNU extraoptions= postconfigure= postinstall= 

GNU_REPOSITORY := gnu://

%fetch_and_build mmake="%(mmake)" package="%(package)" subpackage="%(subpackage)" version="%(version)" \
    suffixes="%(suffixes)" srcdir="%(srcdir)" \
    package_repo="%(package_repo) $(GNU_REPOSITORY)%(package)" \
    patch="%(patch)" patch_repo="%(patch_repo)" \
    prefix="%(prefix)" aros_prefix="%(aros_prefix)" extraoptions="%(extraoptions)" \
    postconfigure="%(postconfigure)" postinstall="%(postinstall)" nix=yes

%end

#-----------------------------------------------------------------------------------------
# Same job as the one of %fetch_and_build_gnu, except that this one assumes
# that the package is a "Development" package, and as such it needs to be placed
# under the $(AROS_DEVELOPMENT) directory, as a default. 
#
# All the arguments have the same meaning as the ones of the %fetch_and_build_gnu 
# macro, but notice that %fetch_and_build_gnu_development *doesn't* have a
# "mmake" argument, because the metatarget is implicitely defined as
#
#     #MM- development-%(package)

%define fetch_and_build_gnu_development package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(AROS_DEVELOPMENT) \
    aros_prefix=/Development postconfigure= postinstall=  extraoptions= 

#MM- development : development-%(package)


%fetch_and_build_gnu mmake=development-%(package) package=%(package) subpackage="%(subpackage)" \
   version=%(version) suffixes="%(suffixes)" srcdir="%(srcdir)"  \
   package_repo="%(package_repo)" patch="%(patch)" patch_repo="%(patch_repo)" prefix=%(prefix) \
   aros_prefix="%(aros_prefix)" postconfigure="%(postconfigure)" postinstall="%(postinstall)" \
   extraoptions="%(extraoptions)"
    
%end

#------------------------------------------------------------------------------
# Generates a list of dependencies on given directories and assigns it to make
# macro with given name. Dependecy on directory is generated only in case it
# doesn't exist. Also generates a rule that creates missing directories. All
# what is left is to add dependency on $(name) in targets that require
# existence of specified directories.
# 
# example usage:
# 
# DIRS := dir1 dir2 dir3
# 
# %dir_deps name=DIR_DEPS dirs=$(DIRS)
# 
# dir1/file1.c: source_directory1/file1.c $(DIR_DEPS)
#       @$(CP) $< $@
#
# dir2/file2.c: source_directory2/file2.c $(DIR_DEPS)
#       @$(CP) $< $@
# 

%define dir_deps name= dirs=
%(name) := $(foreach DEPDIR, %(dirs), $(filter-out $(wildcard $(DEPDIR)), $(DEPDIR)))

%(dirs) :
	%mkdir_q dir=$@
%end
