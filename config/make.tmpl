#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used as commands in a make rule.##
## They are used to help the portability of mmakefile to different         ##
## platforms.                                                              ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt).
%define compile_q cmd=$(TARGET_CC) opt=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Compiling $(notdir %(from))"
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "%(from): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Compile failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd=$(AS) opt=$(AFLAGS) from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "$(notdir %(from)): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Assemble failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building $(notdir $@) ..."
	@if $(STATIC_LD) $(STATIC_LDFLAGS) %(ldflags) \
	    $(GENMAP) %(objdir)/%(module).map \
	    %(objs) %(libs) %(endtag) $(COMPILER_LIBS) \
	    -o $@ 2>&1 > %(objdir)/%(err); \
	then \
	    cat %(objdir)/%(err); \
	else \
	    cat %(objdir)/%(err); \
	    exit 1; \
	fi

	@if $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(STRIP) $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags=$(CFLAGS) from=$< to=$@
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	@$(MKDEPEND) %(flags) %(from) -o %(to)
%end
#------------------------------------------------------------------------------


#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used to do certain tasks in a   ##
## mmakefile. They consist of one or more makefile rules.                  ##
## In general the files generated in these macro's are also defined as     ##
## make targets so that they can be used a dependency in other rules       ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $(BD_REFFILES$(BDID)) >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# include when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

# Only add a rule for a directory for which there is no rule yet.

TOCREATE_TMP := $(filter-out $(CREATED_DIRS_GLOB),%(dirs))

ifdef TOCREATE_TMP
$(TOCREATE_TMP) :
	@$(ECHO) "Creating directory $@"
	%mkdir_q dir=$@

  ifdef CREATED_DIRS_GLOB
    CREATED_DIRS_GLOB += $(TOCREATE_TMP)
  else
    CREATED_DIRS_GLOB := $(TOCREATE_TMP)
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rule to generate a functable
#
%define rule_genfunctable name=functable files=/A dir=. libdefs=libdefs.h

%(dir)/%(name).c : $(addsuffix .c,%(files)) $(SCRIPTDIR)/genfunctable.awk %(libdefs)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
ifneq (%(files),)
	$(AWK) -v file=%(libdefs) -f $(SCRIPTDIR)/genfunctable.awk $(addsuffix .c,%(files)) > $@
else
	$(ARCHTOOL) -t
	$(MV) functable.c $@
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile basename=/A cflags=$(CFLAGS) dflags= targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).o : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).o : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).o : %(basename).c
	%compile_q opt=%(cflags) cmd=$(TMP_CMD)

ifeq (%(dflags),)
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(cflags)
else
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(dflags)
endif
$(TMP_TARGETBASE).d : %(basename).c
	%mkdepend_q flags=$(TMP_DFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Make an alias from one arch specific build to another arch.
# arguments:
# - mainmmake: the mmake of the module in the main tree
# - arch: the current arch
# - alias: the alias to which this should point
%define rule_archalias mainmmake=\A arch=\A alias=\A

#MM- %(mainmmake)-%(arch) : %(mainmmake)-%(alias)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an shared object file with a
# .so suffix. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_shared basename=/A cflags=$(CFLAGS) targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).so : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).so : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)" cmd=$(TMP_CMD)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A flags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : %(basename).s
	%assemble_q opt=%(flags)

else
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q opt=%(flags)

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(objs) to %(prog) using the libraries in %(uselibs)
%define rule_link_prog prog=/A objs=/A ldflags=$(LDFLAGS) uselibs= \
    usehostlibs= usestartup=yes detach=no nix=no

ifeq (%(nix),yes)
    NIX := $(AROS_LIB)/nixmain.o
else
    NIX :=
endif

ifeq (%(usestartup),no)
%(prog) : STARTUP :=
else
ifeq (%(detach),yes)
%(prog) : STARTUP := $(AROS_LIB)/detach.o $(AROS_LIB)/startup.o $(NIX)
else
%(prog) : STARTUP := $(AROS_LIB)/startup.o $(NIX)
endif
endif

%(prog) : %(objs) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from="%(objs)" opt=%(ldflags) \
	    libs="$(addprefix -l,%(uselibs)) -llibinit -lautoinit $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(progs) from object in %(objdir) to executables in %(targetdir) using
# the AROS libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_link_progs progs=/A targetdir=$(AROSDIR)/$(CURDIR) \
    objdir=$(GENDIR)/$(CURDIR) ldflags=$(LDFLAGS) uselibs= usehostlibs= \
    usestartup=yes detach=no

ifeq (%(usestartup),no)
$(addprefix %(targetdir)/,%(progs)) : STARTUP :=
else
ifeq (%(detach),yes)
$(addprefix %(targetdir)/,%(progs)) : STARTUP := $(AROS_LIB)/detach.o $(AROS_LIB)/startup.o
else
$(addprefix %(targetdir)/,%(progs)) : STARTUP := $(AROS_LIB)/startup.o
endif
endif

$(addprefix %(targetdir)/,%(progs)) : %(targetdir)/% : %(objdir)/%.o \
    $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from=$< opt=%(ldflags) \
	    libs="$(addprefix -l,%(uselibs)) -llibinit -lautoinit $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a in
%define rule_link_linklib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).so in
%define rule_link_shlib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).so : %(objs)
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A uselibs= usehostlibs=

%(module) : %(objs) %(endobj) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_module_q err="%(err)" endtag="%(endobj)" objs="%(objs)" \
		       libs="$(addprefix -l,%(uselibs)) -llibinit -lautoinit -L/usr/lib $(addprefix -l,%(usehostlibs))"

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file.
# - includefile: This file will be included at the head of the source file
%define rule_ref basename=/A cflags=$(CFLAGS) targetdir= includefile= compiler=target

ifeq (%(targetdir),)
GENFILE_TMP := %(basename).ref
else
GENFILE_TMP := %(targetdir)/$(notdir %(basename)).ref
endif

ifeq ($(filter %(compiler),target host),)
$(error use of %rule_ref: compiler has to be 'host' or 'target')
endif

ifeq (%(compiler),target)
$(GENFILE_TMP) : CC:=$(TARGET_CC)
else
$(GENFILE_TMP) : CC:=$(HOST_CC)
endif

$(GENFILE_TMP) : %(basename).c $(CXREF) %(includefile)
	@$(ECHO) "Generating $(notdir $@)..."
ifeq (%(includefile),)
	@$(CXREF) -raw -CPP '$(CC) %(cflags) -E -C -dD' $< >$@
else
	@$(CXREF) -raw -CPP '$(CC) %(cflags) -include %(includefile) -E -C -dD' $< >$@
endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genlibdefs modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/%(modname)_libdefs.h : %(conffile) $(GENLIBDEFS)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENLIBDEFS) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate dummy support files so cxref when used on the a module source file
# will find something to include.
%define rule_genmodule_dummy modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/clib/%(modname)_protos.h %(targetdir)/defines/%(modname).h \
%(targetdir)/proto/%(modname).h : %(conffile) $(GENMODULEDUMMY)
	@$(ECHO) "Generating $(notdir $@)"
	%mkdirs_q dirs="%(targetdir) %(targetdir)/clib %(targetdir)/defines %(targetdir)/proto"
	@$(GENMODULEDUMMY) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule modname=/A modtype=/A objdir=/A conffile=/A reffile=/A

GENFILES_TMP := %(objdir)/%(modname)_start.c %(objdir)/%(modname)_end.c

# Some of the generated files are dependent on the module type.
ifeq (%(modtype),library)
GENFILES_TMP += %(objdir)/%(modname)_autoinit.c %(objdir)/%(modname)_stubs.c \
                $(GENINCDIR)/clib/%(modname)_protos.h \
                $(GENINCDIR)/defines/%(modname).h \
                $(GENINCDIR)/proto/%(modname).h
endif

ifneq ($(findstring %(modtype),mcc mui mcp),)
GENFILES_TMP += %(objdir)/%(modname)_stubs.c \
                %(objdir)/%(modname)_mcc_query.c \
                %(objdir)/%(modname)_mcc_init.c
endif

$(GENFILES_TMP) : %(conffile) $(GENMODULE) %(reffile)
	@$(ECHO) "Generating functable and includes for module $(BD_MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) %(modname) %(modtype) %(conffile) %(objdir) $(GENINCDIR) %(reffile)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build an imported source tree which uses the configure script from the
# autoconf package.  This rule will try to "integrate" the produced files as
# much as possible in the AROS build, for exampley by putting libraries in the
# standard library directory, includes in the standard include directory, and
# so on. You can however override this behaviour.
#
# As a special "bonus" for you, the PROGDIR environment variable is defined to
# be %(bindir) (or its deduced value) when running "make install", and
# "PROGDIR:" when running "make" alone; you can use this feature to pass the
# configure script some more parameters whose value depends upon the PROGDIR
# env var, so that the program gets all its stuff installed in the proper place
# when building it, but when running it from inside AROS it can also find that
# stuff by simply opening PROGDIR:, which it will do automatically if it uses
# the configuration parameters set when running ./configure
#
# *NOTICE*: DO NOT put a trailing '/' (slash) after $PROGDIR, as the variable
# already contains either a '/' (slash) or a ':' (colon), thus simply attach it
# to the name which has to follow it.

%define build_with_configure mmake=/A configure=$(TOP)/$(CURDIR)/configure prefix= \
    bindir= libdir= includedir= extraoptions= nix=no host=no install_target=install

.PHONY : %(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick

#MM- %(mmake) : setup includes linklibs %(mmake)-quick

%(mmake)-PATH := PATH=$(TOOLDIR):$$PATH

#MM
%(mmake)-quick : $(GENDIR)/$(CURDIR)/.configured
	@$(%(mmake)-PATH); \
	 if ! $(MAKE) PROGDIR="PROGDIR:" -q -C $(GENDIR)/$(CURDIR); then \
	    $(MAKE) PROGDIR="PROGDIR:" -C $(GENDIR)/$(CURDIR); \
	    ret=$$?; \
	    if [ $$ret -ne 0 ] ; then \
	        exit $$ret; \
	    fi; \
	    $(if %(install_target),$(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" -C $(GENDIR)/$(CURDIR) %(install_target);,) \
	fi

$(TOP)/$(CURDIR)/.files-touched:
	@find . | xargs $(TOUCH) -r configure; \
	$(ECHO) YES > $@

ifeq (%(nix),yes)
    %(mmake)-nix := -nix
endif
ifneq (%(bindir),)
    %(mmake)-bindir := --bindir=%(bindir)
    %(mmake)-PROGDIR := %(bindir)
endif
ifneq (%(includedir),)
    %(mmake)-includedir := --includedir=%(includedir)
endif
ifneq (%(libdir),)
    %(mmake)-libdir := --libdir=%(libdir)
endif
ifneq (%(prefix),)
    %(mmake)-prefix := --prefix=%(prefix)
else
    %(mmake)-prefix := --prefix=$(CONTRIBDIR)
    ifeq ($(%(mmake)-bindir),)
        %(mmake)-bindir := --bindir=$(CONTRIBDIR)
        %(mmake)-PROGDIR := $(CONTRIBDIR)
    endif
    ifeq ($(%(mmake)-libdir),)
        %(mmake)-libdir := --libdir=$(LIBDIR)
    endif
    ifeq ($(%(mmake)-includedir),)
        %(mmake)-includedir := --includedir=$(INCDIR)
    endif
endif

ifeq ($(%(mmake)-PROGDIR),)
    %(mmake)-PROGDIR := %(prefix)/bin
endif

$(GENDIR)/$(CURDIR)/.configured : AR2     := $(firstword $(AR))
$(GENDIR)/$(CURDIR)/.configured : RANLIB2 := $(firstword $(RANLIB))

ifeq (%(host),yes)
$(GENDIR)/$(CURDIR)/.configured : $(TOP)/$(CURDIR)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR); \
	    $(RM) config.cache; \
	    $(%(mmake)-PATH); \
	    AR=$(AR2) RANLIB=$(RANLIB2) OBJCOPY="$(OBJCOPY)" \
	    CC="$(HOST_CC)" \
	    %(configure) $(%(mmake)-prefix) $(%(mmake)-bindir) $(%(mmake)-libdir) \
	    $(%(mmake)-includedir) %(extraoptions); \
	$(ECHO) YES > $@
else
$(GENDIR)/$(CURDIR)/.configured : $(TOP)/$(CURDIR)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR); \
	    $(RM) config.cache; \
	    $(%(mmake)-PATH); \
	    AR=$(AR2) RANLIB=$(RANLIB2) OBJCOPY="$(OBJCOPY)" \
	    CC="$(AROS_TARGET_CPU)-$(AROS_TARGET_ARCH)$(AROS_TARGET_SUFFIX)-aros-gcc $(%(mmake)-nix)" \
	    CC_FOR_BUILD="$(HOST_CC)" \
	    %(configure) $(%(mmake)-prefix) $(%(mmake)-bindir) $(%(mmake)-libdir) \
	    $(%(mmake)-includedir) %(extraoptions) \
	    --host=$(AROS_TARGET_CPU)-$(AROS_TARGET_ARCH)-aros; \
	$(ECHO) YES > $@
endif
	
#MM
%(mmake)-clean :
	-@if [ -e $(GENDIR)/$(CURDIR)/Makefile ]; then \
	    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" -C $(GENDIR)/$(CURDIR) uninstall; \
        fi
	@$(RM) $(GENDIR)/$(CURDIR)
%end

#------------------------------------------------------------------------------
# Build a program
%define build_prog mmake=/A progname=/A files=$(BD_PROGNAME$(BDID)) asmfiles= \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    aflags=$(AFLAFS) uselibs= usehostlibs= usestartup=yes detach=no nix=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_PROGNAME$(BDID)  := %(progname)
BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_ASMFILES$(BDID)  := %(asmfiles)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))

BD_CFLAGS$(BDID)    := %(cflags)
BD_AFLAGS$(BDID)    := %(aflags)
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))

%rule_link_prog prog=$(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID)) \
    objs=$(BD_OBJS$(BDID)) ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" nix="%(nix)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build programs, for every C file an executable will be built with the same
# 
%define build_progs mmake=/A files=/A \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    uselibs= usehostlibs= usestartup=yes detach=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_EXES$(BDID)      := $(addprefix $(BD_TARGETDIR$(BDID))/,$(BD_FILES$(BDID)))

BD_CFLAGS$(BDID)    := %(cflags)
ifneq ($(strip $(filter arosc_shared,%(uselibs))),)
BD_CFLAGS$(BDID)    += -D_CLIB_LIBRARY_ -I$(TOP)/rom/exec
endif
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_EXES$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))

%rule_link_progs progs=$(BD_FILES$(BDID)) \
    targetdir=$(BD_TARGETDIR$(BDID)) objdir=$(BD_OBJDIR$(BDID)) \
    ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A \
  conffile=$(BD_MODNAME$(BDID)).conf files="$(basename $(wildcard *.c))" \
  linklibfiles= cflags=$(CFLAGS) dflags= objdir=$(OBJDIR) \
  reffile=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_ALL.ref \
  linklibname=$(BD_MODNAME$(BDID)) uselibs= \
  compiler=target

%buildid targets="%(mmake) %(mmake)-includes %(mmake)-setup %(mmake)-clean %(mmake)-quick %(mmake)-kobj"

.PHONY : setup-module$(BDID) %(mmake) %(mmake)-includes %(mmake)-setup %(mmake)-clean %(mmake)-quick %(mmake)-kobj

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_FILES$(BDID)      := %(files)
BD_LIBFILES$(BDID)   := %(linklibfiles)
BD_STARTFILE$(BDID)  := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end

BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)))))
BD_STARTOBJ$(BDID)   := $(addsuffix .o,$(BD_STARTFILE$(BDID)))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)) $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID)))

BD_REFFILES$(BDID)   := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .ref, $(notdir $(BD_FILES$(BDID)))))
BD_REFFILE$(BDID)    := %(reffile)

ifeq ($(BD_MODTYPE$(BDID)),library)
BD_GENINCS$(BDID)    := clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
endif
BD_LIBDEFSINC$(BDID) := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -idirafter $(TOP)/$(CURDIR) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library mcc mui mcp),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_MODDIR$(BDID)       := $(AROS_LIBS)
  BD_LINKLIBFILES$(BDID)   := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.c 
  BD_LINKLIBOBJS$(BDID)    := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .o,$(BD_LIBFILES$(BDID)))) \
  	                    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.o 
  BD_LINKLIBGENFILES$(BDID):= $(LIBDIR)/lib%(linklibname).a
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),mcc mui mcp),)
  BD_MODDIR$(BDID)       := $(AROS_CLASSES)/Zune
  BD_OBJS$(BDID)         += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query.o \
                            $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init.o
  BD_LINKLIBGENFILES$(BDID):= 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),library mcc),)
  BD_LINKLIBFILES$(BDID)   += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.c
  BD_LINKLIBOBJS$(BDID)    += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.o
  BD_LINKLIBDEPS$(BDID)    := $(patsubst %.o,%.d,$(BD_LINKLIBOBJS$(BDID))) 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
		compiler=%(compiler)
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID)) $(BD_LINKLIBGENFILES$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

# What are the files that need to be generated before the .d and .ref files
# can be generated ?
BD_REFFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_REFFILE_DEPS$(BDID) += $(addprefix $(BD_OBJDIR$(BDID))/dummyinc/,$(BD_GENINCS$(BDID)))
endif
BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_DFILE_DEPS$(BDID) += $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

#MM %(mmake) : %(mmake)-includes
#MM %(mmake)-kobj : %(mmake)-includes
#MM %(mmake)-includes : %(mmake)-setup includes-generate-deps

#MM
%(mmake)-quick : %(mmake)

#MM
%(mmake) : $(BD_GENFILES$(BDID))

#MM
%(mmake)-includes : $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID)))

#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(addsuffix .c,$(BD_STARTFILE$(BDID)) $(BD_ENDFILE$(BDID))) \
	    $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_ref     basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags="-I$(dir $(GENMODULE))/genmod_inc -I$(BD_OBJDIR$(BDID))/dummyinc $(strip $(BD_CFLAGS$(BDID)))"
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end targetdir=$(BD_OBJDIR$(BDID)) \
 	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
endif

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Only for this target these deps are wanted
$(BD_REFFILES$(BDID)) : $(BD_REFFILE_DEPS$(BDID)) $(dir $(GENMODULE))/genmod_inc/aros/libcall.h
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
%rule_genmodule modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		objdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID)) \
		reffile=$(BD_REFFILE$(BDID))

%rule_genmodule_dummy modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		      targetdir=$(BD_OBJDIR$(BDID))/dummyinc conffile=$(BD_CONFFILE$(BDID))

%rule_genlibdefs modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		 targetdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID))

$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(BD_LIBDEFSINC$(BDID))\"" >$@

# The module ref file is the joint of all individual .ref files
%rule_join from=$(BD_REFFILES$(BDID)) to=$(BD_REFFILE$(BDID)) \
	   text="Collecting function references for module $(BD_MODNAME$(BDID))"

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_STARTOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)"

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(INCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/defines/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/proto/$(BD_MODNAME$(BDID)).h
endif

# For a shared library also build a static link lib
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_link_linklib libname=%(linklibname) objs=$(BD_LINKLIBOBJS$(BDID))
endif

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_OBJDIR$(BDID))/dummyinc/defines $(BD_OBJDIR$(BDID))/dummyinc/proto $(BD_OBJDIR$(BDID))/dummyinc/clib $(BD_MODDIR$(BDID)) $(KOBJSDIR)" \
	       setuptarget=setup-module$(BDID)

%(mmake)-kobj : $(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o

$(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o : \
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start.o \
$(BD_OBJS$(BDID)) \
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end.o
	@$(LD) -r -o $@ $^

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module using the deprecated macro's to define the functions in the
# library. Explanation of this macro is done in the developer's manual
%define build_module_macro mmake=/A modname=/A modtype=/A dir= \
  conffile=$(BD_MODNAME$(BDID)).conf initfile=$(BD_MODNAME$(BDID))_init \
  funcs= files= linklibfiles= cflags=$(CFLAGS) dflags= \
  objdir=$(OBJDIR) uselibs= usehostlibs= \
  genfunctable= genincludes= compiler=target

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-includes %(mmake)-linklib %(mmake)-quick %(mmake)-kobj"

.PHONY : setup-module$(BDID)

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_MODDIR$(BDID)     := %(dir)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_ARCHOBJS$(BDID)   := $(wildcard $(BD_OBJDIR$(BDID))/arch/*.o)
BD_ARCHFILES$(BDID)  := $(basename $(notdir $(BD_ARCHOBJS$(BDID))))

BD_INITFILE$(BDID)   := %(initfile)
BD_FUNCS$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(funcs))
BD_FILES$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(files))
BD_LIBFILES$(BDID)   := %(linklibfiles)
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end
else
BD_ENDFILE$(BDID)    := 
endif

BD_FUNCSRCS$(BDID)   := $(addsuffix .c,%(funcs))
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
ifeq ($(filter $(BD_INITFILE$(BDID)), $(BD_ARCHFILES$(BDID))),)
  BD_INITOBJ$(BDID)  := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_INITFILE$(BDID)))))
else
  TMP_INITREPLACE    := $(filter $(notdir $(BD_INITFILE$(BDID))), $(BD_ARCHFILES$(BDID)))
  TMP_INITKEEP       := $(filter-out $(TMP_INITREPLACE),$(notdir $(BD_INITFILE$(BDID))))
  BD_INITOBJ$(BDID)  := $(addsuffix .o, \
  		     	    $(addprefix $(BD_OBJDIR$(BDID))/arch/,$(TMP_INITREPLACE)) \
			    $(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_INITKEEP)) \
			 )
  BD_ARCHOBJS$(BDID) := $(filter-out $(BD_INITOBJ$(BDID)),$(BD_ARCHOBJS$(BDID)))
endif

TMP_FILES            := $(notdir $(BD_FILES$(BDID)))
ifeq (%(genfunctable),yes)
  TMP_FILES          := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifeq (%(genfunctable),)
      ifneq ($(BD_MODTYPE$(BDID)),resource)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    else
      ifneq (%(genfunctable),no)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    endif
    TMP_FILES        += $(BD_FUNCS$(BDID))
  endif
endif
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_FILES))) $(BD_ARCHOBJS$(BDID))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_INITFILE$(BDID)) $(TMP_FILES)))

BD_GENINCS$(BDID)    :=
ifneq (%(genincludes),)
  ifeq (%(genincludes),yes)
    BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
  endif
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifneq ($(findstring $(BD_MODTYPE$(BDID)),library gadget device),)
      BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
    endif
  endif
endif
# Only generate libdefs.h if the config file exists
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
  BD_LIBDEFSINC$(BDID):= $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h
else
  BD_LIBDEFSINC$(BDID):=
endif

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library gadget datatype handler device resource mui mcc hidd),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODDIR$(BDID)),)
  ifeq ($(BD_MODTYPE$(BDID)),library)
    BD_MODDIR$(BDID)  := $(AROS_LIBS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),gadget)
    BD_MODDIR$(BDID)  := $(AROS_GADGETS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),datatype)
    BD_MODDIR$(BDID)  := $(AROS_DATATYPES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),handler)
    BD_MODDIR$(BDID)  := $(AROS_FS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),device)
    BD_MODDIR$(BDID)  := $(AROS_DEVS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),resource)
    BD_MODDIR$(BDID)  := $(AROS_RESOURCES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mui)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mcc)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),hidd)
    BD_MODDIR$(BDID)  := $(AROS_DRIVERS)
  endif
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

#MM %(mmake) : %(mmake)-setup
#MM %(mmake)-includes : %(mmake)-setup
#MM %(mmake) : %(mmake)-includes

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_GENFILES$(BDID))

#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(BD_ENDFILE$(BDID)).c $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

#MM %(mmake)-includes : setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-includes : $(TMP_DEPS)
  
$(TMP_DEPS) : $(BD_LIBDEFSINC$(BDID))

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-linklib %(mmake)-quick %(mmake)-kobj),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FUNCS$(BDID)) $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_ENDFILE$(BDID)) targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_functable targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
endif

BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick %(mmake)-linklib) %(mmake)-kobj,) # Only for this target these deps are wanted
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(notdir $(BD_LIBDEFSINC$(BDID)))\"" >$@

%libdefs_rule conffile=$(BD_CONFFILE$(BDID)) dest=$(BD_LIBDEFSINC$(BDID))

ifneq ($(BD_ENDFILE$(BDID)),)
$(BD_ENDFILE$(BDID)).c :
	@$(ECHO) "generating $@"
	@$(ECHO) "#include <libcore/libtail.c>" >$@
endif

%rule_genfunctable name=$(BD_MODNAME$(BDID))_functable files=$(BD_FUNCS$(BDID)) dir=$(BD_OBJDIR$(BDID)) \
  libdefs=$(BD_LIBDEFSINC$(BDID))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)" \
		 usehostlibs="%(usehostlibs)"

BD_HEADER_DEPS$(BDID) := $(wildcard headers.tmpl) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_FUNCSRCS$(BDID)) \
	    $(SCRIPTDIR)/genshared \
	    $(SCRIPTDIR)/genclib.awk $(SCRIPTDIR)/genpclib.awk \
	    $(SCRIPTDIR)/gendefines.awk $(SCRIPTDIR)/genpdefines.awk

# Regenerate the includes when some of the dependencies are changed
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp : $(BD_HEADER_DEPS$(BDID))
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -defines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $@

# Generate includes the first time they are needed
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_private_protos.h \
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h \
$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h \
$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h :
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(INCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/defines/$(BD_MODNAME$(BDID)).h
#%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/proto/$(BD_MODNAME$(BDID)).h

MYDIRS$(BDID) := $(BD_OBJDIR$(BDID)) $(GENINCDIR) $(GENINCDIR)/clib \
  $(GENINCDIR)/proto $(GENINCDIR)/defines \
  $(GENINCDIR)/pragmas $(INCDIR) $(INCDIR)/clib $(INCDIR)/proto \
  $(INCDIR)/defines $(INCDIR)/pragmas \
  $(BD_MODDIR$(BDID)) $(KOBJSDIR)

%rule_makedirs dirs=$(MYDIRS$(BDID)) setuptarget=setup-module$(BDID)

#MM %(mmake)-linklib : %(mmake)-setup setup-clib
#MM %(mmake)-kobj : %(mmake)-setup setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
  $(BD_LIBDEFSINC$(BDID))
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-linklib : $(TMP_DEPS)
%(mmake)-kobj : $(TMP_DEPS)

# Link only when target %(mmake)-linklib otherwise for example jpeg.datatype
# that depend on the jpeg library can cause to get this rule executed unwanted
ifneq ($(filter $(TARGET),%(mmake)-linklib %(mmake)-kobj),)
%(mmake)-linklib : $(LIBDIR)/lib$(BD_MODNAME$(BDID)).a
%(mmake)-kobj : $(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o

%rule_link_linklib libname=$(BD_MODNAME$(BDID)) libdir=$(LIBDIR) \
  objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))"

$(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o : $(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))
	@$(LD) -r -o $@ $^

endif

%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-linklib %(mmake)-kobj" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given with the .s suffix
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags use during makedepend (default equal to cflags)
# - aflags are the flags use during assembling (default $(AFLAGS))
# - objdir is where the .o are generated
# - libdir is the directory where the linklib will be placed (default $(LIBDIR))
%define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c))" \
  asmfiles= cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) objdir=$(OBJDIR) libdir=$(LIBDIR)

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

# assign and generate the local variables used in this macro
BD_LIBNAME$(BDID)    := %(libname)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)
BD_LIBDIR$(BDID)     := %(libdir)

BD_FILES$(BDID)      := %(files)
BD_ASMFILES$(BDID)   := %(asmfiles)
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID)))))
BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)))

BD_CFLAGS$(BDID)     := %(cflags)
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags)
endif
BD_AFLAGS$(BDID)     := %(aflags)

BD_LINKLIB$(BDID)    := $(BD_LIBDIR$(BDID))/lib$(BD_LIBNAME$(BDID)).a

.PHONY : setup-linklib$(BDID)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_LINKLIB$(BDID))

#MM
%(mmake)-setup : setup-linklib$(BDID)

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID))

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_LIBDIR$(BDID))" \
	       setuptarget=setup-linklib$(BDID)

ifeq ($(TARGET),%(mmake))
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))
endif

%rule_link_linklib libname=%(libname) objs=$(BD_OBJS$(BDID)) libdir=$(BD_LIBDIR$(BDID))

%include_deps depstargets=%(mmake) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd) (default *.cd)
# - subdir is the destination subdir of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - source is the path to the generated source code file
# - dir is the base destination directory (default $(AROS_CATALOGS))
# - sourcedescription is the path to the FlexCat's source description file, without the .sd suffix

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs="$(basename $(wildcard *.ct))" source="../strings.h" \
 description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS) \
 sourcedescription="$(TOOLDIR)/C_h_orig"

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_SRCS$(BDID) := $(foreach name, %(catalogs), $(name).ct)
BD_OBJS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir)/%(name).catalog)
BD_DIRS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir))

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID)) %(source)

#MM %(mmake)-setup
%rule_makedirs dirs=$(BD_DIRS$(BDID)) setuptarget=%(mmake)-setup

%(dir)/%/%(subdir)/%(name).catalog : %.ct %(description).cd
	@$(ECHO) "Creating %(name) catalog for language $*."
	@$(IF) $(FLEXCAT) %(description).cd $*.ct CATALOG=%(dir)/$*/%(subdir)/%(name).catalog ; then $(NOP) ; else $(NOP) ; fi ;

ifneq (%(source),)
%(source) : %(description).cd
	@$(ECHO) "Creating %(name) catalog source file %(source)"
	@$(FLEXCAT) %(description).cd %(source)=%(sourcedescription).sd
endif

#MM
%(mmake)-clean ::
	$(RM) $(BD_OBJS$(BDID)) %(source)

.PHONY: %(mmake) %(mmake-setup) %(mmake-clean)

%end

#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Build icons.
# - mmake is the mmaketarget
# - icons is a list of icon base names (ie. without the .info suffix)
# - dir is the destination directory
#-----------------------------------------------------------------------------

%define build_icons mmake=/A icons=/A dir=/A

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_OBJS$(BDID) := $(foreach icon, %(icons), %(dir)/$(icon).info)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID))

%(dir)/%.info : %.info.src %.png
	@$(ECHO) Creating $(notdir $@)...
	@$(ILBMTOICON) $+ $@

#MM %(mmake)-setup
%rule_makedirs dirs=%(dir) setuptarget=%(mmake)-setup

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID))

.PHONY: %(mmake)

%end

#-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Compile files for a arch specific replacement of code for a module
# - files: the basename of the C files to compile.
# - asmfiles: the basename of the asm file to assemble.
# - mainmmake: the mmake of the module in the main directory to compile these
#   arch specific files for.
# - maindir: the object directory for the main module
# - arch: the arch for which to compile these files. It can has to have the form
#   of ARCH, CPU or ARCH-CPU, e.g. linux, i386 or linux-i386
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - aflags: the flags used during assembling
# - compiler: (host or target) specifies which compiler to use. By default
#   the target compiler is used
%define build_archspecific files= asmfiles= mainmmake=/A maindir=/A arch=/A \
cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) compiler=target

ifeq (%(files) %(asmfiles),)
  $(error no files or asmfiles given)
endif

%buildid targets="%(mainmmake)-%(arch) %(mainmmake)-%(arch)-setup"

#MM- %(mainmmake) : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-linklib : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)

#MM %(mainmmake)-%(arch) : %(mainmmake)-%(arch)-setup

ifeq (%(arch),)
  $(error argument arch has to be non empty for the rule_compile_archspecific macro)
endif

BD_OBJDIR$(BDID)  := $(GENDIR)/%(maindir)/arch
BD_COBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))
BD_ASMOBJS$(BDID) := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(asmfiles))))
BD_OBJS$(BDID)    := $(BD_COBJS$(BDID)) $(BD_ASMOBJS$(BDID))
BD_DEPS$(BDID)    := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))

ifeq ($(TARGET),%(mainmmake)-%(arch))
vpath %.c $(filter-out ./,$(dir %(files)))
vpath %.s $(filter-out ./,$(dir %(asmfiles)))
vpath %.S $(filter-out ./,$(dir %(asmfiles)))
endif

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

#MM
%(mainmmake)-%(arch) :: $(BD_OBJS$(BDID))

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(HOST_CC)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.c
	%compile_q opt=%(cflags) cmd=$(TMP_CMD)
endif

ifeq (%(dflags),)
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(cflags)
else
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(dflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.d : %.c
	%mkdepend_q flags=$(TMP_DFLAGS)
endif

$(BD_ASMOBJS$(BDID)) : AFLAGS:=%(aflags)

ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.s
	%assemble_q opt=$(AFLAGS)
$(BD_OBJDIR$(BDID))/%.o : %.S
	%assemble_q opt=$(AFLAGS)
endif

%include_deps depstargets=%(mainmmake)-%(arch) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------







# ======================
# Old stuff, will probably be removed in the future




# GNU Make automatic variables
# $@ current target
# $< First dependency
# $? All newer dependencies
# $^ All dependencies
# $* The stem (ie. target is dir/a.foo.b and the pattern is
#    a.%.b, then the stem is dir/foo)

#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#------------------------------------------------------------------------------
# Same, more noisy
%define mkdirs dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#------------------------------------------------------------------------------
%define link_q cmd=$(CC) opt=$(LDFLAGS) startup=$(STARTUP) from=$< to=$@ libs=$(LIBS) end=$()
	@$(ECHO) "Linking %(to)..."
	@$(IF) %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) $(COMPILER_LIBS) %(end) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "%(to): %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) %(end)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	   	else \
			$(NOP) ; \
    		fi ; \
	else \
	    $(ECHO) "Link failed: %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) %(end)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi; \
	$(STRIP) %(to)
%end

#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Same but more noisy
%define mklib ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	%(ar) %(to) %(from)
	%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Same but more noisy
%define mkdepend flags=$(CFLAGS) from=$< to=$@ dir=$(@D) opt=
	@$(IF) [ ! -d %(dir) ]; then $(MKDIR) %(dir) ; else $(NOP) ; fi
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	$(MKDEPEND) %(flags) %(from) -o %(to)
%end

#------------------------------------------------------------------------------
# Do something in all subdirs
# This macro uses a trick: %(target) is evaluated *after* %(text), so one
# can use %(target) in %(text).
%define subdirs_q text="Making %(target)" target=$(TARGET) dirs=$(SUBDIRS) curdir=$(CURDIR) mflags=$(MFLAGS) submf=makefile top=$(TOP)
	@$(FOR) dir in %(dirs) ; do \
	    $(ECHO) "%(text) in %(curdir)/$$dir..." ; \
	    if $(TEST) -f $$dir/%(submf).src && \
		{ $(TEST) ! -f $$dir/%(submf) \
		-o $$dir/%(submf).src -nt $$dir/%(submf) \
		-o %(top)/config/make.tmpl -nt $$dir/%(submf) ; } ; then \
		$(ECHO) "Generating %(submf)..." ; \
		$(AWK) -f $(TOP)/scripts/genmf.gawk \
		-v TOP="$(TOP)" \
		$$dir/%(submf).src > $$dir/%(submf) || exit 1 ; \
	    fi ; \
	    if ( cd $$dir ; \
		$(MAKE) %(mflags) --file=%(submf) \
		    TOP="%(top)/.." CURDIR="%(curdir)/$$dir" \
		    TARGET=%(target) %(target) ) ; \
	    then $(NOP) ; else exit 1 ; fi ; \
	done
%end

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(TOP)/config/make.tail

BDID := $(BDTARGETID)
%end

#------------------------------------------------------------------------------
# rule to generate libdefs.h with archtool (options may go away!)
%define libdefs_rule conffile=lib.conf genlibdefstool=$(ARCHTOOL) dest=libdefs.h
%(dest) : %(conffile) %(genlibdefstool)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@%(genlibdefstool) -c -o $@ %(conffile)
%end


#------------------------------------------------------------------------------
# rule to generate asm files from c files (for debugging purposes)
%define asm_rule opt=$(GENASM)
.PHONY : asm
asm : $(foreach f,%(opt),$(f).s) all
%end

#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) -S $(CFLAGS) $< -c -o $@
%end

#------------------------------------------------------------------------------
# Convert two png images to an Amiga icon file based on the description
# file %(from), with outputfile going to %(to).
%define makeicon2 from=$< to=$@ img1="$(basename $(basename $<))_N.png" img2="$(basename $(basename $<))_S.png"
	@$(ECHO) "Creating icon %(to)..."
	@$(PNGTOPNM) %(img1) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon1.iff
	@$(PNGTOPNM) %(img2) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon2.iff
	@$(ILBMTOICON) %(from) $(GENDIR)/genicon1.iff $(GENDIR)/genicon2.iff %(to)
%end

#------------------------------------------------------------------------------
# NOTE: The following are all part of Iain's build changes, please don't use
# or change anything below this line until you know what you are doing. This
# is so that I don't conflict with the semantics of any of the above macros.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q files=$(FILES) src=. dst=/A maketarget=files-copy

SRC_FILES := $(foreach f, %(files), %(src)/$(f))
DST_FILES := $(foreach f, %(files), %(dst)/$(f))

%(maketarget) : setup $(DST_FILES)

$(DST_FILES) : %(dst)/% : %(src)/%
	@$(CP) $< $@
	
setup ::
	%mkdirs_q %(dst)

%end


#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake= includes=$(INCLUDE_FILES) path=. dir=include

ifneq (%(dir),)
INCL_FILES_1 := $(subst %(dir),$(AROS_INCLUDES)/%(path),%(includes))
INCL_FILES_2 := $(subst %(dir),$(GENINCDIR)/%(path),%(includes))
_INC_PATH := %(dir)/
else
INCL_FILES_1 := $(foreach f,%(includes),$(AROS_INCLUDES)/%(path)/$(f))
INCL_FILES_2 := $(foreach f,%(includes),$(GENINCDIR)/%(path)/$(f))
_INC_PATH :=
endif

ifneq (%(mmake),)
#MM 
includes-copy : %(mmake)

#MM
%(mmake) : %(mmake)-includes-setup $(INCL_FILES_1) $(INCL_FILES_2)

.PHONY: %(mmake)

else
#MM
includes-copy : includes-setup $(INCL_FILES_1) $(INCL_FILES_2)
endif


$(AROS_INCLUDES)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

$(GENINCDIR)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

ifneq (%(mmake),)
%(mmake)-includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)

.PHONY: %(mmake)-includes-setup
else
includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)
endif

$(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path) :
	%mkdir_q dir=$@

,PHONY: includes-copy includes-setup

%end

%define make_hidd_stubs hidd=/A cflags=$(CFLAGS) dflags=$(CFLAGS) parenttarget=linklibs
STUBS_SRC := $(foreach f,$(STUBS),$(f).c)
STUBS_OBJ := $(foreach f,$(STUBS),$(OBJDIR)/$(f).o)
STUBS_MEM := $(foreach f,$(STUBS),$(f).o)
STUBS_DEP := $(foreach f,$(STUBS),$(OBJDIR)/$(f).d)
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs : hidd-%(hidd)-stubs
#MM- %(parenttarget): hidd-%(hidd)-stubs
#MM hidd-%(hidd)-stubs : includes includes-copy
hidd-%(hidd)-stubs : setup $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC) 
	%compile_q cmd=$(TARGET_CC) opt=%(cflags)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags=%(dflags)

setup ::
	%mkdirs_q $(OBJDIR) $(LIBDIR)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end

#------------------------------------------------------------------------------
#   Hey! iaint says don't add things here, add them before my other message.
#   The reason is that I'm trying to work out which of macros are still
#   needed, and because of this, I'm trying to keep my additions separate
#   from all the others.

