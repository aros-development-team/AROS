#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used as commands in a make rule.##
## They are used to help the portability of mmakefile to different         ##
## platforms.                                                              ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt).
%define compile_q cmd=$(TARGET_CC) opt=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Compiling $(notdir %(from))"
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "%(from): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Compile failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd=$(AS) opt=$(AFLAGS) from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "$(notdir %(from)): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Assemble failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building $(notdir $@) ..."
	@if $(STATIC_LD) $(STATIC_LDFLAGS) %(ldflags) \
	    $(GENMAP) %(objdir)/%(module).map \
	    %(objs) %(libs) %(endtag) $(COMPILER_LIBS) \
	    -o $@ 2>&1 > %(objdir)/%(err); \
	then \
	    cat %(objdir)/%(err); \
	else \
	    cat %(objdir)/%(err); \
	    exit 1; \
	fi

	@if $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(STRIP) $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags=$(CFLAGS) from=$< to=$@
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	@$(MKDEPEND) %(flags) %(from) -o %(to)
%end
#------------------------------------------------------------------------------


#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used to do certain tasks in a   ##
## mmakefile. They consist of one or more makefile rules.                  ##
## In general the files generated in these macro's are also defined as     ##
## make targets so that they can be used a dependency in other rules       ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $(BD_REFFILES$(BDID)) >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# include when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

# Only add a rule for a directory for which there is no rule yet.

TOCREATE_TMP := $(filter-out $(CREATED_DIRS_GLOB),%(dirs))

ifdef TOCREATE_TMP
$(TOCREATE_TMP) :
	@$(ECHO) "Creating directory $@"
	%mkdir_q dir=$@

  ifdef CREATED_DIRS_GLOB
    CREATED_DIRS_GLOB += $(TOCREATE_TMP)
  else
    CREATED_DIRS_GLOB := $(TOCREATE_TMP)
  endif
endif
%end
#------------------------------------------------------------------------------


#-------------------------------------------------------------------------
# Use cpak to generate the files functions.[ch]
#
%define rule_module_collect files=/A dir=. archfile=

ifeq (%(archfile),)
%(dir)/functions.c %(dir)/functions.h : $(addsuffix .c,%(files))
	%mkdir_q %(dir)
	@$(CPAK) -d %(dir) %(files)
else
$(OBJDIR)/functions.c : %(archfile) $(ARCHTOOL)
	@$(ARCHTOOL) -s $@ %(archfile)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rule to generate a functable
#
%define rule_genfunctable files=/A dir=. libdefs=libdefs.h archfile=

ifeq (%(archfile),)
%(dir)/functable.c : $(addsuffix .c,%(files)) $(BINDIR)/scripts/genfunctable.awk %(libdefs)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(AWK) -v file=%(libdefs) -f $(BINDIR)/scripts/genfunctable.awk $(addsuffix .c,%(files)) > $@
else
%(dir)/functable.c : %(archfile) $(ARCHTOOL)
	@$(ECHO) "Generating $@..."
	@$(ARCHTOOL) -t %(archfile)
	@$(MV) functable.c $@
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile basename=/A cflags=$(CFLAGS) dflags= targetdir=

ifeq (%(targetdir),)
%(basename).o : %(basename).c
	%compile_q opt=%(cflags)

ifeq (%(dflags),)
%(basename).d : %(basename).c
	%mkdepend_q flags=%(cflags)
else
%(basename).d : %(basename).c
	%mkdepend_q flags=%(dflags)
endif

else

%(targetdir)/$(notdir %(basename)).o : %(basename).c
	%compile_q opt=%(cflags)

ifeq (%(dflags),)
%(targetdir)/$(notdir %(basename)).d : %(basename).c
	%mkdepend_q flags=%(cflags)
else
%(targetdir)/$(notdir %(basename)).d : %(basename).c
	%mkdepend_q flags=%(dflags)
endif

endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an shared object file with a
# .so suffix. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_shared basename=/A cflags=$(CFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)"
else
%(targetdir)/$(notdir %(basename)).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)"
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A flags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : %(basename).s
	%assemble_q opt=%(flags)

else
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q opt=%(flags)

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a in
%define rule_link_linklib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).so in
%define rule_link_shlib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).so : %(objs)
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in use_libs
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A extradeps= uselibs=

%(module) : %(objs) %(endobj) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_module_q err="%(err)" endtag="%(endobj)" objs="%(objs)" \
		       libs="$(addprefix -l,%(uselibs)) -llibinit -lautoinit"

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file.
# - includefile: This file will be included at the head of the source file
%define rule_ref basename=/A cflags=$(CFLAGS) targetdir= includefile=

ifeq (%(targetdir),)
GENFILE_TMP := %(basename).ref
else
GENFILE_TMP := %(targetdir)/$(notdir %(basename)).ref
endif

$(GENFILE_TMP) : %(basename).c $(CXREF) %(includefile)
	@$(ECHO) "Generating $(notdir $@)..."
ifeq (%(includefile),)
	@$(CXREF) -raw -CPP 'gcc %(cflags) -E -C -dD' $< >$@
else
	@$(CXREF) -raw -CPP 'gcc %(cflags) -include %(includefile) -E -C -dD' $< >$@
endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genlibdefs modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/%(modname)_libdefs.h : %(conffile) $(GENLIBDEFS)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENLIBDEFS) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate dummy support files so cxref when used on the a module source file
# will find something to include.
%define rule_genmodule_dummy modname=/A modtype=/A conffile=/A targetdir=/A

%(targetdir)/clib/%(modname)_protos.h %(targetdir)/defines/%(modname).h \
%(targetdir)/proto/%(modname).h : %(conffile) $(GENMODULEDUMMY)
	@$(ECHO) "Generating $(notdir $@)"
	%mkdirs_q dirs="%(targetdir) %(targetdir)/clib %(targetdir)/defines %(targetdir)/proto"
	@$(GENMODULEDUMMY) %(modname) %(modtype) %(conffile) %(targetdir)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule modname=/A modtype=/A objdir=/A conffile=/A reffile=/A

GENFILES_TMP := %(objdir)/%(modname)_start.c %(objdir)/%(modname)_end.c

# Some of the generated files are dependent on the module type.
ifeq (%(modtype),library)
GENFILES_TMP += %(objdir)/%(modname)_autoinit.c %(objdir)/%(modname)_stubs.c \
                $(GENINCDIR)/clib/%(modname)_protos.h \
                $(GENINCDIR)/defines/%(modname).h \
                $(GENINCDIR)/proto/%(modname).h
endif

ifneq ($(findstring %(modtype),mcc mui mcp),)
GENFILES_TMP += %(objdir)/%(modname)_stubs.c \
                %(objdir)/%(modname)_mcc_query.c \
                %(objdir)/%(modname)_mcc_init.c
endif

$(GENFILES_TMP) : %(conffile) $(GENMODULE) %(reffile)
	@$(ECHO) "Generating functable and includes for module $(BD_MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) %(modname) %(modtype) %(conffile) %(objdir) $(GENINCDIR) %(reffile)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A \
  conffile=$(BD_MODNAME$(BDID)).conf files="$(basename $(wildcard *.c))" \
  linklibfiles= cflags=$(CFLAGS) dflags= objdir=$(OBJDIR) \
  reffile=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID)).ref \
  linklibname=$(BD_MODNAME$(BDID)) uselibs=

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

.PHONY : setup-module$(BDID)

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_FILES$(BDID)      := %(files)
BD_LIBFILES$(BDID)   := %(linklibfiles)
BD_STARTFILE$(BDID)  := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end

BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)))))
BD_STARTOBJ$(BDID)   := $(addsuffix .o,$(BD_STARTFILE$(BDID)))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)) $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID)))

BD_REFFILES$(BDID)   := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .ref, $(notdir $(BD_FILES$(BDID)))))
BD_REFFILE$(BDID)    := %(reffile)

ifeq ($(BD_MODTYPE$(BDID)),library)
BD_GENINCS$(BDID)    := clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
endif
BD_LIBDEFSINC$(BDID) := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
#Add extra flag if shared AROS C library is used
ifneq ($(strip $(filter arosc_shared,%(uselibs))),)
BD_CFLAGS$(BDID)     += -D_CLIB_LIBRARY_ -I$(TOP)/rom/exec
endif
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library mcc mui mcp),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_MODDIR$(BDID)       := $(AROS_LIBS)
  BD_LINKLIBFILES$(BDID)   := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.c 
  BD_LINKLIBOBJS$(BDID)    := $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .o,$(BD_LIBFILES$(BDID)))) \
  	                    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit.o 
  BD_LINKLIBGENFILES$(BDID):= $(LIBDIR)/lib%(linklibname).a
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_autoinit \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),mcc mui mcp),)
  BD_MODDIR$(BDID)       := $(AROS_CLASSES)/Zune
  BD_SRCS$(BDID)         += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query.c \
                            $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init.c
  BD_OBJS$(BDID)         += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query.o \
                            $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init.o
  BD_LINKLIBGENFILES$(BDID):= 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_query \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_mcc_init \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
endif

ifneq ($(findstring $(BD_MODTYPE$(BDID)),library mcc),)
  BD_LINKLIBFILES$(BDID)   += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.c
  BD_LINKLIBOBJS$(BDID)    += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs.o
  BD_LINKLIBDEPS$(BDID)    := $(patsubst %.o,%.d,$(BD_LINKLIBOBJS$(BDID))) 
  %rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_stubs \
  		targetdir=$(BD_OBJDIR$(BDID)) \
		cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID)) $(BD_LINKLIBGENFILES$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

# What are the files that need to be generated before the .d and .ref files
# can be generated ?
BD_REFFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_REFFILE_DEPS$(BDID) += $(addprefix $(BD_OBJDIR$(BDID))/dummyinc/,$(BD_GENINCS$(BDID)))
endif
BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_DFILE_DEPS$(BDID) += $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake) : $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) $(BD_GENFILES$(BDID))

#MM
%(mmake)-clean :
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(addsuffix .c,$(BD_STARTFILE$(BDID)) $(BD_ENDFILE$(BDID))) \
	    $(BD_STARTOBJ$(BDID)) $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

ifeq ($(TARGET),%(mmake)) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_ref     basename=% targetdir=$(BD_OBJDIR$(BDID)) cflags="-I$(BD_OBJDIR$(BDID))/dummyinc $(strip $(BD_CFLAGS$(BDID)))"
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_start targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end   targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
endif

# Some include files need to be generated before the .c can be parsed.
ifeq ($(TARGET),%(mmake)) # Only for this target these deps are wanted
$(BD_REFFILES$(BDID)) : $(BD_REFFILE_DEPS$(BDID))
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
%rule_genmodule modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		objdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID)) \
		reffile=$(BD_REFFILE$(BDID))

%rule_genmodule_dummy modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		      targetdir=$(BD_OBJDIR$(BDID))/dummyinc conffile=$(BD_CONFFILE$(BDID))

%rule_genlibdefs modname=$(BD_MODNAME$(BDID)) modtype=$(BD_MODTYPE$(BDID)) \
		 targetdir=$(BD_OBJDIR$(BDID)) conffile=$(BD_CONFFILE$(BDID))

$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(BD_LIBDEFSINC$(BDID))\"" >$@

# The module ref file is the joint of all individual .ref files
%rule_join from=$(BD_REFFILES$(BDID)) to=$(BD_REFFILE$(BDID)) \
	   text="Collecting function references for module $(BD_MODNAME$(BDID))"

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_STARTOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)"

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(INCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/defines/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/inline/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/inline/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/proto/$(BD_MODNAME$(BDID)).h
endif

# For a shared library also build a static link lib
ifeq ($(BD_MODTYPE$(BDID)),library)
%rule_link_linklib libname=%(linklibname) objs=$(BD_LINKLIBOBJS$(BDID))
endif

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_OBJDIR$(BDID))/dummyinc/defines $(BD_OBJDIR$(BDID))/dummyinc/proto $(BD_OBJDIR$(BDID))/dummyinc/clib $(BD_MODDIR$(BDID))" \
	       setuptarget=setup-module$(BDID)

%include_deps depstargets=%(mmake) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module using the deprecated macro's to define the functions in the
# library. Explanation of this macro is done in the developer's manual
%define build_module_macro mmake=/A modname=/A modtype=/A \
  conffile=$(BD_MODNAME$(BDID)).conf initfile=$(BD_MODNAME$(BDID))_init \
  funcs= files= archfile= linklibfiles= cflags=$(CFLAGS) dflags= \
  objdir=$(OBJDIR) linklibname=$(BD_MODNAME$(BDID)) uselibs= usecpak=$(USE_CPAK) \
  genshlinklib=no

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-includes %(mmake)-linklib"

.PHONY : setup-module$(BDID)

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_INITFILE$(BDID)   := %(initfile)
BD_FUNCS$(BDID)      := %(funcs)
BD_FILES$(BDID)      := %(files)
BD_ARCHFILE$(BDID)   := %(archfile)
BD_LIBFILES$(BDID)   := %(linklibfiles)
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end
else
BD_ENDFILE$(BDID)    := 
endif

BD_FUNCSRCS$(BDID)   := $(addsuffix .c,$(BD_FUNCS$(BDID)))
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_INITOBJ$(BDID)    := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_INITFILE$(BDID)))))
USE_CPAK             ?= $(USE_CPAK_DEFAULT)

TMP_FILES            := $(notdir $(BD_FILES$(BDID)))
ifneq ($(BD_ARCHFILE$(BDID)),)
  TMP_FILES        += functions
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifeq (%(usecpak), yes)
      TMP_FILES      += functions
    else
      TMP_FILES      += $(BD_FUNCS$(BDID))
    endif
  endif
endif
ifneq ($(strip $(BD_ARCHFILE$(BDID)) $(BD_FUNCS$(BDID))),)
  TMP_FILES          := functable $(TMP_FILES)
endif
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_FILES)))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID)))

ifeq ($(BD_FUNCS$(BDID)),)
  ifeq ($(BD_ARCHFILE$(BDID)),)
    BD_GENINCS$(BDID)  :=
  else
    BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
  endif    
else
  ifneq ($(findstring $(BD_MODTYPE$(BDID)),library gadget device),)
    BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
  endif
endif
# Only generate libdefs.h if the config file exists
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
  BD_LIBDEFSINC$(BDID):= $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h
else
  BD_LIBDEFSINC$(BDID):=
endif

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
#Add extra flag if shared AROS C library is used
ifneq ($(strip $(filter arosc_shared,%(uselibs))),)
BD_CFLAGS$(BDID)     += -D_CLIB_LIBRARY_ -I$(TOP)/rom/exec
endif
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library gadget datatype handler device),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODTYPE$(BDID)),library)
  BD_MODDIR$(BDID)  := $(AROS_LIBS)
endif
ifeq ($(BD_MODTYPE$(BDID)),gadget)
  BD_MODDIR$(BDID)  := $(AROS_GADGETS)
endif
ifeq ($(BD_MODTYPE$(BDID)),datatype)
  BD_MODDIR$(BDID)  := $(AROS_DATATYPES)
endif
ifeq ($(BD_MODTYPE$(BDID)),handler)
  BD_MODDIR$(BDID)  := $(AROS_FS)
endif
ifeq ($(BD_MODTYPE$(BDID)),device)
  BD_MODDIR$(BDID)  := $(AROS_DEVS)
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

#MM %(mmake) : %(mmake)-setup
#MM %(mmake)-includes : %(mmake)-setup

TMP_DEPS := $(BD_GENFILES$(BDID))
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

#MM %(mmake) : setup-clib

%(mmake) : $(TMP_DEPS)

#MM
%(mmake)-clean :
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) $(BD_REFFILE$(BDID)) \
	    $(BD_REFFILES$(BDID))\
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LINKLIBFILES$(BDID)) $(BD_LINKLIBOBJS$(BDID)) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(BD_ENDFILE$(BDID)).c $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

#MM- includes-generate : %(mmake)-includes
#MM- includes-copy : %(mmake)-includes
#MM %(mmake)-includes : %(mmake)-includes-libdefs setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-includes : $(TMP_DEPS)
  

#MM
%(mmake)-includes-libdefs : $(BD_LIBDEFSINC$(BDID))

ifneq ($(findstring $(TARGET),%(mmake) %(mmake)-linklib),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FUNCS$(BDID)) $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_compile basename=$(BD_ENDFILE$(BDID)) targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_compile basename=$(BD_OBJDIR$(BDID))/functable targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_compile basename=$(BD_OBJDIR$(BDID))/functions targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
endif

BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h

# Some include files need to be generated before the .c can be parsed.
ifeq ($(TARGET),%(mmake)) # Only for this target these deps are wanted
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(notdir $(BD_LIBDEFSINC$(BDID)))\"" >$@

%libdefs_rule conffile=$(BD_CONFFILE$(BDID)) dest=$(BD_LIBDEFSINC$(BDID))

$(BD_ENDFILE$(BDID)).c :
	@$(ECHO) "generating $@"
	@$(ECHO) "#include <libcore/libtail.c>" >$@

%rule_module_collect files=$(BD_FUNCS$(BDID)) dir=$(BD_OBJDIR$(BDID)) \
  archfile=$(BD_ARCHFILE$(BDID))

%rule_genfunctable files=$(BD_FUNCS$(BDID)) dir=$(BD_OBJDIR$(BDID)) \
  libdefs=$(BD_LIBDEFSINC$(BDID)) archfile=$(BD_ARCHFILE$(BDID))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)"

ifeq ($(BD_ARCHFILE$(BDID)),)
BD_HEADER_DEPS$(BDID) := $(wildcard headers.tmpl) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_FUNCSRCS$(BDID)) \
	    $(SCRIPTDIR)/genshared $(SCRIPTDIR)/genclib.awk \
	    $(SCRIPTDIR)/gendefines.awk $(SCRIPTDIR)/geninline.awk

# Regenerate the includes when some of the dependencies are changed
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp : $(BD_HEADER_DEPS$(BDID))
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -defines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -inline -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $@

# Generate includes the first time they are needed
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h :
$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h :
$(GENINCDIR)/inline/$(BD_MODNAME$(BDID)).h :
$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h :
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -defines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -inline -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp
else
BD_HEADER_DEPS$(BDID) := $(wildcard headers.tmpl) $(BD_LIBDEFSINC$(BDID))

$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp : $(BD_HEADER_DEPS$(BDID))
	@$(ARCHTOOL) -I $(GENINCDIR) $(BD_ARCHFILE$(BDID))
	$(TOUCH) $@

$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h \
$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h \
$(GENINCDIR)/inline/$(BD_MODNAME$(BDID)).h \
$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h :
	@$(ARCHTOOL) -I $(GENINCDIR) $(BD_ARCHFILE$(BDID))
	$(TOUCH) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp
endif

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(INCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/defines/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/inline/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/inline/$(BD_MODNAME$(BDID)).h
#%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(INCDIR)/proto/$(BD_MODNAME$(BDID)).h

MYDIRS$(BDID) := $(BD_OBJDIR$(BDID)) $(GENINCDIR) $(GENINCDIR)/clib \
  $(GENINCDIR)/proto $(GENINCDIR)/defines $(GENINCDIR)/inline \
  $(GENINCDIR)/pragmas $(INCDIR) $(INCDIR)/clib $(INCDIR)/proto \
  $(INCDIR)/defines $(INCDIR)/inline $(INCDIR)/pragmas \
  $(BD_MODDIR$(BDID))

%rule_makedirs dirs=$(MYDIRS$(BDID)) setuptarget=setup-module$(BDID)

# %(mmake)-linklib is a real big mess (bigger then the rest) but it has
# to disappear in the so don't try to hard
#MM %(mmake)-linklib : %(mmake)-setup setup-clib

TMP_DEPS :=
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(INCDIR)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-linklib : $(TMP_DEPS)

# Link only when target %(mmake)-linklib otherwise for example jpeg.datatype
# that depend on the jpeg library can cause to get this rule executed unwanted
ifeq ($(TARGET),%(mmake)-linklib)
ifneq (%(genshlinklib),yes)
%(mmake)-linklib : $(LIBDIR)/lib$(BD_MODNAME$(BDID)).a
else
%(mmake)-linklib : $(LIBDIR)/lib$(BD_MODNAME$(BDID)).so
endif

%rule_link_linklib libname=$(BD_MODNAME$(BDID)) libdir=$(LIBDIR) \
  objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))"

BD_SHOBJS$(BDID) := $(patsubst %.o,%.so,$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID)))

%rule_compile_shared basename=% targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID)) 
%rule_compile_shared basename=$(BD_ENDFILE$(BDID)) targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID))
%rule_compile_shared basename=$(BD_OBJDIR$(BDID))/functable targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID))
%rule_compile_shared basename=$(BD_OBJDIR$(BDID))/functions targetdir=$(BD_OBJDIR$(BDID)) cflags=$(BD_CFLAGS$(BDID))

%rule_link_shlib libname=$(BD_MODNAME$(BDID)) libdir=$(LIBDIR) \
  objs=$(BD_SHOBJS$(BDID))

endif

%include_deps depstargets="%(mmake) %(mmake)-linklib deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given with the .s suffix
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags use during makedepend (default equal to cflags)
# - aflags are the flags use during assembling (default $(AFLAGS))
# - objdir is where the .o are generated
# - libdir is the directory where the linklib will be placed (default $(LIBDIR))
%define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c))" \
  asmfiles= cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) objdir=$(OBJDIR) libdir=$(LIBDIR)

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

# assign and generate the local variables used in this macro
BD_LIBNAME$(BDID)    := %(libname)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)
BD_LIBDIR$(BDID)     := %(libdir)

BD_FILES$(BDID)      := %(files)
BD_ASMFILES$(BDID)   := %(asmfiles)
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID)))))
BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)))

BD_CFLAGS$(BDID)     := %(cflags)
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags)
endif
BD_AFLAGS$(BDID)     := %(aflags)

BD_LINKLIB$(BDID)    := $(BD_LIBDIR$(BDID))/lib$(BD_LIBNAME$(BDID)).a

.PHONY : setup-linklib$(BDID)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_LINKLIB$(BDID))

#MM
%(mmake)-setup : setup-linklib$(BDID)

#MM
%(mmake)-clean :
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID))

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_LIBDIR$(BDID))" \
	       setuptarget=setup-linklib$(BDID)

ifeq ($(TARGET),%(mmake))
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))
endif

%rule_link_linklib libname=%(libname) objs=$(BD_OBJS$(BDID)) libdir=$(BD_LIBDIR$(BDID))

%include_deps depstargets=%(mmake) deps=$(BD_DEPS$(BDID))
%end

#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd) (default *.cd)
# - subdir is the destination subdir of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - include is the path to the generated include file 
# - dir is the base destination directory (default $(AROS_CATALOGS))

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs="$(basename $(wildcard *.ct))" include="../strings.h" \
 description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS)

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_SRCS$(BDID) := $(foreach name, %(catalogs), $(name).ct)
BD_OBJS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir)/%(name).catalog)
BD_DIRS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir))

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID)) %(include)

#MM %(mmake)-setup
%rule_makedirs dirs=$(BD_DIRS$(BDID)) setuptarget=%(mmake)-setup

%(dir)/%/%(subdir)/%(name).catalog : %.ct %(description).cd
	@$(ECHO) "Creating %(name) catalog for language $*."
	@$(IF) $(FLEXCAT) %(description).cd $*.ct CATALOG=%(dir)/$*/%(subdir)/%(name).catalog ; then $(NOP) ; else $(NOP) ; fi ;

%(include) : %(description).cd
	@$(ECHO) "Creating %(name) catalog include file %(include)"
	@$(FLEXCAT) %(description).cd %(include)=$(TOOLDIR)/C_h_orig.sd

#MM
%(mmake)-clean :
	$(RM) $(BD_OBJS$(BDID)) %(include)

%end

#-----------------------------------------------------------------------------







# ======================
# Old stuff, will probably be removed in the future




# GNU Make automatic variables
# $@ current target
# $< First dependency
# $? All newer dependencies
# $^ All dependencies
# $* The stem (ie. target is dir/a.foo.b and the pattern is
#    a.%.b, then the stem is dir/foo)

#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#------------------------------------------------------------------------------
# Same, more noisy
%define mkdirs dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#------------------------------------------------------------------------------
%define link_q cmd=$(CC) opt=$(LDFLAGS) startup=$(STARTUP) from=$< to=$@ libs=$(LIBS) end=$()
	@$(ECHO) "Linking %(to)..."
	@$(IF) %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) $(COMPILER_LIBS) %(end) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "%(to): %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) %(end)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	   	else \
			$(NOP) ; \
    		fi ; \
	else \
	    $(ECHO) "Link failed: %(cmd) %(opt) %(startup) %(from) -o %(to) %(libs) %(end)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi; \
	$(STRIP) %(to)
%end

#------------------------------------------------------------------------------
%define checkuds us=$(GENDIR)/undefdsyms.list err=$(GENDIR)/errors to=$@ linkcmd=""
	@$(ECHO) "Checking %(to)..."
	@$(CHECKUDS) %(to) > %(us)
	@$(IF) $(TEST) -s %(us); then \
	    $(ECHO) "%(linkcmd)" >> %(err) ; \
	    $(ECHO) "There are undefined symbols in %(to):" 1>&2 ; \
	    tee < %(us) -a %(err) 1>&2 ; \
	    $(RM) %(to); \
	    exit 1 ; \
	else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
%define mklib_arch ar=$(AR) ranlib=$(RANLIB) to=$@ from="$(OBJS)" cmd=$(CC) opt=$(CFLAGS) archive=$(ARCHIVE)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
	@$(RM) $(RMLIB)

$(OBJDIR)/functions.o : $(OBJDIR)/functions.c
%compile_q opt="$(CFLAGS) -I$(OBJDIR)"

$(OBJDIR)/functions.c : mmakefile.src %(archive)
%mkdir_q $(OBJDIR)
	@$(ARCHTOOL) -s $@ %(archive)

$(OBJDIR)/functions.d : $(OBJDIR)/functions.c
%mkdepend_q flags="$(CFLAGS) -I$(OBJDIR)"
%end

#------------------------------------------------------------------------------
%define mklib_f ar=$(AR) ranlib=$(RANLIB) to=$@ from="$(OBJS)" cmd=$(CC) opt=$(CFLAGS) functions=$(FUNCTIONS) deplibs="$(DEPLIBS)"
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
	@$(RM) $(RMLIB)

$(OBJDIR)/functions.o : $(OBJDIR)/functions.c
%compile_q opt="$(CFLAGS) -I$(OBJDIR)"

$(OBJDIR)/functions.c : mmakefile.src $(foreach f,%(functions),$(f).c)
	@$(CPAK) %(functions)
%mkdir_q $(OBJDIR)
	@$(MV) functions.c functions.h $(OBJDIR)

$(OBJDIR)/functions.d : $(OBJDIR)/functions.c
%mkdepend_q flags="$(CFLAGS) -I$(OBJDIR)"
%end

#------------------------------------------------------------------------------
# Same but more noisy
%define mklib ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	%(ar) %(to) %(from)
	%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Same but more noisy
%define mkdepend flags=$(CFLAGS) from=$< to=$@ dir=$(@D) opt=
	@$(IF) [ ! -d %(dir) ]; then $(MKDIR) %(dir) ; else $(NOP) ; fi
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	$(MKDEPEND) %(flags) %(from) -o %(to)
%end

#------------------------------------------------------------------------------
# Add section with all necessary libs and dependencies for linking
%define define_libs prelibs=$(PRELIBS) postlibs= deplibs=
STARTUP = $(LIBDIR)/startup.o
LIBS = -L$(LIBDIR) %(prelibs) -larossupport -lamiga -larosc -lm -lautoinit %(postlibs) $(COMPILER_LIBS)
DEPLIBS = $(LIBDIR)/libamiga.a $(LIBDIR)/libarossupport.a $(STARTUP) \
	$(LIBDIR)/libarosc.a $(LIBDIR)/libm.a $(LIBDIR)/libautoinit.a %(deplibs)
%end

#------------------------------------------------------------------------------
# Do something in all subdirs
# This macro uses a trick: %(target) is evaluated *after* %(text), so one
# can use %(target) in %(text).
%define subdirs_q text="Making %(target)" target=$(TARGET) dirs=$(SUBDIRS) curdir=$(CURDIR) mflags=$(MFLAGS) submf=makefile top=$(TOP)
	@$(FOR) dir in %(dirs) ; do \
	    $(ECHO) "%(text) in %(curdir)/$$dir..." ; \
	    if $(TEST) -f $$dir/%(submf).src && \
		{ $(TEST) ! -f $$dir/%(submf) \
		-o $$dir/%(submf).src -nt $$dir/%(submf) \
		-o %(top)/config/make.tmpl -nt $$dir/%(submf) ; } ; then \
		$(ECHO) "Generating %(submf)..." ; \
		$(AWK) -f $(TOP)/scripts/genmf.gawk \
		-v TOP="$(TOP)" \
		$$dir/%(submf).src > $$dir/%(submf) || exit 1 ; \
	    fi ; \
	    if ( cd $$dir ; \
		$(MAKE) %(mflags) --file=%(submf) \
		    TOP="%(top)/.." CURDIR="%(curdir)/$$dir" \
		    TARGET=%(target) %(target) ) ; \
	    then $(NOP) ; else exit 1 ; fi ; \
	done
%end

#------------------------------------------------------------------------------
# Prepare creation of a shared lib
%define prepare_shlib lib=dummy shflag=$(SHARED_DUMMY) lib_suffix=$(HOST_LIB_SUFFIX)
ifeq ("%(shflag)","yes")
LIB    := $(LIBDIR)/lib%(lib).so%(lib_suffix)
RMLIB  := $(LIBDIR)/lib%(lib).a
AR     := $(SHARED_LD) $(SHARED_LDFLAGS) -o
RANLIB := $(NOP)
else
LIB    := $(LIBDIR)/lib%(lib).a
RMLIB  := $(LIBDIR)/lib%(lib).so%(lib_suffix)
endif
%end

#------------------------------------------------------------------------------
# Compile function table
%define compilefunctable
$(OBJDIR)/functable.d : $(OBJDIR)/functable.c
%mkdepend_q flags="$(CFLAGS) -I."

$(OBJDIR)/functable.o : $(OBJDIR)/functable.c
%compile_q opt="$(CFLAGS) -I$(OBJDIR) -I."
%end

#------------------------------------------------------------------------------
# Generate function table with archtool
%define mkfunctable_arch archive=$(ARCHIVE)
$(OBJDIR)/functable.c : mmakefile.src %(archive) libdefs.h
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(ARCHTOOL) -t %(archive)
	@$(MV) functable.c $@

%compilefunctable
%end

#------------------------------------------------------------------------------
# Generate function table with some awk script
%define mkfunctable_q
$(OBJDIR)/functable.c : mmakefile.src $(FUNCTABLE_SRCS) $(BINDIR)/scripts/genfunctable.awk libdefs.h
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(AWK) -f $(BINDIR)/scripts/genfunctable.awk $(FUNCTABLE_SRCS) > $@

%compilefunctable
%end

#------------------------------------------------------------------------------
# Generate endskip variable
%define mkendtag_q
$(END_FILE).c : libdefs.h
	%mkdir_q $(OBJDIR)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(ECHO) "#include <libcore/libtail.c>" > $@

$(ENDFUNC) : $(END_FILE).c libdefs.h
%compile_q

$(END_FILE).d : $(END_FILE).c
%mkdepend_q flags="$(MKDEPEND_CFLAGS) -I."
%end

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(TOP)/config/make.tail

BDID := $(BDTARGETID)
%end

#------------------------------------------------------------------------------
# rule to generate libdefs.h with archtool (options may go away!)
%define libdefs_rule conffile=lib.conf genlibdefstool=$(ARCHTOOL) dest=libdefs.h
%(dest) : %(conffile) %(genlibdefstool)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@%(genlibdefstool) -c -o $@ %(conffile)
%end


#------------------------------------------------------------------------------
# rule to generate asm files from c files (for debugging purposes)
%define asm_rule opt=$(GENASM)
.PHONY : asm
asm : $(foreach f,%(opt),$(f).s) all
%end

#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) -S $(CFLAGS) $< -c -o $@
%end

#------------------------------------------------------------------------------
%define gennames name=$(LIBNAME)
%end

#------------------------------------------------------------------------------
%define genlib flags=$(CFLAGS) cc=$(CC)
ifndef SLIB
SLIB := $(SLIBDIR)/$(LIBNAME).library
endif
ifndef LIB
LIB := $(LIBDIR)/lib$(LIBNAME).a
endif
ifndef OBJDIR
OBJDIR := $(GENDIR)/$(CURDIR)
endif
ifndef INIT_FILE
INIT_FILE := $(LIBNAME)_init
endif
ifndef END_FILE
END_FILE := $(OBJDIR)/endtag
endif
ifndef INITFUNC
INITFUNC := $(OBJDIR)/$(INIT_FILE).o
endif
ifndef ENDFUNC
ENDFUNC := $(END_FILE).o
endif
SYS_FILES := $(SYS_FILES) $(INIT_FILE) functable
ifndef OBJS
OBJS := $(foreach f,$(FILES) $(FUNCTIONS) $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
endif
SYS_OBJS := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)

$(SLIB) : $(LIB) $(DEPLIBS) $(EXTRA_DEPLIBS) $(OBJS) $(SYS_OBJS) $(ENDFUNC)
	@$(ECHO) "Building $(notdir $@) ..."
	@$(CC) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(LIBNAME)lib.map $(SYS_OBJS) $(EXTRA_LIBS) $(LIBS) $(COMPILER_LIBS) $(ENDFUNC) -o $@ 2>&1|tee $(LIBNAME)lib.err
	@$(IF) $(TEST) ! -s $(LIBNAME)lib.err; then $(RM) $(LIBNAME)lib.err ; else $(NOP) ; fi
	@$(STRIP) $@

# Collect all functions in a linklib for fast linking:
$(LIB) : $(OBJS)
	@$(ECHO) "Adding functions to $(notdir $@) ..."
	@$(AR) $@ $?
	@$(RANLIB) $@

setup :
	@$(FOR) dir in $(OBJDIR) $(LIBDIR) $(SLIBDIR) $(DESTDIRS) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done

clean ::
	$(RM) $(OBJDIR) *.err libdefs.h $(EXTRA_CLEAN) \
	    $(LIB) $(SLIB)

$(OBJDIR)/%.o : %.c
%compile_q cmd=%(cc) opt=%(flags)

%libdefs_rule

FUNCTABLE_SRCS := $(foreach f,$(FUNCTIONS),$(f).c)

%mkfunctable_q

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

ifneq (,$(ADDITIONAL_OBJS))
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) "Error: The precompiled object $@ did not exist."
	@exit 1
endif

$(OBJDIR)/%.d : %.c
%mkdepend_q
%end

#------------------------------------------------------------------------------
%define genromlib flags=$(CFLAGS) cc=$(CC)
ifndef INIT_FILE
INIT_FILE := $(LIBNAME)_init
endif
ifndef END_FILE
END_FILE := $(OBJDIR)/endtag
endif
ifndef OBJDIR
OBJDIR := $(GENDIR)/$(CURDIR)
endif
ifndef INITFUNC
INITFUNC := $(OBJDIR)/$(INIT_FILE).o
endif
ifndef ENDFUNC
ENDFUNC := $(END_FILE).o
endif
ifndef OSMODULE
OSMODULE := $(LIBNAME).library
endif
SYS_FILES := $(SYS_FILES) $(INIT_FILE) functable
ifndef OBJS
OBJS := $(foreach f,$(FILES) $(FUNCTIONS) $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
endif
SYS_OBJS := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)
ifndef DEPLIBS
DEPLIBS :=
endif
ifndef DEPS
DEPS := $(foreach f,$(INIT_FILE) $(FILES) $(FUNCTIONS) $(notdir $(END_FILE)),$(OBJDIR)/$(f).d)
endif
ALL_OBJS := $(SYS_OBJS) $(OBJS) $(ENDFUNC)

$(OSMODDIR)/$(OSMODULE) : $(LIB) $(INITFUNC) \
	    $(foreach f,$(DEPLIBS), $(LIBDIR)/lib$(f).a)
	@$(ECHO) "Building $(notdir $@) ..."
	@$(CC) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(OSMODULE).map -L$(LIBDIR) \
	    $(INITFUNC) $(LIB) $(foreach f, $(DEPLIBS), -l$(f)) $(COMPILER_LIBS) \
	    -o $@ 2>&1 | tee $(OSMODULE).err
	@if $(TEST) ! -s $(OSMODULE).err; then rm $(OSMODULE).err ; else $(NOP); fi
	@$(STRIP) $@

# Collect all functions in a linklib for fast linking
$(LIB) : $(ALL_OBJS)
	@$(ECHO) "Creating library $@..."
	@$(AR) $@ $(ALL_OBJS)
	@$(RANLIB) $@

setup :
	@$(FOR) dir in $(OBJDIR) $(LIBDIR) $(OSMODDIR) $(DESTDIRS) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done

clean ::
	$(RM) $(OBJDIR) *.err libdefs.h $(EXTRA_CLEAN) \
	    $(LIB) $(SLIB)

$(OBJDIR)/%.o : %.c
%compile_q cmd=%(cc) opt=%(flags)

%libdefs_rule

ifndef FUNCTABLE_SRCS
FUNCTABLE_SRCS := $(foreach f,$(ALL_FUNCTIONS),$(f).c)
endif

%mkfunctable_q

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

ifneq (,$(ADDITIONAL_OBJS))
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) "Error: The precompiled object $@ did not exist."
	@exit 1
endif

$(OBJDIR)/%.d : %.c
%mkdepend_q
%end

#------------------------------------------------------------------------------
# version of genromlib that allows you to use archtools
%define genromlib_arch flags=$(CFLAGS) cc=$(CC) files=$(FILES) archive=$(ARCHIVE)
ifndef OBJDIR
OBJDIR := $(GENDIR)/$(CURDIR)
endif
ifndef INIT_FILE
INIT_FILE := $(LIBNAME)_init
endif
ifndef END_FILE
END_FILE := $(OBJDIR)/endtag
endif
ifndef INITFUNC
INITFUNC := $(OBJDIR)/$(INIT_FILE).o
endif
ifndef ENDFUNC
ENDFUNC := $(END_FILE).o
endif
ifndef OSMODULE
OSMODULE := $(LIBNAME).library
endif
ifndef NO_FUNCTABLE
SYS_FILES := $(SYS_FILES) $(INIT_FILE) functable
else
SYS_FILES := $(SYS_FILES) $(INIT_FILE)
endif
ifndef OBJS
OBJS := $(foreach f,%(files) $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
endif
SYS_OBJS := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)
ifndef DEPLIBS
DEPLIBS :=
endif
ifndef DEPS
DEPS := $(foreach f,$(INIT_FILE) functions $(FILES) $(notdir $(END_FILE)),$(OBJDIR)/$(f).d)
endif
ALL_OBJS := $(SYS_OBJS) $(OBJS) $(OBJDIR)/functions.o $(ENDFUNC)

$(OSMODDIR)/$(OSMODULE) : $(LIB) $(INITFUNC) \
	    $(foreach f,$(DEPLIBS), $(LIBDIR)/lib$(f).a)
	@$(ECHO) "Building $(notdir $@) ..."
	@%(cc) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(OSMODULE).map -L$(LIBDIR) \
	    $(INITFUNC) $(LIB) $(foreach f, $(DEPLIBS), -l$(f)) $(COMPILER_LIBS) \
	    -o $@ 2>&1 | tee $(OSMODULE).err
	@if $(TEST) ! -s $(OSMODULE).err; then rm $(OSMODULE).err ; else $(NOP); fi
	@$(STRIP) $@

setup :
%mkdirs_q $(OBJDIR) $(LIBDIR) $(OSMODDIR) $(DESTDIRS)

clean ::
	$(RM) $(OBJDIR) *.err libdefs.h $(EXTRA_CLEAN) $(LIB) $(OSMODDIR)/$(OSMODULE)

# Collect all functions in a linklib for fast linking
$(LIB) : $(ALL_OBJS)
%mklib_arch from=$(ALL_OBJS) archive=%(archive)

$(OBJDIR)/%.o : %.c
%compile_q

%libdefs_rule

ifndef NO_FUNCTABLE
%mkfunctable_arch archive=%(archive)
endif

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

ifneq (,$(ADDITIONAL_OBJS))
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) "Error: The precompiled object $@ did not exist."
	@exit 1
endif

$(OBJDIR)/%.d : %.c
%mkdepend_q

# Generate include files
%genlibincludes_arch

%end

#------------------------------------------------------------------------------
# version of genromlib that allows you to use cpak and generates inline
%define genromlib_finline flags=$(CFLAGS) cc=$(CC) files=$(FILES) functions=$(FUNCTIONS) hasrt=
ifndef INIT_FILE
INIT_FILE := $(LIBNAME)_init
endif
ifndef END_FILE
END_FILE := $(OBJDIR)/endtag
endif
ifndef OBJDIR
OBJDIR := $(GENDIR)/$(CURDIR)
endif
ifndef INITFUNC
INITFUNC := $(OBJDIR)/$(INIT_FILE).o
endif
ifndef ENDFUNC
ENDFUNC := $(END_FILE).o
endif
ifndef OSMODULE
OSMODULE := $(LIBNAME).library
endif
ifndef NO_FUNCTABLE
SYS_FILES := $(SYS_FILES) $(INIT_FILE) functable
else
SYS_FILES := $(SYS_FILES) $(INIT_FILE)
endif
ifndef OBJS
OBJS := $(foreach f,%(files) $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
endif
SYS_OBJS := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)
ifndef DEPLIBS
DEPLIBS :=
endif
ifndef DEPS
DEPS := $(foreach f,$(INIT_FILE) functions $(FILES) $(notdir $(END_FILE)),$(OBJDIR)/$(f).d)
endif
ALL_OBJS := $(SYS_OBJS) $(OBJS) $(OBJDIR)/functions.o $(ENDFUNC)

$(OSMODDIR)/$(OSMODULE) : $(LIB) $(INITFUNC) \
	    $(foreach f,$(DEPLIBS), $(LIBDIR)/lib$(f).a)
	@$(ECHO) "Building $(notdir $@) ..."
	@%(cc) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(OSMODULE).map -L$(LIBDIR) \
	    $(INITFUNC) $(LIB) $(foreach f, $(DEPLIBS), -l$(f)) $(COMPILER_LIBS) \
	    -o $@ 2>&1 | tee $(OSMODULE).err
	@if $(TEST) ! -s $(OSMODULE).err; then rm $(OSMODULE).err ; else $(NOP); fi
	@$(STRIP) $@

setup ::
%mkdirs_q $(OBJDIR) $(LIBDIR) $(OSMODDIR) $(DESTDIRS)

clean ::
	$(RM) $(OBJDIR) *.err libdefs.h $(EXTRA_CLEAN) \
	    $(LIB) $(OSMODDIR)/$(OSMODULE)

# Collect all functions in a linklib for fast linking
$(LIB) : $(ALL_OBJS)
%mklib_f from=$(ALL_OBJS) functions=%(functions)

$(OBJDIR)/%.o : %.c
%compile_q

$(OBJDIR)/%.o : $(OBJDIR)/%.c
%compile_q opt="$(CFLAGS) -I$(OBJDIR)"

%libdefs_rule

ifndef NO_FUNCTABLE
ifndef FUNCTABLE_SRCS
FUNCTABLE_SRCS := $(foreach f,$(ALL_FUNCTIONS),$(f).c)
endif

%mkfunctable_q
endif

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

ifneq (,$(ADDITIONAL_OBJS))
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) "Error: The precompiled object $@ did not exist."
	@exit 1
endif

$(OBJDIR)/%.d : %.c
%mkdepend_q

# Generate include files
%genlibincludesinline hasrt=%(hasrt)

%end

#------------------------------------------------------------------------------
%define genlibincludes name=$(LIBNAME) functions=$(ALL_FUNCTIONS)
#MM includes-generate : setup-clib
includes-generate :: setup includes-setup $(OBJDIR)/headers.stamp \
            $(INCDIR)/clib/%(name)_protos.h \
            $(INCDIR)/defines/%(name).h
	@$(NOP)

_MOD_INCL_DIRS :=   $(foreach i,clib defines inline pragmas proto,$(INCDIR)/$(i)) \
                    $(foreach i,clib defines inline pragmas proto,$(GENINCDIR)/$(i))

includes-setup : $(_MOD_INCL_DIRS)

$(_MOD_INCL_DIRS) :
	%mkdir_q $@

FSRCS := $(foreach f,%(functions),$(f).c)

$(OBJDIR)/headers.stamp : mmakefile.src $(wildcard headers.tmpl) libdefs.h \
            $(FSRCS) \
            $(SCRIPTDIR)/genshared \
            $(SCRIPTDIR)/genclib.awk $(SCRIPTDIR)/gendefines.awk
	@$(SCRIPTDIR)/genshared -clib -prefix $(GENINCDIR) $(FSRCS)
	@$(SCRIPTDIR)/genshared -defines -prefix $(GENINCDIR) $(FSRCS)
	@$(TOUCH) $@

$(INCDIR)/clib/%(name)_protos.h : $(GENINCDIR)/clib/%(name)_protos.h
	@$(CP) $< $@

$(INCDIR)/defines/%(name).h : $(GENINCDIR)/defines/%(name).h
	@$(CP) $< $@
%end

#------------------------------------------------------------------------------
%define genlibincludes_arch name=$(LIBNAME) archive=$(ARCHIVE)
#MM includes-generate : setup-clib
includes-generate :: setup includes-setup $(OBJDIR)/headers.stamp \
            $(INCDIR)/pragmas/%(name)_pragmas.h \
            $(INCDIR)/clib/%(name)_protos.h \
            $(INCDIR)/defines/%(name).h \
            $(INCDIR)/inline/%(name).h \
            $(INCDIR)/proto/%(name).h
	@$(NOP)

_MOD_INCL_DIRS :=   $(foreach i,clib defines inline pragmas proto,$(INCDIR)/$(i)) \
                    $(foreach i,clib defines inline pragmas proto,$(GENINCDIR)/$(i))

includes-setup : $(_MOD_INCL_DIRS)

$(_MOD_INCL_DIRS) :
	%mkdir_q $@

_HEADER_DEPS := mmakefile.src $(wildcard headers.tmpl) libdefs.h %(archive)
$(OBJDIR)/headers.stamp : $(GENINCDIR)/pragmas/%(name)_pragmas.h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h
	@$(TOUCH) $@

$(GENINCDIR)/pragmas/%(name)_pragmas.h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h :
	@$(ARCHTOOL) -I $(GENINCDIR) %(archive)

$(INCDIR)/pragmas/%(name)_pragmas.h : $(GENINCDIR)/pragmas/%(name)_pragmas.h
	@$(CP) $< $@

$(INCDIR)/clib/%(name)_protos.h : $(GENINCDIR)/clib/%(name)_protos.h
	@$(CP) $< $@

$(INCDIR)/defines/%(name).h : $(GENINCDIR)/defines/%(name).h
	@$(CP) $< $@

$(INCDIR)/inline/%(name).h : $(GENINCDIR)/inline/%(name).h
	@$(CP) $< $@

$(INCDIR)/proto/%(name).h : $(GENINCDIR)/proto/%(name).h
	@$(CP) $< $@
%end



#------------------------------------------------------------------------------
%define genlibincludesinline name=$(LIBNAME) functions=$(ALL_FUNCTIONS) hasrt=
#MM includes-generate : setup-clib
includes-generate :: setup includes-setup $(OBJDIR)/headers.stamp \
            $(INCDIR)/clib/%(name)_protos.h \
            $(INCDIR)/defines/%(name).h \
            $(INCDIR)/inline/%(name).h \
            $(INCDIR)/proto/%(name).h
	@$(NOP)

_MOD_INCL_DIRS :=   $(foreach i,clib defines inline pragmas proto,$(INCDIR)/$(i)) \
                    $(foreach i,clib defines inline pragmas proto,$(GENINCDIR)/$(i))

includes-setup : $(_MOD_INCL_DIRS)

$(_MOD_INCL_DIRS) :
	%mkdir_q $@


FSRCS := $(foreach f,%(functions),$(f).c)

_HEADER_DEPS := mmakefile.src $(wildcard headers.tmpl) libdefs.h \
            $(FSRCS) \
            $(SCRIPTDIR)/genshared \
            $(SCRIPTDIR)/genclib.awk $(SCRIPTDIR)/gendefines.awk \
            $(SCRIPTDIR)/geninline.awk

$(OBJDIR)/headers.stamp : $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h
	@$(TOUCH) $@

$(GENINCDIR)/clib/%(name)_protos.h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -clib %(hasrt) -prefix $(GENINCDIR) $(FSRCS)

$(GENINCDIR)/defines/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -defines %(hasrt) -prefix $(GENINCDIR) $(FSRCS)

$(GENINCDIR)/inline/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -inline %(hasrt) -prefix $(GENINCDIR) $(FSRCS)

$(GENINCDIR)/proto/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -proto %(hasrt) -prefix $(GENINCDIR) $(FSRCS)

$(INCDIR)/clib/%(name)_protos.h : $(GENINCDIR)/clib/%(name)_protos.h
	@$(CP) $< $@

$(INCDIR)/defines/%(name).h : $(GENINCDIR)/defines/%(name).h
	@$(CP) $< $@

$(INCDIR)/inline/%(name).h : $(GENINCDIR)/inline/%(name).h
	@$(CP) $< $@

$(INCDIR)/proto/%(name).h : $(GENINCDIR)/proto/%(name).h
	@$(CP) $< $@

%end

#------------------------------------------------------------------------------
# Used to help with the function replacement mechanism. Use like
#
#	%prepare_replace module=os/exec
#
# This will include the file contain information written out by the
# $(TOP)/config makefiles which is used to filter out files that are
# being replaced by machine dependant versions in the $(TOP)/config
# subtree.
#
# You can also determine which group of files you wish to filter against
# with the filter command. You pass it the variable to modify as var
#
# Eg:
#	%prepare_replace module=os/foobar
#	%filter_replace $(FUNCTIONS)
#
# The variable $(ADDITIONAL_OBJS) will be available for you to link in
# extra files.
#
# You should save the values of the variables which you filter in case
# you need them at a later date.
#
%define prepare_replace module=
-include $(GENDIR)/%(module)/mf.inc
%end

#------------------------------------------------------------------------------
%define filter_replace var=FILES filter=$(SUPPRESS_FILES)
%(var) := $(filter-out %(filter),$(%(var)))
%end

#------------------------------------------------------------------------------
# You can use this to prevent objects which weren't compiled correctly by
# config/$(...) directories to not be compiled by the local makefile.
%define additional_objs_rule
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) Error: One of the precompiled object files did not exist.
	@exit 1
%end

#------------------------------------------------------------------------------
%define add_objects files=/M
	@$(FOR) file in %(files) ; do \
	    $(ECHO) >> $(GENDIR)/config.files "add $$file" ; \
	done
%end

#------------------------------------------------------------------------------
%define exclude_files files=/M
	@$(FOR) file in %(files) ; do \
	    $(ECHO) >> $(GENDIR)/config.files "not $$file" ; \
	done
%end

#------------------------------------------------------------------------------
%define genlib_arch
ifndef BASENAME
  BASENAME := $(ULIBNAME)
endif

SLIB	      := $(SLIBDIR)/$(LIBNAME).library
LIB	      := $(LIBDIR)/lib$(LIBNAME).a
INIT_FILE     := $(LIBNAME)_init
END_FILE      := $(OBJDIR)/endtag
OBJDIR        := $(GENDIR)/$(CURDIR)
INITFUNC      := $(OBJDIR)/$(INIT_FILE).o
ENDFUNC       := $(END_FILE).o
SYS_FILES     := $(SYS_FILES) $(INIT_FILE) functable
OBJS	      := $(foreach f,$(FILES) functions $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
SYS_OBJS      := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)

$(SLIB) : $(LIB) $(DEPLIBS) $(EXTRA_DEPLIBS) $(OBJS) $(SYS_OBJS) $(ENDFUNC)
	@$(ECHO) "Building $(notdir $@) ..."
	@$(CC) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(LIBNAME)lib.map $(OBJS) $(SYS_OBJS) $(EXTRA_LIBS) $(LIBS) $(COMPILER_LIBS) $(ENDFUNC) -o $@ 2>&1|tee $(LIBNAME)lib.err
	@$(IF) $(TEST) ! -s $(LIBNAME)lib.err; then $(RM) $(LIBNAME)lib.err ; else $(NOP) ; fi
	@$(STRIP) $@

$(LIB) : $(OBJS)
	@$(ECHO) "Adding functions to $(notdir $@) ..."
	@$(AR) $@ $(OBJS)
	@$(RANLIB) $@

$(OBJDIR)/functions.o : $(OBJDIR)/functions.c
%compile_q

$(OBJDIR)/functions.c : mmakefile.src $(ARCHIVE)
	@$(ARCHTOOL) -s $@ $(ARCHIVE)

$(OBJDIR)/functions.d : $(OBJDIR)/functions.c
%mkdepend_q flags="$(CFLAGS) -I$(OBJDIR)"

ALL_FUNCTIONS := $(FUNCTIONS)
%genlibincludes_arch

$(OBJDIR)/%.o : %.c
%compile_q

%mkfunctable_arch

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

%libdefs_rule

%end

#------------------------------------------------------------------------------
%define genlib_cpak hasrt=
ifndef LIBPOST
  LIBPOST := library
endif
ifndef DESTDIR
  DESTDIR := $(SLIBDIR)
endif
ifndef BASENAME
  BASENAME := $(ULIBNAME)
endif

SLIB	      := $(DESTDIR)/$(LIBNAME).$(LIBPOST)
LIB	      := $(LIBDIR)/lib$(LIBNAME).a
OBJDIR	      := $(GENDIR)/$(CURDIR)
INIT_FILE     := $(LIBNAME)_init
END_FILE      := $(OBJDIR)/endtag
INITFUNC      := $(OBJDIR)/$(INIT_FILE).o
ENDFUNC       := $(END_FILE).o
SYS_FILES     := $(SYS_FILES) $(INIT_FILE) functable
OBJS	      := $(foreach f,$(FILES) functions $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
SYS_OBJS      := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)
DEPS          := $(DEPS) $(foreach f,$(INIT_FILE) functable functions $(FILES) $(notdir $(END_FILE)),$(OBJDIR)/$(f).d)

$(SLIB) : $(LIB) $(DEPLIBS) $(EXTRA_DEPLIBS) $(OBJS) $(SYS_OBJS) $(ENDFUNC)
	@$(ECHO) "Building $(notdir $@) ..."
	@$(CC) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(LIBNAME)lib.map $(SYS_OBJS) $(EXTRA_LIBS) $(LIBS) $(COMPILER_LIBS) $(ENDFUNC) -o $@ 2>&1|tee $(LIBNAME)lib.err
	@$(IF) $(TEST) ! -s $(LIBNAME)lib.err; then $(RM) $(LIBNAME)lib.err ; else $(NOP) ; fi
	@$(STRIP) $@

$(LIB) : $(OBJS)
	@$(ECHO) "Adding functions to $(notdir $@) ..."
	@$(AR) $@ $(OBJS)
	@$(RANLIB) $@

$(OBJDIR)/functions.c : mmakefile.src $(foreach f,$(FUNCTIONS),$(f).c)
	@$(CPAK) $(FUNCTIONS)
%mkdir_q $(OBJDIR)
	@$(MV) functions.c functions.h $(OBJDIR)

ALL_FUNCTIONS := $(FUNCTIONS)
%genlibincludesinline hasrt=%(hasrt)

$(OBJDIR)/functions.o : $(OBJDIR)/functions.c
%compile_q opt="$(CFLAGS) -I$(OBJDIR) -I."

$(OBJDIR)/functions.d : $(OBJDIR)/functions.c
%mkdepend_q flags="$(CFLAGS) -I$(OBJDIR)"

$(OBJDIR)/%.o : %.c
%compile_q

FUNCTABLE_SRCS := $(foreach f,$(FUNCTIONS),$(f).c)

%mkfunctable_q

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

%libdefs_rule

$(OBJDIR)/%.d : %.c
%mkdepend_q

%include_deps

%end

#------------------------------------------------------------------------------
#Common template for generating non-rom shared objects
%define genwblib flags=$(CFLAGS) cc=$(CC)
ifndef LIBPOST
LIBPOST := library
endif
ifndef DESTDIR
DESTDIR	:= $(SLIBDIR)
endif
ifndef SLIB
SLIB := $(DESTDIR)/$(LIBNAME).$(LIBPOST)
endif
ifndef LIB
LIB := $(LIBDIR)/lib$(LIBNAME).a
endif
ifndef OBJDIR
OBJDIR := $(GENDIR)/$(CURDIR)
endif
ifndef INIT_FILE
INIT_FILE := $(LIBNAME)_init
endif
ifndef END_FILE
END_FILE := $(OBJDIR)/endtag
endif
ifndef INITFUNC
INITFUNC := $(OBJDIR)/$(INIT_FILE).o
endif
ifndef ENDFUNC
ENDFUNC := $(END_FILE).o
endif
SYS_FILES := $(SYS_FILES) $(INIT_FILE) functable
ifndef OBJS
OBJS := $(foreach f,$(FILES) $(FUNCTIONS) $(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o)
endif
SYS_OBJS := $(foreach f,$(SYS_FILES),$(OBJDIR)/$(f).o)
ifndef DEPS
DEPS := $(foreach f, $(INIT_FILE) functable $(FILES) $(FUNCTIONS) $(notdir $(END_FILE)), $(OBJDIR)/$(f).d)
endif

DESTDIRS := $(DESTDIRS) $(DESTDIR)

# Insert collection lib lib$(LIBNAME).a into $(LIBS) for final $(SLIB) target
%define_libs prelibs=-l$(LIBNAME)

$(SLIB) : $(LIB) $(DEPLIBS) $(EXTRA_DEPLIBS) $(OBJS) $(SYS_OBJS) $(ENDFUNC)
	@$(ECHO) "Building $(notdir $@) ..."
	@$(CC) $(ILDFLAGS) $(GENMAP) $(OBJDIR)/$(LIBNAME)lib.map $(SYS_OBJS) $(LIBS) $(COMPILER_LIBS) $(ENDFUNC) $(EXTRA_LIBS) -o $@ 2>&1|tee $(LIBNAME)lib.err
	@$(IF) $(TEST) ! -s $(LIBNAME)lib.err; then $(RM) $(LIBNAME)lib.err ; else $(NOP) ; fi
	@$(STRIP) $@

# Collect all functions in a linklib for fast linking:
$(LIB) : $(OBJS)
	@$(ECHO) "Adding functions to $(notdir $@) ..."
	@$(AR) $@ $(OBJS)
	@$(RANLIB) $@

setup :
	@$(FOR) dir in $(OBJDIR) $(LIBDIR) $(SLIBDIR) $(DESTDIRS) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done

clean ::
	$(RM) $(OBJDIR) *.err libdefs.h $(EXTRA_CLEAN) \
	    $(LIB) $(SLIB)

$(OBJDIR)/%.o : %.c
%compile_q cmd=%(cc) opt=%(flags)

%libdefs_rule

FUNCTABLE_SRCS := $(foreach f,$(FUNCTIONS),$(f).c)

%mkfunctable_arch archive=

%mkendtag_q

$(OBJDIR)/$(LIBNAME)_init.o : libdefs.h

ifneq (,$(ADDITIONAL_OBJS))
$(foreach f,$(ADDITIONAL_OBJS),$(OBJDIR)/$(f).o) :
	@$(ECHO) "Error: The precompiled object $@ did not exist."
	@exit 1
endif

$(OBJDIR)/%.d : %.c
%mkdepend_q

%include_deps
%end


#------------------------------------------------------------------------------
# Convert two png images to an Amiga icon file based on the description
# file %(from), with outputfile going to %(to).
%define makeicon2 from=$< to=$@ img1="$(basename $(basename $<))_N.png" img2="$(basename $(basename $<))_S.png"
	@$(ECHO) "Creating icon %(to)..."
	@$(PNGTOPNM) %(img1) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon1.iff
	@$(PNGTOPNM) %(img2) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon2.iff
	@$(ILBMTOICON) %(from) $(GENDIR)/genicon1.iff $(GENDIR)/genicon2.iff %(to)
%end

#------------------------------------------------------------------------------
# NOTE: The following are all part of Iain's build changes, please don't use
# or change anything below this line until you know what you are doing. This
# is so that I don't conflict with the semantics of any of the above macros.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
#
%define safe_define var=/A value=/M
ifndef %(var)
%(var) := %(value)
endif
%end

#------------------------------------------------------------------------------
# Do some setup common to all compiling directories.
#
#
%define make_common_setup id=
%safe_define var=OBJDIR%(id) value="$(GENDIR)/$(CURDIR)"
ifneq (%(id),)
  LIBS := LIBS%(id)
endif
%safe_define var=CFLAGS%(id) value="$(TARGET_CFLAGS) $(USER_CFLAGS) $(INCLUDES) $(LIB_CFLAGS) -I$(AROS_INCLUDES) -D__AROS__"
%safe_define var=AFLAGS%(id) value="$(TARGET_AFLAGS) $(USER_AFLAGS) $(INCLUDES) $(LIB_CFLAGS) -I$(AROS_INCLUDES) -D__AROS__"
%safe_define var=LDFLAGS%(id) value="$(TARGET_LDFLAGS) $(USER_LDFLAGS)"

%end

#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q files=$(FILES) src=. dst=/A

SRC_FILES := $(foreach f, %(files), %(src)/$(f))
DST_FILES := $(foreach f, %(files), %(dst)/$(f))

files-copy : setup $(DST_FILES)

%(dst)/% : %(src)/%
	@$(CP) $< $@
	
setup ::
	%mkdirs_q %(dst)

%end

#------------------------------------------------------------------------------
# Just as above, but noisy.

%define copy_files files=$(FILES) src=. dst=/A

SRC_FILES := $(foreach f, %(files), %(src)/$(f))
DST_FILES := $(foreach f, %(files), %(dst)/$(f))

files-copy : setup $(DST_FILES)

%(dst)/% : %(src)/%
	$(CP) $< $@
	
setup ::
	%mkdirs_q %(dst)

%end

#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake= includes=$(INCLUDE_FILES) path=. dir=include

ifneq (%(dir),)
INCL_FILES_1 := $(subst %(dir),$(AROS_INCLUDES)/%(path),%(includes))
INCL_FILES_2 := $(subst %(dir),$(GENINCDIR)/%(path),%(includes))
_INC_PATH := %(dir)/
else
INCL_FILES_1 := $(foreach f,%(includes),$(AROS_INCLUDES)/%(path)/$(f))
INCL_FILES_2 := $(foreach f,%(includes),$(GENINCDIR)/%(path)/$(f))
_INC_PATH :=
endif

ifneq (%(mmake),)
#MM 
includes-copy : %(mmake)

#MM
%(mmake) : %(mmake)-includes-setup $(INCL_FILES_1) $(INC_FILES_2)
else
#MM
includes-copy : includes-setup $(INCL_FILES_1) $(INCL_FILES_2)
endif

$(AROS_INCLUDES)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

$(GENINCDIR)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

ifneq (%(mmake),)
%(mmake)-includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)
else
includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)
endif

$(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path) :
	%mkdir_q dir=$@

%end

# This is an unholy hack, and shall be removed...
%define copy_includes_half path=. dir=include

INCL_FILES_1 := $(subst %(dir),$(AROS_INCLUDES)/%(path),$(INCLUDE_FILES))

includes-copy : setup $(INCL_FILES_1)

$(AROS_INCLUDES)/%(path)/%.h : %(dir)/%.h
	@$(CP) $< $@

setup ::
	%mkdirs_q $(AROS_INCLUDES)/%(path)

%end

#------------------------------------------------------------------------------
# Same as copy_includes, except that the includes are in the current
# directory.
#
%define copy_includes_cwd namespace=amiga path=/A

INCL_FILES_1 := $(foreach f,$(INCLUDE_FILES),$(AROS_INCLUDES)/%(path)/$(f))
INCL_FILES_2 := $(foreach f,$(INCLUDE_FILES),$(GENINCDIR)/%(path)/$(f))

includes-copy : includes-setup $(INCL_FILES_1) $(INCL_FILES_2)

$(AROS_INCLUDES)/%(path)/%.h : %.h
	@$(CP) $< $@

$(GENINCDIR)/%(path)/%.h : %.h
	@$(CP) $< $@

includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)

$(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path) :
	@$(MKDIR) $@

%end

#------------------------------------------------------------------------------
# Standard Binary Commands, such as you would find in C:, SYS:Tools/, etc.
# This assumes a one to one mapping between source code and executable. If
# you have a program that has multiple source files, it will need to be in
# a separate directory. In that case see make_prog_multi
#

%define make_prog_single dir=/A id=
%make_prog_common dir=%(dir) id=%(id)

%(dir)/% : $(OBJDIR%(id))/%.o
	%link_q cmd=$(STATIC_LD) opt=$(LDFLAGS%(id)) libs=$(LIBS%(id))

%end

#------------------------------------------------------------------------------
# Standard Binary Programs: Multiple source files to one output.
#
%define make_prog_multi dir=/A target=/A id=
%make_prog_common dir=%(dir) id=%(id)

%(target) : %(dir)/% : $(OBJS%(id))
	%link_q cmd=$(STATIC_LD) opt=$(LDFLAGS%(id)) from=$^ libs=$(LIBS%(id))

%end

#------------------------------------------------------------------------------
# Common code for building programs
#
%define make_prog_common dflags=$(CFLAGS) id= dir=/A
OBJS%(id) := $(foreach f,$(FILES),$(OBJDIR%(id))/$(f).o)
DEPS := $(DEPS) $(foreach f,$(FILES),$(OBJDIR%(id))/$(f).d)

$(OBJDIR%(id))/%.o : %.c
	%compile_q cmd=$(TARGET_CC) opt=$(CFLAGS%(id))

$(OBJDIR%(id))/%.d : %.c
	%mkdepend_q flags=%(dflags)

%(dir)/% : $(STARTUP) $(DEPLIBS)

setup ::
	%mkdirs_q $(OBJDIR%(id)) %(dir)

clean ::
	-@$(RM) $(OBJDIR%(id))

%end

#------------------------------------------------------------------------------
# Common code that is used to build statically linked programs
#
%define make_prog_setup mmake=/A startup=$(AROS_LIB)/startup.o id=
.PHONY : %(mmake) %(mmake)-clean %(mmake)-quick
#MM
%(mmake)-clean : clean
#MM
%(mmake)-quick : %(mmake)

%make_use_linklibs libs=LIBS%(id) startup=%(startup)
%make_common_setup id=%(id)

%end

#------------------------------------------------------------------------------
#   Allow us to use standard link libraries without needing to worry about
#   what they are called, and things like linker flags. This may need to
#   be changed later on to support that kind of thing.
#

%define make_use_linklibs libs=LIBS deps=DEPLIBS prelibs=$(PRELIBS) lib_cflags=LIB_CFLAGS postlibs= startup=$(AROS_LIB)/startup.o module=MODULE
%(libs)       := -L$(LIBDIR) %(prelibs)
%(deps)       :=
%(lib_cflags) :=
ifndef MODNAME
    STARTUP := %(startup)
    ifdef USE_DETACH
        STARTUP := $(LIBDIR)/detach.o $(STARTUP)
    endif
    %(deps) := $(STARTUP)
endif
ifdef USE_AROSLIB
%(libs) := $(%(libs)) -larossupport
%(deps) := $(%(deps)) $(LIBDIR)/libarossupport.a
endif
ifdef USE_AMIGALIB
%(libs) := $(%(libs)) -lamiga
%(deps) := $(%(deps)) $(LIBDIR)/libamiga.a
endif
ifdef USE_ZLIB
%(libs) := $(%(libs)) -lz
%(deps) := $(%(deps)) $(LIBDIR)/libz.a
endif
ifdef USE_EXPATLIB
%(libs) := $(%(libs)) -lexpat
%(deps) := $(%(deps)) $(LIBDIR)/libexpat.a
endif
ifdef USE_COOLIMAGESLIB
%(libs) := $(%(libs)) -lcoolimagesstatic
%(deps) := $(%(deps)) $(LIBDIR)/libcoolimagesstatic.a
endif
ifdef USE_BGUILIB
%(libs) := $(%(libs)) -lbgui
%(deps) := $(%(deps)) $(LIBDIR)/libbgui.a
endif
ifdef USE_MUILIB
%(libs) := $(%(libs)) -lmui
%(deps) := $(%(deps)) $(LIBDIR)/libmui.a
endif
ifdef USE_REQTOOLSLIB
%(libs) := $(%(libs)) -lreqtoolsstubs
%(deps) := $(%(deps)) $(LIBDIR)/libreqtoolsstubs.a
endif
ifdef USE_HIDDSTUBS
%(libs) := $(%(libs)) -lhiddstubs
%(deps) := $(%(deps)) $(LIBDIR)/libhiddstubs.a
endif
ifdef USE_SDLLIB
%(libs) := $(%(libs)) -lSDL
%(deps) := $(%(deps)) $(LIBDIR)/libSDL.a
endif
ifdef USE_RENDERLIB
%(libs) := $(%(libs)) -lrenderstubs
%(deps) := $(%(deps)) $(LIBDIR)/librenderstubs.a
endif

# USE_ROMLIB is a special one to say that this is a shared module, and it
# should use the restricted c.lib. Currently this includes the static parts
# of the normal C lib, but in the future it may contain quite a bit more.

ifdef USE_ROMLIB
%(libs) := $(%(libs)) -lrom
%(deps) := $(%(deps)) $(LIBDIR)/librom.a
endif

ifdef USE_CLIB
# uncomment this if you want to compile by default
# against the shared version of the clib
%(libs) := $(%(libs)) -larosc_shared
%(deps) := $(%(deps)) $(LIBDIR)/libarosc_shared.a

# uncomment this if you want to compile by default
# against the static version of the clib
#%(libs) := $(%(libs)) -larosc
#%(deps) := $(%(deps)) $(LIBDIR)/libarosc.a
else
    ifdef USE_CLIB_SHARED
	%(libs) := $(%(libs)) -larosc_shared
	%(deps) := $(%(deps)) $(LIBDIR)/libarosc_shared.a
    else
	ifdef USE_CLIB_STATIC
	    %(libs) := $(%(libs)) -larosc
	    %(deps) := $(%(deps)) $(LIBDIR)/libarosc.a
	else
	    ifdef USE_CLIB_LIBRARY
	        %(libs) := $(%(libs)) -larosc_shared
		%(deps) := $(%(deps)) $(LIBDIR)/libarosc_shared.a
		%(lib_cflags) := $(%(lib_cflags)) -I$(TOP)/rom/exec -D_CLIB_LIBRARY_
	    endif		
	endif
    endif
endif

# m.lib MUST come after c.lib in it's various incarnations.
ifdef USE_MLIB
%(libs) := $(%(libs)) -lm
%(deps) := $(%(deps)) $(LIBDIR)/libm.a
endif

# These must always be linked if we are NOT building a module,
# otherwise strange things might happen.
ifndef %(module)
ifndef NO_AUTOINIT
%(libs) := $(%(libs)) -lautoinit
%(deps) := $(%(deps)) $(LIBDIR)/libautoinit.a
endif
endif

%(libs) := $(%(libs)) %(postlibs)

ifeq ($(AROS_TARGET_ARCH),morphos)
%(libs) := $(FORCE_LIBS)
%(deps) := $(FORCE_DEPLIBS)
endif
%end

#------------------------------------------------------------------------------
#   Create a shared object (ie library, device, gadget, hidd, ...)
#
%define make_module_setup mmake=/A objdir=$(OBJDIR) id=
.PHONY : %(mmake) %(mmake)-clean %(mmake)-object-quick %(mmake)-linklib-quick
#MM
%(mmake)-clean : clean

%safe_define var=MODULE%(id) value="$(MODNAME).$(MODTYPE)"
%safe_define var=USE_FUNCTABLE value="yes"
%safe_define var=USE_CPAK value="$(USE_CPAK_DEFAULT)"

%make_use_linklibs libs=LIBS%(id) module=MODULE%(id)
%make_common_setup id=%(id)

# Depending upon the value of MODTYPE, much changes...
MOD_DIR%(id) := bollocks
ifeq ($(MODTYPE),library)
MOD_DIR%(id) := $(AROS_LIBS)
endif
ifeq ($(MODTYPE),device)
MOD_DIR%(id) := $(AROS_DEVS)
endif
ifeq ($(MODTYPE),resource)
MOD_DIR%(id) := $(AROS_MODULES)
endif
ifeq ($(MODTYPE),gadget)
MOD_DIR%(id) := $(AROS_GADGETS)
endif
ifeq ($(MODTYPE),class)
MOD_DIR%(id) := $(AROS_CLASSES)
endif
ifeq ($(MODTYPE),datatype)
MOD_DIR%(id) := $(AROS_DATATYPES)
endif
ifeq ($(MODTYPE),handler)
MOD_DIR%(id) := $(AROS_FS)
endif
ifeq ($(MODTYPE),language)
MOD_DIR%(id) := $(AROS_LOCALE)/Languages
endif
ifeq ($(MODTYPE),module)
MOD_DIR%(id) := $(AROS_MODULES)
endif
ifeq ($(MODTYPE),mui)
MOD_DIR%(id) := $(AROS_CLASSES)/Zune
endif
ifeq ($(MODTYPE),mcc)
MOD_DIR%(id) := $(AROS_CLASSES)/Zune
endif
ifeq ($(MODTYPE),mcp)
MOD_DIR%(id) := $(AROS_CLASSES)/Zune
endif
ifeq ($(MOD_DIR%(id)),bollocks)
$(error You have to set MODTYPE to something other than $(MODTYPE))
endif

# Save these because they may be changed later.
FILES_ALL := $(foreach f,$(FILES),$(f).c)
FUNCS_ALL%(id) := $(foreach f,$(FUNCS),$(f).c)

setup :: $(OBJDIR) $(MOD_DIR%(id))

$(OBJDIR) $(MOD_DIR%(id)) :
	$(MKDIR) $@

%end

%define make_module_common dflags=$(CFLAGS) id= cc=$(TARGET_CC)
# You need to put the $(OBJDIR) rules first, because they are more specific.
# and that affects the way that GNU Make binds its dependencies.
#
# Note that if you wish to use a $(OBJDIR)/%.c rather than $(ARCH)/blah/%.c
# or $(CPU)/blah/%.c then you will have to specify that manually. Shouldn't
# happen though.

$(OBJDIR%(id))/%.o : $(OBJDIR%(id))/%.c
	%compile_q cmd=%(cc) opt=$(CFLAGS%(id))

$(OBJDIR%(id))/%.so : $(OBJDIR%(id))/%.c
	%compile_q cmd=%(cc) opt="$(SHARED_CFLAGS) $(CFLAGS%(id))"

$(OBJDIR%(id))/%.d : $(OBJDIR%(id))/%.c
	%mkdepend_q flags=%(dflags)

$(OBJDIR%(id))/%.o : %.c
	%compile_q cmd=%(cc) opt=$(CFLAGS%(id))

$(OBJDIR%(id))/%.so : %.c
	%compile_q cmd=%(cc) opt="$(SHARED_CFLAGS) $(CFLAGS%(id))"

$(OBJDIR%(id))/%.d : %.c
	%mkdepend_q flags=%(dflags)

ifeq ($(USE_LIBDEFS),yes)
LIBDEFS := libdefs.h
%libdefs_rule
endif

setup :: $(LIBDEFS)
	%mkdirs_q  $(OBJDIR%(id)) $(LIBDIR) $(MOD_DIR%(id))

#MM
setup-morphos :: $(LIBDEFS)
	%mkdirs_q  $(OBJDIR%(id)) $(LIBDIR) $(MOD_DIR%(id))

clean ::
	-@$(RM) $(OBJDIR%(id))

%end

#-------------------------------------------------------------------------
# Use cpak to generate the files functions.[ch]. This requires a small
# check to make sure that $(FUNCS) != "".
#
%define make_module_cpak id=
# Don't even bother generating the file if $(FUNCS) is zero.
ifneq ($(FUNCS),)
ifneq ($(USE_CPAK),no)
F_NAME := functions

$(OBJDIR%(id))/functions.c : $(foreach f,$(FUNCS),$(f).c)
	%mkdir_q $(OBJDIR%(id))
	@$(CPAK) $(patsubst %.c,%,$^)
	@$(MV) functions.c functions.h $(OBJDIR%(id))

endif
endif
%end

#-------------------------------------------------------------------------
# Use the old archtool to generate the files functions.[ch].
#
%define make_module_archtool
F_NAME := functions

$(OBJDIR)/functions.c : $(ARCHIVE)
	@$(ARCHTOOL) -s $@ $(ARCHIVE)

# This version of $(OBJDIR)/functable.c will override the one later.
# Especially with $(FUNCS) == ""...
$(OBJDIR)/functable.c : $(ARCHIVE)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(ARCHTOOL) -t $(ARCHIVE)
	@$(MV) functable.c $@

# Because $(FUNCS) is "", then USE_FUNCTABLE is set to no, so I have to do
# myself. Similarly, USE_LIBDEFS = no breaks the END_OBJ
FUNC_OBJ := $(OBJDIR)/functable.o
FUNC_SOBJ := $(OBJDIR)/functable.so

%end

#-------------------------------------------------------------------------
# I want to get rid of this. Either use the new archtool, or the scripts
#
%define make_lib_incl_arch name=$(MODNAME) hasrt=
#MM includes-generate :
includes-generate :: includes-setup \
	    $(INCDIR)/clib/%(name)_protos.h \
	    $(INCDIR)/defines/%(name).h \
	    $(INCDIR)/inline/%(name).h \
	    $(INCDIR)/proto/%(name).h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h
	@$(NOP)

_MOD_INCL_DIRS :=   $(foreach i,clib defines inline pragmas proto,$(INCDIR)/$(i)) \
                    $(foreach i,clib defines inline pragmas proto,$(GENINCDIR)/$(i))

includes-setup : $(_MOD_INCL_DIRS)

$(_MOD_INCL_DIRS) :
	%mkdir_q $@

clean ::
	@$(RM) \
	    $(AROS_INCLUDES)/clib/%(name)_protos.h \
	    $(AROS_INCLUDES)/defines/%(name).h \
	    $(AROS_INCLUDES)/inline/%(name).h \
	    $(AROS_INCLUDES)/proto/%(name).h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h

_HEADER_DEPS := mmakefile.src $(wildcard headers.tmpl) libdefs.h

$(GENINCDIR)/pragmas/%(name)_pragmas.h \
    $(GENINCDIR)/clib/%(name)_protos.h \
    $(GENINCDIR)/defines/%(name).h \
    $(GENINCDIR)/inline/%(name).h \
    $(GENINCDIR)/proto/%(name).h : $(_HEADER_DEPS)
	@$(ARCHTOOL) -I $(GENINCDIR) $(ARCHIVE)

$(AROS_INCLUDES)/clib/%(name)_protos.h : $(GENINCDIR)/clib/%(name)_protos.h
	@$(CP) $< $@

$(AROS_INCLUDES)/defines/%(name).h : $(GENINCDIR)/defines/%(name).h
	@$(CP) $< $@

$(AROS_INCLUDES)/inline/%(name).h : $(GENINCDIR)/inline/%(name).h
	@$(CP) $< $@

$(AROS_INCLUDES)/proto/%(name).h : $(GENINCDIR)/proto/%(name).h
	@$(CP) $< $@
%end

#-------------------------------------------------------------------------------
#   Generate a module like a normal shared library/device/etc that consists
#   of multiple files, with an init file, function table, and an endtag at the
#   end.
#
%define make_module dflags=$(CFLAGS) mmake=/A id= cc=$(TARGET_CC)
%safe_define var=INIT_FILE value="$(MODNAME)_init"
%safe_define var=END_FILE value="endtag"
%safe_define var=USE_ENDTAG value="yes"
%safe_define var=USE_LIBDEFS value="yes"

#MM
%(mmake)-module-quick : %(mmake)-module
#MM
%(mmake)-linklib-quick : %(mmake)-linklib

#MM %(mmake)-module : %(mmake)
%(mmake)-module : setup $(MOD_DIR%(id))/$(MODULE%(id))

#MM %(mmake)-linklib : %(mmake)
ifeq ($(MAKE_SHLIB),yes)
%(mmake)-linklib : setup $(AROSDIR)/lib/lib$(MODNAME).so
else
%(mmake)-linklib : setup $(AROSDIR)/lib/lib$(MODNAME).a
endif

ifeq ($(USE_LIBDEFS),no)
USE_FUNCTABLE := no
USE_ENDTAG := no
endif

# Don't generate a functable if there is nothing there to do.
ifeq ($(FUNCS),)
    USE_FUNCTABLE := no
endif

# F_NAME might be set by make_module_cpak/make_module_archtool
# It should be set to $(FUNCS) otherwise
ifndef F_NAME
  F_NAME := $(FUNCS)
endif

DEPS := $(DEPS) $(foreach f,$(INIT_FILE) $(FILES) $(F_NAME), $(OBJDIR%(id))/$(f).d)
OBJS := $(foreach f,$(FILES) $(F_NAME), $(OBJDIR%(id))/$(f).o)
SOBJS := $(foreach f,$(FILES) $(F_NAME), $(OBJDIR%(id))/$(f).so)

INIT_OBJ := $(OBJDIR%(id))/$(INIT_FILE).o
INIT_SOBJ := $(OBJDIR%(id))/$(INIT_FILE).so

ifeq ($(USE_FUNCTABLE),yes)
FUNC_OBJ := $(OBJDIR%(id))/functable.o
FUNC_SOBJ := $(OBJDIR%(id))/functable.so
endif
ifeq ($(USE_ENDTAG),yes)
END_OBJ := $(OBJDIR%(id))/endtag.o
END_SOBJ := $(OBJDIR%(id))/endtag.so
endif

# Generate the module from the object files.
ifeq ($(NO_MODULE),yes)
$(MOD_DIR%(id))/$(MODULE%(id)) :
	$(error You cannot make $(MODULE%(id)) into a module)
else
$(MOD_DIR%(id))/$(MODULE%(id)) : $(INIT_OBJ) $(FUNC_OBJ) $(OBJS) $(END_OBJ) $(DEPLIBS)
	%link_module_q objs="$(INIT_OBJ) $(FUNC_OBJ) $(OBJS)" endtag="$(END_OBJ)" objdir=$(OBJDIR%(id)) libs=$(LIBS%(id)) module=$(MODULE%(id)) ldflags=$(LDFLAGS%(id))
endif

# Make a library. Not sure about the RHS yet.
$(AROSDIR)/lib/lib$(MODNAME).a : $(INIT_OBJ) $(FUNC_OBJ) $(OBJS) $(END_OBJ)
	%mklib_q from=$^

$(AROSDIR)/lib/lib$(MODNAME).so : $(INIT_SOBJ) $(FUNC_SOBJ) $(SOBJS) $(END_SOBJ)
	@$(ECHO) "Linking $(notdir $@)..."
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^

# Make a function table
ifeq ($(USE_FUNCTABLE),yes)
$(OBJDIR%(id))/functable.c : $(FUNCS_ALL%(id)) $(BINDIR)/scripts/genfunctable.awk libdefs.h
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(AWK) -f $(BINDIR)/scripts/genfunctable.awk $(FUNCS_ALL%(id)) > $@
endif

# Make the end tag if it is needed.
$(OBJDIR%(id))/endtag.c : libdefs.h
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(ECHO) "#include <libcore/libtail.c>" > $@

%asm_rule "$(INIT_FILE) $(FILES) $(FUNCS)"
%ctoasm_q

clean ::
	-@$(RM) $(AROS_MODULES)/$(MODULE%(id)) \
	    $(AROSDIR)/lib/lib$(MODNAME).a $(AROSDIR)/lib/lib$(MODNAME).so

%make_module_common dflags=%(dflags) id=%(id) cc=%(cc)
%end

#--------------------------------------------------------------------------
#   Compile the files $(MODULES) based on single files. It will take a file
#   %.c -> %.o -> %.$(MODTYPE) without generating any of the other regular
#   cruft associated with modules. It also can perform the rule:
#   %.c -> %.o -> %, for those people who don't want an extension.
#
%define make_module_single mmake=/A dflags=$(CFLAGS)
# Munge the linklibs into something that is useful for linking. Don't put
# this before the inclusion of the config/ stuff. This is so that they
# can change the linklibs if necessary.
%make_use_linklibs

$(MOD_DIR)/%.$(MODTYPE) : $(OBJDIR)/%.o $(DEPLIBS)
	%link_module_q objs=$(OBJDIR)/$*.o

$(MOD_DIR)/% : $(OBJDIR)/%.o $(DEPLIBS)
	%link_module_q objs=$(OBJDIR)/$*.o

DEPS := $(DEPS) $(OBJDIR)/$(MODNAME).d

%ctoasm_q

# Use the common rules to generate the rest of the files.
%make_module_common dflags=%(dflags)
%end

%define make_lib_includes name=$(MODNAME) hasrt= id=
#MM includes-generate :
includes-generate :: includes-setup \
	    $(INCDIR)/clib/%(name)_protos.h \
	    $(INCDIR)/defines/%(name).h \
	    $(INCDIR)/inline/%(name).h \
	    $(INCDIR)/proto/%(name).h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h
	@$(NOP)

_MOD_INCL_DIRS :=   $(foreach i,clib defines inline pragmas proto,$(INCDIR)/$(i)) \
                    $(foreach i,clib defines inline pragmas proto,$(GENINCDIR)/$(i))

includes-setup : $(_MOD_INCL_DIRS)

$(_MOD_INCL_DIRS) :
	%mkdir_q $@

clean ::
	@$(RM) \
	    $(AROS_INCLUDES)/clib/%(name)_protos.h \
	    $(AROS_INCLUDES)/defines/%(name).h \
	    $(AROS_INCLUDES)/inline/%(name).h \
	    $(AROS_INCLUDES)/proto/%(name).h \
	    $(GENINCDIR)/clib/%(name)_protos.h \
	    $(GENINCDIR)/defines/%(name).h \
	    $(GENINCDIR)/inline/%(name).h \
	    $(GENINCDIR)/proto/%(name).h

_HEADER_DEPS := mmakefile.src $(wildcard headers.tmpl) libdefs.h \
	    $(FUNCS_ALL%(id)) \
	    $(SCRIPTDIR)/genshared $(SCRIPTDIR)/genclib.awk \
	    $(SCRIPTDIR)/gendefines.awk $(SCRIPTDIR)/geninline.awk

$(GENINCDIR)/clib/%(name)_protos.h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -clib %(hasrt) -prefix $(GENINCDIR) $(FUNCS_ALL%(id))

$(GENINCDIR)/defines/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -defines %(hasrt) -prefix $(GENINCDIR) $(FUNCS_ALL%(id))

$(GENINCDIR)/inline/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -inline %(hasrt) -prefix $(GENINCDIR) $(FUNCS_ALL%(id))

$(GENINCDIR)/proto/%(name).h : $(_HEADER_DEPS)
	@$(SCRIPTDIR)/genshared -proto %(hasrt) -prefix $(GENINCDIR) $(FUNCS_ALL%(id))

$(AROS_INCLUDES)/clib/%(name)_protos.h : $(GENINCDIR)/clib/%(name)_protos.h
	@$(CP) $< $@

$(AROS_INCLUDES)/defines/%(name).h : $(GENINCDIR)/defines/%(name).h
	@$(CP) $< $@

$(AROS_INCLUDES)/inline/%(name).h : $(GENINCDIR)/inline/%(name).h
	@$(CP) $< $@

$(AROS_INCLUDES)/proto/%(name).h : $(GENINCDIR)/proto/%(name).h
	@$(CP) $< $@
%end

%define make_hidd_stubs hidd=/A cflags=$(CFLAGS) dflags=$(CFLAGS)
STUBS_SRC := $(foreach f,$(STUBS),$(f).c)
STUBS_OBJ := $(foreach f,$(STUBS),$(OBJDIR)/$(f).o)
STUBS_MEM := $(foreach f,$(STUBS),$(f).o)
STUBS_DEP := $(foreach f,$(STUBS),$(OBJDIR)/$(f).d)
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs: hidd-%(hidd)-stubs
#MM
hidd-%(hidd)-stubs : $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC)
	%compile_q cmd=$(TARGET_CC) opt=%(cflags)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags=%(dflags)

setup ::
	%mkdirs_q $(OBJDIR) $(LIBDIR)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end

%define add_kernel_module id=/A
AROS_BUILTIN_LIBS := $(AROS_BUILTIN_LIBS) $(AROS_LIB)/lib%(id).mo
AROS_BUILTIN_DEPS := $(AROS_BUILTIN_DEPS) $(AROS_LIB)/lib%(id).mo
%end

#------------------------------------------------------------------------------
#   Hey! iaint says don't add things here, add them before my other message.
#   The reason is that I'm trying to work out which of macros are still
#   needed, and because of this, I'm trying to keep my additions separate
#   from all the others.
