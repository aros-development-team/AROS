############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used as commands in the body    ##
## of a make rule.                                                         ##
## They are used to help the portability of mmakefile to different         ##
## platforms and also will handle the error handling in a standard way.    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Compile the file %(from) to %(to) with %(cmd). Write any errors to %(err)
# and use the options in %(opt).
%define compile_q cmd=$(TARGET_CC) opt=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Compiling $(notdir %(from))"
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "%(from): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Compile failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Assemble the file %(from) to %(to) with %(cmd) with the options in %(opt).
%define assemble_q cmd=$(AS) opt=$(AFLAGS) from=$< to=$@
	@$(ECHO) "Assembling $(notdir %(from))..."
	@$(IF) %(cmd) %(opt) -c %(from) -o %(to) > $(GENDIR)/cerrors 2>&1 ; then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
		$(ECHO) "$(notdir %(from)): %(cmd) %(opt) -c %(from) -o %(to)" >> $(GENDIR)/errors ; \
		$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	    else \
		$(NOP) ; \
	    fi ; \
	else \
	    $(ECHO) "Assemble failed: %(cmd) %(opt) -c %(from) -o %(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi
%end
#-------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link a specified number of objects to an executable
%define link_q cmd=$(AROS_CC) opt=$(LDFLAGS) from=$< to=$@ libs=$(LIBS)
	@$(ECHO) "Linking %(to)..."
	@$(IF) %(cmd) %(opt) %(from) -o %(to) %(libs) 2>&1 > $(GENDIR)/cerrors 2>&1 ; then \
		$(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
				$(ECHO) "%(to): %(cmd) %(opt) %(from) -o %(to) %(libs)" >> $(GENDIR)/errors ; \
				$(CAT) $(GENDIR)/cerrors >> $(GENDIR)/errors ; \
	   	else \
			$(NOP) ; \
    		fi ; \
	else \
	    $(ECHO) "Link failed: %(cmd) %(opt) %(from) -o %(to) %(libs)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    exit 1 ; \
	fi; \
	$(STRIP) %(to)
%end

#-------------------------------------------------------------------------
# Link a module based upon a number of arguments and the standard $(LIBS)
# and $(DEPLIBS) make variables.
#
%define link_module_q err="$(notdir $@).err" objs=/A endtag= module=$(MODULE) ldflags=$(LDFLAGS) libs=$(LIBS) objdir=$(OBJDIR)
	@$(ECHO) "Building $(notdir $@) ..."
	@if $(AROS_CC) $(NOSTARTUP_LDFLAGS) %(ldflags) \
	    $(GENMAP) %(objdir)/%(module).map \
	    %(objs) %(libs) %(endtag) \
	    -o $@ 2>&1 > %(objdir)/%(err); \
	then \
	    cat %(objdir)/%(err); \
	else \
	    cat %(objdir)/%(err); \
	    exit 1; \
	fi

	@if $(TEST) ! -s %(objdir)/%(err) ; then $(RM) %(objdir)/%(err) ; fi
	@$(STRIP) $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the library
%define mklib_q ar=$(AR) ranlib=$(RANLIB) to=$@ from=$(OBJS)
	@$(ECHO) "Creating library %(to)..."
	@%(ar) %(to) %(from)
	@%(ranlib) %(to)
%end

#------------------------------------------------------------------------------
# Create the dependency file %(to) for %(from)
%define mkdepend_q flags=$(CFLAGS) from=$< to=$@ cc=$(AROS_CC)
	%mkdir_q dir="$(dir %(to))"
	@$(ECHO) "Makedepend $(CURDIR)/$(notdir %(from))..."
	@AROS_CC="%(cc)" $(MKDEPEND) %(flags) %(from) -o %(to)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Create the function reference file %(to) to %(from)
%define mkref_q cc=$(AROS_CC) cppflags="-E -C -dD -D__CXREF__" cflags=$(CFLAGS) from=$< to=$@
	@$(ECHO) "Generating ref for $(notdir %(from))..."
	@$(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to) 2>$(GENDIR)/cerrors
	@$(IF) $(TEST) -s %(to) ; \
	then \
	    $(IF) $(TEST) -s $(GENDIR)/cerrors ; then \
	        $(ECHO) "%(from): $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" >> $(GENDIR)/errors ; \
	        tee < $(GENDIR)/cerrors -a $(GENDIR)/errors ; \
	    fi ; \
	else \
	    $(ECHO) "Reference generation failed: $(CXREF) -raw -CPP '%(cc) %(cppflags) %(cflags)' %(from) >%(to)" 1>&2 ; \
	    tee < $(GENDIR)/cerrors -a $(GENDIR)/errors 1>&2 ; \
	    $(RM) %(to) ; \
	    exit 1 ; \
	fi
%end

#------------------------------------------------------------------------------
# Create one directory without any output
%define mkdir_q dir=.
	@$(IF) $(TEST) ! -d %(dir) ; then $(MKDIR) %(dir) ; else $(NOP) ; fi
%end

#------------------------------------------------------------------------------
# Create several directories without any output
%define mkdirs_q dirs=/M
	@$(FOR) dir in %(dirs) ; do \
	    $(IF) $(TEST) ! -d $$dir ; then $(MKDIR) $$dir ; else $(NOP) ; fi ; \
	done
%end

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile macro's that are used to do certain tasks in a   ##
## mmakefile. They consist of one or more full makefile rules.             ##
## In general the files generated in these macro's are also defined as     ##
## make targets so that they can be used as a dependency in other rules    ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Generate a unique id for each of the %build... rules
%define buildid targets=/A
BDID := $(BDID)_
ifneq ($(filter $(TARGET),%(targets)),)
BDTARGETID := $(BDID)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy file %(from) to %(to) in a makefile rule
%define rule_copy from=/A to=/A
%(to) : %(from)
	@$(CP) $< $@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Copy the files %(files) to %(targetdir). If %(srcdir) is not given the dir 
# part will be stripped off and the file will be put in %(targetdir). If
# %(srcdir) is given the file names are relative to %(srcdir) and %(targetdir)
# This rule does not make any directories so one has to make the target dirs
# before this copy
%define rule_copy_multi files=/A targetdir=/A srcdir=

ifeq (%(srcdir),)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(notdir %(files)))
    $(foreach f, %(files), \
          $(eval %(targetdir)/$(notdir $(f)) : $(f)) \
	  $(eval %(targetdir)/$(notdir $(f)) : SRCFILE := $(f)) \
    )
else
    TMP_TARGETS := $(addprefix %(targetdir)/,%(files))
    $(foreach f, %(files), \
          $(eval %(targetdir)/$(f) : %(srcdir)/$(f)) \
          $(eval %(targetdir)/$(f) : SRCFILE := %(srcdir)/$(f)) \
    )
endif

$(TMP_TARGETS) :
	@$(CP) $(SRCFILE) $@
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Will join all the files in %(from) to %(to). When text is specified it will
# be displayed.
# Restriction: at the moment when using a non-empty target dir %(from) may
# not have 
%define rule_join to=/A from=/A text=

%(to) : %(from)
ifneq (%(text),)
	@$(ECHO) %(text)
endif
	@$(CAT) $^ >$@
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Include the dependency files and add some internal rules
# When depstargets is provided the depencies will only be included when one of
# these targets is the $(TARGET). Otherwise the dependencies will only be
# include when the $(TARGET) is not for setup or clean 
%define include_deps deps=$(DEPS)/M  depstargets=
ifneq (%(deps),)
  ifneq (%(depstargets),)
    ifneq ($(findstring $(TARGET),%(depstargets)),)
      -include %(deps)
    endif
  else
    ifeq (,$(filter clean% %clean %clean% setup% includes% %setup,$(TARGET)))
      -include %(deps)
    endif
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Create the directories %(dirs). The creation will be done by adding rules to
# the %(setuptarget) make target with setup as the default. 
%define rule_makedirs dirs=/A setuptarget=setup

%(setuptarget) :: %(dirs)

# Only add a rule for a directory for which there is no rule yet.

TOCREATE_TMP := $(filter-out $(CREATED_DIRS_GLOB),%(dirs))

ifdef TOCREATE_TMP
$(TOCREATE_TMP) :
	@$(ECHO) "Creating directory $@"
	%mkdir_q dir=$@

  ifdef CREATED_DIRS_GLOB
    CREATED_DIRS_GLOB += $(TOCREATE_TMP)
  else
    CREATED_DIRS_GLOB := $(TOCREATE_TMP)
  endif
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Rule to generate a functable
#
%define rule_genfunctable name=functable files=/A dir=. libdefs=libdefs.h

%(dir)/%(name).c : $(addsuffix .c,%(files)) $(SCRIPTDIR)/genfunctable.awk %(libdefs)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
ifneq (%(files),)
	$(AWK) -v file=%(libdefs) -f $(SCRIPTDIR)/genfunctable.awk $(addsuffix .c,%(files)) > $@
else
	$(ARCHTOOL) -t
	$(MV) functable.c $@
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an object file and generate
# the dependency file. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile basename=/A cflags=$(CFLAGS) dflags= targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).o : TMP_CMD:=$(TARGET_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).o : TMP_CMD:=$(HOST_CC)
$(TMP_TARGETBASE).d : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).o : %(basename).c
	%compile_q opt="%(cflags)" cmd=$(TMP_CMD)

ifeq (%(dflags),)
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(cflags)
else
$(TMP_TARGETBASE).d : TMP_DFLAGS:=%(dflags)
endif
$(TMP_TARGETBASE).d : %(basename).c
	%mkdepend_q cc=$(TMP_CMD) flags=$(TMP_DFLAGS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile multiple C source files to an object file and
# generate the corresponding dependency files. # part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basenames: the basenames of the files to compile. The names may include
#   relative or absolute path names. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file. When targetdir is not
#   empty, path names will stripped from the file names so that all files are in
#   that dir and not in subdirectories.
%define rule_compile_multi basenames=/A cflags=$(CFLAGS) dflags= targetdir= \
    compiler=target

ifeq (%(targetdir),)
    TMP_TARGETS := $(addsuffix .o,%(basenames))
    TMP_DTARGETS := $(addsuffix .d,%(basenames))
    $(foreach f,%(basenames),       $(eval $(f).o $(f).d : $(f).c) \
	  $(eval $(f).o $(f).d : SRC_FILE:=$(f).c) \
    )
else
    TMP_TARGETS := $(addsuffix .o,$(addprefix %(targetdir)/,$(notdir %(basenames))))
    TMP_DTARGETS := $(addsuffix .d,$(addprefix %(targetdir)/,$(notdir %(basenames))))
    $(foreach f,%(basenames),\
          $(eval %(targetdir)/$(notdir $(f)).o %(targetdir)/$(notdir $(f)).d : $(f).c) \
          $(eval %(targetdir)/$(notdir $(f)).o %(targetdir)/$(notdir $(f)).d : SRC_FILE:=$(f).c) \
    )
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETS) $(TMP_DTARGETS) : CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETS) $(TMP_DTARGETS) : CMD:=$(HOST_CC)
endif

$(TMP_TARGETS) : CFLAGS := %(cflags)
$(TMP_TARGETS) :
	%compile_q cmd=$(CMD) from=$(SRC_FILE)

ifeq (%(dflags),)
$(TMP_DTARGETS) : DFLAGS:=%(cflags)
else
$(TMP_DTARGETS) : DFLAGS:=%(dflags)
endif
$(TMP_DTARGETS) :
	%mkdepend_q cc=$(CMD) flags=$(DFLAGS) from=$(SRC_FILE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Make an alias from one arch specific build to another arch.
# arguments:
# - mainmmake: the mmake of the module in the main tree
# - arch: the current arch
# - alias: the alias to which this should point
%define rule_archalias mainmmake=\A arch=\A alias=\A

#MM- %(mainmmake)-%(arch) : %(mainmmake)-%(alias)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to compile a C source file to an shared object file with a
# .so suffix. Basename may contain a directory part, then the source
# file has to be in that directory. The generated file will be put in the
# object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the .o file and the .d file. By default
#   it is put in the same directory as the .c file
%define rule_compile_shared basename=/A cflags=$(CFLAGS) targetdir= compiler=target

ifeq (%(targetdir),)
  TMP_TARGETBASE := %(basename)
else
  TMP_TARGETBASE := %(targetdir)/$(notdir %(basename))
endif

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(TMP_TARGETBASE).so : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(TMP_TARGETBASE).so : TMP_CMD:=$(HOST_CC)
endif

$(TMP_TARGETBASE).so : %(basename).c
	%compile_q opt="$(SHARED_CFLAGS) %(cflags)" cmd=$(TMP_CMD)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to assemble a source file to an object file. Basename may
# contain a directory part, then the source file has to be in that directory.
# The generated file will be put in the object directory without the directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - flags (default $(AFLAGS)): the asm flags to use for assembling
# - targetdir: the directory to put the .o file. By default it is put in the
#   same directory as the .s file
%define rule_assemble basename=/A flags=$(AFLAGS) targetdir=

ifeq (%(targetdir),)
%(basename).o : %(basename).s
	%assemble_q opt=%(flags)

else
%(targetdir)/$(notdir %(basename)).o : %(basename).s
	%assemble_q opt=%(flags)

endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(objs) to %(prog) using the libraries in %(uselibs)
%define rule_link_prog prog=/A objs=/A ldflags=$(LDFLAGS) uselibs= \
    usehostlibs= usestartup=yes detach=no nix=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif
%(prog) : EXTRA_LDFLAGS:=$(TMP_EXTRA_LDFLAGS)

%(prog) : %(objs) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from="%(objs)" opt="%(ldflags) $(EXTRA_LDFLAGS)" \
	    libs="$(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link %(progs) from object in %(objdir) to executables in %(targetdir) using
# the AROS libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_link_progs progs=/A targetdir=$(AROSDIR)/$(CURDIR) \
    objdir=$(GENDIR)/$(CURDIR) ldflags=$(LDFLAGS) uselibs= usehostlibs= \
    usestartup=yes detach=no

TMP_EXTRA_LDFLAGS := 
ifeq (%(nix),yes)
    TMP_EXTRA_LDFLAGS += $(NIX_LDFLAGS)
endif
ifeq (%(usestartup),no)
    TMP_EXTRA_LDFLAGS += $(NOSTARTUP_LDFLAGS)
endif
ifeq (%(detach),yes)
    TMP_EXTRA_LDFLAGS += $(DETACH_LDFLAGS)
endif
$(addprefix %(targetdir)/,%(progs)) : EXTRA_LDFLAGS:=$(TMP_EXTRA_LDFLAGS)

$(addprefix %(targetdir)/,%(progs)) : %(targetdir)/% : %(objdir)/%.o \
    $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_q from=$< opt="%(ldflags) $(EXTRA_LDFLAGS)" \
	    libs="$(addprefix -l,%(uselibs)) $(addprefix -l,%(usehostlibs))"
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).a in
%define rule_link_linklib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).a : %(objs)
	%mklib_q from=$^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) to the library %(libdir)/lib%(libname).so in
%define rule_link_shlib libname=/A objs=/A libdir=$(LIBDIR)

%(libdir)/lib%(libname).so : %(objs)
	@$(SHARED_LD) $(SHARED_LDFLAGS) -o $@ $^
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Link the %(objs) and %(endobj) to %(module) with errors in %(err) and using
# the libraries in %(uselibs) and the host libraries in %(usehostlibs)
%define rule_linkmodule module=/A objs=/A endobj=/A err=/A uselibs= usehostlibs=

%(module) : OBJS := %(objs)
%(module) : ENDTAG := %(endobj)
%(module) : ERR := %(err)
%(module) : LIBS := $(addprefix -l,%(uselibs)) -lautoinit -llibinit -L/usr/lib $(addprefix -l,%(usehostlibs))
%(module) : %(objs) %(endobj) $(addprefix $(LIBDIR)/lib,$(addsuffix .a,%(uselibs) libinit autoinit))
	%link_module_q err=$(ERR) endtag=$(ENDTAG) objs=$(OBJS) libs=$(LIBS)

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basename: the basename of the file to compile. Use % for a wildcard rule
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file.
# - includefile: This file will be included at the head of the source file
%define rule_ref basename=/A cflags=$(CFLAGS) targetdir= includefile= compiler=target

ifeq (%(targetdir),)
GENFILE_TMP := %(basename).ref
else
GENFILE_TMP := %(targetdir)/$(notdir %(basename)).ref
endif

ifeq ($(filter %(compiler),target host),)
$(error use of %rule_ref: compiler has to be 'host' or 'target')
endif

ifeq (%(compiler),target)
$(GENFILE_TMP) : CC:=$(TARGET_CC)
else
$(GENFILE_TMP) : CC:=$(HOST_CC)
endif

$(GENFILE_TMP) : %(basename).c $(CXREF) %(includefile)
ifeq (%(includefile),)
	%mkref_q cc=$(CC) cflags="%(cflags)"
else
	%mkref_q cc=$(CC) cflags="%(cflags) -include %(includefile)"
endif

%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a rule to generate a function reference file from a C source file.
# Basename may contain a directory part, then the source file has to be in that
# directory. The generated file will be put in the object directory without the
# directory.
# options
# - basenames: the basenames of the files to compile. No wildcard is allowed
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - targetdir: the directory to put the generated .ref file. By default the
#   .ref file will be put in the same directory as the .c file. When targetdir
#   is not empty all files will be put there and path parts in the basenames
#   will be stripped off.
# - includefile: This file will be included at the head of the source file
%define rule_ref_multi basenames=/A cflags=$(CFLAGS) targetdir= includefile= \
    compiler=target

ifeq (%(targetdir),)
    TMP_TARGETS := $(addsuffix .ref,%(basenames))
    $(foreach f,%(basenames), \
          $(eval $(f).ref : $(f).c) \
	  $(eval $(f).ref : SRCFILE := $(f).c) \
    )
else
    TMP_TARGETS := $(addprefix %(targetdir)/,$(addsuffix .ref,$(notdir %(basenames))))
    $(foreach f,%(basenames), \
          $(eval %(targetdir)/$(notdir $(f)).ref : $(f).c) \
	  $(eval %(targetdir)/$(notdir $(f)).ref : SRCFILE := $(f).c) \
    )
endif

ifeq ($(filter %(compiler),target host),)
$(error use of %rule_ref: compiler has to be 'host' or 'target')
endif

ifeq (%(compiler),target)
$(TMP_TARGETS) : CC:=$(TARGET_CC)
else
$(TMP_TARGETS) : CC:=$(HOST_CC)
endif
ifeq (%(includefile),)
$(TMP_TARGETS) : CFLAGS:=%(cflags)
else
$(TMP_TARGETS) : CFLAGS:="%(cflags) -include %(includefile)"
$(TMP_TARGETS) : %(includefile)
endif
$(TMP_TARGETS) : $(CXREF)
	%mkref_q cc=$(CC) from=$(SRCFILE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the libdefs.h include file for a module.
%define rule_genmodule_genlibdefs modname=/A modtype=/A modsuffix= conffile= targetdir=

TMP_TARGET := %(modname)_libdefs.h
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

%(targetdir)/%(modname)_libdefs.h : OPTS := $(TMP_OPTS)
%(targetdir)/%(modname)_libdefs.h : MODNAME := %(modname)
%(targetdir)/%(modname)_libdefs.h : MODTYPE := %(modtype)
%(targetdir)/%(modname)_libdefs.h : %(conffile) $(GENMODULE)
	@$(ECHO) "Generating $(notdir $@)"
	@$(GENMODULE) $(OPTS) writelibdefs $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate a Makefile.%(modname) with the genmodule program and include this
# generated file in this Makefile
%define rule_genmodule_makefile modname=/A modtype=/A modsuffix= conffile= \
    targetdir=

TMP_TARGET := Makefile.%(modname)
TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGET := %(targetdir)/$(TMP_TARGET)
endif

$(TMP_TARGET) : OPTS := $(TMP_OPTS)
$(TMP_TARGET) : MODNAME := %(modname)
$(TMP_TARGET) : MODTYPE := %(modtype)
$(TMP_TARGET) : $(TMP_DEPS)
	@$(GENMODULE) $(OPTS) writemakefile $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate dummy support files so cxref when used on the a module source file
# will find something to include. This rule has to be preceeded by
# %rule_genmodule_makefile
%define rule_genmodule_dummy modname=/A modtype=/A modsuffix= conffile= targetdir=

ifneq ($(%(modname)_INCLUDES),)
TMP_TARGETS := $(%(modname)_INCLUDES)

TMP_DEPS := $(GENMODULE)
TMP_OPTS := 
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating dummy include files"
	@$(GENMODULE) $(OPTS) writedummy $(MODNAME) $(MODTYPE)
endif
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files. This rule has to be preceeded by
# %rule_genmodule_makefile
%define rule_genmodule_files modname=/A modtype=/A modsuffix= targetdir= \
    conffile= reffile=/A

TMP_TARGETS := $(%(modname)_STARTFILES) $(%(modname)_ENDFILES) \
	       $(%(modname)_LINKLIBFILES)
TMP_TARGETS := $(addsuffix .c,$(TMP_TARGETS))

TMP_DEPS := $(GENMODULE) %(reffile)
TMP_OPTS := -r %(reffile)
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating functable and support files for module $(BD_MODNAME$(BDID))"
ifneq (%(conffile),lib.conf)
	@$(IF) $(TEST) -f lib.conf; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/lib.conf may probably be removed"; \
	fi
endif
	@$(IF) $(TEST) -f libdefs.h; then \
	  $(ECHO) "WARNING !!! $(CURDIR)/libdefs.h may probably be removed"; \
	fi
	@$(GENMODULE) $(OPTS) writefiles $(MODNAME) $(MODTYPE)
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Generate the support files for compiling a module. This includes include
# files and source files.
%define rule_genmodule_includes modname=/A modtype=/A modsuffix= \
    targetdir= conffile= reffile=/A


ifneq ($(%(modname)_INCLUDES),)
TMP_TARGETS := $(%(modname)_INCLUDES)

TMP_DEPS := $(GENMODULE) %(reffile)
TMP_OPTS := -r %(reffile)
ifneq (%(conffile),)
    TMP_OPTS += -c %(conffile)
    TMP_DEPS += %(conffile)
else
    TMP_DEPS += %(modname).conf
endif
ifneq (%(modsuffix),)
    TMP_OPTS += -s %(modsuffix)
endif
ifneq (%(targetdir),)
    TMP_OPTS += -d %(targetdir)
    TMP_TARGETS := $(addprefix %(targetdir)/,$(TMP_TARGETS))
endif

$(TMP_TARGETS) : OPTS := $(TMP_OPTS)
$(TMP_TARGETS) : MODNAME := %(modname)
$(TMP_TARGETS) : MODTYPE := %(modtype)
$(TMP_TARGETS) : $(TMP_DEPS)
	@$(ECHO) "Generating include files"
	@$(GENMODULE) $(OPTS) writeincludes $(MODNAME) $(MODTYPE)
endif
%end
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Common rules for all makefiles
%define common
# Delete generated makefiles
#MM
clean ::
	@$(RM) $(TOP)/$(CURDIR)/mmakefile $(TOP)/$(CURDIR)/mmakefile.bak

include $(TOP)/config/make.tail

BDID := $(BDTARGETID)
%end
#------------------------------------------------------------------------------
      

#############################################################################
#############################################################################
##                                                                         ##
## Here are the mmakefile build macro's. These are macro's that takes care ##
## of everything to go from the sources to the generated target. Also all  ##
## intermediate files and directories that are needed are created by these ##
## rules.                                                                  ##
##                                                                         ##
#############################################################################
#############################################################################

#------------------------------------------------------------------------------
# Build a program
%define build_prog mmake=/A progname=/A files=$(BD_PROGNAME$(BDID)) asmfiles= \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    aflags=$(AFLAFS) uselibs= usehostlibs= usestartup=yes detach=no nix=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_PROGNAME$(BDID)  := %(progname)
BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_ASMFILES$(BDID)  := %(asmfiles)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))

BD_CFLAGS$(BDID)    := %(cflags)
BD_AFLAGS$(BDID)    := %(aflags)
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))

%rule_link_prog prog=$(BD_TARGETDIR$(BDID))/$(BD_PROGNAME$(BDID)) \
    objs=$(BD_OBJS$(BDID)) ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)" nix="%(nix)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build programs, for every C file an executable will be built with the same
# 
%define build_progs mmake=/A files=/A \
    objdir=$(GENDIR)/$(CURDIR) targetdir=$(AROSDIR)/$(CURDIR) \
    cflags=$(CFLAGS) dflags=$(BD_CFLAGS$(BDID)) ldflags=$(LDFLAGS) \
    uselibs= usehostlibs= usestartup=yes detach=no

.PHONY : %(mmake) %(mmake)-setup

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-quick"

BD_OBJDIR$(BDID)    := %(objdir)
BD_TARGETDIR$(BDID) := %(targetdir)

BD_FILES$(BDID)     := %(files)
BD_OBJS$(BDID)      := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_DEPS$(BDID)      := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_FILES$(BDID))))
BD_EXES$(BDID)      := $(addprefix $(BD_TARGETDIR$(BDID))/,$(BD_FILES$(BDID)))

BD_CFLAGS$(BDID)    := %(cflags)
ifneq ($(strip $(filter arosc_shared,%(uselibs))),)
BD_CFLAGS$(BDID)    += -D_CLIB_LIBRARY_ -I$(TOP)/rom/exec
endif
BD_DFLAGS$(BDID)    := %(dflags)
BD_LDFLAGS$(BDID)   := %(ldflags)

#MM %(mmake) : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_EXES$(BDID))

#MM %(mmake)-setup
%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_TARGETDIR$(BDID))" \
    setuptarget=%(mmake)-setup

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick),)
%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
    cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))

%rule_link_progs progs=$(BD_FILES$(BDID)) \
    targetdir=$(BD_TARGETDIR$(BDID)) objdir=$(BD_OBJDIR$(BDID)) \
    ldflags=$(BD_LDFLAGS$(BDID)) \
    uselibs="%(uselibs)" usehostlibs="%(usehostlibs)" \
    usestartup="%(usestartup)" detach="%(detach)"

endif

%include_deps depstargets="%(mmake) %(mmake)-quick" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module
# Explanation of this macro is done in the developer's manual
%define build_module mmake=/A modname=/A modtype=/A modsuffix= \
  conffile= files="$(basename $(wildcard *.c))" \
  linklibfiles= cflags=$(CFLAGS) dflags=$(BD_DEFDFLAGS) \
  objdir=$(OBJDIR) moduledir=$(BD_DEFMODDIR) prefix=$(AROSDIR) \
  reffile=$(BD_DEFREFFILE) noref= \
  linklibname=$(BD_DEFLINKLIBNAME) uselibs= compiler=target genincludes=

# Define metamake targets and their dependencies
#MM- includes-all : %(mmake)-includes
#MM %(mmake) : %(mmake)-includes
#MM %(mmake)-kobj : %(mmake)-includes
#MM %(mmake)-quick : %(mmake)-includes-quick
#MM %(mmake)-includes : %(mmake)-setup includes-generate-deps
#MM %(mmake)-includes-quick
#MM %(mmake)-setup : %(mmake)-makefile
#MM %(mmake)-makefile : %(mmake)-objdir
#MM %(mmake)-objdir
#MM %(mmake)-clean

# All MetaMake targets defined by this macro
BD_ALLTARGETS := %(mmake) %(mmake)-includes %(mmake)-clean %(mmake)-quick \
    %(mmake)-kobj %(mmake)-setup

.PHONY : $(BD_ALLTARGETS) %(mmake)-makefile %(mmake)-objdir

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# Default values for variables and arguments
BD_DEFLINKLIBNAME := %(modname)
BD_DEFREFFILE := %(objdir)/%(modname)_ALL.ref
BD_DEFMODDIR := $(%(modname)_MODDIR)
BD_DEFDFLAGS := %(cflags)
OBJDIR ?= $(GENDIR)/$(CURDIR)

## Create objdir
##
%rule_makedirs dirs=%(objdir) setuptarget=%(mmake)-objdir


## Create genmodule include Makefile for the module
##
%(mmake)-makefile : %(objdir)/Makefile.%(modname)

%rule_genmodule_makefile \
    modname=%(modname) modtype=%(modtype) \
    modsuffix=%(modsuffix) targetdir=%(objdir) \
    conffile=%(conffile)


# Do not parse these statements if metatarget is not appropriate
ifneq ($(filter $(TARGET),$(BD_ALLTARGETS)),)

include %(objdir)/Makefile.%(modname)


## include files generation
##
BD_INCDIR    := %(prefix)/$(AROS_DIR_INCLUDE)
ifeq (%(genincludes),yes)
    %(modname)_INCLUDES := proto/%(modname).h clib/%(modname)_protos.h defines/%(modname).h 
endif
ifeq (%(genincludes),no)
    %(modname)_INCLUDES :=
endif

%(mmake)-includes-quick : %(mmake)-includes
%(mmake)-includes : $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES))

ifneq ($(%(modname)_INCLUDES),)
%rule_genmodule_includes modname=%(modname) modtype=%(modtype) \
		      	 modsuffix=%(modsuffix) targetdir=$(GENINCDIR) \
		      	 conffile=%(conffile) reffile=%(reffile)

%rule_copy_multi \
    files=$(%(modname)_INCLUDES) srcdir=$(GENINCDIR) targetdir=$(BD_INCDIR)


%rule_genmodule_dummy modname=%(modname) modtype=%(modtype) \
		      modsuffix=%(modsuffix) \
		      targetdir=%(objdir)/dummyinc conffile=%(conffile)

BD_INCDIRS := $(filter-out ./,$(sort $(dir $(%(modname)_INCLUDES))))
BD_INCDIRS := $(BD_INCDIR) $(addprefix $(BD_INCDIR)/,$(BD_INCDIRS)) \
    $(addprefix %(objdir)/dummyinc/,$(BD_INCDIRS))
%rule_makedirs dirs=$(BD_INCDIRS) setuptarget=%(mmake)-setup

endif

%rule_genmodule_genlibdefs modname=%(modname) modtype=%(modtype) \
		 	   modsuffix=%(modsuffix) targetdir=%(objdir) \
		 	   conffile=%(conffile)

BD_LIBDEFSINC := %(objdir)/%(modname)_libdefs.h

%(objdir)/%(modname)_deflibdefs.h : FILENAME := $(BD_LIBDEFSINC)
%(objdir)/%(modname)_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(FILENAME)\"" >$@


## Extra genmodule src files generation
## 
%rule_genmodule_files modname=%(modname) modtype=%(modtype) \
		      modsuffix=%(modsuffix) targetdir=%(objdir) \
		      conffile=%(conffile) reffile=%(reffile)

## Compilation
##
BD_FILES      := %(files)
BD_STARTFILES := $(addprefix %(objdir)/,$(%(modname)_STARTFILES))
BD_ENDFILES   := $(addprefix %(objdir)/,$(%(modname)_ENDFILES))

BD_ARCHOBJS   := $(wildcard %(objdir)/arch/*.o)
BD_ARCHFILES  := $(basename $(notdir $(BD_ARCHOBJS)))
BD_NARCHFILES := $(filter-out $(BD_ARCHFILES),$(BD_FILES))

BD_CFLAGS     := %(cflags) -I%(objdir) -idirafter $(TOP)/$(CURDIR) -include %(objdir)/%(modname)_deflibdefs.h
BD_DFLAGS     := %(dflags) -I%(objdir) -include %(objdir)/%(modname)_deflibdefs.h

BD_LINKLIBFILES := $(addprefix %(objdir)/,$(%(modname)_LINKLIBFILES))
ifeq ($(strip $(%(modname)_LINKLIBFILES) %(linklibfiles)),)
    BD_LINKLIB :=
else
    BD_LINKLIB := %(prefix)/$(AROS_DIR_LIB)/lib%(linklibname).a
endif

BD_CCFILES := $(BD_NARCHFILES) $(BD_STARTFILES) \
    $(BD_ENDFILES) $(BD_LINKLIBFILES) %(linklibfiles)

%rule_compile_multi \
    basenames=$(BD_CCFILES) targetdir=%(objdir) \
    cflags=$(BD_CFLAGS) dflags=$(BD_DFLAGS) \
    compiler=%(compiler)

## function reference files generation
##
%rule_ref_multi \
    basenames=$(BD_FILES) targetdir=%(objdir) \
    cflags="-I$(dir $(GENMODULE))/genmod_inc -I%(objdir)/dummyinc $(strip $(BD_CFLAGS))" \
    compiler=%(compiler)

ifeq (%(noref),)
BD_REFS   := $(addprefix %(objdir)/,$(addsuffix .ref, $(notdir $(BD_FILES))))
else
BD_REFS   := $(addprefix %(objdir)/,$(addsuffix .ref, $(notdir $(filter-out %(noref),$(BD_FILES)))))
endif

%rule_join from=$(BD_REFS) to=%(reffile) \
	   text="Collecting function references for module %(modname)"


## Linking
##
ifeq (%(modsuffix),)
BD_MODULE    := %(prefix)/%(moduledir)/%(modname).%(modtype)
BD_KOBJ      := $(KOBJSDIR)/%(modname)_%(modtype).o
else
BD_MODULE    := %(prefix)/%(moduledir)/%(modname).%(modsuffix)
BD_KOBJ      := $(KOBJSDIR)/%(modname)_%(modsuffix).o
endif

%(mmake)-quick : %(mmake)
%(mmake) : $(BD_MODULE) $(BD_LINKLIB)
%(mmake)-kobj : $(BD_KOBJ)

BD_OBJS       := $(addsuffix .o,$(BD_STARTFILES)) $(BD_ARCHOBJS) \
	     	 $(addsuffix .o, $(addprefix %(objdir)/,$(notdir $(BD_NARCHFILES))))
BD_ENDOBJS    := $(addsuffix .o,$(BD_ENDFILES))
BD_LINKLIBOBJS:= $(addsuffix .o,$(addprefix %(objdir)/,$(notdir %(linklibfiles))) $(BD_LINKLIBFILES))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE) objs=$(BD_OBJS) \
		 endobj=$(BD_ENDOBJS) err=$(BD_MODNAME).err uselibs="%(uselibs)"

# Link static lib
ifneq ($(BD_LINKLIB),)
%rule_makedirs dirs=%(prefix)/$(AROS_DIR_LIB) setuptarget=%(mmake)-setup
%rule_link_linklib libname=%(linklibname) objs=$(BD_LINKLIBOBJS) libdir=%(prefix)/$(AROS_DIR_LIB)
endif

# Link kernel object file
$(BD_KOBJ) : $(BD_OBJS) $(BD_ENDOBJS)
	@$(ECHO) "Linking $@"
	@$(AROS_LD) -Ur -o $@ $^
	@$(OBJCOPY) $@ `$(NM_PLAIN) $@ | $(AWK) '$$3 ~ /^__.*_(LIST|END)__$$/ {print "-L " $$3;}'`


## Dependency fine-tuning
##
%rule_makedirs dirs="%(objdir) %(moduledir) $(KOBJSDIR)" setuptarget=%(mmake)-setup

BD_DEPS := $(addsuffix .d,$(addprefix %(objdir)/,$(notdir $(BD_CCFILES))))
%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-kobj" deps=$(BD_DEPS)

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-includes %(mmake)-quick %(mmake)-kobj),) # Only for this target these deps are wanted
BD_REFFILE_DEPS := $(BD_LIBDEFSINC) %(objdir)/%(modname)_deflibdefs.h \
    $(addprefix %(objdir)/dummyinc/,$(%(modname)_INCLUDES))
$(BD_REFS) : $(BD_REFFILE_DEPS) $(dir $(GENMODULE))/genmod_inc/aros/libcall.h

BD_DFILE_DEPS := $(BD_LIBDEFSINC) %(objdir)/%(modname)_deflibdefs.h \
    $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES))
$(BD_DEPS) : $(BD_DFILE_DEPS)
endif

BD_TOCLEAN := $(BD_OBJS) $(BD_DEPS) %(reffile) \
    $(BD_REFS) $(BD_MODULE) $(BD_LINKLIB) $(BD_KOBJ) \
    $(addprefix $(GENINCDIR)/,$(%(modname)_INCLUDES)) \
    $(addprefix $(BD_INCDIR)/,$(%(modname)_INCLUDES)) \
    $(addprefix .c,$(BD_LINKLIBFILES)) $(BD_LINKLIBOBJS) $(BD_LIBDEFSINC) \
    %(objdir)/%(modname)_deflibdefs.h \
    $(addsuffix .c,$(BD_STARTFILES) $(BD_ENDFILES)) \
    $(BD_ENDOBJS)
%(mmake)-clean : FILES := $(BD_TOCLEAN)
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module %(modname)"
	@$(RM) $(FILES)

endif # $(TARGET) in $(BD_ALLTARGETS)
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a module using the deprecated macro's to define the functions in the
# library. Explanation of this macro is done in the developer's manual
%define build_module_macro mmake=/A modname=/A modtype=/A dir= \
  conffile=$(BD_MODNAME$(BDID)).conf initfile=$(BD_MODNAME$(BDID))_init \
  funcs= files= linklibfiles= cflags=$(CFLAGS) dflags= \
  objdir=$(OBJDIR) uselibs= usehostlibs= \
  genfunctable= genincludes= compiler=target

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-includes %(mmake)-linklib %(mmake)-quick %(mmake)-kobj"

.PHONY : setup-module$(BDID)

ifeq (%(modname),)
$(error using %build_module: modname may not be empty)
endif
ifeq (%(modtype),)
$(error using %build_module: $(MODTYPE) has to be defined with the type of the module)
endif

# assign and generate the local variables used in this macro
BD_MODNAME$(BDID)    := %(modname)
BD_MODTYPE$(BDID)    := %(modtype)
BD_MODDIR$(BDID)     := %(dir)
BD_CONFFILE$(BDID)   := %(conffile)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)

BD_ARCHOBJS$(BDID)   := $(wildcard $(BD_OBJDIR$(BDID))/arch/*.o)
BD_ARCHFILES$(BDID)  := $(basename $(notdir $(BD_ARCHOBJS$(BDID))))

BD_INITFILE$(BDID)   := %(initfile)
BD_FUNCS$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(funcs))
BD_FILES$(BDID)      := $(filter-out $(BD_ARCHFILES$(BDID)),%(files))
BD_LIBFILES$(BDID)   := %(linklibfiles)
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
BD_ENDFILE$(BDID)    := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_end
else
BD_ENDFILE$(BDID)    := 
endif

BD_FUNCSRCS$(BDID)   := $(addsuffix .c,%(funcs))
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
ifeq ($(filter $(BD_INITFILE$(BDID)), $(BD_ARCHFILES$(BDID))),)
  BD_INITOBJ$(BDID)  := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_INITFILE$(BDID)))))
else
  TMP_INITREPLACE    := $(filter $(notdir $(BD_INITFILE$(BDID))), $(BD_ARCHFILES$(BDID)))
  TMP_INITKEEP       := $(filter-out $(TMP_INITREPLACE),$(notdir $(BD_INITFILE$(BDID))))
  BD_INITOBJ$(BDID)  := $(addsuffix .o, \
  		     	    $(addprefix $(BD_OBJDIR$(BDID))/arch/,$(TMP_INITREPLACE)) \
			    $(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_INITKEEP)) \
			 )
  BD_ARCHOBJS$(BDID) := $(filter-out $(BD_INITOBJ$(BDID)),$(BD_ARCHOBJS$(BDID)))
endif

TMP_FILES            := $(notdir $(BD_FILES$(BDID)))
ifeq (%(genfunctable),yes)
  TMP_FILES          := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifeq (%(genfunctable),)
      ifneq ($(BD_MODTYPE$(BDID)),resource)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    else
      ifneq (%(genfunctable),no)
        TMP_FILES    := $(BD_MODNAME$(BDID))_functable $(TMP_FILES)
      endif
    endif
    TMP_FILES        += $(BD_FUNCS$(BDID))
  endif
endif
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(TMP_FILES))) $(BD_ARCHOBJS$(BDID))
BD_ENDOBJ$(BDID)     := $(addsuffix .o,$(BD_ENDFILE$(BDID)))

BD_DEPS$(BDID)       := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(BD_INITFILE$(BDID)) $(TMP_FILES)))

BD_GENINCS$(BDID)    :=
ifneq (%(genincludes),)
  ifeq (%(genincludes),yes)
    BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
  endif
else
  ifneq ($(BD_FUNCS$(BDID)),)
    ifneq ($(findstring $(BD_MODTYPE$(BDID)),library gadget device),)
      BD_GENINCS$(BDID):= clib/$(BD_MODNAME$(BDID))_protos.h defines/$(BD_MODNAME$(BDID)).h proto/$(BD_MODNAME$(BDID)).h
    endif
  endif
endif
# Only generate libdefs.h if the config file exists
ifneq ($(wildcard $(BD_CONFFILE$(BDID))),)
  BD_LIBDEFSINC$(BDID):= $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_libdefs.h
else
  BD_LIBDEFSINC$(BDID):=
endif

BD_CFLAGS$(BDID)     := %(cflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags) -I$(BD_OBJDIR$(BDID)) -I. -I$(TOP)/workbench/libs -include $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
endif

# Add additional files depending the module type
ifeq ($(findstring $(BD_MODTYPE$(BDID)),library gadget datatype handler device resource mui mcc mcp hidd),)
    $(error unhandled MODTYPE %(modtype))
endif
ifeq ($(BD_MODDIR$(BDID)),)
  ifeq ($(BD_MODTYPE$(BDID)),library)
    BD_MODDIR$(BDID)  := $(AROS_LIBS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),gadget)
    BD_MODDIR$(BDID)  := $(AROS_GADGETS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),datatype)
    BD_MODDIR$(BDID)  := $(AROS_DATATYPES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),handler)
    BD_MODDIR$(BDID)  := $(AROS_FS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),device)
    BD_MODDIR$(BDID)  := $(AROS_DEVS)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),resource)
    BD_MODDIR$(BDID)  := $(AROS_RESOURCES)
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mui)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mcc)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),mcp)
    BD_MODDIR$(BDID)  := $(AROS_CLASSES)/Zune
  endif
  ifeq ($(BD_MODTYPE$(BDID)),hidd)
    BD_MODDIR$(BDID)  := $(AROS_DRIVERS)
  endif
endif

BD_MODULE$(BDID)    := $(BD_MODDIR$(BDID))/$(BD_MODNAME$(BDID)).$(BD_MODTYPE$(BDID))
BD_GENFILES$(BDID)  := $(BD_MODULE$(BDID))
BD_DEPS$(BDID)      += $(BD_LINKLIBDEPS$(BDID))

#MM- includes-all : %(mmake)-includes
#MM %(mmake) : %(mmake)-includes %(mmake)-setup
#MM %(mmake)-includes : %(mmake)-setup

#MM
%(mmake)-quick : %(mmake)

%(mmake) : $(BD_GENFILES$(BDID))

#MM
%(mmake)-clean ::
	@$(ECHO) "Cleaning up for module $(BD_MODNAME$(BDID))"
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID)) \
	    $(addprefix $(BD_OBJDIR$(BDID))/,$(addsuffix .c,$(BD_GENFILES$(BDID)))) \
	    $(addprefix $(GENINCDIR)/,$(BD_GENINCS$(BDID))) \
	    $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID))) \
	    $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
	    $(BD_ENDFILE$(BDID)).c $(BD_ENDOBJ$(BDID))

#MM
%(mmake)-setup : setup-module$(BDID)

#MM %(mmake)-includes : setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-includes : $(TMP_DEPS)
  
$(TMP_DEPS) : $(BD_LIBDEFSINC$(BDID))

ifneq ($(filter $(TARGET),%(mmake) %(mmake)-linklib %(mmake)-quick %(mmake)-kobj),) # Avoid conflicts
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FUNCS$(BDID)) $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_ENDFILE$(BDID)) targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
%rule_compile basename=$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_functable targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID)) \
	      compiler=%(compiler)
endif

BD_DFILE_DEPS$(BDID) := $(BD_LIBDEFSINC$(BDID)) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h

# Some include files need to be generated before the .c can be parsed.
ifneq ($(filter $(TARGET),%(mmake) %(mmake)-quick %(mmake)-linklib) %(mmake)-kobj,) # Only for this target these deps are wanted
$(BD_DEPS$(BDID)) : $(BD_DFILE_DEPS$(BDID))
endif

# Generation of the autogenerated .c and .h files.
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h :
	@$(ECHO) "generating $@"
	@$(ECHO) "#define LC_LIBDEFS_FILE \"$(notdir $(BD_LIBDEFSINC$(BDID)))\"" >$@

%libdefs_rule conffile=$(BD_CONFFILE$(BDID)) dest=$(BD_LIBDEFSINC$(BDID))

ifneq ($(BD_ENDFILE$(BDID)),)
$(BD_ENDFILE$(BDID)).c :
	@$(ECHO) "generating $@"
	@$(ECHO) "#include <libcore/libtail.c>" >$@
endif

%rule_genfunctable name=$(BD_MODNAME$(BDID))_functable files=$(BD_FUNCS$(BDID)) dir=$(BD_OBJDIR$(BDID)) \
  libdefs=$(BD_LIBDEFSINC$(BDID))

# The module is linked from all the compiled .o files
%rule_linkmodule module=$(BD_MODULE$(BDID)) objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID))" \
		 endobj=$(BD_ENDOBJ$(BDID)) err=$(BD_MODNAME).err uselibs="%(uselibs)" \
		 usehostlibs="%(usehostlibs)"

BD_HEADER_DEPS$(BDID) := $(wildcard headers.tmpl) $(BD_LIBDEFSINC$(BDID)) \
	    $(BD_FUNCSRCS$(BDID)) \
	    $(SCRIPTDIR)/genshared \
	    $(SCRIPTDIR)/genclib.awk $(SCRIPTDIR)/genpclib.awk \
	    $(SCRIPTDIR)/gendefines.awk $(SCRIPTDIR)/genpdefines.awk

# Regenerate the includes when some of the dependencies are changed
$(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp : $(BD_HEADER_DEPS$(BDID))
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -defines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $@

# Generate includes the first time they are needed
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_private_protos.h \
$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h \
$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h \
$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h :
	@$(SCRIPTDIR)/genshared -clib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -proto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pclib -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pdefines -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(SCRIPTDIR)/genshared -pproto -libdefsfile $(BD_LIBDEFSINC$(BDID)) -prefix $(GENINCDIR) $(BD_FUNCSRCS$(BDID))
	@$(TOUCH) $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp

# The include files generated in $(GENINCDIR) have to be mirrored in the AROS include directory
%rule_copy from=$(GENINCDIR)/clib/$(BD_MODNAME$(BDID))_protos.h to=$(AROS_INCLUDES)/clib/$(BD_MODNAME$(BDID))_protos.h
%rule_copy from=$(GENINCDIR)/defines/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/defines/$(BD_MODNAME$(BDID)).h
#%rule_copy from=$(GENINCDIR)/pragmas/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/pragmas/$(BD_MODNAME$(BDID)).h
%rule_copy from=$(GENINCDIR)/proto/$(BD_MODNAME$(BDID)).h to=$(AROS_INCLUDES)/proto/$(BD_MODNAME$(BDID)).h

MYDIRS$(BDID) := $(BD_OBJDIR$(BDID)) $(GENINCDIR) $(GENINCDIR)/clib \
  $(GENINCDIR)/proto $(GENINCDIR)/defines \
  $(GENINCDIR)/pragmas $(AROS_INCLUDES) $(AROS_INCLUDES)/clib $(AROS_INCLUDES)/proto \
  $(AROS_INCLUDES)/defines $(AROS_INCLUDES)/pragmas \
  $(BD_MODDIR$(BDID)) $(KOBJSDIR)

%rule_makedirs dirs=$(MYDIRS$(BDID)) setuptarget=setup-module$(BDID)

#MM %(mmake)-linklib : %(mmake)-setup setup-clib
#MM %(mmake)-kobj : %(mmake)-setup setup-clib

TMP_DEPS := $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_deflibdefs.h \
  $(BD_LIBDEFSINC$(BDID))
ifneq ($(BD_GENINCS$(BDID)),)
TMP_DEPS += $(BD_OBJDIR$(BDID))/$(BD_MODNAME$(BDID))_includes.stamp \
  $(addprefix $(AROS_INCLUDES)/,$(BD_GENINCS$(BDID)))
endif

%(mmake)-linklib : $(TMP_DEPS)
%(mmake)-kobj : $(TMP_DEPS)

# Link only when target %(mmake)-linklib otherwise for example jpeg.datatype
# that depend on the jpeg library can cause to get this rule executed unwanted
ifneq ($(filter $(TARGET),%(mmake)-linklib %(mmake)-kobj),)
%(mmake)-linklib : $(LIBDIR)/lib$(BD_MODNAME$(BDID)).a
%(mmake)-kobj : $(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o

%rule_link_linklib libname=$(BD_MODNAME$(BDID)) libdir=$(LIBDIR) \
  objs="$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))"

$(KOBJSDIR)/$(BD_MODNAME$(BDID))_$(BD_MODTYPE$(BDID)).o : \
$(BD_INITOBJ$(BDID)) $(BD_OBJS$(BDID)) $(BD_ENDOBJ$(BDID))
	@$(ECHO) "Linking $@"
	$(AROS_LD) -Ur -o $@ $^
	$(OBJCOPY) $@ `$(NM_PLAIN) $@ | $(AWK) '$$3 ~ /^__.*_(LIST|END)__$$/ {print "-L " $$3;}'`
endif

%include_deps depstargets="%(mmake) %(mmake)-quick %(mmake)-linklib %(mmake)-kobj" deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build a linklib.
# - mmake is the mmaketarget
# - libname is the baselibname e.g. lib%(libname).a will be created
# - files are the C source files to include in the lib. The list of files
#   has to be given without the .c suffix
# - asmfiles are the asm files to include in the lib. The list of files has to
#   be given with the .s suffix
# - cflags are the flags to compile the source (default $(CFLAGS))
# - dflags are the flags use during makedepend (default equal to cflags)
# - aflags are the flags use during assembling (default $(AFLAGS))
# - objdir is where the .o are generated
# - libdir is the directory where the linklib will be placed (default $(LIBDIR))
%define build_linklib mmake=/A libname=/A files="$(basename $(wildcard *.c))" \
  asmfiles= cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) objdir=$(OBJDIR) libdir=$(LIBDIR)

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

# assign and generate the local variables used in this macro
BD_LIBNAME$(BDID)    := %(libname)
OBJDIR               ?= $(GENDIR)/$(CURDIR)
BD_OBJDIR$(BDID)     := %(objdir)
BD_LIBDIR$(BDID)     := %(libdir)

BD_FILES$(BDID)      := %(files)
BD_ASMFILES$(BDID)   := %(asmfiles)
BD_SRCS$(BDID)       := $(addsuffix .c,$(BD_FILES$(BDID)))
BD_OBJS$(BDID)       := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir $(BD_FILES$(BDID)) $(BD_ASMFILES$(BDID)))))
BD_DEPS$(BDID)       := $(patsubst %.o,%.d,$(BD_OBJS$(BDID)))

BD_CFLAGS$(BDID)     := %(cflags)
ifeq (%(dflags),)
BD_DFLAGS$(BDID)     := $(BD_CFLAGS$(BDID))
else
BD_DFLAGS$(BDID)     := %(dflags)
endif
BD_AFLAGS$(BDID)     := %(aflags)

BD_LINKLIB$(BDID)    := $(BD_LIBDIR$(BDID))/lib$(BD_LIBNAME$(BDID)).a

.PHONY : setup-linklib$(BDID)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_LINKLIB$(BDID))

#MM
%(mmake)-setup : setup-linklib$(BDID)

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID)) $(BD_DEPS$(BDID))

%rule_makedirs dirs="$(BD_OBJDIR$(BDID)) $(BD_LIBDIR$(BDID))" \
	       setuptarget=setup-linklib$(BDID)

ifeq ($(TARGET),%(mmake))
ifneq ($(dir $(BD_FILES$(BDID))),./)
vpath %.c $(filter-out ./,$(dir $(BD_FILES$(BDID))))
endif

%rule_compile basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	      cflags=$(BD_CFLAGS$(BDID)) dflags=$(BD_DFLAGS$(BDID))
%rule_assemble basename=% targetdir=$(BD_OBJDIR$(BDID)) \
	       flags=$(BD_AFLAGS$(BDID))
endif

%rule_link_linklib libname=%(libname) objs=$(BD_OBJS$(BDID)) libdir=$(BD_LIBDIR$(BDID))

%include_deps depstargets=%(mmake) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Build catalogs.
# - mmake is the mmaketarget
# - catalogs is the list of catalogs, without the .ct suffix (default *.ct)
# - description is the catalog description file (.cd) (default *.cd)
# - subdir is the destination subdir of the catalogs
# - name is the name of the destination catalog, without the .catalog suffix
# - source is the path to the generated source code file
# - dir is the base destination directory (default $(AROS_CATALOGS))
# - sourcedescription is the path to the FlexCat's source description file, without the .sd suffix

%define build_catalogs mmake=/A name=/A subdir=/A \
 catalogs="$(basename $(wildcard *.ct))" source="../strings.h" \
 description="$(basename $(wildcard *.cd))" dir=$(AROS_CATALOGS) \
 sourcedescription="$(TOOLDIR)/C_h_orig"

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_SRCS$(BDID) := $(foreach name, %(catalogs), $(name).ct)
BD_OBJS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir)/%(name).catalog)
BD_DIRS$(BDID) := $(foreach name, %(catalogs), %(dir)/$(name)/%(subdir))

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID)) %(source)

#MM %(mmake)-setup
%rule_makedirs dirs=$(BD_DIRS$(BDID)) setuptarget=%(mmake)-setup

%(dir)/%/%(subdir)/%(name).catalog : %.ct %(description).cd
	@$(ECHO) "Creating %(name) catalog for language $*."
	@$(FLEXCAT) %(description).cd $*.ct CATALOG=%(dir)/$*/%(subdir)/%(name).catalog || [ $$? -lt 10 ]

ifneq (%(source),)
%(source) : %(description).cd
	@$(ECHO) "Creating %(name) catalog source file %(source)"
	@$(FLEXCAT) %(description).cd %(source)=%(sourcedescription).sd
endif

#MM
%(mmake)-clean ::
	$(RM) $(BD_OBJS$(BDID)) %(source)

.PHONY: %(mmake) %(mmake-setup) %(mmake-clean)

%end

#-----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
# Build icons.
# - mmake is the mmaketarget
# - icons is a list of icon base names (ie. without the .info suffix)
# - dir is the destination directory
#-----------------------------------------------------------------------------

%define build_icons mmake=/A icons=/A dir=/A

%buildid targets="%(mmake) %(mmake)-setup %(mmake)-clean"

BD_OBJS$(BDID) := $(foreach icon, %(icons), %(dir)/$(icon).info)

#MM %(mmake) : %(mmake)-setup

%(mmake) : $(BD_OBJS$(BDID))

%(dir)/%.info : %.info.src %.png
	@$(ECHO) Creating $(notdir $@)...
	@$(ILBMTOICON) $+ $@

#MM %(mmake)-setup
%rule_makedirs dirs=%(dir) setuptarget=%(mmake)-setup

#MM
%(mmake)-clean ::
	@$(RM) $(BD_OBJS$(BDID))

.PHONY: %(mmake)

%end

#-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Compile files for a arch specific replacement of code for a module
# - files: the basename of the C files to compile.
# - asmfiles: the basename of the asm file to assemble.
# - mainmmake: the mmake of the module in the main directory to compile these
#   arch specific files for.
# - maindir: the object directory for the main module
# - arch: the arch for which to compile these files. It can has to have the form
#   of ARCH, CPU or ARCH-CPU, e.g. linux, i386 or linux-i386
# - cflags (default $(CFLAGS)): the C flags to use for compilation
# - dflags: the flags used during creation of dependency file. If not specified
#   the same value as cflags will be used
# - aflags: the flags used during assembling
# - compiler: (host or target) specifies which compiler to use. By default
#   the target compiler is used
%define build_archspecific files= asmfiles= mainmmake=/A maindir=/A arch=/A \
cflags=$(CFLAGS) dflags= aflags=$(AFLAGS) compiler=target modulename=

ifeq (%(files) %(asmfiles),)
  $(error no files or asmfiles given)
endif

%buildid targets="%(mainmmake)-%(arch) %(mainmmake)-%(arch)-setup"

#MM- %(mainmmake) : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-linklib : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)
#MM- %(mainmmake)-kobj : %(mainmmake)-$(ARCH)-$(CPU) %(mainmmake)-$(ARCH) %(mainmmake)-$(CPU)

#MM %(mainmmake)-%(arch) : %(mainmmake)-%(arch)-setup %(mainmmake)-includes

ifeq (%(arch),)
  $(error argument arch has to be non empty for the rule_compile_archspecific macro)
endif

BD_OBJDIR$(BDID)  := $(GENDIR)/%(maindir)/arch
BD_COBJS$(BDID)   := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))
BD_ASMOBJS$(BDID) := $(addsuffix .o,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(asmfiles))))
BD_OBJS$(BDID)    := $(BD_COBJS$(BDID)) $(BD_ASMOBJS$(BDID))
BD_DEPS$(BDID)    := $(addsuffix .d,$(addprefix $(BD_OBJDIR$(BDID))/,$(notdir %(files))))

ifeq ($(TARGET),%(mainmmake)-%(arch))
vpath %.c $(filter-out ./,$(dir %(files)))
vpath %.s $(filter-out ./,$(dir %(asmfiles)))
vpath %.S $(filter-out ./,$(dir %(asmfiles)))
endif

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

#MM
%(mainmmake)-%(arch) :: $(BD_OBJS$(BDID))

#MM %(mainmmake)-%(arch)-setup
%rule_makedirs dirs=$(BD_OBJDIR$(BDID)) setuptarget=%(mainmmake)-%(arch)-setup

ifeq ($(findstring %(compiler),host target),)
  $(error unknown compiler %(compiler))
endif
ifeq (%(compiler),target)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(TARGET_CC)
endif
ifeq (%(compiler),host)
$(BD_COBJS$(BDID)) : TMP_CMD:=$(HOST_CC)
endif
ifneq (%(modulename),)
$(BD_COBJS$(BDID)) : TMP_CFLAGS:=%(cflags) -I$(GENDIR)/%(maindir) \
                     --include $(GENDIR)/%(maindir)/%(modulename)_deflibdefs.h
else
$(BD_COBJS$(BDID)) : TMP_CFLAGS:=%(cflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.c
	%compile_q opt=$(TMP_CFLAGS) cmd=$(TMP_CMD)
endif

ifeq (%(dflags),)
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(cflags)
else
$(BD_DEPS$(BDID)) : TMP_DFLAGS:=%(dflags)
endif
ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.d : %.c
	%mkdepend_q flags=$(TMP_DFLAGS)
endif

$(BD_ASMOBJS$(BDID)) : AFLAGS:=%(aflags)

ifeq ($(TARGET),%(mainmmake)-%(arch))
$(BD_OBJDIR$(BDID))/%.o : %.s
	%assemble_q opt=$(AFLAGS)
$(BD_OBJDIR$(BDID))/%.o : %.S
	%assemble_q opt=$(AFLAGS)
endif

%include_deps depstargets=%(mainmmake)-%(arch) deps=$(BD_DEPS$(BDID))
%end
#------------------------------------------------------------------------------







# ======================
# Old stuff, will probably be removed in the future




# GNU Make automatic variables
# $@ current target
# $< First dependency
# $? All newer dependencies
# $^ All dependencies
# $* The stem (ie. target is dir/a.foo.b and the pattern is
#    a.%.b, then the stem is dir/foo)

#------------------------------------------------------------------------------
# rule to generate libdefs.h with archtool (options may go away!)
%define libdefs_rule conffile=lib.conf genlibdefstool=$(ARCHTOOL) dest=libdefs.h
%(dest) : %(conffile) %(genlibdefstool)
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@%(genlibdefstool) -c -o $@ %(conffile)
%end


#------------------------------------------------------------------------------
# generate asm files from c files (for debugging purposes)
%define ctoasm_q
%.s : %.c
	@$(ECHO) "Generating $(CURDIR)/$(notdir $@)..."
	@$(TARGET_CC) -S $(CFLAGS) $< -c -o $@
%end

#------------------------------------------------------------------------------
# Convert two png images to an Amiga icon file based on the description
# file %(from), with outputfile going to %(to).
%define makeicon2 from=$< to=$@ img1="$(basename $(basename $<))_N.png" img2="$(basename $(basename $<))_S.png"
	@$(ECHO) "Creating icon %(to)..."
	@$(PNGTOPNM) %(img1) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon1.iff
	@$(PNGTOPNM) %(img2) | $(PPMTOILBM) -maxplanes 8 >$(GENDIR)/genicon2.iff
	@$(ILBMTOICON) %(from) $(GENDIR)/genicon1.iff $(GENDIR)/genicon2.iff %(to)
%end

#------------------------------------------------------------------------------
# NOTE: The following are all part of Iain's build changes, please don't use
# or change anything below this line until you know what you are doing. This
# is so that I don't conflict with the semantics of any of the above macros.
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# Copy files from one directory to another.

%define copy_files_q files=$(FILES) src=. dst=/A maketarget=files-copy

SRC_FILES := $(foreach f, %(files), %(src)/$(f))
DST_FILES := $(foreach f, %(files), %(dst)/$(f))

%(maketarget) : setup $(DST_FILES)

$(DST_FILES) : %(dst)/% : %(src)/%
	@$(CP) $< $@
	
setup ::
	%mkdirs_q %(dst)

%end

#----------------------------------------------------------------------------------
# Copy a diretory recursively to another place, preserving the original 
# hierarchical structure
#
# src: the source directory whose content will be copied
# dst: the directory where to copy src's content. If not existing, it will be made.

%define copy_dir_recursive mmake=/A src=$(TOP)/$(CURDIR) dst=/A

%(mmake)_FILES := $(shell cd %(src); find . -path '*/CVS' -prune -o -path '*/.svn' -prune -o -name .cvsignore -prune -o -name mmakefile -prune -o -name mmakefile.src -prune -o -type f -print)
%(mmake)_DIRS  := $(sort $(foreach f,$(%(mmake)_FILES),$(dir $(f))))

define %(mmake)_mkdir
$(1):
	$(MKDIR) $$@
endef

define %(mmake)_copy
$(3)/$(1): $(2)/$(1) | $(dir $(3)/$(1))
	$(CP) $$< $$@
endef

.PHONY : %(mmake)

#MM
%(mmake): | $(GENDIR)/$(CURDIR)
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";        \
	$(ECHO) "all: $(addprefix \$$(DST)/,$(%(mmake)_FILES))" > $$m 
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";    \
	for d in $(%(mmake)_DIRS); do                      \
	    $(ECHO) "\$$(DST)/$$d: ; $(MKDIR) \$$@" >> $$m;  \
	done
	@m="$(GENDIR)/$(CURDIR)/%(mmake)-auxiliary.mak";                           \
	for f in $(%(mmake)_FILES); do                                            \
	    $(ECHO) "\$$(DST)/$$f: \$$(SRC)/$$f | \$$\$$(@D); $(CP) \$$< \$$@" >> $$m; \
	done;  \
	for dst in %(dst); do \
	    $(MAKE) -f $$m DST=$$dst SRC=%(src) all; \
	done

$(GENDIR)/$(CURDIR):
	$(MKDIR) $@

%end

#------------------------------------------------------------------------------
#   Copy include files into the includes directories. There are currently
#   two include directories. One for building AROS $(AROS_INCLUDES) and one
#   for building tools that need to run on the host system $(GENINCDIR). The
#   $(GENINCDIR) path must not contain any references to the C runtime
#   library header files.
#
%define copy_includes mmake= includes=$(INCLUDE_FILES) path=. dir=include

ifneq (%(dir),)
INCL_FILES_1 := $(subst %(dir),$(AROS_INCLUDES)/%(path),%(includes))
INCL_FILES_2 := $(subst %(dir),$(GENINCDIR)/%(path),%(includes))
_INC_PATH := %(dir)/
else
INCL_FILES_1 := $(foreach f,%(includes),$(AROS_INCLUDES)/%(path)/$(f))
INCL_FILES_2 := $(foreach f,%(includes),$(GENINCDIR)/%(path)/$(f))
_INC_PATH :=
endif

ifneq (%(mmake),)
#MM 
includes-copy : %(mmake)

#MM
%(mmake) : %(mmake)-includes-setup $(INCL_FILES_1) $(INCL_FILES_2)

.PHONY: %(mmake)

else
#MM
includes-copy : includes-setup $(INCL_FILES_1) $(INCL_FILES_2)
endif


$(AROS_INCLUDES)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

$(GENINCDIR)/%(path)/%.h : $(_INC_PATH)%.h
	@$(CP) $< $@

ifneq (%(mmake),)
%(mmake)-includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)

.PHONY: %(mmake)-includes-setup
else
includes-setup : $(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path)
endif

$(AROS_INCLUDES)/%(path) $(GENINCDIR)/%(path) :
	%mkdir_q dir=$@

,PHONY: includes-copy includes-setup

%end

%define make_hidd_stubs hidd=/A cflags=$(CFLAGS) dflags=$(CFLAGS) parenttarget=linklibs
STUBS_SRC := $(foreach f,$(STUBS),$(f).c)
STUBS_OBJ := $(foreach f,$(STUBS),$(OBJDIR)/$(f).o)
STUBS_MEM := $(foreach f,$(STUBS),$(f).o)
STUBS_DEP := $(foreach f,$(STUBS),$(OBJDIR)/$(f).d)
HIDD_LIB := $(AROS_LIB)/libhiddstubs.a

#MM- linklibs : hidd-%(hidd)-stubs
#MM- %(parenttarget): hidd-%(hidd)-stubs
#MM hidd-%(hidd)-stubs : includes includes-copy
hidd-%(hidd)-stubs : setup $(HIDD_LIB)($(STUBS_MEM))

$(HIDD_LIB)($(STUBS_MEM)) : $(STUBS_OBJ)
	%mklib_q from=$^

$(STUBS_OBJ) : $(STUBS_SRC) 
	%compile_q cmd=$(TARGET_CC) opt=%(cflags)

$(STUBS_DEP) : $(STUBS_SRC)
	%mkdepend_q flags=%(dflags)

setup ::
	%mkdirs_q $(OBJDIR) $(LIBDIR)

#MM
clean ::
	-@$(RM) $(HIDD_LIB) $(OBJDIR)

DEPS := $(DEPS) $(STUBS_DEP)

%end
      
#------------------------------------------------------------------------------
# Build an imported source tree which uses the configure script from the
# autoconf package.  This rule will try to "integrate" the produced files as
# much as possible in the AROS build, for exampley by putting libraries in the
# standard library directory, includes in the standard include directory, and
# so on. You can however override this behaviour.
#
# As a special "bonus" for you, the PROGDIR environment variable is defined to
# be %(bindir) (or its deduced value) when running "make install", and
# "PROGDIR:" when running "make" alone; you can use this feature to pass the
# configure script some more parameters whose value depends upon the PROGDIR
# env var, so that the program gets all its stuff installed in the proper place
# when building it, but when running it from inside AROS it can also find that
# stuff by simply opening PROGDIR:, which it will do automatically if it uses
# the configuration parameters set when running ./configure
#
# *NOTICE*: DO NOT put a trailing '/' (slash) after $PROGDIR, as the variable
# already contains either a '/' (slash) or a ':' (colon), thus simply attach it
# to the name which has to follow it.


%define build_with_configure mmake=/A srcdir=$(TOP)/$(CURDIR) prefix= aros_prefix= \
    extraoptions= nix_dir_layout= nix=no host=no \
    install_target=install postconfigure= postinstall=

ifneq (%(prefix),)
    %(mmake)-prefix := %(prefix)
else
    %(mmake)-prefix := $(AROS_CONTRIB)
endif

ifneq (%(aros_prefix),)
    %(mmake)-aros_prefix := %(aros_prefix)
else
    %(mmake)-aros_prefix := $(%(mmake)-prefix)
endif

ifeq (%(nix),yes)
    %(mmake)-nix    := -nix
    %(mmake)-volpfx := /
    %(mmake)-volsfx := /
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := yes
    endif
else
    %(mmake)-volsfx := :
    
    ifeq (%(nix_dir_layout),)
        %(mmake)-nix_dir_layout := no
    endif
endif

%(mmake)-volfunc = $(%(mmake)-volpfx)$(notdir $1)$(%(mmake)-volsfx)

%(mmake)-install_opts := prefix=$(%(mmake)-prefix) exec_prefix=$(%(mmake)-prefix)

ifeq ($(filter yes, $(%(mmake)-nix_dir_layout) %(host)),yes)
    %(mmake)-PROGDIR      := $(%(mmake)-aros_prefix)/bin
    %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
else
    ifeq (%(nix),yes)
        %(mmake)-config_opts := --prefix=/PROGDIR  --bindir=/PROGDIR --sbindir=/PROGDIR \
        --libdir=/LIB --includedir=/INCLUDE --oldincludedir=/INCLUDE   
    else
        %(mmake)-config_opts  := --prefix=$(%(mmake)-aros_prefix)
    endif

    %(mmake)-PROGDIR := $(%(mmake)-aros_prefix)
    
    %(mmake)-install_opts := bindir=$(%(mmake)-prefix) sbindir=$(%(mmake)-prefix) \
    libdir=$(AROS_LIB) includedir=$(AROS_INCLUDES) oldincludedir=$(AROS_INCLUDES)
endif


.PHONY : %(mmake) %(mmake)-setup %(mmake)-clean %(mmake)-build_and_install-quick

#MM- %(mmake) : setup includes linklibs-core %(mmake)-quick

ifneq (%(install_target),)
    %(mmake)-install_command = \
        $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_opts) \
        -C $(GENDIR)/$(CURDIR) %(install_target) && \
        $(TOUCH) $(GENDIR)/$(CURDIR)/.installed

    %(mmake)-uninstall_command = \
    $(RM) $(GENDIR)/$(CURDIR)/.installed && \
    $(MAKE) PROGDIR="$(%(mmake)-PROGDIR)/" $(%(mmake)-install_opts) \
    -C $(GENDIR)/$(CURDIR) uninstall
else
    %(mmake)-install_command   := true
    %(mmake)-uninstall_command := true
endif

#MM- %(mmake)-quick : %(mmake)-configure %(postconfigure) %(mmake)-build_and_install-quick %(postinstall)

#MM
%(mmake)-build_and_install-quick :  $(GENDIR)/$(CURDIR)/.configured
	if ! $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" -q -C $(GENDIR)/$(CURDIR); then \
            $(RM)  $(GENDIR)/$(CURDIR)/.installed && \
	    $(MAKE) PROGDIR="$(call %(mmake)-volfunc, PROGDIR)" -C $(GENDIR)/$(CURDIR) && \
	    $(%(mmake)-install_command); \
        fi

%(srcdir)/.files-touched:
	find %(srcdir) -exec $(TOUCH) -r %(srcdir)/configure '{}' \; && \
	$(TOUCH) $@

#MM
%(mmake)-uninstall :
	$(%(mmake)-uninstall_command)

ifneq ($(DEBUG),yes)
    %(mmake)-s_flag = -s
endif

#MM
%(mmake)-configure : $(GENDIR)/$(CURDIR)/.configured

ifeq (%(host),yes)
$(GENDIR)/$(CURDIR)/.configured : %(srcdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@ 
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(HOST_CC)" \
	    %(srcdir)/configure $(%(mmake)-config_opts) %(extraoptions) && \
	    $(TOUCH) $@
else
$(GENDIR)/$(CURDIR)/.configured : %(srcdir)/.files-touched $(TOP)/$(CURDIR)/mmakefile
	$(RM) $@
	%mkdirs_q $(GENDIR)/$(CURDIR)
	cd $(GENDIR)/$(CURDIR) && \
	find . -name config.cache -exec $(RM) '{}' \; && \
	CC="$(TARGET_CC) $(%(mmake)-nix) $(%(mmake)-s_flag)" CC_FOR_BUILD="$(HOST_CC)" \
	    %(srcdir)/configure $(%(mmake)-config_opts) %(extraoptions) --host=$(AROS_TARGET_CPU)-aros \
	    --target=$(AROS_TARGET_CPU)-aros --build=local --disable-nls --without-x \
            --without-pic --disable-shared && \
	    $(TOUCH) $@
endif
	
#MM
%(mmake)-clean : %(mmake)-uninstall
	@$(RM) $(GENDIR)/$(CURDIR)
%end

#############################################################################
#############################################################################
##                                                                         ##
## Misciellanous macros. Everying that doesn't fin above should be put     ##
## here.                                                                   ##
##                                                                         ##
#############################################################################
#############################################################################

#----------------------------------------------------------------------------------
# Given an archive name, patches names and locations where to find them, fetch
# the archive and the patches from any of those locations, unpack the archive
# and then apply the patches.
#
# Locations currently supported are http and ftp sites, plus local filesystem
# directories. Supported archives are .tar.bz2 and .tar.gz. To modify this,
# the fetch.sh script needs to be modified, since this macro relies on that script.
#
# Arguments:
#
#     - archive_origins = list of locations where to find the archive. They are tried
#                         in sequence, until the archive is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - archive         = the archive name. Mandatory.
#     - destination     = the local directory where to put the archive and patches.
#                         If not specified, the current directory is assumed.
#     - patches_origins = list of locations where to find the patches. They are tried
#                         in sequence, until a patch is found and fetching it 
#                         succeeded. If not specified, the current directory is assumed.
#     - patches_specs   = list of "patch specs". A patch spec is of the form
#                         patch_name[:[patch_subdir][:patch_opt]].
#			  
#			      - patch_name   = the name of the patch file
#			      - patch_subdir = the directory within \destination\ where to
#			                       apply the patch.
#			      - patch_opt    = any options to pass to the `patch' command
#			                       when applying the patch.
#                         
#                         The patch_subdir and patch_opt fields are optional.

%define fetch archive_origins=. archive=/A suffixes= destination=. patches_origins=. patches_specs=::
	$(FETCH) -ao "%(archive_origins)" -a %(archive) -as "%(suffixes)" -d %(destination) \
        -po "%(patches_origins)" -p %(patches_specs)
%end

#-----------------------------------------------------------------------------------------
# Joins the features of %fetch and %build_with_configure, taking advantage of
# the naming scheme of GNU packages. GNU packages names are in the form
#
#     <package name>-<version number>.<archive format suffix>
#
# If a patch is provided, it *must* be named the following way:
#
#    <package name>-<version number>-aros.diff
#
# Moreover, it *must* be appliable with the -p1 option of the `patch' command after
# CD'ing into the archive's extracted directory.
#
# Note that whilst the %fetch macro accepts a list of patches for any given archive,
# the %fetch_and_build macro only accept *one* patch for each package. It's up to you
# to make that patch fully comprehensive.
#
# NOTE: GNU packages are always compiled with *nix semantics turned on.
#
# Arguments:
#
#    - mmake        = the meta make target, as would be supplied to the %build_with_configure
#                     macro.
#    - package      = the GNU package name, sans version and archive format suffixes.
#    - version      = the package's version number, or otherwise any other version string.
#                     It gets appended to the package name to form the basename of the archive.
#    - suffixes     = a list of suffixes to apped to the the package name plus the
#                     version. Each one of them is tried until a matching archive is found.
#                     Defaults to "tat.bz2 tar.gz".
#    - destination  = same meaning as the one for the %fetch macro
#    - package_repo = same meaning as the one of the %fetch macro's %(archive_origins) argument
#    - patch        = "yes" or "no", depending on whether a patch for this package needs to be
#                     fetched or not
#    - patch_repo   = same meaning as the one of the %fetch macro's %(patches_origins) argument
#    - prefix       = same meaning as the one for the %build_with_configure macro. Defaults to
#                     $(GNUDIR).
#    - aros_prefix  = same meaning as the one for the %build_with_configure macro. Defaults to
#                     /GNU.
#    - extraoptions = same meaning as the one for the %build_with_configure macro.
#    - postinstall  = same meaning as the one for the %build_with_configure macro.

%define fetch_and_build mmake=/A package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix= \
    aros_prefix= extraoptions= postconfigure= postinstall= nix=no nix_dir_layout=

#MM- %(mmake)-quick : %(mmake)-%(subpackage)-quick
#MM- %(mmake)-%(subpackage)-quick : %(mmake)-%(subpackage)-fetch
 
%(mmake)-archbase  := %(package)-%(version)

ifeq (%(prefix),)
    %(mmake)-prefix := $(CONTRIB_DIR)/%(package)
else
    %(mmake)-prefix := %(prefix)
endif

ifneq (%(subpackage),)
    %(mmake)-%(subpackage)-archbase  := %(package)-%(subpackage)-%(version)
else
    %(mmake)-%(subpackage)-archbase  := %(package)-%(version)
endif

ifneq (%(srcdir),)
    %(mmake)-%(subpackage)-srcdir  := %(srcdir)
else
    %(mmake)-%(subpackage)-srcdir  := $(%(mmake)-archbase)
endif

ifeq (%(patch),yes)
    %(mmake)-%(subpackage)-patches_specs := $(%(mmake)-%(subpackage)-archbase)-aros.diff:$(%(mmake)-%(subpackage)-srcdir):-p1    
else
    %(mmake)-%(subpackage)-patches_specs := ::
endif

#MM- %(mmake)-fetch : %(mmake)-%(subpackage)-fetch

.PHONY : %(mmake)-%(subpackage)-fetch
#MM
%(mmake)-%(subpackage)-fetch :
	%fetch archive=$(%(mmake)-%(subpackage)-archbase) suffixes="%(suffixes)" \
	    destination=$(PORTSDIR)/%(package) \
	    archive_origins=". %(package_repo)" \
	    patches_specs="$(%(mmake)-%(subpackage)-patches_specs)" patches_origins=". %(patch_repo)"

#MM- %(mmake) : %(mmake)-%(subpackage)

PACKAGES_DIR := $(AROSDIR)/../Packages

%(mmake)-%(subpackage)-package-dir := $(PACKAGES_DIR)/$(%(mmake)-%(subpackage)-archbase)

%(mmake)-%(subpackage)-package-basename := \
    $(PACKAGES_DIR)/$(%(mmake)-%(subpackage)-archbase)-aros-bin.$(AROS_TARGET_CPU)

%build_with_configure mmake=%(mmake)-%(subpackage) \
     srcdir=$(PORTSDIR)/%(package)/$(%(mmake)-%(subpackage)-srcdir) \
     nix=%(nix) nix_dir_layout=%(nix_dir_layout) prefix="$(%(mmake)-%(subpackage)-package-dir)" \
     aros_prefix="%(aros_prefix)" postconfigure="%(postconfigure)" postinstall="%(postinstall) \
     %(mmake)-%(subpackage)-make-package"  extraoptions="%(extraoptions)"

.PHONY : %(mmake)-%(subpackage)-make-package
#MM %(mmake)-%(subpackage)-make-package : %(mmake)-%(subpackage)-quick

#MM
%(mmake)-%(subpackage)-make-package : $(%(mmake)-%(subpackage)-package-basename).tar.bz2
 
#There seems to be a bug, either with my clock or with make, 'cause it may happen
#that $^ and $@ have exactly the same mtime, and in that case make tries
#to rebuild $@ again, which would fail because the directory where
#the package got installed would not exist anymore. 
#We work this around by using an if statement to manually check the mtimes.
$(%(mmake)-%(subpackage)-package-basename).tar.bz2 :
	@if test $(GENDIR)/$(CURDIR)/.installed -nt $@ || ! test -f $@; then \
            $(RM) $@ && \
	    $(ECHO) "Building \`$(%(mmake)-%(subpackage)-package-basename).tar.bz2'" && \
	    cd $(%(mmake)-%(subpackage)-package-dir) && \
            tar --remove-files -cvf $(%(mmake)-%(subpackage)-package-basename).tar * && \
            mkdir -p "$(%(mmake)-prefix)" && \
            tar -xf $(%(mmake)-%(subpackage)-package-basename).tar -C "%(prefix)"/ && \
            bzip2 -9 -f $(%(mmake)-%(subpackage)-package-basename).tar && \
            cd .. && $(RM) $(%(mmake)-%(subpackage)-archbase); \
        fi
%end

%define fetch_and_build_gnu mmake=/A package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(GNUDIR) \
    aros_prefix=/GNU extraoptions= postconfigure= postinstall= 

GNU_REPOSITORY := http://ftp.gnu.org/pub/gnu

%fetch_and_build mmake="%(mmake)" package="%(package)" subpackage="%(subpackage)" version="%(version)" \
    suffixes="%(suffixes)" srcdir="%(srcdir)" \
    package_repo="%(package_repo) $(GNU_REPOSITORY)/%(package)" \
    patch="%(patch)" patch_repo="%(patch_repo)" \
    prefix="%(prefix)" aros_prefix="%(aros_prefix)" extraoptions="%(extraoptions)" \
    postconfigure="%(postconfigure)" postinstall="%(postinstall)" nix=yes

%end

#-----------------------------------------------------------------------------------------
# Same job as the one of %fetch_and_build_gnu, except that this one assumes
# that the package is a "Development" package, and as such it needs to be placed
# under the $(AROS_DEVELOPMENT) directory, as a default. 
#
# All the arguments have the same meaning as the ones of the %fetch_and_build_gnu 
# macro, but notice that %fetch_and_build_gnu_development *doesn't* have a
# "mmake" argument, because the metatarget is implicitely defined as
#
#     #MM- development-%(package)

%define fetch_and_build_gnu_development package=/A subpackage= version=/A suffixes="tar.bz2 tar.gz" \
    srcdir= package_repo= patch=no patch_repo= prefix=$(AROS_DEVELOPMENT) \
    aros_prefix=/Development postconfigure= postinstall=  extraoptions= 

#MM- development : development-%(package)


%fetch_and_build_gnu mmake=development-%(package) package=%(package) subpackage="%(subpackage)" \
   version=%(version) suffixes="%(suffixes)" srcdir="%(srcdir)"  \
   package_repo="%(package_repo)" patch="%(patch)" patch_repo="%(patch_repo)" prefix=%(prefix) \
   aros_prefix="%(aros_prefix)" postconfigure="%(postconfigure)" postinstall="%(postinstall)" \
   extraoptions="%(extraoptions)"
    
%end
