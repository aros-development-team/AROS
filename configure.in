dnl Copyright ï¿½ 1997-2016, The AROS Development Team. All rights reserved.
dnl $Id$
dnl
dnl Desc: Autoconf source for configuration file
dnl Lang: english 

# Note: After file changes, generate configure anew and commit _both_ files.

#TODO
# method of getting shared/non-shared ld/ar tool for target.

# ------------------------------------------------------------------------
# Here starts the first section of the configure.in file.
# ------------------------------------------------------------------------

AC_INIT(mmakefile)
AC_PREREQ(2.61)
AC_CONFIG_AUX_DIR(scripts/autoconf)

# Check what host we are running on.
# If a target is not suggested, we use this one.
# Note that what we call a target, Autoconf calls a host.
AC_CANONICAL_HOST

# Default versions for the gnu tools we build
default_toolchain_family=`cat ${srcdir}/config/toolchain_def`
default_gcc_version=`cat ${srcdir}/config/gcc_def`
exp_gcc_version=`cat ${srcdir}/config/gcc_exp`
default_binutils_version=`cat ${srcdir}/config/binutils_def`
exp_binutils_version=`cat ${srcdir}/config/binutils_exp`
default_grub2_version="2.02"
target_grub2_version=$default_grub2_version

# The AROS target is slightly different to the normal GNU style
# format. We don't have the middle part, and we reverse the order
# of the $(CPU) and $(OS) bits.
#
# Don't strip the version of the target yet, it might be
# useful on some systems.

AC_MSG_CHECKING([for AROS style target])

if test "$target" = "NONE" ; then
    target=$host_os-$host_cpu
else
    if test "$target" = "" ; then
        target=$host_os-$host_cpu
    fi
fi
AC_MSG_RESULT($target)

if test "$host_os" = "mingw32" ; then
    PWDCMD="pwd -W"
fi

# Don't know where else to put this...
AC_MSG_CHECKING([building AROS in])
AROS_BUILDDIR=`${PWDCMD-pwd}`
AROS_BUILDDIR_UNIX=${PWD}
AC_MSG_RESULT($AROS_BUILDDIR)

AC_MSG_CHECKING([AROS source in])
srcpwd=`cd ${srcdir} ; ${PWDCMD-pwd}`
SRCDIR=${srcpwd}
AC_MSG_RESULT($SRCDIR)

# Parse the target field into something useful.
changequote(<<,>>)
target_os=`echo $target | sed 's/^\([^-].*\)-\(.*\)$/\1/'`
target_cpu=`echo $target | sed 's/^\([^-].*\)-\(.*\)$/\2/'`
changequote([,])

# Some debug output, to be removed again.
AC_MSG_CHECKING([for target system (debug output)])
AC_MSG_RESULT($target_os)
AC_MSG_CHECKING([for target cpu (debug output)])
AC_MSG_RESULT($target_cpu)

dnl --------------------------------------------------------------------
dnl Set the default Workbench resolution
dnl --------------------------------------------------------------------
aros_nominal_width=800
aros_nominal_height=600
aros_nominal_depth=4

dnl --------------------------------------------------------------------
dnl Host Configuration Section
dnl --------------------------------------------------------------------
dnl
dnl The idea here is to find out all the information we need about the
dnl host. This means things like tools for building directory structures,
dnl copying files around and the like.

default_c_compilers="gcc clang cc"
AC_ARG_WITH(c-compiler,AC_HELP_STRING([--with-c-compiler=VERSION],[Use specified c compiler for building AROS]),use_c_compiler="$withval",use_c_compiler="")
if test "$use_c_compiler" = ""; then
    host_c_compilers="$default_c_compilers"
else
    host_c_compilers="$use_c_compiler"
fi

default_cxx_compilers="g++ clang++ c++"
AC_ARG_WITH(cxx-compiler,AC_HELP_STRING([--with-cxx-compiler=VERSION],[Use specified c++ compiler building AROS]),use_cxx_compiler="$withval",use_cxx_compiler="")
if test "$use_cxx_compiler" = ""; then
        host_cxx_compilers="$default_cxx_compilers"
else
    host_cxx_compilers="$use_cxx_compiler"
fi


# The first step is to find the host binaries.
# Check for a compiler.
# Due to a bug in autoconf check for c++ compiler first.
# For mor info see, http://osdir.com/ml/bug-autoconf-gnu/2010-05/msg00001.html.
AC_PROG_CXX([${host_cxx_compilers}])
AC_PROG_CC([${host_c_compilers}])
aros_host_def_cc="$CC"
AC_PROG_CC_STDC
AC_PROG_CPP

# Check for a compatible awk
AC_CHECK_PROGS(AWK,[gawk nawk])
AROS_REQUIRED(gawk,$AWK)
AROS_PROG(MMAKE,mmake)

# Perform some default variable assignments. Note all of these will be
# Regenerated from the script, so there is no need to cache them.

aros_build_host=$host
aros_host_cpp="$CPP"
aros_host_cc="$CC"
aros_host_cxx="$CXX"
AROS_TOOL_CCPATH(aros_host_ld,ld)
AROS_REQUIRED(ld,$aros_host_ld)
aros_host_make="make"
aros_host_cflags="$CFLAGS"
aros_host_cxxflags="$CXXFLAGS"
aros_host_cppflags="$CPPFLAGS"
aros_host_ldflags="$LDFLAGS"
aros_host_debug="-g -O0"
aros_host_mkdep="\$(SRCDIR)/scripts/mkdep"
aros_host_mkargs="--no-print-directory"
aros_host_exe_suffix="$EXEEXT"
aros_host_lib_suffix=""

# Ignore all compliance, AROS ROMs = 0
# KickStart v1.0 = 30
# KickStart v1.3 = 34
# KickStart v2.0 = 37
# KickStart v3.0 = 39
# KickStart v3.1 = 40
# AmigaOS   v3.5 = 44
aros_amigaos_compliance=0

AC_CHECK_PROGS(aros_host_aclocal,[aclocal aclocal19 aclocal-1.9])
AC_CHECK_PROGS(aros_host_autoconf,[autoconf autoconf259 autoconf253])
AC_CHECK_PROGS(aros_host_autoheader,[autoheader autoheader259 autoheader253])
AC_CHECK_PROGS(aros_host_automake,[automake automake19 automake-1.9])

AROS_REQUIRED(aclocal/aclocal19/aclocal-1.9, $aros_host_aclocal)
AROS_REQUIRED(automake/automake19/automake-1.9, $aros_host_automake)

case "$aros_host_cc" in
    *clang*)
        aros_host_cc_pipe=""
        ;;
    *gcc*)
        aros_host_cc_pipe="-pipe"
        ;;
    icc)
        aros_host_cc_pipe=""
        ;;
    *)
        aros_host_cc_pipe=""
        ;;
esac

aros_kernel_cc_includes=""
aros_target_cc_includes=""
host_cc_elf=yes

# ----------------------------------------------------------------------------------------
# Host-specific defaults
#
# This is the main host configuration section. It is where the host
# can change the values of any variables it needs to change. We do
# not look at anything that compiles to the target yet, we'll get
# to that later.

case "$host_os" in
    aros*)
        aros_host_arch="aros"
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *x86_64*)
                aros_host_cpu="x86_64"
                ;;
            *powerpc*)
                aros_host_cpu="ppc"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    linux*)
        aros_host_arch="linux"
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        android_build_os="linux-x86"
        android_tool="android"
        default_android_sdk="/opt/android-sdk-linux_x86"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *x86_64*)
                aros_host_cpu="x86_64"
                ;;
            *m68k*)
                aros_host_cpu="m68k"
                ;;
            *powerpc*)
                aros_host_cpu="ppc"
                ;;
            *arm*)
                aros_host_cpu="arm"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    freebsd*)
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe -I/usr/local/include"
        aros_host_make="gmake"
        aros_host_arch="freebsd"
        aros_host_cpu="i386"

        aros_host_ldflags="$aros_host_ldflags -L/usr/local/lib -liconv"

        dnl FreeBSD 5.x (and later) has changed the default object format.
        dnl The double [[]] is necessary to get around m4's quoting rules.
        case $host_os in
            freebsd[[234]]*)
                aros_object_format="elf_i386"
                ;;

            *)
                aros_object_format="elf_i386_fbsd"
                ;;
        esac

        ;;

    darwin*)
        AC_MSG_CHECKING([for macOS SDK files])
        LOC=$( xcode-select -p )
        AS_IF([ test $? != 0],[AC_MSG_ERROR([XCode incorrectly configured!
please run 'xcode-select --install' before
re-running configure])])
        AC_MSG_RESULT($LOC)
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        aros_host_arch="darwin"
        host_cc_elf=no
        if [[ -z ${SED+x} ]]; then SED="gsed"; fi
        android_build_os="darwin-x86"
        android_tool="android"
        default_android_sdk="/android-sdk-mac_x86"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *x86_64*)
                aros_host_cpu="x86_64"
                ;;
            *powerpc*)
                aros_host_cpu="ppc"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for Darwin host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac

        aros_host_ldflags="$aros_host_ldflags -liconv"

        ;;

    dragonfly*)
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        aros_host_make="gmake"
        aros_host_arch="dragonfly"
        case $host_cpu in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *amd64*)
                aros_host_cpu="x86_64"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    netbsd*)
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        aros_host_make="gmake"
        aros_host_arch="netbsd"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *m68k*)
                aros_host_cpu="m68k"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac    
        aros_host_lib_suffix=".0.0"
        ;;

    openbsd*)
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        aros_host_make="gmake"
        aros_host_arch="openbsd"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;
        
    solaris*)
        aros_host_arch="solaris"
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *sparc*)
                aros_host_cpu="sparc"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    morphos*)
        aros_host_arch="morphos"
        aros_host_cpu="ppc"
        host_cc_elf=no
        ;;

    amiga*)
        aros_host_arch="amiga"
        host_cc_elf=no
        SORT="/gg/bin/sort"
        TEST="/gg/bin/test"
        UNIQ="/gg/bin/uniq"
        FOR="for"
        TOUCH="/gg/bin/touch"
        case "$host_cpu" in
            *m68k*)
                aros_host_cpu="m68k"
                ;;
            *powerpc*)
                aros_host_cpu="ppc"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    cygwin*)
        aros_host_arch="cygwin"
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        host_cc_elf=no
        android_build_os="windows"
        android_tool="android.bat"
        default_android_sdk="/cygdrive/c/android-sdk-windows-1.6_r1"

        case "$host_cpu" in
            *i?86*)
                aros_host_cpu="i386"
                ;;
            *)
                AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
                aros_host_cpu="$host_cpu"
                ;;
        esac
        ;;

    mingw32*)
        aros_host_arch="mingw32"
        aros_host_cflags="$aros_host_cflags $aros_host_cc_pipe"
        host_cc_elf=no
        android_build_os="windows"
        android_tool="android.bat"
        default_android_sdk="/c/android-sdk-windows-1.6_r1"

        libpng_libextra="-lws2_32"

        case "$host_cpu" in
        *i?86*)
            dnl Currently there's neither 64-bit MinGW nor MSYS. Both environments are 32-bit
            dnl and run under emulation. Consequently, uname reports i386 even on 64-bit systems.
            dnl Here we attempt to detect Windows home platform by asking gcc about its target.
            dnl 64-bit gcc will output "x86_64-w64-mingw32" here.

            AC_MSG_CHECKING([for Windows native gcc target])
            host_cpu=`gcc -dumpmachine`
            AC_MSG_RESULT($host_cpu)
            ;;

        esac

        case "$host_cpu" in
        *i?86*)
            aros_host_cpu="i386"
            ;;

        mingw32*)
            dnl Native i386 gcc for MinGW32 reports 'mingw32' with -dumpmachine switch
            aros_host_cpu="i386"
            ;;

        *x86_64*)
            aros_host_cpu="x86_64"
            dnl Dragon's x86_64-w64-mingw32-gcc is a bit broken. It ignores standard $prefix/include
            dnl directory, so we have to add it explicitly here.
            aros_host_cflags="$aros_host_cflags -isystem /mingw/include"
            ;;

        *)
            AC_MSG_WARN("Unknown CPU for host -- $host_cpu")
            aros_host_cpu="$host_cpu"
            ;;
        esac
        ;;
    *)
        AC_MSG_ERROR([Unsupported host architecture $host])
        ;;
esac

AROS_PROG(aros_host_ar,[ar],[cr])
AROS_REQUIRED(ar,$aros_host_ar)
AROS_PROG(aros_host_ranlib,ranlib)
AROS_REQUIRED(ranlib,$aros_host_ranlib)
AROS_PROG(aros_host_strip,strip)
AROS_REQUIRED(strip,$aros_host_strip)

AROS_PROG(RM,[rm],[-rf])
AROS_REQUIRED(rm,$RM)
AROS_PROG(CP,[cp])
AROS_REQUIRED(cp,$CP)
AROS_PROG(MV,[mv])
AROS_REQUIRED(mv,$MV)
AROS_PROG(ECHO,[echo])
AROS_REQUIRED(echo,$ECHO)
AROS_PROG(MKDIR,[mkdir],[-p])
AROS_REQUIRED(mkdir,$MKDIR)
AROS_PROG(TOUCH,[touch])
AROS_REQUIRED(touch,$TOUCH)
AROS_PROG(SORT,[sort])
AROS_REQUIRED(sort,$SORT)
AROS_PROG(UNIQ,[uniq])
AROS_REQUIRED(uniq,$UNIQ)
AROS_PROG(NOP,[true])
AROS_REQUIRED(true,$NOP)
AROS_PROG(CAT,[cat])
AROS_REQUIRED(cat,$CAT)
AROS_PROG(BISON,[bison])
AROS_REQUIRED(bison,$BISON)
AROS_PROG(FLEX,[flex])
AROS_REQUIRED(flex,$FLEX)
AROS_PROG(PNGTOPNM,[pngtopnm])
AROS_REQUIRED(pngtopnm,$PNGTOPNM)
AROS_PROG(PPMTOILBM,[ppmtoilbm])
AROS_REQUIRED(ppmtoilbm,$PPMTOILBM)
AROS_PROG(SED,[sed])
AROS_REQUIRED(sed,$SED)
AROS_PROG(CHMOD,[chmod])
AROS_REQUIRED(chmod,$CHMOD)
AROS_PROG(PATCH,[patch])
AROS_REQUIRED(patch,$PATCH)

AM_PATH_PYTHON(2.5)

AC_ARG_ENABLE([libpng-config], [--disable-libpng-config    disable libpng-config test and configuration])
if test "$enable_libpng_config" != "no"; then
  AC_CHECK_PROG([arosconfig_use_libpngconfig],[libpng-config],[yes],[no])
fi
if test "$arosconfig_use_libpngconfig" = "yes"; then
    AC_MSG_CHECKING([libpng-config library])
    libpng_incdir="`libpng-config --cflags`"
    libpng_libextra="$libpng_libextra `libpng-config --ldflags`"
    libpng="`libpng-config --libs`"
    AC_MSG_RESULT($libpng)
else
    AC_CHECK_LIB(png, png_read_png, [libpng="-lpng"], [libpng="no"])
    if test "$libpng_libextra" != ""; then
        if test "$libpng" != "no"; then
            libpng_libextra="$libpng_libextra $libpng"
        fi
    fi
fi
AROS_REQUIRED(libpng, $libpng)
AC_SUBST(libpng)
AC_SUBST(libpng_libextra)
AC_SUBST(libpng_incdir)

AC_SUBST(FOR, for)
AC_SUBST(IF, if)
AC_SUBST(TEST, test)
AC_SUBST(CMP, cmp)

dnl ---------------------------------------------------------------------------
dnl Look for things about the host system, good for hosted targets.
dnl ---------------------------------------------------------------------------

# Check for some includes for the X11 HIDD and the kernel
AC_CHECK_HEADERS([sys/ipc.h sys/shm.h \
    sys/mmap.h sys/mman.h sysexits.h \
    sys/statfs.h sys/statvfs.h sys/vfs.h sys/param.h \
])

AC_CHECK_HEADERS([sys/mount.h],,,[#include <sys/param.h>])
AC_CHECK_HEADERS([GL/glx.h],[host_feature_glx=yes],[host_feature_glx=no],)

AC_MSG_CHECKING([if __unused conflicts with sys/stat.h])
AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
     [[
     #define __unused __attribute__((unused))
     #include <sys/stat.h>
     ]])],
     [host_stat_h__unused_used=no],
     [host_stat_h__unused_used=yes])
AC_MSG_RESULT($host_stat_h__unused_used)

AC_HEADER_DIRENT
AC_HEADER_STAT
AC_HEADER_STDC
AC_HEADER_SYS_WAIT
AC_HEADER_TIME
AC_STRUCT_ST_BLKSIZE
AC_STRUCT_ST_BLOCKS
AC_STRUCT_ST_RDEV
AC_STRUCT_TM
AC_STRUCT_TIMEZONE
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T
AC_TYPE_UID_T

AC_CHECK_MEMBERS(struct tm.tm_gmtoff)

# Look for some functions
AC_CHECK_FUNCS([getpagesize kqueue statfs statvfs \
    clone kse_create rfork_thread thr_create sa_register \
    getcontext makecontext setcontext sigaltstack swapcontext])

AC_FUNC_MMAP

#-----------------------------------------------------------------------------

#
# GCC 4.1+ has a stack protection feature that requires OS support. Ubuntu has
# it switched on by default, and we use the host compiler, so it compiles AROS
# code with this enabled resulting in link failures as we don't have support
# for it.
#
# We use two methods to disable it. For the host compiler (used to compile
# some hosted modules), we test to see if the compiler supports stack
# protection, and if it does we disable it in AROS_CONFIG_CFLAGS. This should
# work on all platforms.
#

AC_MSG_CHECKING([whether ${CC} accepts -fno-stack-protector])
save_cflags="$CFLAGS"
CFLAGS="$CFLAGS -fno-stack-protector"
AC_TRY_COMPILE(,, use_no_stack_protector="yes", use_no_stack_protector="no")
AC_MSG_RESULT($use_no_stack_protector)
if test "x-$use_no_stack_protector" = "x-yes" ; then
    aros_host_cflags="$aros_host_cflags -fno-stack-protector"
fi
CFLAGS="$save_cflags"

#-----------------------------------------------------------------------------

# Disable pointer-signedness warnings if the compiler recognises the option
# (this only works for the host compiler at the moment)

AC_MSG_CHECKING([whether ${CC} accepts -Wno-pointer-sign])
save_cflags="$CFLAGS"
CFLAGS="$CFLAGS -Wno-pointer-sign"
AC_TRY_COMPILE(,, use_no_sign_warning="yes", use_no_sign_warning="no")
AC_MSG_RESULT($use_no_sign_warning)
if test "x-$use_no_sign_warning" = "x-yes" ; then
    aros_host_cflags="$aros_host_cflags -Wno-pointer-sign"
fi
CFLAGS="$save_cflags"

#-----------------------------------------------------------------------------

# Check if host compiler supports -fgnu89-inline, can be needed for crosstools.

AC_MSG_CHECKING([whether ${CC} accepts -fgnu89-inline])
save_cflags="$CFLAGS"
CFLAGS="$CFLAGS -fgnu89-inline"
AC_TRY_COMPILE(,, use_gnu89_inline="yes", use_gnu89_inline="no")
AC_MSG_RESULT($use_gnu89_inline)
if test "x-$use_gnu89_inline" = "x-yes" ; then
    gnu89_inline="-fgnu89-inline"
fi
CFLAGS="$save_cflags"

#
# For GCC < 4.0 -I- is used for giving the search path for '#include "..."'
# On GCC >= 4.0 -iquote should be used
#
AC_MSG_CHECKING([whether ${CC} accepts -iquote])
CFLAGS="$CFLAGS -iquote."
AC_TRY_COMPILE(,, has_iquote="yes", has_iquote="no")
AC_MSG_RESULT($has_iquote)
if test "x-$has_iquote" = "x-yes" ; then
    host_cflags_iquote=-iquote
    host_cflags_iquote_end=
else
    host_cflags_iquote=-I
    host_cflags_iquote_end=-I-
fi

AC_MSG_NOTICE([Performing target configuration...])

dnl --------------------------------------------------------------------
dnl Target Configuration Section
dnl --------------------------------------------------------------------
dnl
dnl The target configuration section is responsible for setting up all
dnl the paths for includes, and tools required to build AROS to some
dnl particular target.

test_kernel_cc=no

aros_nowarn_flags="NOWARN_UNUSED_COMMAND_LINE_ARGUMENT NOWARN_UNKNOWN_WARNING_OPTION NOWARN_POINTER_SIGN NOWARN_PARENTHESES"
export_newline="
"

aros_elf_translate=
aros_warn_flags=
aros_isa_extra=
aros_isa_flags=
aros_config_cppflags=
aros_config_cflags=
aros_config_cxxflags=
aros_config_aflags="$""(WARN_ALL) -x assembler-with-cpp -c"
aros_config_ldflags=""

aros_shared_default=yes

aros_shared_cflags="-fPIC"
aros_shared_aflags=""
aros_shared_ldflags="-Wl,-rpath,./lib -shared"
aros_kernel_ldflags="-Wl,-rpath,./lib"

aros_kernel_ar_flags="cr"
aros_target_ar_flags="cr"
aros_target_nm_flags="-C -ul"
aros_target_strip_flags="--strip-unneeded -R.comment"

aros_compiler_libs=
aros_arch_libs=

aros_target_genmap="-Wl,-Map -Xlinker"

# Native flavour stuff
aros_serial_debug="0"

# Palm native flavour stuff
aros_palm_debug_hack="0"

# Unix flavour stuff
aros_nesting_supervisor="0"

# Collect-aros stuff: "-ius" to ignore undefined symbols
ignore_undefined_symbols=""

# Check for X11 by default
need_x11="auto"

AC_MSG_CHECKING([Which toolchain family to use ...])
AC_ARG_WITH(toolchain,AC_HELP_STRING([--with-toolchain=family],[Which toolchain family to crosscompile with (defaults to gnu)]),aros_toolchain="$withval",aros_toolchain="$default_toolchain_family")
AC_MSG_RESULT($aros_toolchain)


AC_MSG_CHECKING([if we should enable link time optimizations (LTO)])
AC_ARG_ENABLE(lto,AC_HELP_STRING([--enable-lto=[yes|no]],[Enable link time optimizations if the target compiler supports them (default=no)]),
 aros_config_lto="$enableval",aros_config_lto="no")
if test "$aros_config_lto" != "no"; then
    aros_config_lto="yes"
fi
AC_MSG_RESULT($aros_config_lto)

AC_MSG_CHECKING([if we should enable coverage instrumentation])
AC_ARG_ENABLE(coverage,AC_HELP_STRING([--enable-coverage=[yes|no]],[Enable coverage instrumentation if the target compiler supports it (default=no)]),
 aros_config_coverage="$enableval",aros_config_coverage="no")
if test "$aros_config_coverage" != "no"; then
    aros_config_coverage="yes"
fi
AC_MSG_RESULT($aros_config_coverage)

use_ld_wrapper=yes

case "$aros_toolchain" in
    *llvm*)
        toolchain_c_compiler="clang"
        toolchain_cxx_compiler="clang++"
        toolchain_cpp_preprocessor="clang -E"
        toolchain_ld="ld.lld"
        aros_ld="ld"
        toolchain_as="llvm-as"
        toolchain_ar="llvm-ar"
        toolchain_ranlib="llvm-ranlib"
        toolchain_nm="llvm-nm"
        toolchain_strip="true"
        toolchain_objcopy="llvm-objcopy"
        toolchain_objdump="llvm-objdump"
        ;;
    *gnu*)
        toolchain_c_compiler="gcc"
        toolchain_cxx_compiler="g++"
        toolchain_cpp_preprocessor="gcc -E"
        toolchain_as="as"
        aros_ld="ld"
        if test "$aros_config_lto" != "yes"; then
            toolchain_ld="ld"
            toolchain_ar="ar"
            toolchain_ranlib="ranlib"
            toolchain_nm="nm"
        else
            toolchain_ld="ld.bfd"
            toolchain_ar="gcc-ar"
            toolchain_ranlib="gcc-ranlib"
            toolchain_nm="gcc-nm"
        fi
        toolchain_strip="strip"
        toolchain_objcopy="objcopy"
        toolchain_objdump="objdump"
        ;;
    *)
        AC_MSG_WARN("Unknown toolchain family!")
        toolchain_c_compiler="cc"
        toolchain_cxx_compiler="c++"
        toolchain_cpp_preprocessor="cpp"
        toolchain_ld="ld"
        aros_ld="ld"
        toolchain_as="as"
        toolchain_ar="ar"
        toolchain_ranlib="ranlib"
        toolchain_nm="nm"
        toolchain_strip="strip"
        toolchain_objcopy="objcopy"
        toolchain_objdump="objdump"
        ;;
esac

#-----------------------------------------------------------------------------

AC_MSG_CHECKING([which type of build to do])
AC_ARG_ENABLE(build_type,AC_HELP_STRING([--enable-build-type=TYPE],[Select the build type. Available types are: personal, nightly, snapshot, milestone, release. Do NOT use this option unless you know what you are doing! (default=personal)]),build_type=$enableval,build_type="personal")

if test "$build_type" = "nightly"; then
    build_type_string="NIGHTLY"
elif test "$build_type" = "snapshot"; then
    build_type_string="SNAPSHOT"
elif test "$build_type" = "milestone"; then
    build_type_string="MILESTONE"
elif test "$build_type" = "release"; then
    build_type_string="RELEASE"
else
    build_type_string="PERSONAL"
    build_type="personal"
fi

aros_config_cppflags="$aros_config_cppflags -DAROS_BUILD_TYPE=AROS_BUILD_TYPE_$build_type_string"

AC_MSG_RESULT($build_type)

#-----------------------------------------------------------------------------
all_debug_types="messages stack modules mungwall symbols"

AC_MSG_CHECKING([which debug types to enable])
AC_ARG_ENABLE(debug,AC_HELP_STRING([--enable-debug=list],[Enable different types of debug. Commas or whitespaces can be used to separate the items in the list. Available types of debug are: all, none, messages, stack, mungwall, modules, symbols. If no list is provided then "all" is assumed. (default=none)]),
 debug="$enableval",debug="")

if test "$debug" = "" -o "$debug" = "no"; then
    debug="none"
elif test "$debug" = "yes"; then
    debug="all"
fi

if test "$debug" = "all" ; then
    debug="messages stack modules symbols"
    for d in $all_debug_types; do
        export aros_${d}_debug="1"
    done
else
    for d in $all_debug_types; do
        export aros_${d}_debug="0"
    done
fi

if test "$debug" != "none"; then
    debug=`echo $debug | sed s/,/\ /g`
    for d in $debug; do
        found="0"
        for d2 in $all_debug_types; do
            if test "$d2" = "$d"; then
                found="1"
                break
            fi
        done
        if test "$found" = "0"; then
            AC_MSG_ERROR([unrecognized debug type "$d". Available types are: all none $all_debug_types])
        fi
        export aros_${d}_debug="1"
    done
    aros_debug="yes"
fi
AC_MSG_RESULT($debug)

if test "$aros_messages_debug" = "1"; then
    aros_messages_debug="-DADEBUG=1 -DMDEBUG=1"
else
    aros_messages_debug=""
fi
if test "$aros_symbols_debug" = "1"; then
    aros_symbols_debug="-g"
else
    aros_symbols_debug=""
fi

# These are the flags to pass when compiling debugged programs
aros_debug_cppflags="$aros_messages_debug"
aros_debug_cflags="$aros_symbols_debug"
aros_debug_cxxflags=
aros_debug_aflags=""
aros_debug_ldflags="$aros_symbols_debug"

#-----------------------------------------------------------------------------
#   Checking for distcc and ccache.
#
#   Always apply the transforms in this particular order. Basically you should
#   always run 'ccache distcc compiler' in that order for the best performance.
#
AC_MSG_CHECKING([whether to enable distcc])
AC_ARG_ENABLE(distcc,AC_HELP_STRING([--enable-distcc],[Use distcc as a front end to the compiler (default=no).]),distcc="$enableval",distcc="no")
if test "$distcc" != "" -a "$distcc" != "no"; then
    # AC_CHECK_PROG will print out the result in this case
    AC_PATH_PROG(DISTCC,[distcc],distcc,)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING([whether to enable ccache])
AC_ARG_ENABLE(ccache,AC_HELP_STRING([--enable-ccache],[Use ccache as a front end to the compiler (default=no).]),ccache="$enableval",ccache="no")
if test "$ccache" != "" -a "$ccache" != "no"; then
    # AC_CHECK_PROG will print out the result in this case
    AC_CHECK_PROG(CCACHE,[ccache],ccache,)
else
    AC_MSG_RESULT(no)
fi

#-----------------------------------------------------------------------------
AC_MSG_CHECKING([what specific host gcc version to use])
AC_ARG_WITH(kernel-gcc-version,AC_HELP_STRING([--with-kernel-gcc-version=VERSION],[Use gcc-VERSION for building bootstrap]),kernel_tool_version="$withval",kernel_tool_version="")
if test "$kernel_tool_version" != "" ; then
    msg_result=$kernel_tool_version
else
    msg_result="default"
fi
AC_MSG_RESULT($msg_result)

#-----------------------------------------------------------------------------
AC_MSG_CHECKING([what optimization flags to use])
AC_ARG_WITH(optimization,AC_HELP_STRING([--with-optimization=FLAGS],[Use optimization flags FLAGS (e.g --with-optimization=-O2).]),optimization_level="$withval",optimization_level="unknown")
if test "$optimization_level" = "unknown"; then
    dnl default is -O2 for normal builds, -O0 for debug builds
    optimization="default"
    if test "$debug" != "none"; then
        optimization_level="-O0"
    else
        optimization_level="-O2"
    fi
else
    optimization="$optimization_level"
fi
AC_MSG_RESULT($optimization)

paranoia_default=yes
#-----------------------------------------------------------------------------
AC_MSG_CHECKING([which paranoia flags to use])
AC_ARG_WITH(paranoia,AC_HELP_STRING([--with-paranoia=(yes|no|FLAGS)],[Specific compiler warning FLAGS to enable for paranoia builds (default=-Wall -Werror)]),[paranoia_flags="$withval"],[paranoia_flags="$paranoia_default"])
if test "$paranoia_flags" = "no"; then
        paranoia_flags="$""(WARN_ALL) -Werror-implicit-function-declaration"
        msg_result="none"
else
    if test "$paranoia_flags" = "yes"; then
        paranoia_flags="$""(WARN_ALL) $""(WARN_ERROR)"
    fi
    msg_result="$paranoia_flags"
fi
AC_MSG_RESULT($msg_result)
aros_warn_flags="$aros_warn_flags $paranoia_flags"

#-----------------------------------------------------------------------------
AC_MSG_CHECKING([what target variant to enable])
AC_ARG_ENABLE(target_variant,AC_HELP_STRING([--enable-target-variant=NAME],[Enable a specific target variant (default=none)]),target_variant=$enableval,target_variant="")
if test "$target_variant" = ""; then
    aros_target_variant=""
    aros_target_suffix=""
    enableval="none"
else
    aros_target_variant="$target_variant"
    aros_target_suffix="-$target_variant"
fi
AC_MSG_RESULT($enableval)

#-----------------------------------------------------------------------------
# Target-specific defaults. You can override then on a per-target basis.
#
# Bootloader name. Currently used by PC target.
target_bootloader="none"
PLATFORM_EXECSMP=
ENABLE_EXECSMP=

#-----------------------------------------------------------------------------
# Additional options for some specific targets

case "$aros_target_variant" in
ios)
    AC_MSG_CHECKING([XCode path])
    AC_ARG_WITH(xcode,AC_HELP_STRING([--with-xcode=PATH],[Specify XCode path for iOS targets (default=/Developer).]),aros_xcode_path="$withval",aros_xcode_path="/Developer")
    AC_MSG_RESULT($aros_xcode_path)

    AC_MSG_CHECKING([what iOS SDK version to use])
    AC_ARG_WITH(sdk-version,AC_HELP_STRING([--with-sdk-version=VERSION],[Use iOS SDK version VERSION (default=4.1).]),aros_sdk_version="$withval",aros_sdk_version="4.1")
    AC_MSG_RESULT($aros_sdk_version)

    ;;

"android")
    AC_MSG_CHECKING([Android SDK path])
    AC_ARG_WITH(sdk,AC_HELP_STRING([--with-sdk=PATH],[Specify Android SDK path (default=$default_android_sdk).]),aros_android_sdk="$withval",aros_android_sdk=$default_android_sdk)
    AC_MSG_RESULT($aros_android_sdk)

    AC_MSG_CHECKING([Android NDK path])
    AC_ARG_WITH(ndk,AC_HELP_STRING([--with-ndk=PATH],[Specify Android NDK path (default=none).]),aros_android_ndk="$withval",aros_android_ndk="none")
    AC_MSG_RESULT($aros_android_ndk)

    AC_MSG_CHECKING([what Android SDK version to use])
    AC_ARG_WITH(sdk-version,AC_HELP_STRING([--with-sdk-version=LEVEL],[Use Android SDK for API LEVEL (default=12).]),aros_sdk_version="$withval",aros_sdk_version="12")
    AC_MSG_RESULT($aros_sdk_version)

    aros_android_level=android-$aros_sdk_version
    if test ! -d $aros_android_sdk/platforms/$aros_android_level; then
        echo "Platform $aros_android_level is not installed in your SDK"
        echo "Use --with-sdk-version=<API level number> to select another platform version"
        echo "You can check what plaform versions are installed in your SDK"
        echo "by examining contents of $aros_android_sdk/platforms directory"
        AC_MSG_ERROR([Android platform $aros_android_level is not installed])
    fi

    export PATH="$aros_android_sdk/tools:$PATH"
    AC_PATH_PROG(android_tool, $android_tool)
    AROS_REQUIRED(android,$android_tool)

    if test "$aros_android_ndk" != "none"; then
        AC_MSG_CHECKING([what Android NDK version to use])
        AC_ARG_WITH(ndk-version,AC_HELP_STRING([--with-ndk-version=LEVEL],[Use Android NDK for API LEVEL (default=9).]),aros_ndk_version="$withval",aros_ndk_version="9")
        AC_MSG_RESULT($aros_ndk_version)
    fi

    AC_PATH_PROG(ant, ant)
    if test "$ant" = ""; then
        AC_MSG_WARN([Apache Ant is missing, Java bootstrap can't be built automatically])
    fi

    AC_MSG_CHECKING([Build debug or release apk])
    AC_ARG_WITH(apk-version,AC_HELP_STRING([--with-apk-version=(release|debug)],[Which version of AROSBootstrap.apk to compile. Release version needs key for signing, debug version will only run in emulator. (default=release)]),aros_android_antapk=$withval,aros_android_antapk=release)
    if test $aros_android_antapk != release -a $aros_android_antapk != debug; then
        AC_MSG_ERROR([apk-version has to be release or debug])
    fi
    AC_MSG_RESULT($aros_android_antapk)

    target_extra_cfg+="$export_newline""# Android$export_newline""AROS_ANDROID_ANTAPK           := $aros_android_antapk$export_newline"
    host_extra_cfg+="$export_newline""# Android-specific$export_newline""ANDROID                       := $android_tool$export_newline""ANT		                      := $ant$export_newline"
    aros_target_options+="$export_newline""# Enable Android Gfx Driver$export_newline""OPT_HOST_ANDROIDGFX           := yes$export_newline"

    dnl MSYS bash can't run .bat files directly, then need to be started via cmd.exe
    if test "$host_os" = "mingw32"; then
        android_tool="cmd //c $android_tool"
    fi

    need_dlopen="no"

    ;;
esac

#-----------------------------------------------------------------------------
# External toolchains
kernel_tool_prefix="none"
aros_tool_prefix="none"
elf_tool_prefix="${target_cpu}-elf-"

# Base target cpu ISA configuration switch.
case "$target_cpu" in
    *aarch64*)
        ;;
    *arm*)
        ;;
    *m68k*)
        m68k_isa_extra="ISA_MC68000_FLAGS             = -march=68000"
        m68k_020_isa_extra="ISA_MC68020_FLAGS             = -march=68020"
        m68k_030_isa_extra="ISA_MC68030_FLAGS             = -march=68030"
        m68k_040_isa_extra="ISA_MC68040_FLAGS             = -march=68040"
        m68k_060_isa_extra="ISA_MC68060_FLAGS             = -march=68060"
        m68k_ac080_isa_extra="ISA_AC68080_FLAGS             = -march=68040"
        m68k_020_ext="ISA_MC68020_EXT               :=020"
        m68k_030_ext="ISA_MC68030_EXT               :=030"
        m68k_040_ext="ISA_MC68040_EXT               :=040"
        m68k_060_ext="ISA_MC68060_EXT               :=060"
        m68k_020_cflags="ISA_MC68020_CFLAGS            ="
        m68k_030_cflags="ISA_MC68030_CFLAGS            ="
        m68k_040_cflags="ISA_MC68040_CFLAGS            ="
        m68k_060_cflags="ISA_MC68060_CFLAGS            ="
        m68k_020_cppflags="ISA_MC68020_CPPFLAGS          ="
        m68k_030_cppflags="ISA_MC68030_CPPFLAGS          ="
        m68k_040_cppflags="ISA_MC68040_CPPFLAGS          ="
        m68k_060_cppflags="ISA_MC68060_CPPFLAGS          ="
        m68k_020_ldflags="ISA_MC68020_LDFLAGS           ="
        m68k_030_ldflags="ISA_MC68030_LDFLAGS           ="
        m68k_040_ldflags="ISA_MC68040_LDFLAGS           ="
        m68k_060_ldflags="ISA_MC68060_LDFLAGS           ="
        ;;
    *x86_64* | *i?86*)
        x86_isa_extra="ISA_X86_FLAGS                 = -m32 -march=i486"
        x86_64_isa_extra="ISA_X8664_FLAGS               = -mcmodel=large"
        ;;
    *powerpc*)
        ;;
esac

# This is the target configuration switch.
case "$target_os" in
    linux*)
        aros_target_arch="linux"
        aros_target_family="unix"
        case "$target_cpu" in
            *m68k*)
                aros_target_cpu="m68k"
                aros_object_format="m68kelf"
                aros_flavour="emulcompat"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -D__mc68000 -D__linux__"
                aros_isa_flags="$""(ISA_MC68000_FLAGS)"
                aros_shared_ldflags="-Wl,-T,\$(TOP)/config/linux/m68k/script.so"
                aros_kernel_ldflags="-Wl,-rpath,./lib,-T,\$(TOP)/config/linux/m68k/script.normal"
                gcc_target_cpu="mc68000"
                ;;
            *i?86*)
                aros_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386 -D__linux__"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                x86_64_isa_extra="$x86_64_isa_extra $""(CFLAGS_NO_RED_ZONE)"
                aros_kernel_ldflags="-Wl,-melf_i386"
                aros_nominal_depth=8
                gcc_target_cpu="i386"
                pci_hidd_target="hidd-pci-linux"
                android_tool_dir_prefix="x86"
                android_tool_prefix="i686-android-linux"
                android_ndk_arch="x86"
                ;;
            *x86_64*)
                aros_target_cpu="x86_64"
                aros_object_format="elf_x86_64"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dx86_64 -D__linux__"
                aros_isa_flags="$""(ISA_X8664_FLAGS)"
                x86_64_isa_extra="$x86_64_isa_extra $""(CFLAGS_NO_RED_ZONE)"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_OMIT_FP)"
                aros_nominal_depth=8
                pci_hidd_target="hidd-pci-linux"
                ;;
            *powerpc*)
                aros_target_cpu="ppc"
                aros_object_format="elf32ppc"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc -D__linux__"
                aros_nominal_depth=8
                gcc_target_cpu="ppc"
                ;;
# TODO
# Same as powerpc, but I need this for the nightly build to work again.
# Actually, the nightly should be made working with powerpc target.
# That just was too much work for the moment, another week or two.
            *ppc*)
                aros_target_cpu="ppc"
                aros_object_format="elf32ppc"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc -D__linux__"
                aros_nominal_depth=8
                gcc_target_cpu="ppc"
                ;;
            *aarch64*)
                aros_target_cpu="aarch64"
                target_cpu="aarch64"
                aros_object_format="aarch64elf_aros"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm -D__linux__"
                gcc_target_cpu="aarch64"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_STRICT_ALIASING)"
                aros_arch_libs="-laeabi"
                gcc_default_float_abi="hard"
                kernel_tool_prefix="aarch64-linux-gnueabihf-"
                ;;
            *armhf*)
                aros_target_cpu="arm"
                target_cpu="arm"
                aros_object_format="armelf_aros"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm -D__linux__"
                gcc_target_cpu="arm"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_STRICT_ALIASING)"
                aros_arch_libs="-laeabi"
                gcc_default_float_abi="hard"
                android_tool_dir_prefix="arm-linux-androideabi"
                android_tool_prefix="arm-linux-androideabi"
                android_ndk_arch="arm"
                kernel_tool_prefix="arm-linux-gnueabihf-"
                ;;
            *arm*)
                aros_target_cpu="arm"
                aros_object_format="armelf_aros"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm -D__linux__"
                gcc_target_cpu="arm"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_STRICT_ALIASING)"
                aros_arch_libs="-laeabi"
                android_tool_dir_prefix="arm-linux-androideabi"
                android_tool_prefix="arm-linux-androideabi"
                android_ndk_arch="arm"
                kernel_tool_prefix="arm-linux-gnueabi-"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for Linux -- $target_cpu")
                ;;
        esac
        case "$aros_target_variant" in
            android)

                dnl Not all Linux CPUs are supported by Android
                if test "$android_ndk_arch" = ""; then
                    AC_MSG_ERROR("Unsupported CPU for Android -- $target_cpu")
                fi

                aros_nominal_width=320
                aros_nominal_height=480
                if test "$aros_android_ndk" = "none"; then
                    dnl Use standalone toolchain, don't adjust paths
                    aros_kernel_cflags="-mandroid"
                    aros_kernel_ldflags="-mandroid"
                    CFLAGS="-mandroid"
                else
                    dnl In Android NDK toolchains are placed in own directories,
                    dnl but tool names are not suffixed with version 
                    export PATH="$aros_android_ndk/toolchains/$android_tool_dir_prefix-$kernel_tool_version/prebuilt/$android_build_os/bin:$PATH"
                    kernel_tool_version=""
                    aros_android_ndk="$aros_android_ndk/platforms/android-$aros_ndk_version/arch-$android_ndk_arch"
                    aros_kernel_cflags="--sysroot $aros_android_ndk -mandroid"
                    aros_kernel_ldflags="--sysroot $aros_android_ndk -mandroid"
                    CFLAGS="$CFLAGS --sysroot $aros_android_ndk -mandroid"
                    aros_kernel_includes="-isystem $aros_android_ndk/usr/include"
                fi
                need_x11=no
                # Disable implicit PIC mode
                aros_config_cflags="$aros_config_cflags -fno-pic"
                kernel_tool_prefix="$android_tool_prefix-"
            ;;
        esac
    ;;

    pc)
        aros_target_arch="pc"
        aros_shared_default="no"
        target_bootloader="grub2"
        case "$target_cpu" in
            *i?86*)
                aros_target_cpu="i386"

                dnl If somebody hasn't already set the target object
                dnl format, then use this value. Mostly to support
                dnl FreeBSD cross-compilation.
                dnl TODO: Remove when we always use our compiler.

                if test "$aros_object_format" = "" ; then
                    aros_object_format="elf_i386"
                fi
                aros_flavour="standalone"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                x86_64_isa_extra="$x86_64_isa_extra $""(CFLAGS_NO_RED_ZONE)"
                aros_kernel_ldflags="-Wl,-melf_i386"
                aros_nominal_width=640
                aros_nominal_height=480
                gcc_target_cpu="i386"
                ;;
            *x86_64*)
                PLATFORM_EXECSMP="#define __AROSPLATFORM_SMP__"
                aros_target_cpu="x86_64"
                aros_serial_debug=1
                if test "$aros_object_format" = "" ; then
                    aros_object_format="elf_x86_64"
                fi
                aros_flavour="standalone"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dx86_64"
                aros_isa_flags="$""(ISA_X8664_FLAGS)"
                x86_64_isa_extra="$x86_64_isa_extra $""(CFLAGS_NO_RED_ZONE)"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_OMIT_FP)"
                aros_kernel_ldflags=""
                aros_nominal_width=640
                aros_nominal_height=480
                case "$aros_target_variant" in
                    smp)
                        ENABLE_EXECSMP="#define __AROSEXEC_SMP__"
                    ;;
                esac
                ;;
            *)
                AC_MSG_ERROR("Unknown native CPU -- $target_cpu")
                ;;
        esac
        ;;

    prep)
        aros_target_arch="prep"
        aros_shared_default="no"
        aros_target_cpu="ppc"
        aros_object_format="elf32ppc"
        aros_flavour="ppcnative"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc"
        aros_kernel_ldflags=""
        aros_nominal_width=640
        aros_nominal_height=480
        gcc_target_cpu="ppc"
        ;;

    freebsd*)
        aros_target_arch="freebsd"
        aros_target_family="unix"
        aros_target_cpu="i386"
        aros_flavour="emulation"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386"
        gcc_target_cpu="i386"

        aros_target_strip_flags="-x"
        ;;

    darwin*)
        aros_target_arch="darwin"
        aros_target_family="unix"
        aros_flavour="emulation"
        case "$target_cpu" in
            *i?86*)
                aros_ios_platform="iPhoneSimulator"
                aros_target_cpu="i386"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                aros_kernel_ldflags=""
                aros_macosx_version="10.4"
                aros_nominal_depth=8
                gcc_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_kernel_ar_flags="-cr"
                aros_target_strip_flags="-x"
                kernel_tool_flags="-m32"
                ;;
            *x86_64*)
                aros_target_cpu="x86_64"
                aros_object_format="elf_x86_64"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dx86_64"
                aros_isa_flags="$""(ISA_X8664_FLAGS)"
                aros_macosx_version="10.6"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_OMIT_FP)"
                aros_kernel_cflags="-m64"
                aros_kernel_ldflags="-m64"
                aros_nominal_depth=8
                aros_kernel_ar="ar"
                aros_kernel_ar_flags="-cr"
                aros_kernel_ld="ld"
                aros_kernel_as="as"
                aros_kernel_ranlib="ranlib"
                aros_kernel_nm="nm"
                aros_kernel_strip="strip"
                kernel_tool_prefix="i686-apple-darwin10-"
                ;;
            *ppc*)
                aros_target_cpu="ppc"
                aros_object_format="elf32ppc"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc"
                aros_kernel_ldflags=""
                aros_macosx_version="10.0"
                aros_nominal_depth=8
                gcc_target_cpu="ppc"
                aros_kernel_ar="ar"
                aros_kernel_ar_flags="-cr"
                aros_kernel_ld="ld -arch ppc"
                aros_kernel_as="as -arch ppc"
                aros_kernel_ranlib="ranlib -arch ppc"
                aros_kernel_nm="nm -arch ppc"
                aros_kernel_strip="strip -arch ppc"
                kernel_tool_prefix="powerpc-apple-darwin10-"
                ;;
            *arm*)
                aros_ios_platform="iPhoneOS"
                aros_target_cpu="arm"
                aros_object_format="armelf_aros"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm"
                aros_arch_libs="-laeabi"
                aros_nominal_depth=8
                gcc_target_cpu="arm"
                aros_kernel_ar="ar"
                aros_kernel_ar_flags="-cr"
                aros_kernel_ld="ld -arch arm"
                aros_kernel_ranlib="ranlib -arch arm"
                kernel_tool_prefix="arm-apple-darwin10-" 
                export PATH="$aros_xcode_path/Platforms/$aros_ios_platform.platform/Developer/usr/bin:$PATH"
                ;;
            *)
                AC_MSG_ERROR("Unsupported target CPU for darwin hosted flavour -- $target_cpu")
                ;;
        esac
        case "$aros_target_variant" in
            ios)
                make_extra_targetcfg="$export_newline""# Apple iOS stuff for gcc$export_newline""IOS_LDFLAGS  := -F$""(IOS_SDK_PATH)/System/Library/Frameworks$export_newline"
                aros_ios_version="3.0"
                aros_nominal_width=320
                aros_nominal_height=480
                aros_ios_sdk="$aros_xcode_path/Platforms/$aros_ios_platform.platform/Developer/SDKs/$aros_ios_platform$aros_sdk_version.sdk"
                target_extra_cfg+="$export_newline""# Apple iOS specific$export_newline""IOS_PLATFORM            := $aros_ios_platform$export_newline""IOS_OS_VERSION          := $aros_ios_version$export_newline""IOS_SDK_PATH            := $aros_ios_sdk$export_newline"
                kernel_tool_flags="$target_tool_flags -isysroot $aros_ios_sdk"
                aros_kernel_includes="-isystem $aros_ios_sdk/usr/include"
                need_x11=no
                # This is here because it may depend on iOS or SDK version
                aros_kernel_cflags="$aros_kernel_cflags -miphoneos-version-min=$aros_ios_version"
                aros_kernel_ldflags="$aros_kernel_ldflags -miphoneos-version-min=$aros_ios_version"
                aros_kernel_objcflags="-fobjc-abi-version=2 -fobjc-legacy-dispatch"
            ;;
            *)
                aros_kernel_cflags="$aros_kernel_cflags -mmacosx-version-min=$aros_macosx_version"
                aros_kernel_ldflags="$aros_kernel_ldflags -mmacosx-version-min=$aros_macosx_version"
            ;;
        esac
        ;;

    dragonfly*)
        aros_target_arch="dragonfly"
        aros_target_family="unix"
        aros_flavour="emulation"
        case "$target_cpu" in
            *i?86*)
                aros_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386 -D__DragonFly__"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                ;;
            *x86_64*)
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_OMIT_FP)"
                aros_target_cpu="x86_64"
                aros_object_format="elf_x86_64"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dx86_64 -D__DragonFly__"
                aros_isa_flags="$""(ISA_X8664_FLAGS)"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for DragonFly -- $target_cpu")
                ;;
        esac
        ;;

    netbsd*)
        aros_target_arch="netbsd"
        aros_target_family="unix"
        case "$target_cpu" in
            *m68k*)
                aros_target_cpu="m68k"
                aros_object_format="m68kelf"
                aros_flavour="emulcompat"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -D__mc68000 -D__NetBSD__"
                aros_isa_flags="$""(ISA_MC68000_FLAGS)"
                gcc_target_cpu="mc68000"
                ;;
            *i?86*)
                aros_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386 -D__NetBSD__"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                aros_nominal_depth=8
                gcc_target_cpu="i386"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for NetBSD -- $target_cpu")
                ;;
        esac
        aros_target_genmap="-Wl,-M -Xlinker >"
        aros_flavour="emulation"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386"
        ;;   

    openbsd*)
        aros_target_arch="openbsd"
        aros_target_family="unix"
        case "$target_cpu" in
            *i?86*)
                aros_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_flavour="emulation"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386 -D__OpenBSD__"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                gcc_target_cpu="i386"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for OpenBSD -- $target_cpu")
                ;;
        esac
        aros_target_genmap="-Wl,-M -Xlinker >"
        aros_target_nm_flags="-u"
        aros_flavour="emulation"
        ;;

    solaris*)
        aros_target_arch="solaris"
        aros_target_family="unix"
        case "$target_cpu" in
           *i?86*)
               aros_target_cpu="i386"
               aros_object_format="elf_i386"
               aros_flavour="emulation"
               aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386 -D__Solaris__"
               aros_isa_flags="$""(ISA_X86_FLAGS)"
               aros_nominal_depth=8
               gcc_target_cpu="i386"
               ;;
            *sparc*)
                aros_target_cpu="sparc"
                aros_object_format="elf_sparc"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dsparc -D__Solaris__"
                gcc_target_cpu="sparc"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for Solaris -- $target_cpu")
                ;;
        esac
        aros_config_cppflags="$aros_config_cppflags -D$aros_target_cpu"
        aros_flavour="emulation"
        ;;

    morphos*)
        aros_target_arch="morphos"
        aros_shared_default="no"
        aros_target_cpu="ppc"
        aros_object_format="elf_ppc"
        aros_flavour="nativecompat"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc"
        gcc_target_cpu="ppc"
        ;;

    sam440)
        aros_target_arch="sam440"
        aros_shared_default="no"
        aros_target_cpu="ppc"
        aros_object_format="elf32ppc"
        aros_flavour="ppcnative"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc"
        aros_kernel_ldflags=""
        aros_nominal_width=1024
        aros_nominal_height=768
        aros_nominal_depth=24
        aros_isa_flags="$aros_isa_flags -mcpu=440fp -mno-toc"
        aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        gcc_target_cpu="powerpc"
        ;;

    efika)
        aros_target_arch="efika"
        aros_shared_default="no"
        aros_target_cpu="arm"
        aros_object_format="armelf_aros"
        aros_flavour="standalone"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm"
        aros_kernel_ldflags=""
        aros_nominal_width=1024
        aros_nominal_height=600
        aros_arch_libs="-laeabi"
        gcc_default_cpu="armv7-a"
        gcc_default_fpu="vfpv3"
        aros_isa_flags="$aros_isa_flags -mtune=cortex-a8"
        aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        if test "$optimization" = "default"; then
            optimization_level="-Os"
        fi
        case "$target_cpu" in
            *armhf*)
                gcc_default_float_abi="hard"
                target_cpu=arm
                aros_target_cpu=arm
                ;;
            *arm*)
                gcc_default_float_abi="softfp"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for EfikaMX $target_cpu")
                ;;
        esac
        ;;
        
    chrp)
        aros_target_arch="chrp"
        aros_shared_default="no"
        aros_target_cpu="ppc"
        aros_object_format="elf32ppc"
        aros_flavour="ppcnative"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dppc"
        aros_kernel_ldflags=""
        aros_nominal_width=640
        aros_nominal_height=480
        aros_isa_flags="$aros_isa_flags -mno-toc"
        aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES)"
        gcc_target_cpu="powerpc"
        case "$aros_target_variant" in
            efika)
                aros_isa_flags="$aros_isa_flags -mcpu=603e"
                aros_config_cppflags="$aros_config_cppflags -DBIG_ENDIAN_OHCI=1"
            ;;
        esac
        ;;

    r*pi)
        PLATFORM_EXECSMP="#define __AROSPLATFORM_SMP__"
        aros_flavour="standalone"
        aros_target_arch="raspi"

        aros_shared_default="no"

        aros_target_mkdep="$aros_target_mkdep -D__GNUC__"
        
        case "$target_cpu" in
            *aarch64*)
                aros_target_cpu="aarch64"
                gcc_default_cpu="aarch64"
                aros_object_format="aarch64elf_aros"
                ;;
            *armhf*)
                aros_target_cpu="arm"
                gcc_default_cpu="armv6zk"
                gcc_default_cpu_tune="arm1176jzf-s"
                aros_object_format="armelf_aros"
                aros_isa_flags="$aros_isa_flags -marm"
                aros_config_cflags="$aros_config_cflags"
                aros_config_cxxflags="$aros_config_cxxflags"
                aros_config_aflags="$aros_config_aflags -marm"
                aros_kernel_cflags="$aros_kernel_cflags -marm"
                aros_target_mkdep="$aros_target_mkdep -Darm"
                aros_arch_libs="-laeabi"
                ;;
            *armeb*)
                aros_flavour="standcompat"
                aros_target_cpu="armeb"
                gcc_default_float_abi="hard"
                gcc_default_cpu="armv7ve"
                gcc_default_cpu_tune="cortex-a7"
                aros_object_format="armelfb_aros"
                aros_isa_flags="$aros_isa_flags -marm"
                aros_config_cflags="$aros_config_cflags"
                aros_config_cxxflags="$aros_config_cxxflags"
                aros_config_aflags="$aros_config_aflags -marm"
                aros_kernel_cflags="$aros_kernel_cflags -marm"
                aros_target_mkdep="$aros_target_mkdep -Darm"
                aros_arch_libs="-laeabi"
                ;;
            *arm*)
                aros_target_cpu="arm"
                gcc_default_cpu="armv6zk"
                gcc_default_cpu_tune="arm1176jzf-s"
                aros_object_format="armelf_aros"
                aros_isa_flags="$aros_isa_flags -marm"
                aros_config_cflags="$aros_config_cflags"
                aros_config_cxxflags="$aros_config_cxxflags"
                aros_config_aflags="$aros_config_aflags -marm"
                aros_kernel_cflags="$aros_kernel_cflags -marm"
                aros_target_mkdep="$aros_target_mkdep -Darm"
                aros_arch_libs="-laeabi"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for RasPi $target_cpu")
                ;;
        esac

        aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        aros_kernel_cflags="$aros_kernel_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"

        case "$aros_target_variant" in
            smp)
                ENABLE_EXECSMP="#define __AROSEXEC_SMP__"
            ;;
        esac
        ;;

    stm32f7_discovery)
        aros_flavour="standalone"
        aros_target_arch="stm32f7_discovery"
        aros_target_cpu="arm"
        aros_target_cpu_mode="thumb2"
        aros_object_format="armelf_aros"
        aros_shared_default="no"

        gcc_default_cpu="armv7e-m"
        gcc_default_cpu_tune="cortex-m7"
        gcc_default_fpu="fpv5-sp-d16"
        gcc_default_float_abi="hard"

        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dthumb"
        ;;

    amiga*)
        aros_elf_translate="$""(ELF2HUNK)"
        make_extra_commands="$export_newline""ELF2HUNK	:= $""(TOOLDIR)/elf2hunk$""(HOST_EXE_SUFFIX)$export_newline"
        aros_target_arch="amiga"
        aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -D_AMIGA -DAMIGA"
        aros_shared_default="no"

        case "$target_cpu" in
            *m68k*)
                AC_ARG_ENABLE(amigaos_compliance,AC_HELP_STRING([--enable-amigaos-compliance=VERSION],[Enforce userspace AmigaOS compliance to a specific KickStart version (default=none).]),aros_amigaos_compliance="$enableval")
                aros_enable_mmu=no
                aros_target_cpu="m68k"
                aros_object_format="m68kelf"
                aros_flavour="standcompat"
                gcc_target_cpu="m68000"
                aros_isa_flags="$""(ISA_MC68000_FLAGS)"
                aros_nowarn_flags="$aros_nowarn_flags NOWARN_VOLATILE_REGISTER_VAR"
                aros_config_cppflags="$aros_config_cppflags -DNOLIBINLINE"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_FREESTANDING) $""(CFLAGS_OMIT_FP) $""(CFLAGS_BUILTIN)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_STRICT_ALIASING) $""(CFLAGS_FREESTANDING) $""(CFLAGS_OMIT_FP) $""(CFLAGS_BUILTIN)"
                if test "$optimization" = "default"; then
                    optimization_level="-Os"
                fi
                aros_config_aflags="$aros_config_aflags"
                aros_target_strip_flags="-R.comment --strip-debug"
                aros_nominal_width=640
                aros_nominal_height=256
                aros_nominal_depth=2
                ;;
            *ppc*)
                aros_cpu="ppc"
                aros_flavour="native"
                gcc_target_cpu="ppc"
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for Amiga $target_cpu")
                ;;
        esac
        ;;

    mingw*)
        aros_target_arch="mingw32"
        aros_shared_default="no"
        aros_flavour="emulation"
        aros_shared_cflags=""
        need_crosstools="yes"
        need_dlopen="no"
        rescomp="windres"
        case "$target_cpu" in
            *i?86*)
                aros_target_cpu="i386"
                aros_object_format="elf_i386"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Di386"
                aros_isa_flags="$""(ISA_X86_FLAGS)"
                aros_nominal_depth=8
                gcc_target_cpu="i386"

                kernel_tool_prefix="i386-mingw32-"
                ;;
            *x86_64*)
                aros_target_cpu="x86_64"
                aros_object_format="elf_x86_64"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dx86_64"
                aros_isa_flags="$""(ISA_X8664_FLAGS)"
                aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_OMIT_FP)"
                aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_OMIT_FP)"
                aros_nominal_depth=8
                kernel_tool_prefix="x86_64-w64-mingw32-"
                ;;
            *arm*)
                aros_target_cpu="arm"
                aros_object_format="armelf_aros"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Darm"
                aros_arch_libs="-laeabi"
                aros_nominal_depth=8
                gcc_target_cpu="arm"
                gcc_default_float_abi="soft"
                kernel_tool_prefix="arm-mingw32ce-"
                aros_nominal_width=160
                aros_nominal_height=160
                ;;
            *)
                AC_MSG_ERROR("Unknown CPU for Mingw32 -- $target_cpu")
                ;;
        esac
        if test $host_os = "cygwin"; then
                aros_kernel_cflags="-mno-cygwin"
        fi
    ;;
    pp*)
        aros_target_arch="pp"
        aros_shared_default="no"
        case "$target_cpu" in
            *m68k*)
                aros_target_cpu="m68k"
                aros_object_format="m68kelf"
                aros_flavour="palmnative"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dm68k"
                aros_isa_flags="$""(ISA_MC68000_FLAGS)"
                aros_nominal_width=160
                aros_nominal_height=160
                aros_nominal_depth=1
                aros_target_ar_flags="cru"
                aros_compiler_libs="-lgcc1"
                aros_shared_default=no
                aros_shared_cflags="-fpic"
                aros_shared_aflags=""
                aros_shared_ldflags="-Wl,-rpath,./lib -shared"
                aros_kernel_ldflags="-Wl,-rpath,./lib"
                aros_debug_cppflags="$aros_messages_debug"
                aros_debug_cflags="$aros_symbols_debug"
                aros_debug_aflags=""
                aros_debug_ldflags="$aros_symbols_debug"
                aros_mungwall_debug="0"
                aros_modules_debug="0"
                gcc_target_cpu="mc68000"
                ignore_undefined_symbols="-ius"
                ;;
           *)
                AC_MSG_ERROR("Unknown CPU for PalmPilot -- $target_cpu")
                ;;
        esac
        ;;

    mac*)
        aros_target_arch="mac"
        aros_shared_default="no"
        case "$target_cpu" in
            *m68k*)
                aros_target_cpu="m68k"
                aros_object_format="m68kelf"
                aros_flavour="mac68knative"
                aros_target_mkdep="$aros_target_mkdep -D__GNUC__ -Dm68k"
                aros_isa_flags="$""(ISA_MC68000_FLAGS)"
                aros_nominal_width=512
                aros_nominal_height=384
                aros_nominal_depth=8
                aros_target_ar_flags="cru"
                aros_compiler_libs="-lgcc1"
                aros_shared_default=no
                aros_shared_cflags="-fpic"
                aros_shared_aflags=""
                aros_shared_ldflags="-Wl,-rpath,./lib -shared"
                aros_kernel_ldflags="-Wl,-rpath,./lib"
                aros_debug_cppflags="$aros_messages_debug"
                aros_debug_cflags="$aros_symbols_debug"
                aros_debug_aflags=""
                aros_debug_ldflags="$aros_symbols_debug"
                aros_mungwall_debug="0"
                aros_modules_debug="0"
                gcc_target_cpu="mc68000"
                ignore_undefined_symbols="-ius"
                ;;
           *)
                AC_MSG_ERROR("Unknown CPU for Mac68k -- $target_cpu")
                ;;
        esac
        ;;

    *)
        AC_MSG_ERROR([Unsupported target architecture $target])
        ;;
esac

#-----------------------------------------------------------------------------
crosstools_guess="yes"
aros_target_toolchain="no"
aros_kernel_sysroot=""

AC_MSG_CHECKING([Kernel toolchain prefix])
AC_ARG_WITH(kernel-toolchain-prefix,AC_HELP_STRING([--with-kernel-toolchain-prefix=...],[Specify crosscompile toolchain prefix for kernel objects]),[kernel_tool_prefix="$withval"])
AC_MSG_RESULT($kernel_tool_prefix)

AC_MSG_CHECKING([ELF toolchain prefix])
AC_ARG_WITH(elf-toolchain-prefix,AC_HELP_STRING([--with-elf-toolchain-prefix=...],[Specify crosscompile toolchain prefix to wrap for AROS objects]),[elf_tool_prefix="$withval"
                                                 crosstools_guess="no"])
AC_MSG_RESULT($elf_tool_prefix)

AC_MSG_CHECKING([AROS toolchain prefix])
AC_ARG_WITH(aros-toolchain,AC_HELP_STRING([--with-aros-toolchain=PREFIX],[Specify prebuilt AROS toolchain. Use yes for default name]),[aros_tool_prefix="$withval"
                crosstools_guess="no"])
if test "$aros_tool_prefix" = "yes" ; then
    aros_tool_prefix=$aros_target_cpu-aros-
fi
AC_MSG_RESULT($aros_tool_prefix)

#-----------------------------------------------------------------------------
#   Checking if we should build crosstools..
AC_MSG_CHECKING([whether to build crosstools])
AC_ARG_ENABLE(crosstools,AC_HELP_STRING([--disable-crosstools],[Do not build cross-compiler toolchain]),crosstools="$enableval",crosstools="$crosstools_guess")
AC_MSG_RESULT($crosstools)

if test "${crosstools}" = "yes"; then
    if test "${crosstools_guess}" = "no"; then
        AC_MSG_ERROR([Cannot build external toolchain if an external ELF or AROS toolchain is specified])
    fi
fi

if test "${crosstools}" = "yes" || test "${crosstools_guess}" = "no"; then
    aros_target_toolchain="yes"
fi

AC_MSG_CHECKING([where to install the crosstools binaries])
AC_ARG_WITH(aros-toolchain-install,AC_HELP_STRING([--with-aros-toolchain-install=DIR],[Where to install or search for cross tools binaries]),[aros_toolchain_install=$withval])
if test "x$aros_toolchain_install" = "x"; then
    AROS_CROSSTOOLSDIR="$AROS_BUILDDIR_UNIX/bin/$aros_host_arch-$aros_host_cpu/tools/crosstools"
else
    AROS_CROSSTOOLSDIR="$aros_toolchain_install"
    PATH="$AROS_CROSSTOOLSDIR:$PATH"
    if test "$crosstools_guess" = "no" ; then
        if test "x-$aros_flavour" != "x-emulation" -a "x-$aros_flavour" != "x-emulcompat" ; then
            aros_kernel_sysroot="$""(TARGET_SYSROOT)"
        fi
    fi
fi
AC_MSG_RESULT($AROS_CROSSTOOLSDIR)

#-----------------------------------------------------------------------------
if test "$aros_toolchain" = "gnu" ; then
    AC_MSG_CHECKING([what specific target binutils version to use])
fi
AC_ARG_WITH(binutils-version,AC_HELP_STRING([--with-binutils-version=VERSION],[Use binutils-VERSION for building AROS]),use_binutils_version="$withval",use_binutils_version="")
if test "$use_binutils_version" = ""; then
        target_binutils_version="$default_binutils_version"
else
    target_binutils_version="$use_binutils_version"
fi
if test "$aros_toolchain" = "gnu" ; then
    AC_MSG_RESULT($target_binutils_version)
fi


# Helper to identify gcc version
AC_DEFUN([CROSS_GCC_VERSION], [
  target_gcc_version=""
  AC_CACHE_CHECK([gcc version],[ax_cv_gcc_version],[
    ax_cv_gcc_version="`$AROS_CROSSTOOLSDIR/${aros_tool_prefix}${toolchain_cpp_preprocessor} -dumpversion`"
    AS_IF([test "x$ax_cv_gcc_version" = "x"],[
      ax_cv_gcc_version=""
    ])
  ])
  target_gcc_version=$ax_cv_gcc_version
  AC_SUBST([target_gcc_version])
])

#-----------------------------------------------------------------------------
if test "$aros_toolchain" = "gnu" ; then
    AC_MSG_CHECKING([what specific target gcc version to use])
fi
AC_ARG_WITH(gcc-version,AC_HELP_STRING([--with-gcc-version=VERSION],[Compile gcc-VERSION for AROS]),use_gcc_version="$withval",use_gcc_version="")
if test "$use_gcc_version" = ""; then
    if test "${crosstools}" = "no"; then
      if test "x$aros_toolchain_install" != "x"; then
          CROSS_GCC_VERSION
      fi
    fi
    if test "$use_gcc_version" = ""; then
        target_gcc_version="$default_gcc_version"
    fi
else
    target_gcc_version="$use_gcc_version"
fi
if test "$aros_toolchain" = "gnu" ; then
    AC_MSG_RESULT($target_gcc_version)

    GCC_VERSION_MAJOR=$(echo $target_gcc_version | cut -d'.' -f1)
    GCC_VERSION_MINOR=$(echo $target_gcc_version | cut -d'.' -f2)
    GCC_VERSION_PATCH=$(echo $target_gcc_version | cut -d'.' -f3)

    gcc_fix_bitfields="false"
    if test "$GCC_VERSION_MAJOR" -gt "4" ; then
        gcc_fix_bitfields="true"
    else
        if test "$GCC_VERSION_MAJOR" -gt "3" ; then
            if test "$GCC_VERSION_MINOR" -gt "6" ; then
                gcc_fix_bitfields="true"
            fi
        fi
    fi

    if test "$gcc_fix_bitfields" = "true" ; then
        case "$aros_target_cpu" in
        *x86_64* | *i?86*)
            x86_isa_extra="$x86_isa_extra $""(CFLAGS_NO_MS_BITFIELDS)"
            x86_64_isa_extra="$x86_64_isa_extra $""(CFLAGS_NO_MS_BITFIELDS)"
            ;;
        esac
    fi
fi

AC_MSG_CHECKING([whether to enable Objective-C suppport])
AC_ARG_ENABLE(objc,AC_HELP_STRING([--enable-objc],[Enable Objectve-C support (default=no)]),objc="$enableval",objc="no")
AC_MSG_RESULT($objc)
if test "x$objc" = "xyes"; then
    objc_target="$objc"
else
    objc_target="no-objc"
fi

AC_MSG_CHECKING([whether to enable Java suppport])
AC_ARG_ENABLE(java,AC_HELP_STRING([--enable-java],[Enable Java support (default=no)]),java="$enableval",java="no")
AC_MSG_RESULT($java)
if test "x$java" != "xno"; then
    java_target="$java"
else
    java_target="no-java"
fi

spec_obj_format="-m $aros_object_format"
# Now process extra architecture-specific options.
# Currently this is implemented only for ARM. We can specify which minimum CPU and FPU to use,\
# as well as floating-point ABI.
case "$aros_target_cpu" in
    *m68k*)
        aros_isa_targets="M68K_ISA_TARGETS              :=MC68020 MC68040"
        aros_isa_extra="$aros_isa_extra$export_newline$aros_isa_targets$export_newline"
        aros_isa_extra="$aros_isa_extra$m68k_isa_extra$export_newline$m68k_020_isa_extra$export_newline$m68k_030_isa_extra$export_newline$m68k_040_isa_extra$export_newline$m68k_060_isa_extra$export_newline$m68k_ac080_isa_extra$export_newline"
        aros_isa_extra="$aros_isa_extra$m68k_020_cppflags$export_newline$m68k_030_cppflags$export_newline$m68k_040_cppflags$export_newline$m68k_060_cppflags$export_newline"
        aros_isa_extra="$aros_isa_extra$m68k_020_cflags$export_newline$m68k_030_cflags$export_newline$m68k_040_cflags$export_newline$m68k_060_cflags$export_newline"
        aros_isa_extra="$aros_isa_extra$m68k_020_ldflags$export_newline$m68k_030_ldflags$export_newline$m68k_040_ldflags$export_newline$m68k_060_ldflags$export_newline"
        aros_isa_extra="$aros_isa_extra$m68k_020_ext$export_newline$m68k_030_ext$export_newline$m68k_040_ext$export_newline$m68k_060_ext$export_newline"
        ;;
    *x86_64*)
        aros_isa_extra="$export_newline$x86_isa_extra$export_newline$x86_64_isa_extra$export_newline"
        dnl x86_64 can build 32 or 64bit code
        spec_obj_format="%{!m32:-m elf_x86_64} %{m32:-m elf_i386}"
        ;;
    arm*)
        dnl ARM defaults are: armv6 + vfp (unless overriden in per-target section above)
        if test "$gcc_default_cpu" = ""; then
            gcc_default_cpu="armv6"
        fi
        if test "$gcc_default_fpu" = ""; then
            gcc_default_fpu="vfp"
        fi
        if test "$gcc_default_endian" = ""; then
            if test "$target_cpu" = "armeb"; then
                gcc_default_endian="big-endian"
            else
                gcc_default_endian="little-endian"
            fi
        fi
        if test "$gcc_default_float_abi" = ""; then
            if test "$target_cpu" = "armhf"; then
                gcc_default_float_abi="hard"
            else
                gcc_default_float_abi="softfp"
            fi
        fi

        AC_MSG_CHECKING([Which minimum CPU to use])
        AC_ARG_WITH(cpu,AC_HELP_STRING([--with-cpu=<spec>],[Specify minumum CPU (default=$gcc_default_cpu).]),aros_gcc_cpu="$withval",aros_gcc_cpu=$gcc_default_cpu)
        AC_MSG_RESULT($aros_gcc_cpu)

        AC_MSG_CHECKING([Which minimum FPU to use])
        AC_ARG_WITH(fpu,AC_HELP_STRING([--with-fpu=<spec>],[Specify minumum FPU (default=$gcc_default_fpu).]),aros_gcc_fpu="$withval",aros_gcc_fpu=$gcc_default_fpu)
        AC_MSG_RESULT($aros_gcc_fpu)

        AC_MSG_CHECKING([Which floating point ABI to use])
        AC_ARG_WITH(float,AC_HELP_STRING([--with-float=<spec>],[Specify floating point ABI (default=$gcc_default_float_abi).]),aros_gcc_float_abi="$withval",aros_gcc_float_abi=$gcc_default_float_abi)
        AC_MSG_RESULT($aros_gcc_float_abi)

        AC_MSG_CHECKING([Which ARM mode to use])
        if test "$aros_target_cpu_mode" = ""; then
            aros_target_cpu_mode="arm32"
            AC_MSG_RESULT([Defaulting to $aros_target_cpu_mode])
        else
            AC_MSG_RESULT([$aros_target_cpu_mode])
        fi

        case "$aros_target_cpu_mode" in
        arm32)
            gcc_default_mode="arm"
            aros_isa_flags="$aros_isa_flags -m$gcc_default_mode -m$gcc_default_endian -mthumb-interwork -march=$aros_gcc_cpu -mfpu=$aros_gcc_fpu -mfloat-abi=$aros_gcc_float_abi"
        ;;
        arm64)
            AC_MSG_ERROR([ARM 64-bit mode is unsupported])
        ;;
        thumb)
            AC_MSG_ERROR([Thumb1 16-bit mode is unsupported])
        ;;
        thumb1)
            AC_MSG_ERROR([Thumb1 16-bit mode is unsupported])
        ;;
        thumb2)
            gcc_default_mode="thumb"
            # Do not specify -mthumb-interwork as it may add extra code to support arm/thumb interwork
            aros_isa_flags="$aros_isa_flags -m$gcc_default_mode -$gcc_default_endian -march=$aros_gcc_cpu -mfpu=$aros_gcc_fpu -mfloat-abi=$aros_gcc_float_abi"
        ;;
        *)
            AC_MSG_ERROR([Unsupported ARM mode specified $aros_target_cpu_mode])
        ;;
        esac

        aros_config_cflags="$aros_config_cflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        aros_config_cxxflags="$aros_config_cxxflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        aros_config_aflags="$aros_config_aflags $""(CFLAGS_NO_ASYNCHRONOUS_UNWIND_TABLES) $""(CFLAGS_NO_EXCEPTIONS)"
        ;;
    i386)
        aros_isa_extra="$x86_isa_extra$export_newline$x86_64_isa_extra$export_newline"
        aros_kernel_ldflags="$aros_kernel_ldflags -m32" 
        ;;
esac

# Some architectures may need custom ELF specs.
if test -f $SRCDIR/config/${aros_object_format}-specs.in; then
    elf_specs_in=config/${aros_object_format}-specs.in
else
    elf_specs_in=config/elf-specs.in
fi

# Some compilers (ppc-elf-gcc is known to) have CPU defines in specs
# Since we override specs, we may need to put these defines there
if test "$gcc_target_cpu" != ""; then
    gcc_target_cpu="-D__${gcc_target_cpu}__"
fi

AC_MSG_CHECKING([where to download sourcecode for external ports])
AC_ARG_WITH(portssources,AC_HELP_STRING([--with-portssources=DIR],[Where to download sourcecode for external ports]),with_portssrcdir=$withval,with_portssrcdir="default")
if test "$with_portssrcdir" = "default"; then
    AROS_PORTSSRCDIR="$AROS_BUILDDIR_UNIX/bin/Sources"
else
    AROS_PORTSSRCDIR="$with_portssrcdir"
fi
AC_MSG_RESULT($AROS_PORTSSRCDIR)

AC_MSG_CHECKING([which bootloader to use])
AC_ARG_WITH(bootloader,AC_HELP_STRING([--with-bootloader=NAME],[Use a specific bootloader]),target_bootloader=$withval,target_bootloader=$target_bootloader)
if test "$target_bootloader" = "none"; then
    aros_target_bootloader=""
else
    aros_target_bootloader="$target_bootloader"
fi
AC_MSG_RESULT($target_bootloader)

AC_MSG_CHECKING([which icon-set to use])
AC_ARG_WITH(iconset,AC_HELP_STRING([--with-iconset=NAME],[Use a specific Icon-set (default=Gorilla).]),target_iconset=$withval,target_iconset="default")
if test "$target_iconset" = "default"; then
    aros_target_iconset="Gorilla"
    target_iconset="default (Gorilla)"
else
    aros_target_iconset="$target_iconset"
fi
AC_MSG_RESULT($target_iconset)

AC_MSG_CHECKING([which GUI Theme to use])
AC_ARG_WITH(theme,AC_HELP_STRING([--with-theme=NAME],[Use a specific GUI Theme]),target_guitheme=$withval,target_guitheme="default")
if test "$target_guitheme" = "default"; then
    aros_target_guitheme="Ice"
else
    aros_target_guitheme="$target_guitheme"
fi
AC_MSG_RESULT($aros_target_guitheme)

# Find out if we are cross-compiling (i.e. if we can't use the host compiler
# for target code)
cross_compiling=no

dnl The first case is simple. If we are compiling for another CPU, we are cross-compiling for sure
if test "$aros_host_cpu" != "$aros_target_cpu" ; then
    cross_compiling=yes
fi

dnl x86-64 toolchains can also produce i386 binaries, given -m32 flag.
dnl The flag itself is given in per-target section, because some targets require to pass it
dnl in a different manner, otherwise some tests fail.
dnl TODO: Justify this.
if test "$aros_host_cpu" == "x86_64" ; then
    if test "$aros_target_cpu" == "i386" ; then
        cross_compiling=no
    fi
fi

if test "x-$aros_flavour" = "x-emulation" -o "x-$aros_flavour" = "x-emulcompat" ; then
    dnl For a hosted build we are cross-compiling if host OS differs from build OS.
    dnl TODO: This might get a little bit more tricky if we ever cross-compile ARM-Android-hosted
    dnl AROS on ARM Linux, or even vice versa (Linux-hosted ARM AROS building on ARM Android).
    dnl ARM ABIs of Linux and Android are not compatible (despite very close), so host_cc can't be
    dnl used to build bootstrap for target arch in either case.
    dnl For us Android is not a separate OS, but a variant of Linux, so both systems will be
    dnl identified as 'linux'. If this ever involves, we'll have to implement some additional check,
    dnl perhaps introducing aros_host_variant
    if test "$aros_host_arch" != "$aros_target_arch" ; then
        cross_compiling=yes
    fi
else
    dnl For a native build we only care if our host_cc can produce static ELF files. If so, we can use
    dnl it as kernel_cc. If not, (e.g. we are on Windows or Darwin), we need a crosscompiler.
    dnl if test "$host_cc_elf" = "no" ; then
        cross_compiling=yes
    dnl fi
fi

if test "$cross_compiling" = "no" ; then
    kernel_tool_prefix=""
    if test "$host_cc_elf" = "yes" ; then
        elf_tool_prefix=""
    fi
fi

if test "$kernel_tool_version" != ""; then
    kernel_tool_version="-$kernel_tool_version"
fi

#######################################################################
## Compute what toolchains to use, and their paths                   ##
#######################################################################
#
# This takes, as input:
#   crosstools             {yes,no}
#   kernel_tool_version    {"",[version]}
#   target_tool_version    {"",[version]}
#   kernel_tool_prefix     {none,[some-arch-os-]}
#   gnu-toolchain -:
#     target_tool_prefix     ${aros_target_cpu}-aros-
#     aros_tool_prefix       ${aros_target_cpu}-aros-
#
# The output is
#   aros_kernel_{cpp,cc,ar,ld,as,ranlib,nm,strip}
#        Where the 'kernel' binaries are located
#   orig_target_{cpp,cc,ar,ld,as,ranlib,nm,strip}
#        Where the 'target' binaries are located
#        (not the symlink farm - that is aros_target_*!)
#
# The rules are:
#   if crosstools then
#      if kernel_tools_prefix = "no-kernel-prefix-"
#          aros_kernel_* = crosstools cc paths
#          aros_kernel_cc = elf cc wrapper around crosstools cc
#      else
#          VALIDATE(${kernel_tools_prefix}*)
#          aros_kernel_* = ${kernel_tools_prefix}*
#          if ${kernel_tools_prefix}cc is an AROS gcc
#              aros_kernel_cc = ${kernel_tools_prefix}cc
#          else
#              aros_kernel_cc = elf cc wrapper around ${kernel_tools_prefix}cc
#          fi
#      fi
#
#      orig_target_* = aros built crosstools
#      orig_target_cc = elf cc wrapper around crosstools cc
#   else
#      VALIDATE(${kernel_tools_prefix}*)
#
#      orig_target_* = aros_kernel_*
#      if aros_kernel_cc is an AROS gcc
#          orig_target_cc = aros_kernel_cc
#      else
#          orig_target_cc = aros cc wrapper around aros_kernel_cc
#      fi
#   fi
#
if test "$aros_toolchain" = "gnu" ; then
    target_tool_prefix="${aros_target_cpu}-aros-"
elif test "$aros_toolchain" = "llvm" ; then
    target_tool_prefix="bin/"
fi

if test "$kernel_tool_prefix" != "" ; then
    AC_MSG_CHECKING([which kernel tools])
    AC_MSG_RESULT([$kernel_tool_prefix]);
fi

if test "$kernel_tool_prefix" = "none" ; then
    dnl ELF wrapper can be used only for native bootstrap
    if test "x-$aros_flavour" = "x-emulation" -o "x-$aros_flavour" = "x-emulcompat" ; then
        AC_MSG_ERROR([--with-kernel-toolchain-prefix= is required for this arch])
    fi
else
    if test "x-$aros_flavour" != "x-standalone" -o "x-$aros_flavour" != "x-standcompat" ; then
        # Kernel tools required - find them
        # Note that 'normally', aros_kernel_* overrides will be
        # empty, unless specified in the per-arch sections above.
        test_kernel_cc=yes
        if test "x$aros_kernel_cpp" = "x"; then
            aros_kernel_cpp=${kernel_tool_prefix}${CPP}
        fi
        AROS_BUILDCMD(aros_kernel_cpp,$aros_kernel_cpp,${kernel_tool_version})
        AROS_TOOL_KERNEL(aros_kernel_cpp,cpp,$aros_kernel_cpp)
        AROS_REQUIRED(cpp,$aros_kernel_cpp)

        if test "x$aros_kernel_cc" = "x"; then
            aros_kernel_cc=${kernel_tool_prefix}${CC}
        fi
        AROS_BUILDCMD(aros_kernel_cc,$aros_kernel_cc,${kernel_tool_version})
        AROS_TOOL_KERNEL(aros_kernel_cc,cc,$aros_kernel_cc)
        AROS_REQUIRED(cc,$aros_kernel_cc)

        if test "x$aros_kernel_cxx" = "x"; then
            aros_kernel_cxx=${kernel_tool_prefix}${CXX}
        fi
        AROS_BUILDCMD(aros_kernel_cxx,$aros_kernel_cxx,${kernel_tool_version})
        AROS_TOOL_KERNEL(aros_kernel_cxx,cxx,$aros_kernel_cxx)
        # If it's set, make sure it's really there
        if test "x$aros_kernel_cxx" != "x" ; then
            AROS_REQUIRED(cxx,$aros_kernel_cxx)
        fi
        AROS_TOOL_KERNEL(aros_kernel_ld,ld,$aros_kernel_ld)
        AROS_REQUIRED(ld,$aros_kernel_ld)
        AROS_TOOL_KERNEL(aros_kernel_as,as,$aros_kernel_as)
        AROS_REQUIRED(as,$aros_kernel_as)
        AROS_TOOL_KERNEL(aros_kernel_ar,ar,$aros_kernel_ar)
        AROS_REQUIRED(ar,$aros_kernel_ar)
        AROS_TOOL_KERNEL(aros_kernel_ranlib,ranlib,$aros_kernel_ranlib)
        AROS_REQUIRED(ranlib,$aros_kernel_ranlib)
        AROS_TOOL_KERNEL(aros_kernel_nm,nm,$aros_kernel_nm)
        AROS_REQUIRED(nm,$aros_kernel_nm)
        AROS_TOOL_KERNEL(aros_kernel_strip,strip,$aros_kernel_strip)
        AROS_REQUIRED(strip,$aros_kernel_strip)

        # Objcopy and objdump are not required for the kernel
        # toolchain on many architectures.
        # So we'll look for them, but not make them strictly required.
        AROS_TOOL_KERNEL(aros_kernel_objcopy,objcopy,$aros_kernel_objcopy)
        AROS_TOOL_KERNEL(aros_kernel_objdump,objdump,$aros_kernel_objdump)
        if test "x${crosstools}" != "xyes" ; then
            AROS_REQUIRED(objcopy,$aros_kernel_objcopy)
            AROS_REQUIRED(objdump,$aros_kernel_objdump)
        fi
    fi
fi

AC_MSG_CHECKING([which target tools to use])
if test "$aros_target_toolchain" = "yes"; then
    if test "$aros_toolchain" = "llvm" ; then
        msg_result="llvm"
    else
        msg_result=$target_tool_prefix
    fi
    AC_MSG_RESULT([$msg_result])
    # We are building AROS crosstools
    tmp_tool_prefix="$AROS_CROSSTOOLSDIR/${target_tool_prefix}"
    orig_target_cc="${tmp_tool_prefix}${toolchain_c_compiler}${target_tool_version}"
    orig_target_cxx="${tmp_tool_prefix}${toolchain_cxx_compiler}${target_tool_version}"
    orig_target_cpp="${tmp_tool_prefix}${toolchain_cpp_preprocessor}"
    orig_target_ld="${tmp_tool_prefix}${toolchain_ld}"
    orig_target_as="${tmp_tool_prefix}${toolchain_as}"
    orig_target_ar="${tmp_tool_prefix}${toolchain_ar}"
    orig_target_ranlib="${tmp_tool_prefix}${toolchain_ranlib}"
    orig_target_nm="${tmp_tool_prefix}${toolchain_nm}"
    orig_target_strip="${tmp_tool_prefix}${toolchain_strip}"
    orig_target_objcopy="${tmp_tool_prefix}${toolchain_objcopy}"
    orig_target_objdump="${tmp_tool_prefix}${toolchain_objdump}"
else
    # Determine whether AROS or ELF tools should be used
    if test "$aros_tool_prefix" = "none"; then
        aros_tool_prefix="${elf_tool_prefix}"
    fi

    AC_MSG_RESULT([$aros_tool_prefix])
    # We are *not* building AROS crosstools - use the AROS or ELF tools
    AROS_TOOL_TARGET(orig_target_cpp,cpp,${aros_tool_prefix}${toolchain_cpp_preprocessor}${target_tool_version})
    AROS_REQUIRED(cpp,$orig_target_cpp)
    AROS_TOOL_TARGET(orig_target_cc,gcc,${aros_tool_prefix}${toolchain_c_compiler}${target_tool_version})
    AROS_REQUIRED(cc,$orig_target_cc)
    AROS_TOOL_TARGET(orig_target_cxx,g++,${aros_tool_prefix}${toolchain_cxx_compiler}${target_tool_version})
    AROS_REQUIRED(cxx,$orig_target_cxx)
    AROS_TOOL_TARGET(orig_target_ld,gcc,${aros_tool_prefix}${toolchain_ld})
    AROS_REQUIRED(ld,$orig_target_ld)
    AROS_TOOL_TARGET(orig_target_as,as,aros_tool_prefix}${toolchain_as})
    AROS_REQUIRED(as,$orig_target_as)
    AROS_TOOL_TARGET(orig_target_ar,ar,${aros_tool_prefix}${toolchain_ar})
    AROS_REQUIRED(ar,$orig_target_ar)
    AROS_TOOL_TARGET(orig_target_ranlib,ar,${aros_tool_prefix}${toolchain_ranlib})
    AROS_REQUIRED(ranlib,$orig_target_ranlib)
    AROS_TOOL_TARGET(orig_target_nm,nm,${aros_tool_prefix}${toolchain_nm})
    AROS_REQUIRED(nm,$orig_target_nm)
    AROS_TOOL_TARGET(orig_target_strip,strip,${aros_tool_prefix}${toolchain_strip})
    AROS_REQUIRED(strip,$orig_target_strip)
    AROS_TOOL_TARGET(orig_target_objcopy,objcopy,${aros_tool_prefix}${toolchain_objcopy})
    AROS_REQUIRED(objcopy,$orig_target_objcopy)
    AROS_TOOL_TARGET(orig_target_objdump,objdump,${aros_tool_prefix}${toolchain_objdump})
    AROS_REQUIRED(objdump,$orig_target_objdump)
fi

if test "$kernel_tool_prefix" = "none" ; then
    # No kernel tools specified
    # Assume target tools == kernel tools with ELF wrapper
    aros_kernel_cc=$orig_target_cc
    aros_kernel_cxx=$orig_target_cxx
    aros_kernel_cpp=$orig_target_cpp
    aros_kernel_ld=$orig_target_ld
    aros_kernel_as=$orig_target_as
    aros_kernel_ar=$orig_target_ar
    aros_kernel_ranlib=$orig_target_ranlib
    aros_kernel_nm=$orig_target_nm
    aros_kernel_strip=$orig_target_strip
    aros_kernel_objcopy=$orig_target_objcopy
    aros_kernel_objdump=$orig_target_objdump
    use_kernel_cc_wrapper=yes
fi

# At this point, all aros_kernel_* and aros_target_* 
# tools should be set up correctly

CC="$aros_kernel_cc $kernel_tool_flags"
CPP="$aros_kernel_cpp"

#-----------------------------------------------------------------------------

# Find all the tools we need to compile. This could be cross-compiling
# though! If that is the case we use the GNU form of the target and
# simply add this to the front of the binary name. This is rather simple,
# but it should work under most circumstances.
#
# The default tools are to use the same as the host, but only if the
# host and target CPU are the same. With GCC this is normally enough.
#

aros_cc_pre=""
aros_shared_ld="$aros_host_ld"

aros_target_mkdep="$aros_host_mkdep"

# The default tools executables to be linked to.
if test "$rescomp" != ""; then
    AC_PATH_PROG(aros_kernel_rescomp,${kernel_tool_prefix}$rescomp)
    AROS_REQUIRED($rescomp,$aros_kernel_rescomp)
fi

# Set up the sources for the symlink farm
if test "$crosstools" = "yes"; then
    crosstools_target=tools-crosstools
fi

aros_kernel_cc="$aros_kernel_cc $kernel_tool_flags"
aros_kernel_ar="$aros_kernel_ar $aros_kernel_ar_flags"

aros_hostcfg_dir="bin/${aros_host_arch}-${aros_host_cpu}/gen/host/config"
aros_targetcfg_dir="bin/${aros_target_arch}-${aros_target_cpu}${aros_target_suffix}/gen/config"
aros_inc_dir="bin/${aros_target_arch}-${aros_target_cpu}${aros_target_suffix}/AROS/Developer/include/aros"
aros_gendir="bin/${aros_target_arch}-${aros_target_cpu}${aros_target_suffix}/gen"
aros_geninc_dir="bin/${aros_target_arch}-${aros_target_cpu}${aros_target_suffix}/gen/include/aros"
aros_tools_dir="bin/${aros_host_arch}-${aros_host_cpu}/tools"
aros_scripts_dir="bin/${aros_target_arch}-${aros_target_cpu}${aros_target_suffix}/gen/scripts"

# aros_cc_pre is a variable that is added to the front of the compiler name
# in the generated aros-gcc shell script. We need this to enable the cache
# to work across cleaned builds. Also, support DISTCC using the correct
# environment variable.
#

if test "x${DISTCC}" != "x" ; then
    if test "x${CCACHE}" != "x" ; then
        aros_cc_pre="env CCACHE_PREFIX=${DISTCC} ${CCACHE} "
    else
        aros_cc_pre="${DISTCC} "
    fi
else
    if test "x${CCACHE}" != "x" ; then
        aros_cc_pre="${CCACHE} "
    fi
fi

AC_SUBST(aros_target_nostdinc_cflags,-nostdinc)
AC_SUBST(aros_target_nostartup_ldflags,-nostartfiles)
AC_SUBST(aros_target_nix_ldflags,-nix)
AC_SUBST(aros_target_detach_ldflags,-detach)
AC_SUBST(aros_target_nostdlib_ldflags,-nostdlib)

aros_target_cc_path=

# Target tools
AC_SUBST(aros_toolchain)
if test "$aros_target_toolchain" != "yes"; then
    prefix="${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-"
    if test "$GCC" = "yes"; then
        aros_target_cc_path=`$orig_target_cc -print-search-dirs | grep "programs: =" | cut -c 12-`
    fi
else
    # We do not know which c compiler version we are going to build and what we need to know
    # here is different for different versions so this will be set later during the
    # build of crosstools.
    if test "$aros_toolchain" = "gnu" ; then
        prefix="$AROS_CROSSTOOLSDIR/${aros_target_cpu}-aros-"
    elif test "$aros_toolchain" = "llvm" ; then
        prefix="$AROS_CROSSTOOLSDIR/bin/"
    fi
    aros_target_cc_path=@aros_target_cc_path@
fi
aros_target_cpp="${prefix}${toolchain_cpp_preprocessor}"
aros_target_cc="${prefix}${toolchain_c_compiler}"
aros_target_cxx="${prefix}${toolchain_cxx_compiler}"
aros_target_as="${prefix}${toolchain_as}"
if test "${use_ld_wrapper}" = "yes"; then
    aros_target_ld="${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-${aros_ld}"
else
    aros_target_ld="${prefix}${toolchain_ld}"
fi
aros_toolchain_ld="${prefix}${toolchain_ld}"

aros_target_ar="${prefix}${toolchain_ar} $aros_target_ar_flags"
aros_target_objcopy="${prefix}${toolchain_objcopy}"
aros_target_objdump="${prefix}${toolchain_objdump}"
aros_target_ranlib="${prefix}${toolchain_ranlib} $aros_target_ranlib_flags"
aros_target_nm="${prefix}${toolchain_nm} $aros_target_nm_flags"
aros_target_strip="${prefix}${toolchain_strip}"
aros_plain_nm="${prefix}${toolchain_nm}"
aros_plain_ar="${prefix}${toolchain_ar}"

AC_ARG_ENABLE(includes,
AC_HELP_STRING([--enable-includes=dir],[Alternative system include directory]),
[aros_target_incl=$enable_includes], [aros_target_incl=no])

if test "x$aros_target_incl" = "xno"; then
    if test "x$test_kernel_cc" != "xno"; then
        aros_target_incl=`$aros_kernel_cc -print-sysroot`/`$aros_kernel_cc --print-sysroot-headers-suffix 2>/dev/null || echo usr/include`
    else
        aros_target_incl=
    fi
fi

if test "x$aros_kernel_includes" = "x"; then
    if test "x-$aros_flavour" = "x-emulation" -o "x-$aros_flavour" = "x-emulcompat" ; then
        if test "x$aros_target_incl" != "x"; then
            aros_kernel_includes="-isystem $aros_target_incl"
        fi
    fi
fi

if test "x$test_kernel_cc" != "xno"; then
    if test "$aros_kernel_includes" != "" ; then
        dnl find out about the kernel cc's include path
        AC_MSG_CHECKING([for the kernel compiler's include path])
        if test "$aros_kernel_cc_includes" = "" ; then
            # Try to guess where the directory is.
            aros_kernel_cc_includes=`dirname \`${aros_kernel_cc} ${aros_kernel_cflags} -print-libgcc-file-name\``/include
            if test -d $aros_kernel_cc_includes; then
                # Check if there is also an include-fixed directory and add it
                # to kernel compiler's include path as it may contain some of
                # the headers we need.
                if test -d "$aros_kernel_cc_includes"-fixed; then
                    aros_kernel_cc_includes+=" -isystem $aros_kernel_cc_includes"-fixed
                fi
                # Check for specific includes directory. Needed for Ubuntu 11.10 and Debian
                if test -d "/usr/include/${aros_target_cpu}-linux-gnu"; then
                    aros_kernel_cc_includes+=" -isystem /usr/include/${aros_target_cpu}-linux-gnu"
                fi
            else
                # The directory doesn't exist, we need to do some more work.
                aros_kernel_cc_includes=${PWD}/${aros_gendir}/cc_include

                # These are the headers we're looking for.
                headers="limits.h mmintrin.h stdbool.h syslimits.h float.h \
                         stddef.h xmmintrin.h iso646.h stdarg.h unwind.h   \
                         zutil.h stdint.h"

                dirs=
                for h in $headers; do
                    # Which other headers are needed by each of the above?
                    deps=$(echo "#include <$h>" | \
                           $aros_kernel_cc -E -M - 2>/dev/null | \
                           sed 's/^.*://; s/\\$/ /g; s/[[ \t]]\+/ /g')

                    # Copy all the needed headers to a directory beneath gendir.
                    for d in $deps; do
                        h=$(basename $d)
                        dir=${aros_kernel_cc_includes}$(echo $(dirname $d) | \
                                                sed -n "s,^.*/include\(/.*\),\1,p")
                        ! test -d $dir && mkdir -p $dir
                        ! test -f $dir/$h && { cp $d $dir; chmod u+w $dir/$h; }
                    done
                done            
            fi
        fi
        AC_MSG_RESULT($aros_kernel_cc_includes)
        # Adding -nostdinc to kernel includes as they are always used together.
        aros_kernel_includes="$aros_kernel_includes $aros_target_nostdinc_cflags -isystem $aros_kernel_cc_includes"
    fi
fi

if test "$crosstools" != "yes"; then
    dnl find out about the target cc's include path
    AC_MSG_CHECKING([for the target compiler's include path])
    if test "$aros_target_cc_includes" = "" ; then
        #try to guess where the directory is
        aros_target_cc_includes=`dirname \`${orig_target_cc} -print-libgcc-file-name\``/include
        if ! test -d $aros_target_cc_includes; then
            #the directory doesn't exist, we need to do some more work
            aros_target_cc_includes=${PWD}/${aros_gendir}/cc_include
        
            #these are the headers we're looking for
            headers="limits.h mmintrin.h stdbool.h syslimits.h float.h \
                    stddef.h xmmintrin.h iso646.h stdarg.h unwind.h   \
                    zutil.h"

            dirs=
            for h in $headers; do
                #which other headers each of the above headers needs?
                deps=$(echo "#include <$h>" | \
                    $orig_target_cc -E -M - 2>/dev/null | \
                    sed 's/^.*://; s/\\$/ /g; s/[[ \t]]\+/ /g')
            
                #copy all the needed headers to a directory beneath gendir
                for d in $deps; do
                    h=$(basename $d)
                    dir=${aros_target_cc_includes}$(echo $(dirname $d) | \
                                                sed -n "s,^.*/include\(/.*\),\1,p")
                    ! test -d $dir && mkdir -p $dir
                    ! test -f $dir/$h && { cp $d $dir; chmod u+w $dir/$h; }
                done
            done
        fi
    fi
    AC_MSG_RESULT($aros_target_cc_includes)
else
    # We do not know which c compiler version we are going to build and what we need to know
    # here is different for different versions so this will be set later during the
    # build of crosstools.
    aros_target_cc_includes=@aros_target_cc_includes@
fi

#
# For GCC < 4.0 -I- is used for giving the search path for '#include "..."'
# On GCC >= 4.0 -iquote should be used
#

save_cc="$CC"
save_cflags="$CFLAGS"
if test "x$test_kernel_cc" != "xno"; then
    CFLAGS="-iquote."
    kernel_cflags_iquote=$host_cflags_iquote
    kernel_cflags_iquote_end=$host_cflags_iquote_end
    if test "x-$cross_compiling" = "x-yes"; then
        CC="$aros_kernel_cc"
        AC_MSG_CHECKING([whether ${CC} accepts -fno-stack-protector])
        if test "x-$crosstools" != "x-yes"; then
            AC_TRY_COMPILE(,, use_no_stack_protector="yes", use_no_stack_protector="no")
        else
            # we do know it is supported for the smallest version of gcc we are going to build
            # we assume it's also supported by later versions
            use_no_stack_protector=yes
        fi
        AC_MSG_RESULT($use_no_stack_protector)
        AC_MSG_CHECKING([whether ${CC} accepts -iquote])
        if test "x-$crosstools" != "x-yes"; then
            AC_TRY_COMPILE(,, has_iquote="yes", has_iquote="no")
        else
            # we do know it is supported for the smallest version of gcc we are going to build
            # we assume it's also supported by later versions
            has_iquote=yes
        fi
        AC_MSG_RESULT($has_iquote)
        if test "x-$has_iquote" = "x-yes" ; then
            kernel_cflags_iquote=-iquote
            kernel_cflags_iquote_end=
        else
            kernel_cflags_iquote=-I
            kernel_cflags_iquote_end=-I-
        fi
    fi
    if test "x-$use_no_stack_protector" = "x-yes" ; then
        aros_kernel_cflags="$aros_kernel_cflags -fno-stack-protector"
    fi

    #-----------------------------------------------------------------------------

    # Check if we can explicitly choose older version of symbol hashing

    CFLAGS="save_cflags -Wl,--hash-style=sysv"
    CC="$aros_kernel_cc"
    AC_MSG_CHECKING([whether ${CC} accepts -Wl,--hash-style=sysv])
    AC_TRY_LINK(,, use_hash_style="yes", use_hash_style="no")
    AC_MSG_RESULT($use_hash_style)
    if test "x-$use_hash_style" = "x-yes" ; then
        aros_kernel_cflags="$aros_kernel_cflags -Wl,--hash-style=sysv"
    fi
else
    kernel_cflags_iquote="$""(CFLAGS_IQUOTE)"
    kernel_cflags_iquote_end="$""(CFLAGS_IQUOTE_END)"
fi
CC="$save_cc"
CFLAGS="$save_cflags"

AC_SUBST(host_cflags_iquote)
AC_SUBST(host_cflags_iquote_end)
AC_SUBST(kernel_cflags_iquote)
AC_SUBST(kernel_cflags_iquote_end)


dnl Check if user specified --with-resolution=XRESxYRESxDEPTH
AC_MSG_CHECKING([for default resolution of WBScreen])
AC_ARG_WITH(resolution,AC_HELP_STRING([--with-resolution=XRESxYRESxDEPTH],[Default resolution of the initial WorkbenchScreen]),resolution=$withval,resolution=none)
# We require an argument, so map --with/--without ("yes"/"no") to "none" specified
if test "$resolution" = "yes" ; then
    resolution="none"
fi
if test "$resolution" = "no" ; then
    resolution="none"
fi
if test "$resolution" != "none" ; then
    aros_nominal_width=`echo $resolution | cut -d'x' -f1`
    aros_nominal_height=`echo $resolution | cut -d'x' -f2`
    aros_nominal_depth=`echo $resolution | cut -d'x' -f3`
fi
AC_MSG_RESULT($aros_nominal_width x $aros_nominal_height x $aros_nominal_depth)
aros_cv_nominal_width=$aros_nominal_width
aros_cv_nominal_height=$aros_nominal_height
aros_cv_nominal_depth=$aros_nominal_depth

dnl See if the user wants the serial debug output for native flavour
AC_MSG_CHECKING([whether serial debug is enabled])
AC_ARG_WITH(serial-debug,AC_HELP_STRING([--with-serial-debug],[Enable serial debug output in native (default=no)]),serial_debug=$withval,serial_debug=none)
if test "$aros_serial_debug" = 0 ; then
    serial_debug_forced=""
    if test "$serial_debug" = "yes" ; then
        serial_debug="1"
    fi
    if test "$serial_debug" = "no" ; then
        serial_debug="none"
    fi
else
    serial_debug_forced="(forced)"
    serial_debug=$aros_serial_debug
fi
if test "$serial_debug" != "none" ; then
    aros_serial_debug=$serial_debug
    AC_MSG_RESULT($serial_debug_forced on port $serial_debug)
else
    AC_MSG_RESULT(no)
fi

dnl See if the user wants the palm debug output hack for palm native flavour
AC_MSG_CHECKING([whether palm debug hack is enabled])
AC_ARG_ENABLE(palm_debug_hack,AC_HELP_STRING([--enable-palm-debug-hack],[Enable palm debug output hack in palm native (default=no)]),palm_debug_hack="yes",palm_debug_hack="no")
if test "$palm_debug_hack" = "yes" ; then
    aros_palm_debug_hack="1"
fi
AC_MSG_RESULT($palm_debug_hack)

dnl See if dev wants the usb3.0 code
AC_MSG_CHECKING([whether usb3.0 code is enabled])
AC_ARG_ENABLE(usb30_code,AC_HELP_STRING([--enable-usb30-code],[Enable usb3.0 code (default=no)]),usb30_code="yes",usb30_code="no")
if test "$usb30_code" = "yes" ; then
    aros_config_cppflags="$aros_config_cppflags -DAROS_USB30_CODE"
    aros_kernel_cflags="$aros_kernel_cflags -DAROS_USB30_CODE"
fi
AC_MSG_RESULT($usb30_code)

dnl See if the user wants nesting supervisor activated for unix flavour
AC_MSG_CHECKING([whether nesting supervisor support is enabled])
AC_ARG_ENABLE(nesting_supervisor,AC_HELP_STRING([--enable-nesting-supervisor],[Enable nesting supervisor support in unix (default=no)]),nesting_supervisor="yes",nesting_supervisor="no")
if test "$nesting_supervisor" = "yes" ; then
    aros_nesting_supervisor="1"
fi
AC_MSG_RESULT($nesting_supervisor)

dnl See if the user wants to disable MMU support
dnl This can be overriden on per-target basis,
dnl set $aros_enable_mmu to "yes" or "no" to do this
if test "$aros_enable_mmu" = "" ; then
    AC_MSG_CHECKING([whether MMU support is enabled])
    dnl Enabled by default
    AC_ARG_ENABLE(mmu,AC_HELP_STRING([--disable-mmu],[Disable MMU support (default=enabled)]),aros_enable_mmu=$enableval,aros_enable_mmu="yes")
    if test "$aros_enable_mmu" = "" ; then
        aros_enable_mmu="yes"
    fi
    AC_MSG_RESULT($aros_enable_mmu)
fi
if test "$aros_enable_mmu" = "no" ; then
    aros_enable_mmu="0"
else
    aros_enable_mmu="1"
fi
    

dnl things specifically required for hosted flavours
if test "x-$aros_flavour" = "x-emulation" -o "x-$aros_flavour" = "x-emulcompat" ; then

    if test "x-$need_dlopen" != "x-no" ; then
      save_libs="$LIBS"
      LIBS=""
      dnl some kind of dynamic library access system is required for hostlib.resource
      AC_CHECK_FUNC(dlopen, have_dl="yes", have_dl="no")
      if test "x-$have_dl" = "x-no" ; then
          AC_CHECK_LIB(dl, dlopen, [have_dl="yes"
                                    aros_host_ldflags="$aros_host_ldflags -ldl"],
                                    have_dl="no")
      fi
      if test "x-$have_dl" = "x-no" ; then
          AC_MSG_ERROR([dlopen() dynamic linker functions not available])
      fi
      LIBS="$save_libs"
    fi


    dnl x11 hidd
    AC_ARG_ENABLE(x11_hidd, AC_HELP_STRING([--enable-x11-hidd],
                                           [build X11 hidd for hosted (default=auto)]),
                                           x11_hidd="$enableval",
                                           x11_hidd="$need_x11")
    case "x-$x11_hidd" in
        x-yes|x-no|x-auto)                 ;;
        *)                 x11_hidd="$need_x11" ;;
    esac

    ENABLE_X11=0

    dnl they want it
    if test "x-$x11_hidd" != "x-no" ; then

        dnl find x11 stuff
        AC_PATH_X

        if test -n "$x_includes"; then
            X_CFLAGS="$X_CFLAGS -I$x_includes"
        fi

        if test -n "$x_libraries"; then
            X_LIBS="$X_LIBS -L$x_libraries"
        fi

        if test "x-$no_x" = "x-yes" ; then

            dnl didn't find it
            if test "x-$x11_hidd" != "x-auto" ; then
                dnl and they explicitly asked for it, bail out
                AC_MSG_ERROR([X11 libs/headers not found, cannot build X11 hidd as requested])
            fi
        
        else
            dnl found it, setup the metatarget
            aros_target_options+="$export_newline""# Enable X11 Gfx Driver$export_newline""OPT_HOST_X11GFX               := yes$export_newline"
            if test "x-$host_feature_glx" != "x-no" ; then
                aros_target_options+="$export_newline""# Enable X11 HostGL 3D Passthrough$export_newline""OPT_HOST_X11_HOSTGL           := yes$export_newline"
            fi
            ENABLE_X11=1

            aros_host_x11_cflags="$X_CFLAGS"
            aros_host_x11_ldflags="$X_LIBS  -lX11"

            dnl setup shared memory extensions
            AC_ARG_ENABLE(x11_shm, AC_HELP_STRING([--enable-x11-shm],
                                                  [use X11 shared memory (default=auto)]),
                                                  x11_hidd_shm="$enableval",
                                                  x11_hidd_shm="auto")
            case "x-$x11_hidd_shm" in
                x-yes|x-no|x-auto)                     ;;
                *)                 x11_hidd_shm="auto" ;;
            esac

            have_xshm=no

            dnl they want it
            if test "x-$x11_hidd_shm" != "x-no" ; then

                dnl system shm headers
                AC_CHECK_HEADERS(sys/ipc.h)
                AC_CHECK_HEADERS(sys/shm.h)

                dnl got them
                if test "x-$ac_cv_header_sys_ipc_h" = "x-yes" -a "x-$ac_cv_header_sys_shm_h" = "x-yes" ; then

                    dnl make sure X libs have shm functions
                    save_cflags="$CFLAGS"
                    save_ldflags="$LDFLAGS"
                    CFLAGS="$CFLAGS $X_CFLAGS"
                    LDFLAGS="$LDFLAGS $X_LIBS"
                    AC_CHECK_LIB(Xext, XShmQueryExtension, have_xshm=yes)
                    CFLAGS="$save_cflags"
                    LDFLAGS="$save_ldflags"
                fi
            fi

            dnl detection done, prepare output
            if test "x-$have_xshm" = "x-yes" ; then
                dnl we can do shm
                DO_XSHM_SUPPORT="1"
            elif test "x-$x11_hidd_shm" = "x-yes" ; then
                dnl they explicitly asked for it, but we can't do it
                AC_MSG_ERROR([X11 has no support for shared memory, cannot enable it as requested])
            else
                dnl otherwise just disable it
                DO_XSHM_SUPPORT="0"
            fi

            
            dnl setup vidmode (fullscreen) extensions
            AC_ARG_ENABLE(x11_vidmode, AC_HELP_STRING([--enable-x11-vidmode],
                                                      [use X11 vidmode extension (default=auto)]),
                                                      x11_hidd_vidmode="$enableval",
                                                      x11_hidd_vidmode="auto")
            case "x-$x11_hidd_vidmode" in
                x-yes|x-no|x-auto)                         ;;
                *)                 x11_hidd_vidmode="auto" ;;
            esac

            have_vidmode=no

            dnl they want it
            if test "x-$x11_hidd_vidmode" != "x-no" ; then

                dnl make sure X libs have vidmode functions
                save_cflags="$CFLAGS"
                save_ldflags="$LDFLAGS"
                CFLAGS="$CFLAGS $X_CFLAGS"
                LDFLAGS="$LDFLAGS $X_LIBS"
                AC_CHECK_LIB(Xxf86vm, XF86VidModeQueryExtension, have_vidmode=yes)
                CFLAGS="$save_cflags"
                LDFLAGS="$save_ldflags"
            fi

            dnl detection done, prepare output
            if test "x-$have_vidmode" = "x-yes" ; then
                dnl we can do vidmode
                DO_VIDMODE_SUPPORT="1"
            elif test "x-$x11_hidd_vidmode" = "x-yes" ; then
                dnl they explicitly asked for it, but we can't do it
                AC_MSG_ERROR([X11 vidmode extension not available, cannot enable it as requested])
            else
                dnl otherwise just disable it
                DO_VIDMODE_SUPPORT="0"
            fi
        fi
    fi

    dnl sdl hidd
    AC_ARG_ENABLE(sdl_hidd, AC_HELP_STRING([--enable-sdl-hidd],
                                           [build SDL hidd for hosted (default=auto)]),
                                           sdl_hidd="$enableval",
                                           sdl_hidd="auto")
    case "x-$sdl_hidd" in
        x-yes|x-no|x-auto)                 ;;
        *)                 sdl_hidd="auto" ;;
    esac

    dnl they want it
    if test "x-$sdl_hidd" != "x-no" ; then

        dnl find sdl
        SDL_VERSION=1.2.5
        AM_PATH_SDL($SDL_VERSION, [have_sdl="yes"],
            [have_sdl="no"])

        if test "x-$have_sdl" != "x-yes" ; then

            dnl didn't find it
            if test "x-$sdl_hidd" != "x-auto" ; then
                dnl and they explicitly asked for it, bail out
                AC_MSG_ERROR([SDL libs/headers not found, cannot build SDL hidd as requested])
            fi

        else
            dnl found it, enable the build
            aros_target_options+="$export_newline""# Enable SDL Gfx Driver$export_newline""OPT_HOST_SDLGFX               := yes$export_newline"
            aros_host_sdl_cflags=$SDL_CFLAGS
            aros_host_sdl_libs=$SDL_LIBS
        fi
    fi

fi


dnl See if the user wants dbus.library
AC_MSG_CHECKING([whether building of dbus.library is enabled])
AC_ARG_ENABLE(dbus,AC_HELP_STRING([--enable-dbus],[Enable DBUS support via dbus.library (default=no)]),dbus="yes",dbus="no")
if test "$dbus" = "yes" ; then
    ENABLE_DBUS=1
    DBUS_CFLAGS=`pkg-config --cflags dbus-1`
    DBUS_LIBFLAGS=`pkg-config --libs dbus-1`
    KERNEL_DBUS_KOBJ=kernel-dbus-kobj
    KERNEL_DBUS_INCLUDES=kernel-dbus-includes
else
    ENABLE_DBUS=0
fi
AC_MSG_RESULT($dbus)

if test "$use_kernel_cc_wrapper" = "yes" ; then
    aros_kernel_cc="${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-elf-${toolchain_c_compiler}"
fi

aros_kernel_cppflags=$aros_config_cppflags
aros_optimization_cflags="$optimization_level"
if test "$optimization" = "default"; then
AC_MSG_CHECKING([default optimization level to use])
AC_MSG_RESULT($optimization_level)
fi

if ! test "$gcc_default_cpu" = "" ; then
    target_extra_cfg+="$export_newline""# ARM gcc default target$export_newline""GCC_DEFAULT_CPU         := $gcc_default_cpu$export_newline""GCC_DEFAULT_FPU         := $gcc_default_fpu$export_newline""GCC_DEFAULT_FLOAT_ABI   := $gcc_default_float_abi$export_newline""GCC_DEFAULT_MODE        := $gcc_default_mode$export_newline"
fi

dnl --------------------------------------------------------------------
dnl Configuration Output Section
dnl --------------------------------------------------------------------

# Generic
AC_SUBST(aros_arch)
AC_SUBST(aros_cpu)
AC_SUBST(aros_flavour)
AC_SUBST(aros_flavour_uc)
AC_SUBST(aros_target_toolchain)
AC_SUBST(aros_toolchain_ld)
AC_SUBST(aros_build_host)
AC_SUBST(AROS_BUILDDIR)
AC_SUBST(AROS_BUILDDIR_UNIX)
AC_SUBST(SRCDIR)
AC_SUBST(AROS_CROSSTOOLSDIR)
AC_SUBST(AROS_PORTSSRCDIR)

# Compatability with other Amiga-like operation systems
AC_SUBST(aros_amigaos_compliance)

# Host related
AC_SUBST(host_stat_h__unused_used)
AC_SUBST(host_extra_cfg)
AC_SUBST(aros_cc_pre)
AC_SUBST(aros_host_strip)
AC_SUBST(aros_host_arch)
AC_SUBST(aros_host_cpu)
AC_SUBST(aros_host_cpp)
AC_SUBST(aros_host_def_cc)
AC_SUBST(aros_host_cc)
AC_SUBST(aros_host_cxx)
AC_SUBST(aros_host_ar)
AC_SUBST(aros_host_ranlib)
AC_SUBST(aros_host_ld)
AC_SUBST(aros_host_make)
AC_SUBST(aros_host_cppflags)
AC_SUBST(aros_host_cflags)
AC_SUBST(aros_host_cxxflags)
AC_SUBST(gnu89_inline)
AC_SUBST(aros_host_ldflags)
AC_SUBST(aros_host_debug)
AC_SUBST(aros_host_mkdep)
AC_SUBST(aros_host_mkargs)
AC_SUBST(aros_host_exe_suffix)
AC_SUBST(aros_host_lib_suffix)
AC_SUBST(aros_tools_dir)
AC_SUBST(aros_host_aclocal)
AC_SUBST(aros_host_autoconf)
AC_SUBST(aros_host_autoheader)
AC_SUBST(aros_host_automake)
AC_SUBST(ant)

# Target Related
AC_SUBST(aros_elf_translate)
AC_SUBST(make_extra_commands)
AC_SUBST(make_extra_targetcfg)
AC_SUBST(target_extra_cfg)
AC_SUBST(aros_target_options)

AC_SUBST(aros_target_guitheme)
AC_SUBST(aros_target_iconset)
AC_SUBST(aros_target_bootloader)
AC_SUBST(aros_target_arch)
AC_SUBST(aros_target_family)
AC_SUBST(aros_target_cpu)
AC_SUBST(aros_target_cpu_mode)
AC_SUBST(aros_target_variant)
AC_SUBST(aros_target_suffix)
AC_SUBST(aros_target_ar)
AC_SUBST(aros_target_ranlib)
AC_SUBST(aros_plain_nm)
AC_SUBST(aros_plain_ar)
AC_SUBST(aros_kernel_ar)
AC_SUBST(aros_kernel_ranlib)
AC_SUBST(orig_target_cc)
AC_SUBST(aros_target_cc)
AC_SUBST(aros_kernel_cc)
AC_SUBST(orig_target_cxx)
AC_SUBST(aros_target_cxx)
AC_SUBST(aros_kernel_cxx)
AC_SUBST(orig_target_cpp)
AC_SUBST(aros_target_cpp)
AC_SUBST(aros_kernel_cpp)
AC_SUBST(orig_target_as)
AC_SUBST(aros_target_as)
AC_SUBST(aros_kernel_as)
AC_SUBST(orig_target_ld)
AC_SUBST(aros_target_ld)
AC_SUBST(aros_kernel_ld)
AC_SUBST(aros_target_cc_includes)
AC_SUBST(aros_target_cc_path)
AC_SUBST(aros_target_objdump)
AC_SUBST(aros_target_objcopy)
AC_SUBST(aros_target_strip)
AC_SUBST(aros_target_nm)
AC_SUBST(aros_kernel_rescomp)
AC_SUBST(aros_shared_default)
AC_SUBST(aros_shared_ld)
AC_SUBST(aros_object_format)
AC_SUBST(spec_obj_format)
AC_SUBST(aros_compiler_libs)
AC_SUBST(aros_arch_libs)

AC_SUBST(aros_shared_cflags)
AC_SUBST(aros_shared_aflags)
AC_SUBST(aros_shared_ldflags)

AC_SUBST(aros_warn_flags)
AC_SUBST(aros_nowarn_flags)
AC_SUBST(aros_config_cppflags)
AC_SUBST(aros_config_cflags)
AC_SUBST(aros_config_cxxflags)
AC_SUBST(aros_config_aflags)
AC_SUBST(aros_config_ldflags)

AC_SUBST(aros_kernel_sysroot)
AC_SUBST(aros_kernel_cppflags)
AC_SUBST(aros_kernel_cflags)
AC_SUBST(aros_kernel_includes)
AC_SUBST(aros_kernel_objcflags)
AC_SUBST(aros_kernel_ldflags)
AC_SUBST(aros_debug_cppflags)
AC_SUBST(aros_debug_cflags)
AC_SUBST(aros_debug_cxxflags)
AC_SUBST(aros_debug_aflags)
AC_SUBST(aros_debug_ldflags)
AC_SUBST(aros_target_genmap)
AC_SUBST(aros_target_strip_flags)
AC_SUBST(aros_config_lto)
AC_SUBST(aros_config_coverage)
AC_SUBST(aros_optimization_cflags)
AC_SUBST(aros_isa_extra)
AC_SUBST(aros_isa_flags)

AC_SUBST(crosstools_target)
AC_SUBST(crosstools_cxx_target)


AC_SUBST(pci_hidd_target)

AC_SUBST(aros_nominal_width)
AC_SUBST(aros_nominal_height)
AC_SUBST(aros_nominal_depth)
AC_SUBST(DO_XSHM_SUPPORT)
AC_SUBST(DO_VIDMODE_SUPPORT)

AC_SUBST(aros_host_x11_cflags)
AC_SUBST(aros_host_x11_ldflags)
AC_SUBST(aros_host_sdl_cflags)
AC_SUBST(aros_host_sdl_libs)

# Bootloader related
AC_SUBST(target_grub2_version)

# Native version related
AC_SUBST(aros_serial_debug)
AC_SUBST(PLATFORM_EXECSMP)
AC_SUBST(ENABLE_EXECSMP)

# Palm native version related
AC_SUBST(aros_palm_debug_hack)

# Unix/Hosted version related
AC_SUBST(aros_nesting_supervisor)

# MMU related
AC_SUBST(aros_enable_mmu)

# Apple iOS related
AC_SUBST(aros_ios_platform)
AC_SUBST(aros_ios_version)
AC_SUBST(aros_ios_sdk)

# ARM default GCC target related
AC_SUBST(gcc_default_cpu)
AC_SUBST(gcc_default_cpu_tune)
AC_SUBST(gcc_default_fpu)
AC_SUBST(gcc_default_float_abi)
AC_SUBST(gcc_default_mode)

# Android related
AC_SUBST(android_tool)
AC_SUBST(aros_android_level)
AC_SUBST(aros_android_antapk)

# DBUS related
AC_SUBST(ENABLE_DBUS)
AC_SUBST(DBUS_CFLAGS)
AC_SUBST(DBUS_LIBFLAGS)
AC_SUBST(KERNEL_DBUS_KOBJ)
AC_SUBST(KERNEL_DBUS_INCLUDES)

#X11 related
AC_SUBST(ENABLE_X11)

# Debug related
AC_SUBST(aros_debug)
AC_SUBST(aros_mungwall_debug)
AC_SUBST(aros_stack_debug)
AC_SUBST(aros_modules_debug)

# Collect-aros stuff: "-ius" to ignore undefined symbols
AC_SUBST(ignore_undefined_symbols)

# C compiler related
AC_SUBST(gcc_target_cpu)
AC_SUBST(target_binutils_version)
AC_SUBST(target_gcc_version)

#ObjC compiler related
AC_SUBST(objc_target)

#Java related
AC_SUBST(java_target)

# USB3.0 code
AC_SUBST(aros_usb30_code)

dnl Prepare for output, make up all the generated patches
case "$aros_flavour" in
emulation)      aros_flavour_uc="AROS_FLAVOUR_EMULATION"
                aros_flavour="emulation" ;;
emulcompat)     aros_flavour_uc="(AROS_FLAVOUR_EMULATION|AROS_FLAVOUR_BINCOMPAT)"
                aros_flavour="emulation" ;;
standalone)     aros_flavour_uc="AROS_FLAVOUR_STANDALONE"
                aros_flavour="standalone";;
standcompat)    aros_flavour_uc="(AROS_FLAVOUR_STANDALONE|AROS_FLAVOUR_BINCOMPAT)"
                aros_flavour="standalone";;
native)         aros_flavour_uc="AROS_FLAVOUR_NATIVE"
                aros_flavour="native" ;;
nativecompat)   aros_flavour_uc="(AROS_FLAVOUR_NATIVE|AROS_FLAVOUR_BINCOMPAT)"
                aros_flavour="native" ;;
linklib)        aros_flavour_uc="AROS_FLAVOUR_LINKLIB"
                aros_flavour="linklib" ;;
palmnative)     aros_flavour_uc="(AROS_FLAVOUR_STANDALONE|AROS_FLAVOUR_EMULATION)"
                aros_flavour="palmnative" ;;
mac68knative)   aros_flavour_uc="(AROS_FLAVOUR_STANDALONE|AROS_FLAVOUR_EMULATION)"
                aros_flavour="mac68knative" ;;
ppcnative)      aros_flavour_uc="(AROS_FLAVOUR_STANDALONE|AROS_FLAVOUR_BINCOMPAT)"
                aros_flavour="ppcnative" ;;
esac

if test ! -d ${aros_inc_dir} ; then
    ${MKDIR} ${aros_inc_dir}
fi
if test ! -d ${aros_geninc_dir} ; then
    ${MKDIR} ${aros_geninc_dir}
fi
if test ! -d ${aros_hostcfg_dir} ; then
    ${MKDIR} ${aros_hostcfg_dir}
fi
if test ! -d ${aros_targetcfg_dir} ; then
    ${MKDIR} ${aros_targetcfg_dir}
fi
if test ! -d ${aros_tools_dir} ; then
    ${MKDIR} ${aros_tools_dir}
fi
if test ! -d ${aros_scripts_dir} ; then
    ${MKDIR} ${aros_scripts_dir}
fi

AC_CONFIG_HEADERS(${aros_geninc_dir}/host-conf.h:config/host-conf.h.in)

# Generic build tools (metamake, etc)
AC_CONFIG_COMMANDS([genmf-executable-support],
    [
        chmod a+x ${AROS_CROSSTOOLSDIR}/${aros_target_cpu}-aros-uname
        chmod a+x ${aros_tools_dir}/genmf.py
    ],
    [
        AROS_CROSSTOOLSDIR=${AROS_CROSSTOOLSDIR}
        aros_tools_dir=${aros_tools_dir}
    ]
)
AC_CONFIG_FILES(
    Makefile
    config/make.cfg
    ${aros_inc_dir}/config.h:config/config.h.in
    ${aros_geninc_dir}/config.h:config/config.h.in
    ${aros_hostcfg_dir}/host.cfg:config/host.cfg.in
    ${aros_targetcfg_dir}/target.cfg:config/target.cfg.in
    ${aros_targetcfg_dir}/build.cfg:config/build.cfg.in
    mmake.config
    compiler/include/geninc.cfg:compiler/include/geninc.cfg.in
    ${aros_targetcfg_dir}/make.defaults:config/make.defaults.in
    ${aros_tools_dir}/genmf.py:tools/genmf/genmf.py
    ${AROS_CROSSTOOLSDIR}/${aros_target_cpu}-aros-uname:scripts/uname.in
    tools/collect-aros/env.h
)

# Binutils
AC_CONFIG_COMMANDS([binutils-support],
    [
        prefix=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}
        mkdir -p $prefix
        prefix2=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros

        chmod a+x ${prefix2}-ld

        ln -sf $orig_target_as$aros_host_exe_suffix      ${prefix2}-as$aros_host_exe_suffix
        ln -sf $orig_target_nm$aros_host_exe_suffix      ${prefix2}-nm$aros_host_exe_suffix
        ln -sf $orig_target_ar$aros_host_exe_suffix      ${prefix2}-ar$aros_host_exe_suffix
        ln -sf $orig_target_ranlib$aros_host_exe_suffix  ${prefix2}-ranlib$aros_host_exe_suffix
        ln -sf $orig_target_objcopy$aros_host_exe_suffix ${prefix2}-objcopy$aros_host_exe_suffix
        ln -sf $orig_target_objdump$aros_host_exe_suffix ${prefix2}-objdump$aros_host_exe_suffix
        ln -sf $orig_target_strip$aros_host_exe_suffix   ${prefix2}-strip$aros_host_exe_suffix
    ],
    [
        aros_host_exe_suffix=${aros_host_exe_suffix}
        aros_tools_dir=${aros_tools_dir}
        aros_target_cpu=${aros_target_cpu}
        aros_target_arch=${aros_target_arch}
        aros_target_suffix=${aros_target_suffix}
        orig_target_nm=${orig_target_nm}
        orig_target_as=${orig_target_as}
        orig_target_ar=${orig_target_ar}
        orig_target_ranlib=${orig_target_ranlib}
        orig_target_objdump=${orig_target_objdump}
        orig_target_objcopy=${orig_target_objcopy}
        orig_target_strip=${orig_target_strip}
        aros_kernel_ld=${aros_kernel_ld}
    ]
)
if test "${use_ld_wrapper}" = "yes"; then
    AC_CONFIG_FILES(
        ${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-${aros_ld}:scripts/aros-ld.in
    )
fi
# Bare Elf support script and spec
if test "${use_kernel_cc_wrapper}" = "yes"; then
    AC_CONFIG_COMMANDS([elf-compiler-support],
        [
            prefix=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}
            mkdir -p $prefix
            prefix2=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-elf

            chmod a+x ${prefix2}-gcc

            ln -sf $aros_kernel_ld$aros_host_exe_suffix         ${prefix2}-ld$aros_host_exe_suffix
        ],
        [
            aros_host_exe_suffix=${aros_host_exe_suffix}
            aros_tools_dir=${aros_tools_dir}
            aros_target_cpu=${aros_target_cpu}
            aros_target_arch=${aros_target_arch}
            aros_target_suffix=${aros_target_suffix}
            aros_kernel_ld=${aros_kernel_ld}
        ]
    )
    AC_CONFIG_FILES(
        ${aros_targetcfg_dir}/elf-specs:${elf_specs_in}
        ${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-elf-gcc:scripts/elf-gcc.in
    )
fi

# Host compiler support scripts and spec
if test "${aros_target_toolchain}" = "no"; then
    AC_CONFIG_COMMANDS([host-compiler-wrapper-support],
        [
            prefix=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}
            mkdir -p $prefix
            prefix2=${PWD}/${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros

            chmod a+x ${prefix2}-${toolchain_c_compiler} ${prefix2}-${toolchain_cxx_compiler} ${prefix2}-${toolchain_cpp_preprocessor}
        ],
        [
            aros_host_exe_suffix=${aros_host_exe_suffix}
            aros_tools_dir=${aros_tools_dir}
            aros_target_cpu=${aros_target_cpu}
            aros_target_arch=${aros_target_arch}
            aros_target_suffix=${aros_target_suffix}
        ]
    )
    AC_CONFIG_FILES(
        ${aros_targetcfg_dir}/specs:config/specs.in
        ${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-${toolchain_cpp_preprocessor}:scripts/aros-${toolchain_cpp_preprocessor}.in
        ${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-${toolchain_c_compiler}:scripts/aros-${toolchain_c_compiler}.in
        ${aros_tools_dir}/${aros_target_cpu}-${aros_target_arch}${aros_target_suffix}-aros-${toolchain_cxx_compiler}:scripts/aros-${toolchain_cxx_compiler}.in
    )
fi

# Android support
if test "$aros_target_variant" == "android"; then
    AC_CONFIG_FILES(${aros_gendir}/arch/all-android/bootstrap/app/default.properties:arch/all-android/bootstrap/app/default.properties.in)
fi

# cmake helper
AC_CONFIG_FILES(${aros_targetcfg_dir}/conf.cmake:config/conf.cmake.in)

AC_OUTPUT

dnl This is in order to not define SHARED_CFLAGS sometimes
dnl We don't always do aros_shared_ar, aros_shared_cflags

#XXX compatability...
aros_shared_ar="$aros_shared_ld $aros_shared_ldflags -o"

if test -n "$aros_shared_cflags" ; then
    echo "SHARED_CFLAGS := $aros_shared_cflags" >> ${aros_hostcfg_dir}/host.cfg
    echo "SHARED_AR := $aros_shared_ar" >> ${aros_hostcfg_dir}/host.cfg
fi

